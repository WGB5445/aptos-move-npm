export default [{"content":"/// Access control list (acl) module. An acl is a list of account addresses who\n/// have the access permission to a certain object.\n/// This module uses a `vector` to represent the list, but can be refactored to\n/// use a \"set\" instead when it's available in the language in the future.\n\nmodule std::acl {\n    use std::vector;\n    use std::error;\n\n    /// The ACL already contains the address.\n    const ECONTAIN: u64 = 0;\n    /// The ACL does not contain the address.\n    const ENOT_CONTAIN: u64 = 1;\n\n    struct ACL has store, drop, copy {\n        list: vector<address>\n    }\n\n    /// Return an empty ACL.\n    public fun empty(): ACL {\n        ACL{ list: vector::empty<address>() }\n    }\n\n    /// Add the address to the ACL.\n    public fun add(acl: &mut ACL, addr: address) {\n        assert!(!vector::contains(&mut acl.list, &addr), error::invalid_argument(ECONTAIN));\n        vector::push_back(&mut acl.list, addr);\n    }\n\n    /// Remove the address from the ACL.\n    public fun remove(acl: &mut ACL, addr: address) {\n        let (found, index) = vector::index_of(&mut acl.list, &addr);\n        assert!(found, error::invalid_argument(ENOT_CONTAIN));\n        vector::remove(&mut acl.list, index);\n    }\n\n    /// Return true iff the ACL contains the address.\n    public fun contains(acl: &ACL, addr: address): bool {\n        vector::contains(&acl.list, &addr)\n    }\n\n    /// assert! that the ACL has the address.\n    public fun assert_contains(acl: &ACL, addr: address) {\n        assert!(contains(acl, addr), error::invalid_argument(ENOT_CONTAIN));\n    }\n}\n","name":"acl.move"},{"content":"/// Utility for converting a Move value to its binary representation in BCS (Binary Canonical\n/// Serialization). BCS is the binary encoding for Move resources and other non-module values\n/// published on-chain. See https://github.com/aptos-labs/bcs#binary-canonical-serialization-bcs for more\n/// details on BCS.\nmodule std::bcs {\n    /// Return the binary representation of `v` in BCS (Binary Canonical Serialization) format\n    native public fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;\n\n    // ==============================\n    // Module Specification\n    spec module {} // switch to module documentation context\n\n    spec module {\n        /// Native function which is defined in the prover's prelude.\n        native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;\n    }\n}\n","name":"bcs.move"},{"content":"module std::bit_vector {\n    use std::vector;\n\n    /// The provided index is out of bounds\n    const EINDEX: u64 = 0x20000;\n    /// An invalid length of bitvector was given\n    const ELENGTH: u64 = 0x20001;\n\n    const WORD_SIZE: u64 = 1;\n    /// The maximum allowed bitvector size\n    const MAX_SIZE: u64 = 1024;\n\n    spec BitVector {\n        invariant length == len(bit_field);\n    }\n\n    struct BitVector has copy, drop, store {\n        length: u64,\n        bit_field: vector<bool>,\n    }\n\n    public fun new(length: u64): BitVector {\n        assert!(length > 0, ELENGTH);\n        assert!(length < MAX_SIZE, ELENGTH);\n        let counter = 0;\n        let bit_field = vector::empty();\n        while ({spec {\n            invariant counter <= length;\n            invariant len(bit_field) == counter;\n        };\n            (counter < length)}) {\n            vector::push_back(&mut bit_field, false);\n            counter = counter + 1;\n        };\n        spec {\n            assert counter == length;\n            assert len(bit_field) == length;\n        };\n\n        BitVector {\n            length,\n            bit_field,\n        }\n    }\n    spec new {\n        include NewAbortsIf;\n        ensures result.length == length;\n        ensures len(result.bit_field) == length;\n    }\n    spec schema NewAbortsIf {\n        length: u64;\n        aborts_if length <= 0 with ELENGTH;\n        aborts_if length >= MAX_SIZE with ELENGTH;\n    }\n\n    /// Set the bit at `bit_index` in the `bitvector` regardless of its previous state.\n    public fun set(bitvector: &mut BitVector, bit_index: u64) {\n        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);\n        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);\n        *x = true;\n    }\n    spec set {\n        include SetAbortsIf;\n        ensures bitvector.bit_field[bit_index];\n    }\n    spec schema SetAbortsIf {\n        bitvector: BitVector;\n        bit_index: u64;\n        aborts_if bit_index >= length(bitvector) with EINDEX;\n    }\n\n    /// Unset the bit at `bit_index` in the `bitvector` regardless of its previous state.\n    public fun unset(bitvector: &mut BitVector, bit_index: u64) {\n        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);\n        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);\n        *x = false;\n    }\n    spec unset {\n        include UnsetAbortsIf;\n        ensures !bitvector.bit_field[bit_index];\n    }\n    spec schema UnsetAbortsIf {\n        bitvector: BitVector;\n        bit_index: u64;\n        aborts_if bit_index >= length(bitvector) with EINDEX;\n    }\n\n    /// Shift the `bitvector` left by `amount`. If `amount` is greater than the\n    /// bitvector's length the bitvector will be zeroed out.\n    public fun shift_left(bitvector: &mut BitVector, amount: u64) {\n        if (amount >= bitvector.length) {\n            vector::for_each_mut(&mut bitvector.bit_field, |elem| {\n                *elem = false;\n            });\n        } else {\n            let i = amount;\n\n            while (i < bitvector.length) {\n                if (is_index_set(bitvector, i)) set(bitvector, i - amount)\n                else unset(bitvector, i - amount);\n                i = i + 1;\n            };\n\n            i = bitvector.length - amount;\n\n            while (i < bitvector.length) {\n                unset(bitvector, i);\n                i = i + 1;\n            };\n        }\n    }\n    spec shift_left {\n        // TODO: set to false because data invariant cannot be proved with inline function. Will remove it once inline is supported\n        pragma verify = false;\n    }\n\n    /// Return the value of the bit at `bit_index` in the `bitvector`. `true`\n    /// represents \"1\" and `false` represents a 0\n    public fun is_index_set(bitvector: &BitVector, bit_index: u64): bool {\n        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);\n        *vector::borrow(&bitvector.bit_field, bit_index)\n    }\n    spec is_index_set {\n        include IsIndexSetAbortsIf;\n        ensures result == bitvector.bit_field[bit_index];\n    }\n    spec schema IsIndexSetAbortsIf {\n        bitvector: BitVector;\n        bit_index: u64;\n        aborts_if bit_index >= length(bitvector) with EINDEX;\n    }\n    spec fun spec_is_index_set(bitvector: BitVector, bit_index: u64): bool {\n        if (bit_index >= length(bitvector)) {\n            false\n        } else {\n            bitvector.bit_field[bit_index]\n        }\n    }\n\n    /// Return the length (number of usable bits) of this bitvector\n    public fun length(bitvector: &BitVector): u64 {\n        vector::length(&bitvector.bit_field)\n    }\n\n    /// Returns the length of the longest sequence of set bits starting at (and\n    /// including) `start_index` in the `bitvector`. If there is no such\n    /// sequence, then `0` is returned.\n    public fun longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {\n        assert!(start_index < bitvector.length, EINDEX);\n        let index = start_index;\n\n        // Find the greatest index in the vector such that all indices less than it are set.\n        while ({\n            spec {\n                invariant index >= start_index;\n                invariant index == start_index || is_index_set(bitvector, index - 1);\n                invariant index == start_index || index - 1 < vector::length(bitvector.bit_field);\n                invariant forall j in start_index..index: is_index_set(bitvector, j);\n                invariant forall j in start_index..index: j < vector::length(bitvector.bit_field);\n            };\n            index < bitvector.length\n        }) {\n            if (!is_index_set(bitvector, index)) break;\n            index = index + 1;\n        };\n\n        index - start_index\n    }\n\n    spec longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {\n        aborts_if start_index >= bitvector.length;\n        ensures forall i in start_index..result: is_index_set(bitvector, i);\n    }\n\n    #[test_only]\n    public fun word_size(): u64 {\n        WORD_SIZE\n    }\n\n    #[verify_only]\n    public fun shift_left_for_verification_only(bitvector: &mut BitVector, amount: u64) {\n        if (amount >= bitvector.length) {\n            let len = vector::length(&bitvector.bit_field);\n            let i = 0;\n            while ({\n                spec {\n                    invariant len == bitvector.length;\n                    invariant forall k in 0..i: !bitvector.bit_field[k];\n                    invariant forall k in i..bitvector.length: bitvector.bit_field[k] == old(bitvector).bit_field[k];\n                };\n                i < len\n            }) {\n                let elem = vector::borrow_mut(&mut bitvector.bit_field, i);\n                *elem = false;\n                i = i + 1;\n            };\n        } else {\n            let i = amount;\n\n            while ({\n                spec {\n                    invariant i >= amount;\n                    invariant bitvector.length == old(bitvector).length;\n                    invariant forall j in amount..i: old(bitvector).bit_field[j] == bitvector.bit_field[j - amount];\n                    invariant forall j in (i-amount)..bitvector.length : old(bitvector).bit_field[j] == bitvector.bit_field[j];\n                    invariant forall k in 0..i-amount: bitvector.bit_field[k] == old(bitvector).bit_field[k + amount];\n                };\n                i < bitvector.length\n            }) {\n                if (is_index_set(bitvector, i)) set(bitvector, i - amount)\n                else unset(bitvector, i - amount);\n                i = i + 1;\n            };\n\n\n            i = bitvector.length - amount;\n\n            while ({\n                spec {\n                    invariant forall j in bitvector.length - amount..i: !bitvector.bit_field[j];\n                    invariant forall k in 0..bitvector.length - amount: bitvector.bit_field[k] == old(bitvector).bit_field[k + amount];\n                    invariant i >= bitvector.length - amount;\n                };\n                i < bitvector.length\n            }) {\n                unset(bitvector, i);\n                i = i + 1;\n            }\n        }\n    }\n    spec shift_left_for_verification_only {\n        aborts_if false;\n        ensures amount >= bitvector.length ==> (forall k in 0..bitvector.length: !bitvector.bit_field[k]);\n        ensures amount < bitvector.length ==>\n            (forall i in bitvector.length - amount..bitvector.length: !bitvector.bit_field[i]);\n        ensures amount < bitvector.length ==>\n            (forall i in 0..bitvector.length - amount: bitvector.bit_field[i] == old(bitvector).bit_field[i + amount]);\n    }\n}\n","name":"bit_vector.move"},{"content":"/// Defines feature flags for Aptos. Those are used in Aptos specific implementations of features in\n/// the Move stdlib, the Aptos stdlib, and the Aptos framework.\n///\n/// ============================================================================================\n/// Feature Flag Definitions\n///\n/// Each feature flag should come with documentation which justifies the need of the flag.\n/// Introduction of a new feature flag requires approval of framework owners. Be frugal when\n/// introducing new feature flags, as too many can make it hard to understand the code.\n///\n/// Each feature flag should come with a specification of a lifetime:\n///\n/// - a *transient* feature flag is only needed until a related code rollout has happened. This\n///   is typically associated with the introduction of new native Move functions, and is only used\n///   from Move code. The owner of this feature is obliged to remove it once this can be done.\n///\n/// - a *permanent* feature flag is required to stay around forever. Typically, those flags guard\n///   behavior in native code, and the behavior with or without the feature need to be preserved\n///   for playback.\n///\n/// Note that removing a feature flag still requires the function which tests for the feature\n/// (like `code_dependency_check_enabled` below) to stay around for compatibility reasons, as it\n/// is a public function. However, once the feature flag is disabled, those functions can constantly\n/// return true.\nmodule std::features {\n    use std::error;\n    use std::signer;\n    use std::vector;\n\n    const EINVALID_FEATURE: u64 = 1;\n    const EAPI_DISABLED: u64 = 2;\n\n    // --------------------------------------------------------------------------------------------\n    // Code Publishing\n\n    /// Whether validation of package dependencies is enabled, and the related native function is\n    /// available. This is needed because of introduction of a new native function.\n    /// Lifetime: transient\n    const CODE_DEPENDENCY_CHECK: u64 = 1;\n\n    public fun code_dependency_check_enabled(): bool acquires Features {\n        is_enabled(CODE_DEPENDENCY_CHECK)\n    }\n\n    /// Whether during upgrade compatibility checking, friend functions should be treated similar like\n    /// private functions.\n    /// Lifetime: permanent\n    const TREAT_FRIEND_AS_PRIVATE: u64 = 2;\n\n    public fun treat_friend_as_private(): bool acquires Features {\n        is_enabled(TREAT_FRIEND_AS_PRIVATE)\n    }\n\n    /// Whether the new SHA2-512, SHA3-512 and RIPEMD-160 hash function natives are enabled.\n    /// This is needed because of the introduction of new native functions.\n    /// Lifetime: transient\n    const SHA_512_AND_RIPEMD_160_NATIVES: u64 = 3;\n\n    public fun get_sha_512_and_ripemd_160_feature(): u64 { SHA_512_AND_RIPEMD_160_NATIVES }\n\n    public fun sha_512_and_ripemd_160_enabled(): bool acquires Features {\n        is_enabled(SHA_512_AND_RIPEMD_160_NATIVES)\n    }\n\n    /// Whether the new `aptos_stdlib::type_info::chain_id()` native for fetching the chain ID is enabled.\n    /// This is needed because of the introduction of a new native function.\n    /// Lifetime: transient\n    const APTOS_STD_CHAIN_ID_NATIVES: u64 = 4;\n\n    public fun get_aptos_stdlib_chain_id_feature(): u64 { APTOS_STD_CHAIN_ID_NATIVES }\n\n    public fun aptos_stdlib_chain_id_enabled(): bool acquires Features {\n        is_enabled(APTOS_STD_CHAIN_ID_NATIVES)\n    }\n\n    /// Whether to allow the use of binary format version v6.\n    /// Lifetime: transient\n    const VM_BINARY_FORMAT_V6: u64 = 5;\n\n    public fun get_vm_binary_format_v6(): u64 { VM_BINARY_FORMAT_V6 }\n\n    public fun allow_vm_binary_format_v6(): bool acquires Features {\n        is_enabled(VM_BINARY_FORMAT_V6)\n    }\n\n    /// Whether gas fees are collected and distributed to the block proposers.\n    /// Lifetime: transient\n    const COLLECT_AND_DISTRIBUTE_GAS_FEES: u64 = 6;\n\n    public fun get_collect_and_distribute_gas_fees_feature(): u64 { COLLECT_AND_DISTRIBUTE_GAS_FEES }\n\n    public fun collect_and_distribute_gas_fees(): bool acquires Features {\n        is_enabled(COLLECT_AND_DISTRIBUTE_GAS_FEES)\n    }\n\n    /// Whether the new `aptos_stdlib::multi_ed25519::public_key_validate_internal_v2()` native is enabled.\n    /// This is needed because of the introduction of a new native function.\n    /// Lifetime: transient\n    const MULTI_ED25519_PK_VALIDATE_V2_NATIVES: u64 = 7;\n\n    public fun multi_ed25519_pk_validate_v2_feature(): u64 { MULTI_ED25519_PK_VALIDATE_V2_NATIVES }\n\n    public fun multi_ed25519_pk_validate_v2_enabled(): bool acquires Features {\n        is_enabled(MULTI_ED25519_PK_VALIDATE_V2_NATIVES)\n    }\n\n    /// Whether the new BLAKE2B-256 hash function native is enabled.\n    /// This is needed because of the introduction of new native function(s).\n    /// Lifetime: transient\n    const BLAKE2B_256_NATIVE: u64 = 8;\n\n    public fun get_blake2b_256_feature(): u64 { BLAKE2B_256_NATIVE }\n\n    public fun blake2b_256_enabled(): bool acquires Features {\n        is_enabled(BLAKE2B_256_NATIVE)\n    }\n\n    /// Whether resource groups are enabled.\n    /// This is needed because of new attributes for structs and a change in storage representation.\n    const RESOURCE_GROUPS: u64 = 9;\n\n    public fun get_resource_groups_feature(): u64 { RESOURCE_GROUPS }\n\n    public fun resource_groups_enabled(): bool acquires Features {\n        is_enabled(RESOURCE_GROUPS)\n    }\n\n    /// Whether multisig accounts (different from accounts with multi-ed25519 auth keys) are enabled.\n    const MULTISIG_ACCOUNTS: u64 = 10;\n\n    public fun get_multisig_accounts_feature(): u64 { MULTISIG_ACCOUNTS }\n\n    public fun multisig_accounts_enabled(): bool acquires Features {\n        is_enabled(MULTISIG_ACCOUNTS)\n    }\n\n    /// Whether delegation pools are enabled.\n    /// Lifetime: transient\n    const DELEGATION_POOLS: u64 = 11;\n\n    public fun get_delegation_pools_feature(): u64 { DELEGATION_POOLS }\n\n    public fun delegation_pools_enabled(): bool acquires Features {\n        is_enabled(DELEGATION_POOLS)\n    }\n\n    /// Whether generic algebra basic operation support in `crypto_algebra.move` are enabled.\n    ///\n    /// Lifetime: transient\n    const CRYPTOGRAPHY_ALGEBRA_NATIVES: u64 = 12;\n\n    public fun get_cryptography_algebra_natives_feature(): u64 { CRYPTOGRAPHY_ALGEBRA_NATIVES }\n\n    public fun cryptography_algebra_enabled(): bool acquires Features {\n        is_enabled(CRYPTOGRAPHY_ALGEBRA_NATIVES)\n    }\n\n    /// Whether the generic algebra implementation for BLS12381 operations are enabled.\n    ///\n    /// Lifetime: transient\n    const BLS12_381_STRUCTURES: u64 = 13;\n\n    public fun get_bls12_381_strutures_feature(): u64 { BLS12_381_STRUCTURES }\n\n    public fun bls12_381_structures_enabled(): bool acquires Features {\n        is_enabled(BLS12_381_STRUCTURES)\n    }\n\n\n    /// Whether native_public_key_validate aborts when a public key of the wrong length is given\n    /// Lifetime: ephemeral\n    const ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH: u64 = 14;\n\n    /// Whether struct constructors are enabled\n    ///\n    /// Lifetime: transient\n    const STRUCT_CONSTRUCTORS: u64 = 15;\n\n    /// Whether reward rate decreases periodically.\n    /// Lifetime: transient\n    const PERIODICAL_REWARD_RATE_DECREASE: u64 = 16;\n\n    public fun get_periodical_reward_rate_decrease_feature(): u64 { PERIODICAL_REWARD_RATE_DECREASE }\n\n    public fun periodical_reward_rate_decrease_enabled(): bool acquires Features {\n        is_enabled(PERIODICAL_REWARD_RATE_DECREASE)\n    }\n\n    /// Whether enable paritial governance voting on aptos_governance.\n    /// Lifetime: transient\n    const PARTIAL_GOVERNANCE_VOTING: u64 = 17;\n\n    public fun get_partial_governance_voting(): u64 { PARTIAL_GOVERNANCE_VOTING }\n\n    public fun partial_governance_voting_enabled(): bool acquires Features {\n        is_enabled(PARTIAL_GOVERNANCE_VOTING)\n    }\n\n    /// Charge invariant violation error.\n    /// Lifetime: transient\n    const CHARGE_INVARIANT_VIOLATION: u64 = 20;\n\n    /// Whether enable paritial governance voting on delegation_pool.\n    /// Lifetime: transient\n    const DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING: u64 = 21;\n\n    public fun get_delegation_pool_partial_governance_voting(): u64 { DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING }\n\n    public fun delegation_pool_partial_governance_voting_enabled(): bool acquires Features {\n        is_enabled(DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING)\n    }\n\n    /// Whether alternate gas payer is supported\n    /// Lifetime: transient\n    const FEE_PAYER_ENABLED: u64 = 22;\n\n    public fun fee_payer_enabled(): bool acquires Features {\n        is_enabled(FEE_PAYER_ENABLED)\n    }\n\n    /// Whether enable MOVE functions to call create_auid method to create AUIDs.\n    /// Lifetime: transient\n    const APTOS_UNIQUE_IDENTIFIERS: u64 = 23;\n\n    public fun get_auids(): u64 { APTOS_UNIQUE_IDENTIFIERS }\n\n    public fun auids_enabled(): bool acquires Features {\n        is_enabled(APTOS_UNIQUE_IDENTIFIERS)\n    }\n\n    /// Whether the Bulletproofs zero-knowledge range proof module is enabled, and the related native function is\n    /// available. This is needed because of the introduction of a new native function.\n    /// Lifetime: transient\n    const BULLETPROOFS_NATIVES: u64 = 24;\n\n    public fun get_bulletproofs_feature(): u64 { BULLETPROOFS_NATIVES }\n\n    public fun bulletproofs_enabled(): bool acquires Features {\n        is_enabled(BULLETPROOFS_NATIVES)\n    }\n\n    /// Fix the native formatter for signer.\n    /// Lifetime: transient\n    const SIGNER_NATIVE_FORMAT_FIX: u64 = 25;\n\n    public fun get_signer_native_format_fix_feature(): u64 { SIGNER_NATIVE_FORMAT_FIX }\n\n    public fun signer_native_format_fix_enabled(): bool acquires Features {\n        is_enabled(SIGNER_NATIVE_FORMAT_FIX)\n    }\n\n    /// Whether emit function in `event.move` are enabled for module events.\n    ///\n    /// Lifetime: transient\n    const MODULE_EVENT: u64 = 26;\n\n    public fun get_module_event_feature(): u64 { MODULE_EVENT }\n\n    public fun module_event_enabled(): bool acquires Features {\n        is_enabled(MODULE_EVENT)\n    }\n\n    /// Whether the fix for a counting bug in the script path of the signature checker pass is enabled.\n    /// Lifetime: transient\n    const SIGNATURE_CHECKER_V2_SCRIPT_FIX: u64 = 29;\n\n    /// Whether the Aggregator V2 API feature is enabled.\n    /// Once enabled, the functions from aggregator_v2.move will be available for use.\n    /// Lifetime: transient\n    const AGGREGATOR_V2_API: u64 = 30;\n\n    public fun get_aggregator_v2_api_feature(): u64 { AGGREGATOR_V2_API }\n\n    public fun aggregator_v2_api_enabled(): bool acquires Features {\n        is_enabled(AGGREGATOR_V2_API)\n    }\n\n    #[deprecated]\n    public fun get_aggregator_snapshots_feature(): u64 {\n        abort error::invalid_argument(EINVALID_FEATURE)\n    }\n\n    #[deprecated]\n    public fun aggregator_snapshots_enabled(): bool {\n        abort error::invalid_argument(EINVALID_FEATURE)\n    }\n\n    const SAFER_RESOURCE_GROUPS: u64 = 31;\n\n    const SAFER_METADATA: u64 = 32;\n\n    const SINGLE_SENDER_AUTHENTICATOR: u64 = 33;\n\n    /// Whether the automatic creation of accounts is enabled for sponsored transactions.\n    /// Lifetime: transient\n    const SPONSORED_AUTOMATIC_ACCOUNT_CREATION: u64 = 34;\n\n    public fun get_sponsored_automatic_account_creation(): u64 { SPONSORED_AUTOMATIC_ACCOUNT_CREATION }\n\n    public fun sponsored_automatic_account_creation_enabled(): bool acquires Features {\n        is_enabled(SPONSORED_AUTOMATIC_ACCOUNT_CREATION)\n    }\n\n    const FEE_PAYER_ACCOUNT_OPTIONAL: u64 = 35;\n\n    /// Whether the Aggregator V2 delayed fields feature is enabled.\n    /// Once enabled, Aggregator V2 functions become parallel.\n    /// Lifetime: transient\n    const AGGREGATOR_V2_DELAYED_FIELDS: u64 = 36;\n\n    /// Whether enable TokenV2 collection creation and Fungible Asset creation\n    /// to create higher throughput concurrent variants.\n    /// Lifetime: transient\n    const CONCURRENT_TOKEN_V2: u64 = 37;\n\n    public fun get_concurrent_token_v2_feature(): u64 { CONCURRENT_TOKEN_V2 }\n\n    public fun concurrent_token_v2_enabled(): bool acquires Features {\n        // concurrent token v2 cannot be used if aggregator v2 api is not enabled.\n        is_enabled(CONCURRENT_TOKEN_V2) && aggregator_v2_api_enabled()\n    }\n\n    #[deprecated]\n    public fun get_concurrent_assets_feature(): u64 {\n        abort error::invalid_argument(EINVALID_FEATURE)\n    }\n\n    #[deprecated]\n    public fun concurrent_assets_enabled(): bool {\n        abort error::invalid_argument(EINVALID_FEATURE)\n    }\n\n    const LIMIT_MAX_IDENTIFIER_LENGTH: u64 = 38;\n\n    /// Whether allow changing beneficiaries for operators.\n    /// Lifetime: transient\n    const OPERATOR_BENEFICIARY_CHANGE: u64 = 39;\n\n    public fun get_operator_beneficiary_change_feature(): u64 { OPERATOR_BENEFICIARY_CHANGE }\n\n    public fun operator_beneficiary_change_enabled(): bool acquires Features {\n        is_enabled(OPERATOR_BENEFICIARY_CHANGE)\n    }\n\n    const VM_BINARY_FORMAT_V7: u64 = 40;\n\n    const RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET: u64 = 41;\n\n    /// Whether the operator commission rate change in delegation pool is enabled.\n    /// Lifetime: transient\n    const COMMISSION_CHANGE_DELEGATION_POOL: u64 = 42;\n\n    public fun get_commission_change_delegation_pool_feature(): u64 { COMMISSION_CHANGE_DELEGATION_POOL }\n\n    public fun commission_change_delegation_pool_enabled(): bool acquires Features {\n        is_enabled(COMMISSION_CHANGE_DELEGATION_POOL)\n    }\n\n    /// Whether the generic algebra implementation for BN254 operations are enabled.\n    ///\n    /// Lifetime: transient\n    const BN254_STRUCTURES: u64 = 43;\n\n    public fun get_bn254_strutures_feature(): u64 { BN254_STRUCTURES }\n\n    public fun bn254_structures_enabled(): bool acquires Features {\n        is_enabled(BN254_STRUCTURES)\n    }\n\n    /// Deprecated by `aptos_framework::randomness_config::RandomnessConfig`.\n    const RECONFIGURE_WITH_DKG: u64 = 45;\n\n    public fun get_reconfigure_with_dkg_feature(): u64 { RECONFIGURE_WITH_DKG }\n\n    public fun reconfigure_with_dkg_enabled(): bool acquires Features {\n        is_enabled(RECONFIGURE_WITH_DKG)\n    }\n\n    /// Whether the OIDB feature is enabled, possibly with the ZK-less verification mode.\n    ///\n    /// Lifetime: transient\n    const KEYLESS_ACCOUNTS: u64 = 46;\n\n    public fun get_keyless_accounts_feature(): u64 { KEYLESS_ACCOUNTS }\n\n    public fun keyless_accounts_enabled(): bool acquires Features {\n        is_enabled(KEYLESS_ACCOUNTS)\n    }\n\n    /// Whether the ZK-less mode of the keyless accounts feature is enabled.\n    ///\n    /// Lifetime: transient\n    const KEYLESS_BUT_ZKLESS_ACCOUNTS: u64 = 47;\n\n    public fun get_keyless_but_zkless_accounts_feature(): u64 { KEYLESS_BUT_ZKLESS_ACCOUNTS }\n\n    public fun keyless_but_zkless_accounts_feature_enabled(): bool acquires Features {\n        is_enabled(KEYLESS_BUT_ZKLESS_ACCOUNTS)\n    }\n\n    /// Deprecated by `aptos_framework::jwk_consensus_config::JWKConsensusConfig`.\n    const JWK_CONSENSUS: u64 = 49;\n\n    public fun get_jwk_consensus_feature(): u64 { JWK_CONSENSUS }\n\n    public fun jwk_consensus_enabled(): bool acquires Features {\n        is_enabled(JWK_CONSENSUS)\n    }\n\n    /// Whether enable Fungible Asset creation\n    /// to create higher throughput concurrent variants.\n    /// Lifetime: transient\n    const CONCURRENT_FUNGIBLE_ASSETS: u64 = 50;\n\n    public fun get_concurrent_fungible_assets_feature(): u64 { CONCURRENT_FUNGIBLE_ASSETS }\n\n    public fun concurrent_fungible_assets_enabled(): bool acquires Features {\n        // concurrent fungible assets cannot be used if aggregator v2 api is not enabled.\n        is_enabled(CONCURRENT_FUNGIBLE_ASSETS) && aggregator_v2_api_enabled()\n    }\n\n    /// Whether deploying to objects is enabled.\n    const OBJECT_CODE_DEPLOYMENT: u64 = 52;\n\n    public fun is_object_code_deployment_enabled(): bool acquires Features {\n        is_enabled(OBJECT_CODE_DEPLOYMENT)\n    }\n\n    /// Whether checking the maximum object nesting is enabled.\n    const MAX_OBJECT_NESTING_CHECK: u64 = 53;\n\n    public fun get_max_object_nesting_check_feature(): u64 { MAX_OBJECT_NESTING_CHECK }\n\n    public fun max_object_nesting_check_enabled(): bool acquires Features {\n        is_enabled(MAX_OBJECT_NESTING_CHECK)\n    }\n\n    /// Whether keyless accounts support passkey-based ephemeral signatures.\n    ///\n    /// Lifetime: transient\n    const KEYLESS_ACCOUNTS_WITH_PASSKEYS: u64 = 54;\n\n    public fun get_keyless_accounts_with_passkeys_feature(): u64 { KEYLESS_ACCOUNTS_WITH_PASSKEYS }\n\n    public fun keyless_accounts_with_passkeys_feature_enabled(): bool acquires Features {\n        is_enabled(KEYLESS_ACCOUNTS_WITH_PASSKEYS)\n    }\n\n    /// Whether the Multisig V2 enhancement feature is enabled.\n    ///\n    /// Lifetime: transient\n    const MULTISIG_V2_ENHANCEMENT: u64 = 55;\n\n    public fun get_multisig_v2_enhancement_feature(): u64 { MULTISIG_V2_ENHANCEMENT }\n\n    public fun multisig_v2_enhancement_feature_enabled(): bool acquires Features {\n        is_enabled(MULTISIG_V2_ENHANCEMENT)\n    }\n\n    /// Whether delegators allowlisting for delegation pools is supported.\n    /// Lifetime: transient\n    const DELEGATION_POOL_ALLOWLISTING: u64 = 56;\n\n    public fun get_delegation_pool_allowlisting_feature(): u64 { DELEGATION_POOL_ALLOWLISTING }\n\n    public fun delegation_pool_allowlisting_enabled(): bool acquires Features {\n        is_enabled(DELEGATION_POOL_ALLOWLISTING)\n    }\n\n    /// Whether aptos_framwork enables the behavior of module event migration.\n    ///\n    /// Lifetime: transient\n    const MODULE_EVENT_MIGRATION: u64 = 57;\n\n    public fun get_module_event_migration_feature(): u64 { MODULE_EVENT_MIGRATION }\n\n    public fun module_event_migration_enabled(): bool acquires Features {\n        is_enabled(MODULE_EVENT_MIGRATION)\n    }\n\n    /// Whether the transaction context extension is enabled. This feature allows the module\n    /// `transaction_context` to provide contextual information about the user transaction.\n    ///\n    /// Lifetime: transient\n    const TRANSACTION_CONTEXT_EXTENSION: u64 = 59;\n\n    public fun get_transaction_context_extension_feature(): u64 { TRANSACTION_CONTEXT_EXTENSION }\n\n    public fun transaction_context_extension_enabled(): bool acquires Features {\n        is_enabled(TRANSACTION_CONTEXT_EXTENSION)\n    }\n\n    /// Whether migration from coin to fungible asset feature is enabled.\n    ///\n    /// Lifetime: transient\n    const COIN_TO_FUNGIBLE_ASSET_MIGRATION: u64 = 60;\n\n    public fun get_coin_to_fungible_asset_migration_feature(): u64 { COIN_TO_FUNGIBLE_ASSET_MIGRATION }\n\n    public fun coin_to_fungible_asset_migration_feature_enabled(): bool acquires Features {\n        is_enabled(COIN_TO_FUNGIBLE_ASSET_MIGRATION)\n    }\n\n    const PRIMARY_APT_FUNGIBLE_STORE_AT_USER_ADDRESS: u64 = 61;\n\n    public fun get_primary_apt_fungible_store_at_user_address_feature(\n    ): u64 { PRIMARY_APT_FUNGIBLE_STORE_AT_USER_ADDRESS }\n\n    public fun primary_apt_fungible_store_at_user_address_enabled(): bool acquires Features {\n        is_enabled(PRIMARY_APT_FUNGIBLE_STORE_AT_USER_ADDRESS)\n    }\n\n    /// Whether we use more efficient native implementation of computing object derived address\n    const OBJECT_NATIVE_DERIVED_ADDRESS: u64 = 62;\n\n    public fun get_object_native_derived_address_feature(): u64 { OBJECT_NATIVE_DERIVED_ADDRESS }\n\n    public fun object_native_derived_address_enabled(): bool acquires Features {\n        is_enabled(OBJECT_NATIVE_DERIVED_ADDRESS)\n    }\n\n    /// Whether the dispatchable fungible asset standard feature is enabled.\n    ///\n    /// Lifetime: transient\n    const DISPATCHABLE_FUNGIBLE_ASSET: u64 = 63;\n\n    public fun get_dispatchable_fungible_asset_feature(): u64 { DISPATCHABLE_FUNGIBLE_ASSET }\n\n    public fun dispatchable_fungible_asset_enabled(): bool acquires Features {\n        is_enabled(DISPATCHABLE_FUNGIBLE_ASSET)\n    }\n\n    // ============================================================================================\n    // Feature Flag Implementation\n\n    /// The provided signer has not a framework address.\n    const EFRAMEWORK_SIGNER_NEEDED: u64 = 1;\n\n    /// The enabled features, represented by a bitset stored on chain.\n    struct Features has key {\n        features: vector<u8>,\n    }\n\n    /// This resource holds the feature vec updates received in the current epoch.\n    /// On epoch change, the updates take effect and this buffer is cleared.\n    struct PendingFeatures has key {\n        features: vector<u8>,\n    }\n\n    /// Deprecated to prevent validator set changes during DKG.\n    ///\n    /// Genesis/tests should use `change_feature_flags_internal()` for feature vec initialization.\n    ///\n    /// Governance proposals should use `change_feature_flags_for_next_epoch()` to enable/disable features.\n    public fun change_feature_flags(_framework: &signer, _enable: vector<u64>, _disable: vector<u64>) {\n        abort (error::invalid_state(EAPI_DISABLED))\n    }\n\n    /// Update feature flags directly. Only used in genesis/tests.\n    fun change_feature_flags_internal(framework: &signer, enable: vector<u64>, disable: vector<u64>) acquires Features {\n        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));\n        if (!exists<Features>(@std)) {\n            move_to<Features>(framework, Features { features: vector[] })\n        };\n        let features = &mut borrow_global_mut<Features>(@std).features;\n        vector::for_each_ref(&enable, |feature| {\n            set(features, *feature, true);\n        });\n        vector::for_each_ref(&disable, |feature| {\n            set(features, *feature, false);\n        });\n    }\n\n    /// Enable and disable features for the next epoch.\n    public fun change_feature_flags_for_next_epoch(\n        framework: &signer,\n        enable: vector<u64>,\n        disable: vector<u64>\n    ) acquires PendingFeatures, Features {\n        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));\n\n        // Figure out the baseline feature vec that the diff will be applied to.\n        let new_feature_vec = if (exists<PendingFeatures>(@std)) {\n            // If there is a buffered feature vec, use it as the baseline.\n            let PendingFeatures { features } = move_from<PendingFeatures>(@std);\n            features\n        } else if (exists<Features>(@std)) {\n            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.\n            borrow_global<Features>(@std).features\n        } else {\n            // Otherwise, use an empty feature vec.\n            vector[]\n        };\n\n        // Apply the diff and save it to the buffer.\n        apply_diff(&mut new_feature_vec, enable, disable);\n        move_to(framework, PendingFeatures { features: new_feature_vec });\n    }\n\n    /// Apply all the pending feature flag changes. Should only be used at the end of a reconfiguration with DKG.\n    ///\n    /// While the scope is public, it can only be usd in system transactions like `block_prologue` and governance proposals,\n    /// who have permission to set the flag that's checked in `extract()`.\n    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {\n        ensure_framework_signer(framework);\n        if (exists<PendingFeatures>(@std)) {\n            let PendingFeatures { features } = move_from<PendingFeatures>(@std);\n            if (exists<Features>(@std)) {\n                borrow_global_mut<Features>(@std).features = features;\n            } else {\n                move_to(framework, Features { features })\n            }\n        }\n    }\n\n    #[view]\n    /// Check whether the feature is enabled.\n    public fun is_enabled(feature: u64): bool acquires Features {\n        exists<Features>(@std) &&\n            contains(&borrow_global<Features>(@std).features, feature)\n    }\n\n    /// Helper to include or exclude a feature flag.\n    fun set(features: &mut vector<u8>, feature: u64, include: bool) {\n        let byte_index = feature / 8;\n        let bit_mask = 1 << ((feature % 8) as u8);\n        while (vector::length(features) <= byte_index) {\n            vector::push_back(features, 0)\n        };\n        let entry = vector::borrow_mut(features, byte_index);\n        if (include)\n            *entry = *entry | bit_mask\n        else\n            *entry = *entry & (0xff ^ bit_mask)\n    }\n\n    /// Helper to check whether a feature flag is enabled.\n    fun contains(features: &vector<u8>, feature: u64): bool {\n        let byte_index = feature / 8;\n        let bit_mask = 1 << ((feature % 8) as u8);\n        byte_index < vector::length(features) && (*vector::borrow(features, byte_index) & bit_mask) != 0\n    }\n\n    fun apply_diff(features: &mut vector<u8>, enable: vector<u64>, disable: vector<u64>) {\n        vector::for_each(enable, |feature| {\n            set(features, feature, true);\n        });\n        vector::for_each(disable, |feature| {\n            set(features, feature, false);\n        });\n    }\n\n    fun ensure_framework_signer(account: &signer) {\n        let addr = signer::address_of(account);\n        assert!(addr == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));\n    }\n\n    #[verify_only]\n    public fun change_feature_flags_for_verification(\n        framework: &signer,\n        enable: vector<u64>,\n        disable: vector<u64>\n    ) acquires Features {\n        change_feature_flags_internal(framework, enable, disable)\n    }\n\n    #[test_only]\n    public fun change_feature_flags_for_testing(\n        framework: &signer,\n        enable: vector<u64>,\n        disable: vector<u64>\n    ) acquires Features {\n        change_feature_flags_internal(framework, enable, disable)\n    }\n\n    #[test]\n    fun test_feature_sets() {\n        let features = vector[];\n        set(&mut features, 1, true);\n        set(&mut features, 5, true);\n        set(&mut features, 17, true);\n        set(&mut features, 23, true);\n        assert!(contains(&features, 1), 0);\n        assert!(contains(&features, 5), 1);\n        assert!(contains(&features, 17), 2);\n        assert!(contains(&features, 23), 3);\n        set(&mut features, 5, false);\n        set(&mut features, 17, false);\n        assert!(contains(&features, 1), 0);\n        assert!(!contains(&features, 5), 1);\n        assert!(!contains(&features, 17), 2);\n        assert!(contains(&features, 23), 3);\n    }\n\n    #[test(fx = @std)]\n    fun test_change_feature_txn(fx: signer) acquires Features {\n        change_feature_flags_for_testing(&fx, vector[1, 9, 23], vector[]);\n        assert!(is_enabled(1), 1);\n        assert!(is_enabled(9), 2);\n        assert!(is_enabled(23), 3);\n        change_feature_flags_for_testing(&fx, vector[17], vector[9]);\n        assert!(is_enabled(1), 1);\n        assert!(!is_enabled(9), 2);\n        assert!(is_enabled(17), 3);\n        assert!(is_enabled(23), 4);\n    }\n}\n","name":"features.move"},{"content":"/// This module defines a set of canonical error codes which are optional to use by applications for the\n/// `abort` and `assert!` features.\n///\n/// Canonical error codes use the 3 lowest bytes of the u64 abort code range (the upper 5 bytes are free for other use).\n/// Of those, the highest byte represents the *error category* and the lower two bytes the *error reason*.\n/// Given an error category `0x1` and a reason `0x3`, a canonical abort code looks as `0x10003`.\n///\n/// A module can use a canonical code with a constant declaration of the following form:\n///\n/// ```\n/// ///  An invalid ASCII character was encountered when creating a string.\n/// const EINVALID_CHARACTER: u64 = 0x010003;\n/// ```\n///\n/// This code is both valid in the worlds with and without canonical errors. It can be used as a plain module local\n/// error reason understand by the existing error map tooling, or as a canonical code.\n///\n/// The actual canonical categories have been adopted from Google's canonical error codes, which in turn are derived\n/// from Unix error codes [see here](https://cloud.google.com/apis/design/errors#handling_errors). Each code has an\n/// associated HTTP error code which can be used in REST apis. The mapping from error code to http code is not 1:1;\n/// error codes here are a bit richer than HTTP codes.\nmodule std::error {\n\n  /// Caller specified an invalid argument (http: 400)\n  const INVALID_ARGUMENT: u64 = 0x1;\n\n  /// An input or result of a computation is out of range (http: 400)\n  const OUT_OF_RANGE: u64 = 0x2;\n\n  /// The system is not in a state where the operation can be performed (http: 400)\n  const INVALID_STATE: u64 = 0x3;\n\n  /// Request not authenticated due to missing, invalid, or expired auth token (http: 401)\n  const UNAUTHENTICATED: u64 = 0x4;\n\n  /// client does not have sufficient permission (http: 403)\n  const PERMISSION_DENIED: u64 = 0x5;\n\n  /// A specified resource is not found (http: 404)\n  const NOT_FOUND: u64 = 0x6;\n\n  /// Concurrency conflict, such as read-modify-write conflict (http: 409)\n  const ABORTED: u64 = 0x7;\n\n  /// The resource that a client tried to create already exists (http: 409)\n  const ALREADY_EXISTS: u64 = 0x8;\n\n  /// Out of gas or other forms of quota (http: 429)\n  const RESOURCE_EXHAUSTED: u64 = 0x9;\n\n  /// Request cancelled by the client (http: 499)\n  const CANCELLED: u64 = 0xA;\n\n  /// Internal error (http: 500)\n  const INTERNAL: u64 = 0xB;\n\n  /// Feature not implemented (http: 501)\n  const NOT_IMPLEMENTED: u64 = 0xC;\n\n  /// The service is currently unavailable. Indicates that a retry could solve the issue (http: 503)\n  const UNAVAILABLE: u64 = 0xD;\n\n  /// Construct a canonical error code from a category and a reason.\n  public fun canonical(category: u64, reason: u64): u64 {\n    (category << 16) + reason\n  }\n  spec canonical {\n    pragma opaque = true;\n    let shl_res = category << 16;\n    ensures [concrete] result == shl_res + reason;\n    aborts_if [abstract] false;\n    ensures [abstract] result == category;\n  }\n\n  /// Functions to construct a canonical error code of the given category.\n  public fun invalid_argument(r: u64): u64 {  canonical(INVALID_ARGUMENT, r) }\n  public fun out_of_range(r: u64): u64 {  canonical(OUT_OF_RANGE, r) }\n  public fun invalid_state(r: u64): u64 {  canonical(INVALID_STATE, r) }\n  public fun unauthenticated(r: u64): u64 { canonical(UNAUTHENTICATED, r) }\n  public fun permission_denied(r: u64): u64 { canonical(PERMISSION_DENIED, r) }\n  public fun not_found(r: u64): u64 { canonical(NOT_FOUND, r) }\n  public fun aborted(r: u64): u64 { canonical(ABORTED, r) }\n  public fun already_exists(r: u64): u64 { canonical(ALREADY_EXISTS, r) }\n  public fun resource_exhausted(r: u64): u64 {  canonical(RESOURCE_EXHAUSTED, r) }\n  public fun internal(r: u64): u64 {  canonical(INTERNAL, r) }\n  public fun not_implemented(r: u64): u64 {  canonical(NOT_IMPLEMENTED, r) }\n  public fun unavailable(r: u64): u64 { canonical(UNAVAILABLE, r) }\n}\n","name":"error.move"},{"content":"/// Defines a fixed-point numeric type with a 32-bit integer part and\n/// a 32-bit fractional part.\n\nmodule std::fixed_point32 {\n\n    /// Define a fixed-point numeric type with 32 fractional bits.\n    /// This is just a u64 integer but it is wrapped in a struct to\n    /// make a unique type. This is a binary representation, so decimal\n    /// values may not be exactly representable, but it provides more\n    /// than 9 decimal digits of precision both before and after the\n    /// decimal point (18 digits total). For comparison, double precision\n    /// floating-point has less than 16 decimal digits of precision, so\n    /// be careful about using floating-point to convert these values to\n    /// decimal.\n    struct FixedPoint32 has copy, drop, store { value: u64 }\n\n    const MAX_U64: u128 = 18446744073709551615;\n\n    /// The denominator provided was zero\n    const EDENOMINATOR: u64 = 0x10001;\n    /// The quotient value would be too large to be held in a `u64`\n    const EDIVISION: u64 = 0x20002;\n    /// The multiplied value would be too large to be held in a `u64`\n    const EMULTIPLICATION: u64 = 0x20003;\n    /// A division by zero was encountered\n    const EDIVISION_BY_ZERO: u64 = 0x10004;\n    /// The computed ratio when converting to a `FixedPoint32` would be unrepresentable\n    const ERATIO_OUT_OF_RANGE: u64 = 0x20005;\n\n    /// Multiply a u64 integer by a fixed-point number, truncating any\n    /// fractional part of the product. This will abort if the product\n    /// overflows.\n    public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64 {\n        // The product of two 64 bit values has 128 bits, so perform the\n        // multiplication with u128 types and keep the full 128 bit product\n        // to avoid losing accuracy.\n        let unscaled_product = (val as u128) * (multiplier.value as u128);\n        // The unscaled product has 32 fractional bits (from the multiplier)\n        // so rescale it by shifting away the low bits.\n        let product = unscaled_product >> 32;\n        // Check whether the value is too large.\n        assert!(product <= MAX_U64, EMULTIPLICATION);\n        (product as u64)\n    }\n    spec multiply_u64 {\n        pragma opaque;\n        include MultiplyAbortsIf;\n        ensures result == spec_multiply_u64(val, multiplier);\n    }\n    spec schema MultiplyAbortsIf {\n        val: num;\n        multiplier: FixedPoint32;\n        aborts_if spec_multiply_u64(val, multiplier) > MAX_U64 with EMULTIPLICATION;\n    }\n    spec fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num {\n        (val * multiplier.value) >> 32\n    }\n\n    /// Divide a u64 integer by a fixed-point number, truncating any\n    /// fractional part of the quotient. This will abort if the divisor\n    /// is zero or if the quotient overflows.\n    public fun divide_u64(val: u64, divisor: FixedPoint32): u64 {\n        // Check for division by zero.\n        assert!(divisor.value != 0, EDIVISION_BY_ZERO);\n        // First convert to 128 bits and then shift left to\n        // add 32 fractional zero bits to the dividend.\n        let scaled_value = (val as u128) << 32;\n        let quotient = scaled_value / (divisor.value as u128);\n        // Check whether the value is too large.\n        assert!(quotient <= MAX_U64, EDIVISION);\n        // the value may be too large, which will cause the cast to fail\n        // with an arithmetic error.\n        (quotient as u64)\n    }\n    spec divide_u64 {\n        pragma opaque;\n        include DivideAbortsIf;\n        ensures result == spec_divide_u64(val, divisor);\n    }\n    spec schema DivideAbortsIf {\n        val: num;\n        divisor: FixedPoint32;\n        aborts_if divisor.value == 0 with EDIVISION_BY_ZERO;\n        aborts_if spec_divide_u64(val, divisor) > MAX_U64 with EDIVISION;\n    }\n    spec fun spec_divide_u64(val: num, divisor: FixedPoint32): num {\n        (val << 32) / divisor.value\n    }\n\n    /// Create a fixed-point value from a rational number specified by its\n    /// numerator and denominator. Calling this function should be preferred\n    /// for using `Self::create_from_raw_value` which is also available.\n    /// This will abort if the denominator is zero. It will also\n    /// abort if the numerator is nonzero and the ratio is not in the range\n    /// 2^-32 .. 2^32-1. When specifying decimal fractions, be careful about\n    /// rounding errors: if you round to display N digits after the decimal\n    /// point, you can use a denominator of 10^N to avoid numbers where the\n    /// very small imprecision in the binary representation could change the\n    /// rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.\n    public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32 {\n        // If the denominator is zero, this will abort.\n        // Scale the numerator to have 64 fractional bits and the denominator\n        // to have 32 fractional bits, so that the quotient will have 32\n        // fractional bits.\n        let scaled_numerator = (numerator as u128) << 64;\n        let scaled_denominator = (denominator as u128) << 32;\n        assert!(scaled_denominator != 0, EDENOMINATOR);\n        let quotient = scaled_numerator / scaled_denominator;\n        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);\n        // Return the quotient as a fixed-point number. We first need to check whether the cast\n        // can succeed.\n        assert!(quotient <= MAX_U64, ERATIO_OUT_OF_RANGE);\n        FixedPoint32 { value: (quotient as u64) }\n    }\n    spec create_from_rational {\n        pragma opaque;\n        include CreateFromRationalAbortsIf;\n        ensures result == spec_create_from_rational(numerator, denominator);\n    }\n    spec schema CreateFromRationalAbortsIf {\n        numerator: u64;\n        denominator: u64;\n        let scaled_numerator = (numerator as u128)<< 64;\n        let scaled_denominator = (denominator as u128) << 32;\n        let quotient = scaled_numerator / scaled_denominator;\n        aborts_if scaled_denominator == 0 with EDENOMINATOR;\n        aborts_if quotient == 0 && scaled_numerator != 0 with ERATIO_OUT_OF_RANGE;\n        aborts_if quotient > MAX_U64 with ERATIO_OUT_OF_RANGE;\n    }\n    spec fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint32 {\n        FixedPoint32{value: (numerator << 64) / (denominator << 32)}\n    }\n\n    /// Create a fixedpoint value from a raw value.\n    public fun create_from_raw_value(value: u64): FixedPoint32 {\n        FixedPoint32 { value }\n    }\n    spec create_from_raw_value {\n        pragma opaque;\n        aborts_if false;\n        ensures result.value == value;\n    }\n\n    /// Accessor for the raw u64 value. Other less common operations, such as\n    /// adding or subtracting FixedPoint32 values, can be done using the raw\n    /// values directly.\n    public fun get_raw_value(num: FixedPoint32): u64 {\n        num.value\n    }\n\n    /// Returns true if the ratio is zero.\n    public fun is_zero(num: FixedPoint32): bool {\n        num.value == 0\n    }\n\n    /// Returns the smaller of the two FixedPoint32 numbers.\n    public fun min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {\n        if (num1.value < num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n    spec min {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_min(num1, num2);\n    }\n    spec fun spec_min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {\n        if (num1.value < num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n\n    /// Returns the larger of the two FixedPoint32 numbers.\n    public fun max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {\n        if (num1.value > num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n    spec max {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_max(num1, num2);\n    }\n    spec fun spec_max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {\n        if (num1.value > num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n\n    /// Create a fixedpoint value from a u64 value.\n    public fun create_from_u64(val: u64): FixedPoint32 {\n        let value = (val as u128) << 32;\n        assert!(value <= MAX_U64, ERATIO_OUT_OF_RANGE);\n        FixedPoint32 {value: (value as u64)}\n    }\n    spec create_from_u64 {\n        pragma opaque;\n        include CreateFromU64AbortsIf;\n        ensures result == spec_create_from_u64(val);\n    }\n    spec schema CreateFromU64AbortsIf {\n        val: num;\n        let scaled_value = (val as u128) << 32;\n        aborts_if scaled_value > MAX_U64;\n    }\n    spec fun spec_create_from_u64(val: num): FixedPoint32 {\n        FixedPoint32 {value: val << 32}\n    }\n\n    /// Returns the largest integer less than or equal to a given number.\n    public fun floor(num: FixedPoint32): u64 {\n        num.value >> 32\n    }\n    spec floor {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_floor(num);\n    }\n    spec fun spec_floor(val: FixedPoint32): u64 {\n        let fractional = val.value % (1 << 32);\n        if (fractional == 0) {\n            val.value >> 32\n        } else {\n            (val.value - fractional) >> 32\n        }\n    }\n\n    /// Rounds up the given FixedPoint32 to the next largest integer.\n    public fun ceil(num: FixedPoint32): u64 {\n        let floored_num = floor(num) << 32;\n        if (num.value == floored_num) {\n            return floored_num >> 32\n        };\n        let val = ((floored_num as u128) + (1 << 32));\n        (val >> 32 as u64)\n    }\n    spec ceil {\n        pragma verify_duration_estimate = 120;\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_ceil(num);\n    }\n    spec fun spec_ceil(val: FixedPoint32): u64 {\n        let fractional = val.value % (1 << 32);\n        let one = 1 << 32;\n        if (fractional == 0) {\n            val.value >> 32\n        } else {\n            (val.value - fractional + one) >> 32\n        }\n    }\n\n    /// Returns the value of a FixedPoint32 to the nearest integer.\n    public fun round(num: FixedPoint32): u64 {\n        let floored_num = floor(num) << 32;\n        let boundary = floored_num + ((1 << 32) / 2);\n        if (num.value < boundary) {\n            floored_num >> 32\n        } else {\n            ceil(num)\n        }\n    }\n    spec round {\n        pragma verify_duration_estimate = 120;\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_round(num);\n    }\n    spec fun spec_round(val: FixedPoint32): u64 {\n        let fractional = val.value % (1 << 32);\n        let boundary = (1 << 32) / 2;\n        let one = 1 << 32;\n        if (fractional < boundary) {\n            (val.value - fractional) >> 32\n        } else {\n            (val.value - fractional + one) >> 32\n        }\n    }\n\n    // **************** SPECIFICATIONS ****************\n\n    spec module {} // switch documentation context to module level\n\n    spec module {\n        pragma aborts_if_is_strict;\n    }\n}\n","name":"fixed_point32.move"},{"content":"/// Module which defines SHA hashes for byte vectors.\n///\n/// The functions in this module are natively declared both in the Move runtime\n/// as in the Move prover's prelude.\nmodule std::hash {\n    native public fun sha2_256(data: vector<u8>): vector<u8>;\n    native public fun sha3_256(data: vector<u8>): vector<u8>;\n}\n","name":"hash.move"},{"content":"/// This module defines the Option type and its methods to represent and handle an optional value.\nmodule std::option {\n    use std::vector;\n\n    /// Abstraction of a value that may or may not be present. Implemented with a vector of size\n    /// zero or one because Move bytecode does not have ADTs.\n    struct Option<Element> has copy, drop, store {\n        vec: vector<Element>\n    }\n    spec Option {\n        /// The size of vector is always less than equal to 1\n        /// because it's 0 for \"none\" or 1 for \"some\".\n        invariant len(vec) <= 1;\n    }\n\n    /// The `Option` is in an invalid state for the operation attempted.\n    /// The `Option` is `Some` while it should be `None`.\n    const EOPTION_IS_SET: u64 = 0x40000;\n    /// The `Option` is in an invalid state for the operation attempted.\n    /// The `Option` is `None` while it should be `Some`.\n    const EOPTION_NOT_SET: u64 = 0x40001;\n    /// Cannot construct an option from a vector with 2 or more elements.\n    const EOPTION_VEC_TOO_LONG: u64 = 0x40002;\n\n    /// Return an empty `Option`\n    public fun none<Element>(): Option<Element> {\n        Option { vec: vector::empty() }\n    }\n    spec none {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_none<Element>();\n    }\n    spec fun spec_none<Element>(): Option<Element> {\n        Option{ vec: vec() }\n    }\n\n    /// Return an `Option` containing `e`\n    public fun some<Element>(e: Element): Option<Element> {\n        Option { vec: vector::singleton(e) }\n    }\n    spec some {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_some(e);\n    }\n    spec fun spec_some<Element>(e: Element): Option<Element> {\n        Option{ vec: vec(e) }\n    }\n\n    public fun from_vec<Element>(vec: vector<Element>): Option<Element> {\n        assert!(vector::length(&vec) <= 1, EOPTION_VEC_TOO_LONG);\n        Option { vec }\n    }\n\n    spec from_vec {\n        aborts_if vector::length(vec) > 1;\n    }\n\n    /// Return true if `t` does not hold a value\n    public fun is_none<Element>(t: &Option<Element>): bool {\n        vector::is_empty(&t.vec)\n    }\n    spec is_none {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_is_none(t);\n    }\n    spec fun spec_is_none<Element>(t: Option<Element>): bool {\n        vector::is_empty(t.vec)\n    }\n\n    /// Return true if `t` holds a value\n    public fun is_some<Element>(t: &Option<Element>): bool {\n        !vector::is_empty(&t.vec)\n    }\n    spec is_some {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_is_some(t);\n    }\n    spec fun spec_is_some<Element>(t: Option<Element>): bool {\n        !vector::is_empty(t.vec)\n    }\n\n    /// Return true if the value in `t` is equal to `e_ref`\n    /// Always returns `false` if `t` does not hold a value\n    public fun contains<Element>(t: &Option<Element>, e_ref: &Element): bool {\n        vector::contains(&t.vec, e_ref)\n    }\n    spec contains {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_contains(t, e_ref);\n    }\n    spec fun spec_contains<Element>(t: Option<Element>, e: Element): bool {\n        is_some(t) && borrow(t) == e\n    }\n\n    /// Return an immutable reference to the value inside `t`\n    /// Aborts if `t` does not hold a value\n    public fun borrow<Element>(t: &Option<Element>): &Element {\n        assert!(is_some(t), EOPTION_NOT_SET);\n        vector::borrow(&t.vec, 0)\n    }\n    spec borrow {\n        pragma opaque;\n        include AbortsIfNone<Element>;\n        ensures result == spec_borrow(t);\n    }\n    spec fun spec_borrow<Element>(t: Option<Element>): Element {\n        t.vec[0]\n    }\n\n    /// Return a reference to the value inside `t` if it holds one\n    /// Return `default_ref` if `t` does not hold a value\n    public fun borrow_with_default<Element>(t: &Option<Element>, default_ref: &Element): &Element {\n        let vec_ref = &t.vec;\n        if (vector::is_empty(vec_ref)) default_ref\n        else vector::borrow(vec_ref, 0)\n    }\n    spec borrow_with_default {\n        pragma opaque;\n        aborts_if false;\n        ensures result == (if (spec_is_some(t)) spec_borrow(t) else default_ref);\n    }\n\n    /// Return the value inside `t` if it holds one\n    /// Return `default` if `t` does not hold a value\n    public fun get_with_default<Element: copy + drop>(\n        t: &Option<Element>,\n        default: Element,\n    ): Element {\n        let vec_ref = &t.vec;\n        if (vector::is_empty(vec_ref)) default\n        else *vector::borrow(vec_ref, 0)\n    }\n    spec get_with_default {\n        pragma opaque;\n        aborts_if false;\n        ensures result == (if (spec_is_some(t)) spec_borrow(t) else default);\n    }\n\n    /// Convert the none option `t` to a some option by adding `e`.\n    /// Aborts if `t` already holds a value\n    public fun fill<Element>(t: &mut Option<Element>, e: Element) {\n        let vec_ref = &mut t.vec;\n        if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e)\n        else abort EOPTION_IS_SET\n    }\n    spec fill {\n        pragma opaque;\n        aborts_if spec_is_some(t) with EOPTION_IS_SET;\n        ensures spec_is_some(t);\n        ensures spec_borrow(t) == e;\n    }\n\n    /// Convert a `some` option to a `none` by removing and returning the value stored inside `t`\n    /// Aborts if `t` does not hold a value\n    public fun extract<Element>(t: &mut Option<Element>): Element {\n        assert!(is_some(t), EOPTION_NOT_SET);\n        vector::pop_back(&mut t.vec)\n    }\n    spec extract {\n        pragma opaque;\n        include AbortsIfNone<Element>;\n        ensures result == spec_borrow(old(t));\n        ensures spec_is_none(t);\n    }\n\n    /// Return a mutable reference to the value inside `t`\n    /// Aborts if `t` does not hold a value\n    public fun borrow_mut<Element>(t: &mut Option<Element>): &mut Element {\n        assert!(is_some(t), EOPTION_NOT_SET);\n        vector::borrow_mut(&mut t.vec, 0)\n    }\n    spec borrow_mut {\n        include AbortsIfNone<Element>;\n        ensures result == spec_borrow(t);\n        ensures t == old(t);\n    }\n\n    /// Swap the old value inside `t` with `e` and return the old value\n    /// Aborts if `t` does not hold a value\n    public fun swap<Element>(t: &mut Option<Element>, e: Element): Element {\n        assert!(is_some(t), EOPTION_NOT_SET);\n        let vec_ref = &mut t.vec;\n        let old_value = vector::pop_back(vec_ref);\n        vector::push_back(vec_ref, e);\n        old_value\n    }\n    spec swap {\n        pragma opaque;\n        include AbortsIfNone<Element>;\n        ensures result == spec_borrow(old(t));\n        ensures spec_is_some(t);\n        ensures spec_borrow(t) == e;\n    }\n\n    /// Swap the old value inside `t` with `e` and return the old value;\n    /// or if there is no old value, fill it with `e`.\n    /// Different from swap(), swap_or_fill() allows for `t` not holding a value.\n    public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {\n        let vec_ref = &mut t.vec;\n        let old_value = if (vector::is_empty(vec_ref)) none()\n            else some(vector::pop_back(vec_ref));\n        vector::push_back(vec_ref, e);\n        old_value\n    }\n    spec swap_or_fill {\n        pragma opaque;\n        aborts_if false;\n        ensures result == old(t);\n        ensures spec_borrow(t) == e;\n    }\n\n    /// Destroys `t.` If `t` holds a value, return it. Returns `default` otherwise\n    public fun destroy_with_default<Element: drop>(t: Option<Element>, default: Element): Element {\n        let Option { vec } = t;\n        if (vector::is_empty(&mut vec)) default\n        else vector::pop_back(&mut vec)\n    }\n    spec destroy_with_default {\n        pragma opaque;\n        aborts_if false;\n        ensures result == (if (spec_is_some(t)) spec_borrow(t) else default);\n    }\n\n    /// Unpack `t` and return its contents\n    /// Aborts if `t` does not hold a value\n    public fun destroy_some<Element>(t: Option<Element>): Element {\n        assert!(is_some(&t), EOPTION_NOT_SET);\n        let Option { vec } = t;\n        let elem = vector::pop_back(&mut vec);\n        vector::destroy_empty(vec);\n        elem\n    }\n    spec destroy_some {\n        pragma opaque;\n        include AbortsIfNone<Element>;\n        ensures result == spec_borrow(t);\n    }\n\n    /// Unpack `t`\n    /// Aborts if `t` holds a value\n    public fun destroy_none<Element>(t: Option<Element>) {\n        assert!(is_none(&t), EOPTION_IS_SET);\n        let Option { vec } = t;\n        vector::destroy_empty(vec)\n    }\n    spec destroy_none {\n        pragma opaque;\n        aborts_if spec_is_some(t) with EOPTION_IS_SET;\n    }\n\n    /// Convert `t` into a vector of length 1 if it is `Some`,\n    /// and an empty vector otherwise\n    public fun to_vec<Element>(t: Option<Element>): vector<Element> {\n        let Option { vec } = t;\n        vec\n    }\n    spec to_vec {\n        pragma opaque;\n        aborts_if false;\n        ensures result == t.vec;\n    }\n    /// Apply the function to the optional element, consuming it. Does nothing if no value present.\n    public inline fun for_each<Element>(o: Option<Element>, f: |Element|) {\n        if (is_some(&o)) {\n            f(destroy_some(o))\n        } else {\n            destroy_none(o)\n        }\n    }\n\n    /// Apply the function to the optional element reference. Does nothing if no value present.\n    public inline fun for_each_ref<Element>(o: &Option<Element>, f: |&Element|) {\n        if (is_some(o)) {\n            f(borrow(o))\n        }\n    }\n\n    /// Apply the function to the optional element reference. Does nothing if no value present.\n    public inline fun for_each_mut<Element>(o: &mut Option<Element>, f: |&mut Element|) {\n        if (is_some(o)) {\n            f(borrow_mut(o))\n        }\n    }\n\n    /// Folds the function over the optional element.\n    public inline fun fold<Accumulator, Element>(\n        o: Option<Element>,\n        init: Accumulator,\n        f: |Accumulator,Element|Accumulator\n    ): Accumulator {\n        if (is_some(&o)) {\n            f(init, destroy_some(o))\n        } else {\n            destroy_none(o);\n            init\n        }\n    }\n\n    /// Maps the content of an option.\n    public inline fun map<Element, OtherElement>(o: Option<Element>, f: |Element|OtherElement): Option<OtherElement> {\n        if (is_some(&o)) {\n            some(f(destroy_some(o)))\n        } else {\n            destroy_none(o);\n            none()\n        }\n    }\n\n    /// Maps the content of an option without destroying the original option.\n    public inline fun map_ref<Element, OtherElement>(\n        o: &Option<Element>, f: |&Element|OtherElement): Option<OtherElement> {\n        if (is_some(o)) {\n            some(f(borrow(o)))\n        } else {\n            none()\n        }\n    }\n\n    /// Filters the content of an option\n    public inline fun filter<Element:drop>(o: Option<Element>, f: |&Element|bool): Option<Element> {\n        if (is_some(&o) && f(borrow(&o))) {\n            o\n        } else {\n            none()\n        }\n    }\n\n    /// Returns true if the option contains an element which satisfies predicate.\n    public inline fun any<Element>(o: &Option<Element>, p: |&Element|bool): bool {\n        is_some(o) && p(borrow(o))\n    }\n\n    /// Utility function to destroy an option that is not droppable.\n    public inline fun destroy<Element>(o: Option<Element>, d: |Element|) {\n        let vec = to_vec(o);\n        vector::destroy(vec, |e| d(e));\n    }\n\n    spec module {} // switch documentation context back to module level\n\n    spec module {\n        pragma aborts_if_is_strict;\n    }\n\n    /// # Helper Schema\n\n    spec schema AbortsIfNone<Element> {\n        t: Option<Element>;\n        aborts_if spec_is_none(t) with EOPTION_NOT_SET;\n    }\n}\n","name":"option.move"},{"content":"module std::signer {\n    /// Borrows the address of the signer\n    /// Conceptually, you can think of the `signer` as being a struct wrapper around an\n    /// address\n    /// ```\n    /// struct signer has drop { addr: address }\n    /// ```\n    /// `borrow_address` borrows this inner field\n    native public fun borrow_address(s: &signer): &address;\n\n    // Copies the address of the signer\n    public fun address_of(s: &signer): address {\n        *borrow_address(s)\n    }\n\n    /// Return true only if `s` is a transaction signer. This is a spec function only available in spec.\n    spec native fun is_txn_signer(s: signer): bool;\n\n    /// Return true only if `a` is a transaction signer address. This is a spec function only available in spec.\n    spec native fun is_txn_signer_addr(a: address): bool;\n}\n","name":"signer.move"},{"content":"/// The `string` module defines the `String` type which represents UTF8 encoded strings.\nmodule std::string {\n    use std::vector;\n    use std::option::{Self, Option};\n\n    /// An invalid UTF8 encoding.\n    const EINVALID_UTF8: u64 = 1;\n\n    /// Index out of range.\n    const EINVALID_INDEX: u64 = 2;\n\n    /// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.\n    struct String has copy, drop, store {\n        bytes: vector<u8>,\n    }\n\n    /// Creates a new string from a sequence of bytes. Aborts if the bytes do not represent valid utf8.\n    public fun utf8(bytes: vector<u8>): String {\n        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);\n        String{bytes}\n    }\n\n    /// Tries to create a new string from a sequence of bytes.\n    public fun try_utf8(bytes: vector<u8>): Option<String> {\n        if (internal_check_utf8(&bytes)) {\n            option::some(String{bytes})\n        } else {\n            option::none()\n        }\n    }\n\n    /// Returns a reference to the underlying byte vector.\n    public fun bytes(s: &String): &vector<u8> {\n        &s.bytes\n    }\n\n    /// Checks whether this string is empty.\n    public fun is_empty(s: &String): bool {\n        vector::is_empty(&s.bytes)\n    }\n\n    /// Returns the length of this string, in bytes.\n    public fun length(s: &String): u64 {\n        vector::length(&s.bytes)\n    }\n\n    /// Appends a string.\n    public fun append(s: &mut String, r: String) {\n        vector::append(&mut s.bytes, r.bytes)\n    }\n\n    /// Appends bytes which must be in valid utf8 format.\n    public fun append_utf8(s: &mut String, bytes: vector<u8>) {\n        append(s, utf8(bytes))\n    }\n\n    /// Insert the other string at the byte index in given string. The index must be at a valid utf8 char\n    /// boundary.\n    public fun insert(s: &mut String, at: u64, o: String) {\n        let bytes = &s.bytes;\n        assert!(at <= vector::length(bytes) && internal_is_char_boundary(bytes, at), EINVALID_INDEX);\n        let l = length(s);\n        let front = sub_string(s, 0, at);\n        let end = sub_string(s, at, l);\n        append(&mut front, o);\n        append(&mut front, end);\n        *s = front;\n    }\n\n    /// Returns a sub-string using the given byte indices, where `i` is the first byte position and `j` is the start\n    /// of the first byte not included (or the length of the string). The indices must be at valid utf8 char boundaries,\n    /// guaranteeing that the result is valid utf8.\n    public fun sub_string(s: &String, i: u64, j: u64): String {\n        let bytes = &s.bytes;\n        let l = vector::length(bytes);\n        assert!(\n            j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j),\n            EINVALID_INDEX\n        );\n        String { bytes: internal_sub_string(bytes, i, j) }\n    }\n\n    /// Computes the index of the first occurrence of a string. Returns `length(s)` if no occurrence found.\n    public fun index_of(s: &String, r: &String): u64 {\n        internal_index_of(&s.bytes, &r.bytes)\n    }\n\n    // Native API\n    public native fun internal_check_utf8(v: &vector<u8>): bool;\n    native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;\n    native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;\n    native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;\n}\n","name":"string.move"},{"content":"/// A variable-sized container that can hold any type. Indexing is 0-based, and\n/// vectors are growable. This module has many native functions.\n/// Verification of modules that use this one uses model functions that are implemented\n/// directly in Boogie. The specification language has built-in functions operations such\n/// as `singleton_vector`. There are some helper functions defined here for specifications in other\n/// modules as well.\n///\n/// >Note: We did not verify most of the\n/// Move functions here because many have loops, requiring loop invariants to prove, and\n/// the return on investment didn't seem worth it for these simple functions.\nmodule std::vector {\n    /// The index into the vector is out of bounds\n    const EINDEX_OUT_OF_BOUNDS: u64 = 0x20000;\n\n    /// The index into the vector is out of bounds\n    const EINVALID_RANGE: u64 = 0x20001;\n\n    /// The length of the vectors are not equal.\n    const EVECTORS_LENGTH_MISMATCH: u64 = 0x20002;\n\n    /// The step provided in `range` is invalid, must be greater than zero.\n    const EINVALID_STEP: u64 = 0x20003;\n\n    /// The range in `slice` is invalid.\n    const EINVALID_SLICE_RANGE: u64 = 0x20004;\n\n    #[bytecode_instruction]\n    /// Create an empty vector.\n    native public fun empty<Element>(): vector<Element>;\n\n    #[bytecode_instruction]\n    /// Return the length of the vector.\n    native public fun length<Element>(v: &vector<Element>): u64;\n\n    #[bytecode_instruction]\n    /// Acquire an immutable reference to the `i`th element of the vector `v`.\n    /// Aborts if `i` is out of bounds.\n    native public fun borrow<Element>(v: &vector<Element>, i: u64): &Element;\n\n    #[bytecode_instruction]\n    /// Add element `e` to the end of the vector `v`.\n    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);\n\n    #[bytecode_instruction]\n    /// Return a mutable reference to the `i`th element in the vector `v`.\n    /// Aborts if `i` is out of bounds.\n    native public fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;\n\n    #[bytecode_instruction]\n    /// Pop an element from the end of vector `v`.\n    /// Aborts if `v` is empty.\n    native public fun pop_back<Element>(v: &mut vector<Element>): Element;\n\n    #[bytecode_instruction]\n    /// Destroy the vector `v`.\n    /// Aborts if `v` is not empty.\n    native public fun destroy_empty<Element>(v: vector<Element>);\n\n    #[bytecode_instruction]\n    /// Swaps the elements at the `i`th and `j`th indices in the vector `v`.\n    /// Aborts if `i` or `j` is out of bounds.\n    native public fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64);\n\n    /// Return an vector of size one containing element `e`.\n    public fun singleton<Element>(e: Element): vector<Element> {\n        let v = empty();\n        push_back(&mut v, e);\n        v\n    }\n    spec singleton {\n        aborts_if false;\n        ensures result == vec(e);\n    }\n\n    /// Reverses the order of the elements in the vector `v` in place.\n    public fun reverse<Element>(v: &mut vector<Element>) {\n        let len = length(v);\n        reverse_slice(v, 0, len);\n    }\n\n    spec reverse {\n        pragma intrinsic = true;\n    }\n\n    /// Reverses the order of the elements [left, right) in the vector `v` in place.\n    public fun reverse_slice<Element>(v: &mut vector<Element>, left: u64, right: u64) {\n        assert!(left <= right, EINVALID_RANGE);\n        if (left == right) return;\n        right = right - 1;\n        while (left < right) {\n            swap(v, left, right);\n            left = left + 1;\n            right = right - 1;\n        }\n    }\n    spec reverse_slice {\n        pragma intrinsic = true;\n    }\n\n    /// Pushes all of the elements of the `other` vector into the `lhs` vector.\n    public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>) {\n        reverse(&mut other);\n        reverse_append(lhs, other);\n    }\n    spec append {\n        pragma intrinsic = true;\n    }\n    spec is_empty {\n        pragma intrinsic = true;\n    }\n\n    /// Pushes all of the elements of the `other` vector into the `lhs` vector.\n    public fun reverse_append<Element>(lhs: &mut vector<Element>, other: vector<Element>) {\n        let len = length(&other);\n        while (len > 0) {\n            push_back(lhs, pop_back(&mut other));\n            len = len - 1;\n        };\n        destroy_empty(other);\n    }\n    spec reverse_append {\n        pragma intrinsic = true;\n    }\n\n    /// Trim a vector to a smaller size, returning the evicted elements in order\n    public fun trim<Element>(v: &mut vector<Element>, new_len: u64): vector<Element> {\n        let res = trim_reverse(v, new_len);\n        reverse(&mut res);\n        res\n    }\n    spec trim {\n        pragma intrinsic = true;\n    }\n\n    /// Trim a vector to a smaller size, returning the evicted elements in reverse order\n    public fun trim_reverse<Element>(v: &mut vector<Element>, new_len: u64): vector<Element> {\n        let len = length(v);\n        assert!(new_len <= len, EINDEX_OUT_OF_BOUNDS);\n        let result = empty();\n        while (new_len < len) {\n            push_back(&mut result, pop_back(v));\n            len = len - 1;\n        };\n        result\n    }\n    spec trim_reverse {\n        pragma intrinsic = true;\n    }\n\n\n    /// Return `true` if the vector `v` has no elements and `false` otherwise.\n    public fun is_empty<Element>(v: &vector<Element>): bool {\n        length(v) == 0\n    }\n\n    /// Return true if `e` is in the vector `v`.\n    public fun contains<Element>(v: &vector<Element>, e: &Element): bool {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            if (borrow(v, i) == e) return true;\n            i = i + 1;\n        };\n        false\n    }\n    spec contains {\n        pragma intrinsic = true;\n    }\n\n    /// Return `(true, i)` if `e` is in the vector `v` at index `i`.\n    /// Otherwise, returns `(false, 0)`.\n    public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            if (borrow(v, i) == e) return (true, i);\n            i = i + 1;\n        };\n        (false, 0)\n    }\n    spec index_of {\n        pragma intrinsic = true;\n    }\n\n    /// Return `(true, i)` if there's an element that matches the predicate. If there are multiple elements that match\n    /// the predicate, only the index of the first one is returned.\n    /// Otherwise, returns `(false, 0)`.\n    public inline fun find<Element>(v: &vector<Element>, f: |&Element|bool): (bool, u64) {\n        let find = false;\n        let found_index = 0;\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            // Cannot call return in an inline function so we need to resort to break here.\n            if (f(borrow(v, i))) {\n                find = true;\n                found_index = i;\n                break\n            };\n            i = i + 1;\n        };\n        (find, found_index)\n    }\n\n    /// Insert a new element at position 0 <= i <= length, using O(length - i) time.\n    /// Aborts if out of bounds.\n    public fun insert<Element>(v: &mut vector<Element>, i: u64, e: Element) {\n        let len = length(v);\n        assert!(i <= len, EINDEX_OUT_OF_BOUNDS);\n        push_back(v, e);\n        while (i < len) {\n            swap(v, i, len);\n            i = i + 1;\n        };\n    }\n    spec insert {\n        pragma intrinsic = true;\n    }\n\n    /// Remove the `i`th element of the vector `v`, shifting all subsequent elements.\n    /// This is O(n) and preserves ordering of elements in the vector.\n    /// Aborts if `i` is out of bounds.\n    public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {\n        let len = length(v);\n        // i out of bounds; abort\n        if (i >= len) abort EINDEX_OUT_OF_BOUNDS;\n\n        len = len - 1;\n        while (i < len) swap(v, i, { i = i + 1; i });\n        pop_back(v)\n    }\n    spec remove {\n        pragma intrinsic = true;\n    }\n\n    /// Remove the first occurrence of a given value in the vector `v` and return it in a vector, shifting all\n    /// subsequent elements.\n    /// This is O(n) and preserves ordering of elements in the vector.\n    /// This returns an empty vector if the value isn't present in the vector.\n    /// Note that this cannot return an option as option uses vector and there'd be a circular dependency between option\n    /// and vector.\n    public fun remove_value<Element>(v: &mut vector<Element>, val: &Element): vector<Element> {\n        // This doesn't cost a O(2N) run time as index_of scans from left to right and stops when the element is found,\n        // while remove would continue from the identified index to the end of the vector.\n        let (found, index) = index_of(v, val);\n        if (found) {\n            vector[remove(v, index)]\n        } else {\n           vector[]\n        }\n    }\n    spec remove_value {\n        pragma intrinsic = true;\n    }\n\n    /// Swap the `i`th element of the vector `v` with the last element and then pop the vector.\n    /// This is O(1), but does not preserve ordering of elements in the vector.\n    /// Aborts if `i` is out of bounds.\n    public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {\n        assert!(!is_empty(v), EINDEX_OUT_OF_BOUNDS);\n        let last_idx = length(v) - 1;\n        swap(v, i, last_idx);\n        pop_back(v)\n    }\n    spec swap_remove {\n        pragma intrinsic = true;\n    }\n\n    /// Apply the function to each element in the vector, consuming it.\n    public inline fun for_each<Element>(v: vector<Element>, f: |Element|) {\n        reverse(&mut v); // We need to reverse the vector to consume it efficiently\n        for_each_reverse(v, |e| f(e));\n    }\n\n    /// Apply the function to each element in the vector, consuming it.\n    public inline fun for_each_reverse<Element>(v: vector<Element>, f: |Element|) {\n        let len = length(&v);\n        while (len > 0) {\n            f(pop_back(&mut v));\n            len = len - 1;\n        };\n        destroy_empty(v)\n    }\n\n    /// Apply the function to a reference of each element in the vector.\n    public inline fun for_each_ref<Element>(v: &vector<Element>, f: |&Element|) {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            f(borrow(v, i));\n            i = i + 1\n        }\n    }\n\n    /// Apply the function to each pair of elements in the two given vectors, consuming them.\n    public inline fun zip<Element1, Element2>(v1: vector<Element1>, v2: vector<Element2>, f: |Element1, Element2|) {\n        // We need to reverse the vectors to consume it efficiently\n        reverse(&mut v1);\n        reverse(&mut v2);\n        zip_reverse(v1, v2, |e1, e2| f(e1, e2));\n    }\n\n    /// Apply the function to each pair of elements in the two given vectors in the reverse order, consuming them.\n    /// This errors out if the vectors are not of the same length.\n    public inline fun zip_reverse<Element1, Element2>(\n        v1: vector<Element1>,\n        v2: vector<Element2>,\n        f: |Element1, Element2|,\n    ) {\n        let len = length(&v1);\n        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(len == length(&v2), 0x20002);\n        while (len > 0) {\n            f(pop_back(&mut v1), pop_back(&mut v2));\n            len = len - 1;\n        };\n        destroy_empty(v1);\n        destroy_empty(v2);\n    }\n\n    /// Apply the function to the references of each pair of elements in the two given vectors.\n    /// This errors out if the vectors are not of the same length.\n    public inline fun zip_ref<Element1, Element2>(\n        v1: &vector<Element1>,\n        v2: &vector<Element2>,\n        f: |&Element1, &Element2|,\n    ) {\n        let len = length(v1);\n        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(len == length(v2), 0x20002);\n        let i = 0;\n        while (i < len) {\n            f(borrow(v1, i), borrow(v2, i));\n            i = i + 1\n        }\n    }\n\n    /// Apply the function to a reference of each element in the vector with its index.\n    public inline fun enumerate_ref<Element>(v: &vector<Element>, f: |u64, &Element|) {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            f(i, borrow(v, i));\n            i = i + 1;\n        };\n    }\n\n    /// Apply the function to a mutable reference to each element in the vector.\n    public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: |&mut Element|) {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            f(borrow_mut(v, i));\n            i = i + 1\n        }\n    }\n\n    /// Apply the function to mutable references to each pair of elements in the two given vectors.\n    /// This errors out if the vectors are not of the same length.\n    public inline fun zip_mut<Element1, Element2>(\n        v1: &mut vector<Element1>,\n        v2: &mut vector<Element2>,\n        f: |&mut Element1, &mut Element2|,\n    ) {\n        let i = 0;\n        let len = length(v1);\n        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(len == length(v2), 0x20002);\n        while (i < len) {\n            f(borrow_mut(v1, i), borrow_mut(v2, i));\n            i = i + 1\n        }\n    }\n\n    /// Apply the function to a mutable reference of each element in the vector with its index.\n    public inline fun enumerate_mut<Element>(v: &mut vector<Element>, f: |u64, &mut Element|) {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            f(i, borrow_mut(v, i));\n            i = i + 1;\n        };\n    }\n\n    /// Fold the function over the elements. For example, `fold(vector[1,2,3], 0, f)` will execute\n    /// `f(f(f(0, 1), 2), 3)`\n    public inline fun fold<Accumulator, Element>(\n        v: vector<Element>,\n        init: Accumulator,\n        f: |Accumulator,Element|Accumulator\n    ): Accumulator {\n        let accu = init;\n        for_each(v, |elem| accu = f(accu, elem));\n        accu\n    }\n\n    /// Fold right like fold above but working right to left. For example, `fold(vector[1,2,3], 0, f)` will execute\n    /// `f(1, f(2, f(3, 0)))`\n    public inline fun foldr<Accumulator, Element>(\n        v: vector<Element>,\n        init: Accumulator,\n        f: |Element, Accumulator|Accumulator\n    ): Accumulator {\n        let accu = init;\n        for_each_reverse(v, |elem| accu = f(elem, accu));\n        accu\n    }\n\n    /// Map the function over the references of the elements of the vector, producing a new vector without modifying the\n    /// original vector.\n    public inline fun map_ref<Element, NewElement>(\n        v: &vector<Element>,\n        f: |&Element|NewElement\n    ): vector<NewElement> {\n        let result = vector<NewElement>[];\n        for_each_ref(v, |elem| push_back(&mut result, f(elem)));\n        result\n    }\n\n    /// Map the function over the references of the element pairs of two vectors, producing a new vector from the return\n    /// values without modifying the original vectors.\n    public inline fun zip_map_ref<Element1, Element2, NewElement>(\n        v1: &vector<Element1>,\n        v2: &vector<Element2>,\n        f: |&Element1, &Element2|NewElement\n    ): vector<NewElement> {\n        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(length(v1) == length(v2), 0x20002);\n\n        let result = vector<NewElement>[];\n        zip_ref(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));\n        result\n    }\n\n    /// Map the function over the elements of the vector, producing a new vector.\n    public inline fun map<Element, NewElement>(\n        v: vector<Element>,\n        f: |Element|NewElement\n    ): vector<NewElement> {\n        let result = vector<NewElement>[];\n        for_each(v, |elem| push_back(&mut result, f(elem)));\n        result\n    }\n\n    /// Map the function over the element pairs of the two vectors, producing a new vector.\n    public inline fun zip_map<Element1, Element2, NewElement>(\n        v1: vector<Element1>,\n        v2: vector<Element2>,\n        f: |Element1, Element2|NewElement\n    ): vector<NewElement> {\n        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(length(&v1) == length(&v2), 0x20002);\n\n        let result = vector<NewElement>[];\n        zip(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));\n        result\n    }\n\n    /// Filter the vector using the boolean function, removing all elements for which `p(e)` is not true.\n    public inline fun filter<Element:drop>(\n        v: vector<Element>,\n        p: |&Element|bool\n    ): vector<Element> {\n        let result = vector<Element>[];\n        for_each(v, |elem| {\n            if (p(&elem)) push_back(&mut result, elem);\n        });\n        result\n    }\n\n    /// Partition, sorts all elements for which pred is true to the front.\n    /// Preserves the relative order of the elements for which pred is true,\n    /// BUT NOT for the elements for which pred is false.\n    public inline fun partition<Element>(\n        v: &mut vector<Element>,\n        pred: |&Element|bool\n    ): u64 {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            if (!pred(borrow(v, i))) break;\n            i = i + 1;\n        };\n        let p = i;\n        i = i + 1;\n        while (i < len) {\n            if (pred(borrow(v, i))) {\n                swap(v, p, i);\n                p = p + 1;\n            };\n            i = i + 1;\n        };\n        p\n    }\n\n    /// rotate(&mut [1, 2, 3, 4, 5], 2) -> [3, 4, 5, 1, 2] in place, returns the split point\n    /// ie. 3 in the example above\n    public fun rotate<Element>(\n        v: &mut vector<Element>,\n        rot: u64\n    ): u64 {\n        let len = length(v);\n        rotate_slice(v, 0, rot, len)\n    }\n    spec rotate {\n        pragma intrinsic = true;\n    }\n\n    /// Same as above but on a sub-slice of an array [left, right) with left <= rot <= right\n    /// returns the\n    public fun rotate_slice<Element>(\n        v: &mut vector<Element>,\n        left: u64,\n        rot: u64,\n        right: u64\n    ): u64 {\n        reverse_slice(v, left, rot);\n        reverse_slice(v, rot, right);\n        reverse_slice(v, left, right);\n        left + (right - rot)\n    }\n    spec rotate_slice {\n        pragma intrinsic = true;\n    }\n\n    /// Partition the array based on a predicate p, this routine is stable and thus\n    /// preserves the relative order of the elements in the two partitions.\n    public inline fun stable_partition<Element>(\n        v: &mut vector<Element>,\n        p: |&Element|bool\n    ): u64 {\n        let len = length(v);\n        let t = empty();\n        let f = empty();\n        while (len > 0) {\n            let e = pop_back(v);\n            if (p(&e)) {\n                push_back(&mut t, e);\n            } else {\n                push_back(&mut f, e);\n            };\n            len = len - 1;\n        };\n        let pos = length(&t);\n        reverse_append(v, t);\n        reverse_append(v, f);\n        pos\n    }\n\n    /// Return true if any element in the vector satisfies the predicate.\n    public inline fun any<Element>(\n        v: &vector<Element>,\n        p: |&Element|bool\n    ): bool {\n        let result = false;\n        let i = 0;\n        while (i < length(v)) {\n            result = p(borrow(v, i));\n            if (result) {\n                break\n            };\n            i = i + 1\n        };\n        result\n    }\n\n    /// Return true if all elements in the vector satisfy the predicate.\n    public inline fun all<Element>(\n        v: &vector<Element>,\n        p: |&Element|bool\n    ): bool {\n        let result = true;\n        let i = 0;\n        while (i < length(v)) {\n            result = p(borrow(v, i));\n            if (!result) {\n                break\n            };\n            i = i + 1\n        };\n        result\n    }\n\n    /// Destroy a vector, just a wrapper around for_each_reverse with a descriptive name\n    /// when used in the context of destroying a vector.\n    public inline fun destroy<Element>(\n        v: vector<Element>,\n        d: |Element|\n    ) {\n        for_each_reverse(v, |e| d(e))\n    }\n\n    public fun range(start: u64, end: u64): vector<u64> {\n        range_with_step(start, end, 1)\n    }\n\n    public fun range_with_step(start: u64, end: u64, step: u64): vector<u64> {\n        assert!(step > 0, EINVALID_STEP);\n\n        let vec = vector[];\n        while (start < end) {\n            push_back(&mut vec, start);\n            start = start + step;\n        };\n        vec\n    }\n\n    public fun slice<Element: copy>(\n        v: &vector<Element>,\n        start: u64,\n        end: u64\n    ): vector<Element> {\n        assert!(start <= end && end <= length(v), EINVALID_SLICE_RANGE);\n\n        let vec = vector[];\n        while (start < end) {\n            push_back(&mut vec, *borrow(v, start));\n            start = start + 1;\n        };\n        vec\n    }\n\n    // =================================================================\n    // Module Specification\n\n    spec module {} // Switch to module documentation context\n\n    /// # Helper Functions\n\n    spec module {\n        /// Check if `v1` is equal to the result of adding `e` at the end of `v2`\n        fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {\n            len(v1) == len(v2) + 1 &&\n            v1[len(v1)-1] == e &&\n            v1[0..len(v1)-1] == v2[0..len(v2)]\n        }\n\n        /// Check if `v` is equal to the result of concatenating `v1` and `v2`\n        fun eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {\n            len(v) == len(v1) + len(v2) &&\n            v[0..len(v1)] == v1 &&\n            v[len(v1)..len(v)] == v2\n        }\n\n        /// Check `v1` is equal to the result of removing the first element of `v2`\n        fun eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {\n            len(v1) + 1 == len(v2) &&\n            v1 == v2[1..len(v2)]\n        }\n\n        /// Check that `v1` is equal to the result of removing the element at index `i` from `v2`.\n        fun eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {\n            len(v1) + 1 == len(v2) &&\n            v1[0..i] == v2[0..i] &&\n            v1[i..len(v1)] == v2[i + 1..len(v2)]\n        }\n\n        /// Check if `v` contains `e`.\n        fun spec_contains<Element>(v: vector<Element>, e: Element): bool {\n            exists x in v: x == e\n        }\n    }\n\n}\n","name":"vector.move"}]