export default [{"content":"/// This defines a minimally viable token for no-code solutions akin to the original token at\n/// 0x3::token module.\n/// The key features are:\n/// * Base token and collection features\n/// * Creator definable mutability for tokens\n/// * Creator-based freezing of tokens\n/// * Standard object-based transfer and events\n/// * Metadata property type\nmodule aptos_token_objects::aptos_token {\n    use std::error;\n    use std::option::{Self, Option};\n    use std::string::String;\n    use std::signer;\n    use aptos_framework::object::{Self, ConstructorRef, Object};\n    use aptos_token_objects::collection;\n    use aptos_token_objects::property_map;\n    use aptos_token_objects::royalty;\n    use aptos_token_objects::token;\n\n    /// The collection does not exist\n    const ECOLLECTION_DOES_NOT_EXIST: u64 = 1;\n    /// The token does not exist\n    const ETOKEN_DOES_NOT_EXIST: u64 = 2;\n    /// The provided signer is not the creator\n    const ENOT_CREATOR: u64 = 3;\n    /// The field being changed is not mutable\n    const EFIELD_NOT_MUTABLE: u64 = 4;\n    /// The token being burned is not burnable\n    const ETOKEN_NOT_BURNABLE: u64 = 5;\n    /// The property map being mutated is not mutable\n    const EPROPERTIES_NOT_MUTABLE: u64 = 6;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Storage state for managing the no-code Collection.\n    struct AptosCollection has key {\n        /// Used to mutate collection fields\n        mutator_ref: Option<collection::MutatorRef>,\n        /// Used to mutate royalties\n        royalty_mutator_ref: Option<royalty::MutatorRef>,\n        /// Determines if the creator can mutate the collection's description\n        mutable_description: bool,\n        /// Determines if the creator can mutate the collection's uri\n        mutable_uri: bool,\n        /// Determines if the creator can mutate token descriptions\n        mutable_token_description: bool,\n        /// Determines if the creator can mutate token names\n        mutable_token_name: bool,\n        /// Determines if the creator can mutate token properties\n        mutable_token_properties: bool,\n        /// Determines if the creator can mutate token uris\n        mutable_token_uri: bool,\n        /// Determines if the creator can burn tokens\n        tokens_burnable_by_creator: bool,\n        /// Determines if the creator can freeze tokens\n        tokens_freezable_by_creator: bool,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Storage state for managing the no-code Token.\n    struct AptosToken has key {\n        /// Used to burn.\n        burn_ref: Option<token::BurnRef>,\n        /// Used to control freeze.\n        transfer_ref: Option<object::TransferRef>,\n        /// Used to mutate fields\n        mutator_ref: Option<token::MutatorRef>,\n        /// Used to mutate properties\n        property_mutator_ref: property_map::MutatorRef,\n    }\n\n    /// Create a new collection\n    public entry fun create_collection(\n        creator: &signer,\n        description: String,\n        max_supply: u64,\n        name: String,\n        uri: String,\n        mutable_description: bool,\n        mutable_royalty: bool,\n        mutable_uri: bool,\n        mutable_token_description: bool,\n        mutable_token_name: bool,\n        mutable_token_properties: bool,\n        mutable_token_uri: bool,\n        tokens_burnable_by_creator: bool,\n        tokens_freezable_by_creator: bool,\n        royalty_numerator: u64,\n        royalty_denominator: u64,\n    ) {\n        create_collection_object(\n            creator,\n            description,\n            max_supply,\n            name,\n            uri,\n            mutable_description,\n            mutable_royalty,\n            mutable_uri,\n            mutable_token_description,\n            mutable_token_name,\n            mutable_token_properties,\n            mutable_token_uri,\n            tokens_burnable_by_creator,\n            tokens_freezable_by_creator,\n            royalty_numerator,\n            royalty_denominator\n        );\n    }\n\n    public fun create_collection_object(\n        creator: &signer,\n        description: String,\n        max_supply: u64,\n        name: String,\n        uri: String,\n        mutable_description: bool,\n        mutable_royalty: bool,\n        mutable_uri: bool,\n        mutable_token_description: bool,\n        mutable_token_name: bool,\n        mutable_token_properties: bool,\n        mutable_token_uri: bool,\n        tokens_burnable_by_creator: bool,\n        tokens_freezable_by_creator: bool,\n        royalty_numerator: u64,\n        royalty_denominator: u64,\n    ): Object<AptosCollection> {\n        let creator_addr = signer::address_of(creator);\n        let royalty = royalty::create(royalty_numerator, royalty_denominator, creator_addr);\n        let constructor_ref = collection::create_fixed_collection(\n            creator,\n            description,\n            max_supply,\n            name,\n            option::some(royalty),\n            uri,\n        );\n\n        let object_signer = object::generate_signer(&constructor_ref);\n        let mutator_ref = if (mutable_description || mutable_uri) {\n            option::some(collection::generate_mutator_ref(&constructor_ref))\n        } else {\n            option::none()\n        };\n\n        let royalty_mutator_ref = if (mutable_royalty) {\n            option::some(royalty::generate_mutator_ref(object::generate_extend_ref(&constructor_ref)))\n        } else {\n            option::none()\n        };\n\n        let aptos_collection = AptosCollection {\n            mutator_ref,\n            royalty_mutator_ref,\n            mutable_description,\n            mutable_uri,\n            mutable_token_description,\n            mutable_token_name,\n            mutable_token_properties,\n            mutable_token_uri,\n            tokens_burnable_by_creator,\n            tokens_freezable_by_creator,\n        };\n        move_to(&object_signer, aptos_collection);\n        object::object_from_constructor_ref(&constructor_ref)\n    }\n\n    /// With an existing collection, directly mint a viable token into the creators account.\n    public entry fun mint(\n        creator: &signer,\n        collection: String,\n        description: String,\n        name: String,\n        uri: String,\n        property_keys: vector<String>,\n        property_types: vector<String>,\n        property_values: vector<vector<u8>>,\n    ) acquires AptosCollection, AptosToken {\n        mint_token_object(creator, collection, description, name, uri, property_keys, property_types, property_values);\n    }\n\n    /// Mint a token into an existing collection, and retrieve the object / address of the token.\n    public fun mint_token_object(\n        creator: &signer,\n        collection: String,\n        description: String,\n        name: String,\n        uri: String,\n        property_keys: vector<String>,\n        property_types: vector<String>,\n        property_values: vector<vector<u8>>,\n    ): Object<AptosToken> acquires AptosCollection, AptosToken {\n        let constructor_ref = mint_internal(\n            creator,\n            collection,\n            description,\n            name,\n            uri,\n            property_keys,\n            property_types,\n            property_values,\n        );\n\n        let collection = collection_object(creator, &collection);\n\n        // If tokens are freezable, add a transfer ref to be able to freeze transfers\n        let freezable_by_creator = are_collection_tokens_freezable(collection);\n        if (freezable_by_creator) {\n            let aptos_token_addr = object::address_from_constructor_ref(&constructor_ref);\n            let aptos_token = borrow_global_mut<AptosToken>(aptos_token_addr);\n            let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n            option::fill(&mut aptos_token.transfer_ref, transfer_ref);\n        };\n\n        object::object_from_constructor_ref(&constructor_ref)\n    }\n\n    /// With an existing collection, directly mint a soul bound token into the recipient's account.\n    public entry fun mint_soul_bound(\n        creator: &signer,\n        collection: String,\n        description: String,\n        name: String,\n        uri: String,\n        property_keys: vector<String>,\n        property_types: vector<String>,\n        property_values: vector<vector<u8>>,\n        soul_bound_to: address,\n    ) acquires AptosCollection {\n        mint_soul_bound_token_object(\n            creator,\n            collection,\n            description,\n            name,\n            uri,\n            property_keys,\n            property_types,\n            property_values,\n            soul_bound_to\n        );\n    }\n\n    /// With an existing collection, directly mint a soul bound token into the recipient's account.\n    public fun mint_soul_bound_token_object(\n        creator: &signer,\n        collection: String,\n        description: String,\n        name: String,\n        uri: String,\n        property_keys: vector<String>,\n        property_types: vector<String>,\n        property_values: vector<vector<u8>>,\n        soul_bound_to: address,\n    ): Object<AptosToken> acquires AptosCollection {\n        let constructor_ref = mint_internal(\n            creator,\n            collection,\n            description,\n            name,\n            uri,\n            property_keys,\n            property_types,\n            property_values,\n        );\n\n        let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n        let linear_transfer_ref = object::generate_linear_transfer_ref(&transfer_ref);\n        object::transfer_with_ref(linear_transfer_ref, soul_bound_to);\n        object::disable_ungated_transfer(&transfer_ref);\n\n        object::object_from_constructor_ref(&constructor_ref)\n    }\n\n    fun mint_internal(\n        creator: &signer,\n        collection: String,\n        description: String,\n        name: String,\n        uri: String,\n        property_keys: vector<String>,\n        property_types: vector<String>,\n        property_values: vector<vector<u8>>,\n    ): ConstructorRef acquires AptosCollection {\n        let constructor_ref = token::create(creator, collection, description, name, option::none(), uri);\n\n        let object_signer = object::generate_signer(&constructor_ref);\n\n        let collection_obj = collection_object(creator, &collection);\n        let collection = borrow_collection(&collection_obj);\n\n        let mutator_ref = if (\n            collection.mutable_token_description\n                || collection.mutable_token_name\n                || collection.mutable_token_uri\n        ) {\n            option::some(token::generate_mutator_ref(&constructor_ref))\n        } else {\n            option::none()\n        };\n\n        let burn_ref = if (collection.tokens_burnable_by_creator) {\n            option::some(token::generate_burn_ref(&constructor_ref))\n        } else {\n            option::none()\n        };\n\n        let aptos_token = AptosToken {\n            burn_ref,\n            transfer_ref: option::none(),\n            mutator_ref,\n            property_mutator_ref: property_map::generate_mutator_ref(&constructor_ref),\n        };\n        move_to(&object_signer, aptos_token);\n\n        let properties = property_map::prepare_input(property_keys, property_types, property_values);\n        property_map::init(&constructor_ref, properties);\n\n        constructor_ref\n    }\n\n    // Token accessors\n\n    inline fun borrow<T: key>(token: &Object<T>): &AptosToken {\n        let token_address = object::object_address(token);\n        assert!(\n            exists<AptosToken>(token_address),\n            error::not_found(ETOKEN_DOES_NOT_EXIST),\n        );\n        borrow_global<AptosToken>(token_address)\n    }\n\n    #[view]\n    public fun are_properties_mutable<T: key>(token: Object<T>): bool acquires AptosCollection {\n        let collection = token::collection_object(token);\n        borrow_collection(&collection).mutable_token_properties\n    }\n\n    #[view]\n    public fun is_burnable<T: key>(token: Object<T>): bool acquires AptosToken {\n        option::is_some(&borrow(&token).burn_ref)\n    }\n\n    #[view]\n    public fun is_freezable_by_creator<T: key>(token: Object<T>): bool acquires AptosCollection {\n        are_collection_tokens_freezable(token::collection_object(token))\n    }\n\n    #[view]\n    public fun is_mutable_description<T: key>(token: Object<T>): bool acquires AptosCollection {\n        is_mutable_collection_token_description(token::collection_object(token))\n    }\n\n    #[view]\n    public fun is_mutable_name<T: key>(token: Object<T>): bool acquires AptosCollection {\n        is_mutable_collection_token_name(token::collection_object(token))\n    }\n\n    #[view]\n    public fun is_mutable_uri<T: key>(token: Object<T>): bool acquires AptosCollection {\n        is_mutable_collection_token_uri(token::collection_object(token))\n    }\n\n    // Token mutators\n\n    inline fun authorized_borrow<T: key>(token: &Object<T>, creator: &signer): &AptosToken {\n        let token_address = object::object_address(token);\n        assert!(\n            exists<AptosToken>(token_address),\n            error::not_found(ETOKEN_DOES_NOT_EXIST),\n        );\n\n        assert!(\n            token::creator(*token) == signer::address_of(creator),\n            error::permission_denied(ENOT_CREATOR),\n        );\n        borrow_global<AptosToken>(token_address)\n    }\n\n    public entry fun burn<T: key>(creator: &signer, token: Object<T>) acquires AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            option::is_some(&aptos_token.burn_ref),\n            error::permission_denied(ETOKEN_NOT_BURNABLE),\n        );\n        move aptos_token;\n        let aptos_token = move_from<AptosToken>(object::object_address(&token));\n        let AptosToken {\n            burn_ref,\n            transfer_ref: _,\n            mutator_ref: _,\n            property_mutator_ref,\n        } = aptos_token;\n        property_map::burn(property_mutator_ref);\n        token::burn(option::extract(&mut burn_ref));\n    }\n\n    public entry fun freeze_transfer<T: key>(creator: &signer, token: Object<T>) acquires AptosCollection, AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            are_collection_tokens_freezable(token::collection_object(token))\n                && option::is_some(&aptos_token.transfer_ref),\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        object::disable_ungated_transfer(option::borrow(&aptos_token.transfer_ref));\n    }\n\n    public entry fun unfreeze_transfer<T: key>(\n        creator: &signer,\n        token: Object<T>\n    ) acquires AptosCollection, AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            are_collection_tokens_freezable(token::collection_object(token))\n                && option::is_some(&aptos_token.transfer_ref),\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        object::enable_ungated_transfer(option::borrow(&aptos_token.transfer_ref));\n    }\n\n    public entry fun set_description<T: key>(\n        creator: &signer,\n        token: Object<T>,\n        description: String,\n    ) acquires AptosCollection, AptosToken {\n        assert!(\n            is_mutable_description(token),\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        let aptos_token = authorized_borrow(&token, creator);\n        token::set_description(option::borrow(&aptos_token.mutator_ref), description);\n    }\n\n    public entry fun set_name<T: key>(\n        creator: &signer,\n        token: Object<T>,\n        name: String,\n    ) acquires AptosCollection, AptosToken {\n        assert!(\n            is_mutable_name(token),\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        let aptos_token = authorized_borrow(&token, creator);\n        token::set_name(option::borrow(&aptos_token.mutator_ref), name);\n    }\n\n    public entry fun set_uri<T: key>(\n        creator: &signer,\n        token: Object<T>,\n        uri: String,\n    ) acquires AptosCollection, AptosToken {\n        assert!(\n            is_mutable_uri(token),\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        let aptos_token = authorized_borrow(&token, creator);\n        token::set_uri(option::borrow(&aptos_token.mutator_ref), uri);\n    }\n\n    public entry fun add_property<T: key>(\n        creator: &signer,\n        token: Object<T>,\n        key: String,\n        type: String,\n        value: vector<u8>,\n    ) acquires AptosCollection, AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            are_properties_mutable(token),\n            error::permission_denied(EPROPERTIES_NOT_MUTABLE),\n        );\n\n        property_map::add(&aptos_token.property_mutator_ref, key, type, value);\n    }\n\n    public entry fun add_typed_property<T: key, V: drop>(\n        creator: &signer,\n        token: Object<T>,\n        key: String,\n        value: V,\n    ) acquires AptosCollection, AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            are_properties_mutable(token),\n            error::permission_denied(EPROPERTIES_NOT_MUTABLE),\n        );\n\n        property_map::add_typed(&aptos_token.property_mutator_ref, key, value);\n    }\n\n    public entry fun remove_property<T: key>(\n        creator: &signer,\n        token: Object<T>,\n        key: String,\n    ) acquires AptosCollection, AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            are_properties_mutable(token),\n            error::permission_denied(EPROPERTIES_NOT_MUTABLE),\n        );\n\n        property_map::remove(&aptos_token.property_mutator_ref, &key);\n    }\n\n    public entry fun update_property<T: key>(\n        creator: &signer,\n        token: Object<T>,\n        key: String,\n        type: String,\n        value: vector<u8>,\n    ) acquires AptosCollection, AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            are_properties_mutable(token),\n            error::permission_denied(EPROPERTIES_NOT_MUTABLE),\n        );\n\n        property_map::update(&aptos_token.property_mutator_ref, &key, type, value);\n    }\n\n    public entry fun update_typed_property<T: key, V: drop>(\n        creator: &signer,\n        token: Object<T>,\n        key: String,\n        value: V,\n    ) acquires AptosCollection, AptosToken {\n        let aptos_token = authorized_borrow(&token, creator);\n        assert!(\n            are_properties_mutable(token),\n            error::permission_denied(EPROPERTIES_NOT_MUTABLE),\n        );\n\n        property_map::update_typed(&aptos_token.property_mutator_ref, &key, value);\n    }\n\n    // Collection accessors\n\n    inline fun collection_object(creator: &signer, name: &String): Object<AptosCollection> {\n        let collection_addr = collection::create_collection_address(&signer::address_of(creator), name);\n        object::address_to_object<AptosCollection>(collection_addr)\n    }\n\n    inline fun borrow_collection<T: key>(token: &Object<T>): &AptosCollection {\n        let collection_address = object::object_address(token);\n        assert!(\n            exists<AptosCollection>(collection_address),\n            error::not_found(ECOLLECTION_DOES_NOT_EXIST),\n        );\n        borrow_global<AptosCollection>(collection_address)\n    }\n\n    public fun is_mutable_collection_description<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).mutable_description\n    }\n\n    public fun is_mutable_collection_royalty<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        option::is_some(&borrow_collection(&collection).royalty_mutator_ref)\n    }\n\n    public fun is_mutable_collection_uri<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).mutable_uri\n    }\n\n    public fun is_mutable_collection_token_description<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).mutable_token_description\n    }\n\n    public fun is_mutable_collection_token_name<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).mutable_token_name\n    }\n\n    public fun is_mutable_collection_token_uri<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).mutable_token_uri\n    }\n\n    public fun is_mutable_collection_token_properties<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).mutable_token_properties\n    }\n\n    public fun are_collection_tokens_burnable<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).tokens_burnable_by_creator\n    }\n\n    public fun are_collection_tokens_freezable<T: key>(\n        collection: Object<T>,\n    ): bool acquires AptosCollection {\n        borrow_collection(&collection).tokens_freezable_by_creator\n    }\n\n    // Collection mutators\n\n    inline fun authorized_borrow_collection<T: key>(collection: &Object<T>, creator: &signer): &AptosCollection {\n        let collection_address = object::object_address(collection);\n        assert!(\n            exists<AptosCollection>(collection_address),\n            error::not_found(ECOLLECTION_DOES_NOT_EXIST),\n        );\n        assert!(\n            collection::creator(*collection) == signer::address_of(creator),\n            error::permission_denied(ENOT_CREATOR),\n        );\n        borrow_global<AptosCollection>(collection_address)\n    }\n\n    public entry fun set_collection_description<T: key>(\n        creator: &signer,\n        collection: Object<T>,\n        description: String,\n    ) acquires AptosCollection {\n        let aptos_collection = authorized_borrow_collection(&collection, creator);\n        assert!(\n            aptos_collection.mutable_description,\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        collection::set_description(option::borrow(&aptos_collection.mutator_ref), description);\n    }\n\n    public fun set_collection_royalties<T: key>(\n        creator: &signer,\n        collection: Object<T>,\n        royalty: royalty::Royalty,\n    ) acquires AptosCollection {\n        let aptos_collection = authorized_borrow_collection(&collection, creator);\n        assert!(\n            option::is_some(&aptos_collection.royalty_mutator_ref),\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        royalty::update(option::borrow(&aptos_collection.royalty_mutator_ref), royalty);\n    }\n\n    entry fun set_collection_royalties_call<T: key>(\n        creator: &signer,\n        collection: Object<T>,\n        royalty_numerator: u64,\n        royalty_denominator: u64,\n        payee_address: address,\n    ) acquires AptosCollection {\n        let royalty = royalty::create(royalty_numerator, royalty_denominator, payee_address);\n        set_collection_royalties(creator, collection, royalty);\n    }\n\n    public entry fun set_collection_uri<T: key>(\n        creator: &signer,\n        collection: Object<T>,\n        uri: String,\n    ) acquires AptosCollection {\n        let aptos_collection = authorized_borrow_collection(&collection, creator);\n        assert!(\n            aptos_collection.mutable_uri,\n            error::permission_denied(EFIELD_NOT_MUTABLE),\n        );\n        collection::set_uri(option::borrow(&aptos_collection.mutator_ref), uri);\n    }\n\n    // Tests\n\n    #[test_only]\n    use std::string;\n    #[test_only]\n    use aptos_framework::account;\n\n    #[test(creator = @0x123)]\n    fun test_create_and_transfer(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        assert!(object::owner(token) == signer::address_of(creator), 1);\n        object::transfer(creator, token, @0x345);\n        assert!(object::owner(token) == @0x345, 1);\n    }\n\n    #[test(creator = @0x123, bob = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = object)]\n    fun test_mint_soul_bound(creator: &signer, bob: &signer) acquires AptosCollection {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, false);\n\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n\n        let token = mint_soul_bound_token_object(\n            creator,\n            collection_name,\n            string::utf8(b\"\"),\n            token_name,\n            string::utf8(b\"\"),\n            vector[],\n            vector[],\n            vector[],\n            signer::address_of(bob),\n        );\n\n        object::transfer(bob, token, @0x345);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = object)]\n    fun test_frozen_transfer(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        freeze_transfer(creator, token);\n        object::transfer(creator, token, @0x345);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_unfrozen_transfer(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        freeze_transfer(creator, token);\n        unfreeze_transfer(creator, token);\n        object::transfer(creator, token, @0x345);\n    }\n\n    #[test(creator = @0x123, another = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_noncreator_freeze(creator: &signer, another: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        freeze_transfer(another, token);\n    }\n\n    #[test(creator = @0x123, another = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_noncreator_unfreeze(creator: &signer, another: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        freeze_transfer(creator, token);\n        unfreeze_transfer(another, token);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_description(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        let description = string::utf8(b\"not\");\n        assert!(token::description(token) != description, 0);\n        set_description(creator, token, description);\n        assert!(token::description(token) == description, 1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_set_immutable_description(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, false);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        set_description(creator, token, string::utf8(b\"\"));\n    }\n\n    #[test(creator = @0x123, noncreator = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_set_description_non_creator(\n        creator: &signer,\n        noncreator: &signer,\n    ) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        let description = string::utf8(b\"not\");\n        set_description(noncreator, token, description);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_name(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        let name = string::utf8(b\"not\");\n        assert!(token::name(token) != name, 0);\n        set_name(creator, token, name);\n        assert!(token::name(token) == name, 1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_set_immutable_name(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, false);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        set_name(creator, token, string::utf8(b\"\"));\n    }\n\n    #[test(creator = @0x123, noncreator = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_set_name_non_creator(\n        creator: &signer,\n        noncreator: &signer,\n    ) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        let name = string::utf8(b\"not\");\n        set_name(noncreator, token, name);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_uri(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        let uri = string::utf8(b\"not\");\n        assert!(token::uri(token) != uri, 0);\n        set_uri(creator, token, uri);\n        assert!(token::uri(token) == uri, 1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_set_immutable_uri(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, false);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        set_uri(creator, token, string::utf8(b\"\"));\n    }\n\n    #[test(creator = @0x123, noncreator = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_set_uri_non_creator(\n        creator: &signer,\n        noncreator: &signer,\n    ) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        let uri = string::utf8(b\"not\");\n        set_uri(noncreator, token, uri);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_burnable(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        let token_addr = object::object_address(&token);\n\n        assert!(exists<AptosToken>(token_addr), 0);\n        burn(creator, token);\n        assert!(!exists<AptosToken>(token_addr), 1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50005, location = Self)]\n    fun test_not_burnable(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, false);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        burn(creator, token);\n    }\n\n    #[test(creator = @0x123, noncreator = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_burn_non_creator(\n        creator: &signer,\n        noncreator: &signer,\n    ) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        burn(noncreator, token);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_collection_description(creator: &signer) acquires AptosCollection {\n        let collection_name = string::utf8(b\"collection name\");\n        let collection = create_collection_helper(creator, collection_name, true);\n        let value = string::utf8(b\"not\");\n        assert!(collection::description(collection) != value, 0);\n        set_collection_description(creator, collection, value);\n        assert!(collection::description(collection) == value, 1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_set_immutable_collection_description(creator: &signer) acquires AptosCollection {\n        let collection_name = string::utf8(b\"collection name\");\n        let collection = create_collection_helper(creator, collection_name, false);\n        set_collection_description(creator, collection, string::utf8(b\"\"));\n    }\n\n    #[test(creator = @0x123, noncreator = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_set_collection_description_non_creator(\n        creator: &signer,\n        noncreator: &signer,\n    ) acquires AptosCollection {\n        let collection_name = string::utf8(b\"collection name\");\n        let collection = create_collection_helper(creator, collection_name, true);\n        set_collection_description(noncreator, collection, string::utf8(b\"\"));\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_collection_uri(creator: &signer) acquires AptosCollection {\n        let collection_name = string::utf8(b\"collection name\");\n        let collection = create_collection_helper(creator, collection_name, true);\n        let value = string::utf8(b\"not\");\n        assert!(collection::uri(collection) != value, 0);\n        set_collection_uri(creator, collection, value);\n        assert!(collection::uri(collection) == value, 1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_set_immutable_collection_uri(creator: &signer) acquires AptosCollection {\n        let collection_name = string::utf8(b\"collection name\");\n        let collection = create_collection_helper(creator, collection_name, false);\n        set_collection_uri(creator, collection, string::utf8(b\"\"));\n    }\n\n    #[test(creator = @0x123, noncreator = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_set_collection_uri_non_creator(\n        creator: &signer,\n        noncreator: &signer,\n    ) acquires AptosCollection {\n        let collection_name = string::utf8(b\"collection name\");\n        let collection = create_collection_helper(creator, collection_name, true);\n        set_collection_uri(noncreator, collection, string::utf8(b\"\"));\n    }\n\n    #[test(creator = @0x123)]\n    fun test_property_add(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n        let property_name = string::utf8(b\"u8\");\n        let property_type = string::utf8(b\"u8\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        add_property(creator, token, property_name, property_type, vector [ 0x08 ]);\n\n        assert!(property_map::read_u8(&token, &property_name) == 0x8, 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_property_typed_add(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n        let property_name = string::utf8(b\"u8\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        add_typed_property<AptosToken, u8>(creator, token, property_name, 0x8);\n\n        assert!(property_map::read_u8(&token, &property_name) == 0x8, 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_property_update(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n        let property_name = string::utf8(b\"bool\");\n        let property_type = string::utf8(b\"bool\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        update_property(creator, token, property_name, property_type, vector [ 0x00 ]);\n\n        assert!(!property_map::read_bool(&token, &property_name), 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_property_update_typed(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n        let property_name = string::utf8(b\"bool\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        update_typed_property<AptosToken, bool>(creator, token, property_name, false);\n\n        assert!(!property_map::read_bool(&token, &property_name), 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_property_remove(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n        let property_name = string::utf8(b\"bool\");\n\n        create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n        remove_property(creator, token, property_name);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_royalties(creator: &signer) acquires AptosCollection, AptosToken {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        let collection = create_collection_helper(creator, collection_name, true);\n        let token = mint_helper(creator, collection_name, token_name);\n\n        let royalty_before = option::extract(&mut token::royalty(token));\n        set_collection_royalties_call(creator, collection, 2, 3, @0x444);\n        let royalty_after = option::extract(&mut token::royalty(token));\n        assert!(royalty_before != royalty_after, 0);\n    }\n\n    #[test_only]\n    fun create_collection_helper(\n        creator: &signer,\n        collection_name: String,\n        flag: bool,\n    ): Object<AptosCollection> {\n        create_collection_object(\n            creator,\n            string::utf8(b\"collection description\"),\n            1,\n            collection_name,\n            string::utf8(b\"collection uri\"),\n            flag,\n            flag,\n            flag,\n            flag,\n            flag,\n            flag,\n            flag,\n            flag,\n            flag,\n            1,\n            100,\n        )\n    }\n\n    #[test_only]\n    fun mint_helper(\n        creator: &signer,\n        collection_name: String,\n        token_name: String,\n    ): Object<AptosToken> acquires AptosCollection, AptosToken {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n\n        mint_token_object(\n            creator,\n            collection_name,\n            string::utf8(b\"description\"),\n            token_name,\n            string::utf8(b\"uri\"),\n            vector[string::utf8(b\"bool\")],\n            vector[string::utf8(b\"bool\")],\n            vector[vector[0x01]],\n        )\n    }\n}\n","name":"aptos_token.move"},{"content":"/// This defines an object-based Collection. A collection acts as a set organizer for a group of\n/// tokens. This includes aspects such as a general description, project URI, name, and may contain\n/// other useful generalizations across this set of tokens.\n///\n/// Being built upon objects enables collections to be relatively flexible. As core primitives it\n/// supports:\n/// * Common fields: name, uri, description, creator\n/// * MutatorRef leaving mutability configuration to a higher level component\n/// * Addressed by a global identifier of creator's address and collection name, thus collections\n///   cannot be deleted as a restriction of the object model.\n/// * Optional support for collection-wide royalties\n/// * Optional support for tracking of supply with events on mint or burn\n///\n/// TODO:\n/// * Consider supporting changing the name of the collection with the MutatorRef. This would\n///   require adding the field original_name.\n/// * Consider supporting changing the aspects of supply with the MutatorRef.\n/// * Add aggregator support when added to framework\nmodule aptos_token_objects::collection {\n    use std::error;\n    use std::features;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::string::{Self, String};\n    use aptos_framework::aggregator_v2::{Self, Aggregator, AggregatorSnapshot};\n    use aptos_framework::event;\n    use aptos_framework::object::{Self, ConstructorRef, ExtendRef, Object};\n\n    use aptos_token_objects::royalty::{Self, Royalty};\n\n    friend aptos_token_objects::token;\n\n    /// The collection does not exist\n    const ECOLLECTION_DOES_NOT_EXIST: u64 = 1;\n    /// The collection has reached its supply and no more tokens can be minted, unless some are burned\n    const ECOLLECTION_SUPPLY_EXCEEDED: u64 = 2;\n    /// The collection name is over the maximum length\n    const ECOLLECTION_NAME_TOO_LONG: u64 = 3;\n    /// The URI is over the maximum length\n    const EURI_TOO_LONG: u64 = 4;\n    /// The description is over the maximum length\n    const EDESCRIPTION_TOO_LONG: u64 = 5;\n    /// The max supply must be positive\n    const EMAX_SUPPLY_CANNOT_BE_ZERO: u64 = 6;\n    /// Concurrent feature flag is not yet enabled, so the function cannot be performed\n    const ECONCURRENT_NOT_ENABLED: u64 = 7;\n    /// Tried upgrading collection to concurrent, but collection is already concurrent\n    const EALREADY_CONCURRENT: u64 = 8;\n    /// The new max supply cannot be less than the current supply\n    const EINVALID_MAX_SUPPLY: u64 = 9;\n    /// The collection does not have a max supply\n    const ENO_MAX_SUPPLY_IN_COLLECTION: u64 = 10;\n\n    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;\n    const MAX_URI_LENGTH: u64 = 512;\n    const MAX_DESCRIPTION_LENGTH: u64 = 2048;\n\n    const MAX_U64: u64 = 18446744073709551615;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Represents the common fields for a collection.\n    struct Collection has key {\n        /// The creator of this collection.\n        creator: address,\n        /// A brief description of the collection.\n        description: String,\n        /// An optional categorization of similar token.\n        name: String,\n        /// The Uniform Resource Identifier (uri) pointing to the JSON file stored in off-chain\n        /// storage; the URL length will likely need a maximum any suggestions?\n        uri: String,\n        /// Emitted upon any mutation of the collection.\n        mutation_events: event::EventHandle<MutationEvent>,\n    }\n\n    /// This enables mutating description and URI by higher level services.\n    struct MutatorRef has drop, store {\n        self: address,\n    }\n\n    /// Contains the mutated fields name. This makes the life of indexers easier, so that they can\n    /// directly understand the behavior in a writeset.\n    struct MutationEvent has drop, store {\n        mutated_field_name: String,\n    }\n\n    #[event]\n    /// Contains the mutated fields name. This makes the life of indexers easier, so that they can\n    /// directly understand the behavior in a writeset.\n    struct Mutation has drop, store {\n        mutated_field_name: String,\n        collection: Object<Collection>,\n        old_value: String,\n        new_value: String,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Fixed supply tracker, this is useful for ensuring that a limited number of tokens are minted.\n    /// and adding events and supply tracking to a collection.\n    struct FixedSupply has key {\n        /// Total minted - total burned\n        current_supply: u64,\n        max_supply: u64,\n        total_minted: u64,\n        /// Emitted upon burning a Token.\n        burn_events: event::EventHandle<BurnEvent>,\n        /// Emitted upon minting an Token.\n        mint_events: event::EventHandle<MintEvent>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Unlimited supply tracker, this is useful for adding events and supply tracking to a collection.\n    struct UnlimitedSupply has key {\n        current_supply: u64,\n        total_minted: u64,\n        /// Emitted upon burning a Token.\n        burn_events: event::EventHandle<BurnEvent>,\n        /// Emitted upon minting an Token.\n        mint_events: event::EventHandle<MintEvent>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Supply tracker, useful for tracking amount of issued tokens.\n    /// If max_value is not set to U64_MAX, this ensures that a limited number of tokens are minted.\n    struct ConcurrentSupply has key {\n        /// Total minted - total burned\n        current_supply: Aggregator<u64>,\n        total_minted: Aggregator<u64>,\n    }\n\n    struct BurnEvent has drop, store {\n        index: u64,\n        token: address,\n    }\n\n    struct MintEvent has drop, store {\n        index: u64,\n        token: address,\n    }\n\n    #[event]\n    struct Burn has drop, store {\n        collection: address,\n        index: u64,\n        token: address,\n        previous_owner: address,\n    }\n\n    #[event]\n    struct Mint has drop, store {\n        collection: address,\n        index: AggregatorSnapshot<u64>,\n        token: address,\n    }\n\n    // DEPRECATED, NEVER USED\n    #[deprecated]\n    #[event]\n    struct ConcurrentBurnEvent has drop, store {\n        collection_addr: address,\n        index: u64,\n        token: address,\n    }\n\n    // DEPRECATED, NEVER USED\n    #[deprecated]\n    #[event]\n    struct ConcurrentMintEvent has drop, store {\n        collection_addr: address,\n        index: AggregatorSnapshot<u64>,\n        token: address,\n    }\n\n    #[event]\n    struct SetMaxSupply has drop, store {\n        collection: Object<Collection>,\n        old_max_supply: u64,\n        new_max_supply: u64,\n    }\n\n    /// Creates a fixed-sized collection, or a collection that supports a fixed amount of tokens.\n    /// This is useful to create a guaranteed, limited supply on-chain digital asset. For example,\n    /// a collection 1111 vicious vipers. Note, creating restrictions such as upward limits results\n    /// in data structures that prevent Aptos from parallelizing mints of this collection type.\n    /// Beyond that, it adds supply tracking with events.\n    public fun create_fixed_collection(\n        creator: &signer,\n        description: String,\n        max_supply: u64,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        assert!(max_supply != 0, error::invalid_argument(EMAX_SUPPLY_CANNOT_BE_ZERO));\n        let collection_seed = create_collection_seed(&name);\n        let constructor_ref = object::create_named_object(creator, collection_seed);\n        let object_signer = object::generate_signer(&constructor_ref);\n        if (features::concurrent_token_v2_enabled()) {\n            let supply = ConcurrentSupply {\n                current_supply: aggregator_v2::create_aggregator(max_supply),\n                total_minted: aggregator_v2::create_unbounded_aggregator(),\n            };\n\n            create_collection_internal(\n                creator,\n                constructor_ref,\n                description,\n                name,\n                royalty,\n                uri,\n                option::some(supply),\n            )\n        } else {\n            let supply = FixedSupply {\n                current_supply: 0,\n                max_supply,\n                total_minted: 0,\n                burn_events: object::new_event_handle(&object_signer),\n                mint_events: object::new_event_handle(&object_signer),\n            };\n\n            create_collection_internal(\n                creator,\n                constructor_ref,\n                description,\n                name,\n                royalty,\n                uri,\n                option::some(supply),\n            )\n        }\n    }\n\n    /// Creates an unlimited collection. This has support for supply tracking but does not limit\n    /// the supply of tokens.\n    public fun create_unlimited_collection(\n        creator: &signer,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let collection_seed = create_collection_seed(&name);\n        let constructor_ref = object::create_named_object(creator, collection_seed);\n        let object_signer = object::generate_signer(&constructor_ref);\n\n        if (features::concurrent_token_v2_enabled()) {\n            let supply = ConcurrentSupply {\n                current_supply: aggregator_v2::create_unbounded_aggregator(),\n                total_minted: aggregator_v2::create_unbounded_aggregator(),\n            };\n\n            create_collection_internal(\n                creator,\n                constructor_ref,\n                description,\n                name,\n                royalty,\n                uri,\n                option::some(supply),\n            )\n        } else {\n            let supply = UnlimitedSupply {\n                current_supply: 0,\n                total_minted: 0,\n                burn_events: object::new_event_handle(&object_signer),\n                mint_events: object::new_event_handle(&object_signer),\n            };\n\n            create_collection_internal(\n                creator,\n                constructor_ref,\n                description,\n                name,\n                royalty,\n                uri,\n                option::some(supply),\n            )\n        }\n    }\n\n    /// Creates an untracked collection, or a collection that supports an arbitrary amount of\n    /// tokens. This is useful for mass airdrops that fully leverage Aptos parallelization.\n    /// TODO: Hide this until we bring back meaningful way to enforce burns\n    fun create_untracked_collection(\n        creator: &signer,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let collection_seed = create_collection_seed(&name);\n        let constructor_ref = object::create_named_object(creator, collection_seed);\n\n        create_collection_internal<FixedSupply>(\n            creator,\n            constructor_ref,\n            description,\n            name,\n            royalty,\n            uri,\n            option::none(),\n        )\n    }\n\n    inline fun create_collection_internal<Supply: key>(\n        creator: &signer,\n        constructor_ref: ConstructorRef,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n        supply: Option<Supply>,\n    ): ConstructorRef {\n        assert!(string::length(&name) <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));\n        assert!(string::length(&description) <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));\n\n        let object_signer = object::generate_signer(&constructor_ref);\n\n        let collection = Collection {\n            creator: signer::address_of(creator),\n            description,\n            name,\n            uri,\n            mutation_events: object::new_event_handle(&object_signer),\n        };\n        move_to(&object_signer, collection);\n\n        if (option::is_some(&supply)) {\n            move_to(&object_signer, option::destroy_some(supply))\n        } else {\n            option::destroy_none(supply)\n        };\n\n        if (option::is_some(&royalty)) {\n            royalty::init(&constructor_ref, option::extract(&mut royalty))\n        };\n\n        let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n        object::disable_ungated_transfer(&transfer_ref);\n\n        constructor_ref\n    }\n\n    /// Generates the collections address based upon the creators address and the collection's name\n    public fun create_collection_address(creator: &address, name: &String): address {\n        object::create_object_address(creator, create_collection_seed(name))\n    }\n\n    /// Named objects are derived from a seed, the collection's seed is its name.\n    public fun create_collection_seed(name: &String): vector<u8> {\n        assert!(string::length(name) <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));\n        *string::bytes(name)\n    }\n\n    /// Called by token on mint to increment supply if there's an appropriate Supply struct.\n    /// TODO[agg_v2](cleanup): remove in a future release. We need to have both functions, as\n    /// increment_concurrent_supply cannot be used until AGGREGATOR_API_V2 is enabled.\n    public(friend) fun increment_supply(\n        collection: &Object<Collection>,\n        token: address,\n    ): Option<u64> acquires FixedSupply, UnlimitedSupply {\n        let collection_addr = object::object_address(collection);\n        if (exists<FixedSupply>(collection_addr)) {\n            let supply = borrow_global_mut<FixedSupply>(collection_addr);\n            supply.current_supply = supply.current_supply + 1;\n            supply.total_minted = supply.total_minted + 1;\n            assert!(\n                supply.current_supply <= supply.max_supply,\n                error::out_of_range(ECOLLECTION_SUPPLY_EXCEEDED),\n            );\n\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(\n                    Mint {\n                        collection: collection_addr,\n                        index: aggregator_v2::create_snapshot(supply.total_minted),\n                        token,\n                    },\n                );\n            };\n            event::emit_event(&mut supply.mint_events,\n                MintEvent {\n                    index: supply.total_minted,\n                    token,\n                },\n            );\n            option::some(supply.total_minted)\n        } else if (exists<UnlimitedSupply>(collection_addr)) {\n            let supply = borrow_global_mut<UnlimitedSupply>(collection_addr);\n            supply.current_supply = supply.current_supply + 1;\n            supply.total_minted = supply.total_minted + 1;\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(\n                    Mint {\n                        collection: collection_addr,\n                        index: aggregator_v2::create_snapshot(supply.total_minted),\n                        token,\n                    },\n                );\n            };\n            event::emit_event(\n                &mut supply.mint_events,\n                MintEvent {\n                    index: supply.total_minted,\n                    token,\n                },\n            );\n            option::some(supply.total_minted)\n        } else if (exists<ConcurrentSupply>(collection_addr)) {\n            abort error::invalid_argument(ECONCURRENT_NOT_ENABLED)\n        } else {\n            option::none()\n        }\n    }\n\n    /// Called by token on mint to increment supply if there's an appropriate Supply struct.\n    public(friend) fun increment_concurrent_supply(\n        collection: &Object<Collection>,\n        token: address,\n    ): Option<AggregatorSnapshot<u64>> acquires FixedSupply, UnlimitedSupply, ConcurrentSupply {\n        let collection_addr = object::object_address(collection);\n        if (exists<ConcurrentSupply>(collection_addr)) {\n            let supply = borrow_global_mut<ConcurrentSupply>(collection_addr);\n            assert!(\n                aggregator_v2::try_add(&mut supply.current_supply, 1),\n                error::out_of_range(ECOLLECTION_SUPPLY_EXCEEDED),\n            );\n            aggregator_v2::add(&mut supply.total_minted, 1);\n            event::emit(\n                Mint {\n                    collection: collection_addr,\n                    index: aggregator_v2::snapshot(&supply.total_minted),\n                    token,\n                },\n            );\n            option::some(aggregator_v2::snapshot(&supply.total_minted))\n        } else if (exists<FixedSupply>(collection_addr)) {\n            let supply = borrow_global_mut<FixedSupply>(collection_addr);\n            supply.current_supply = supply.current_supply + 1;\n            supply.total_minted = supply.total_minted + 1;\n            assert!(\n                supply.current_supply <= supply.max_supply,\n                error::out_of_range(ECOLLECTION_SUPPLY_EXCEEDED),\n            );\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(\n                    Mint {\n                        collection: collection_addr,\n                        index: aggregator_v2::create_snapshot(supply.total_minted),\n                        token,\n                    },\n                );\n            };\n            event::emit_event(&mut supply.mint_events,\n                MintEvent {\n                    index: supply.total_minted,\n                    token,\n                },\n            );\n            option::some(aggregator_v2::create_snapshot<u64>(supply.total_minted))\n        } else if (exists<UnlimitedSupply>(collection_addr)) {\n            let supply = borrow_global_mut<UnlimitedSupply>(collection_addr);\n            supply.current_supply = supply.current_supply + 1;\n            supply.total_minted = supply.total_minted + 1;\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(\n                    Mint {\n                        collection: collection_addr,\n                        index: aggregator_v2::create_snapshot(supply.total_minted),\n                        token,\n                    },\n                );\n            };\n            event::emit_event(\n                &mut supply.mint_events,\n                MintEvent {\n                    index: supply.total_minted,\n                    token,\n                },\n            );\n            option::some(aggregator_v2::create_snapshot<u64>(supply.total_minted))\n        } else {\n            option::none()\n        }\n    }\n\n    /// Called by token on burn to decrement supply if there's an appropriate Supply struct.\n    public(friend) fun decrement_supply(\n        collection: &Object<Collection>,\n        token: address,\n        index: Option<u64>,\n        previous_owner: address,\n    ) acquires FixedSupply, UnlimitedSupply, ConcurrentSupply {\n        let collection_addr = object::object_address(collection);\n        if (exists<ConcurrentSupply>(collection_addr)) {\n            let supply = borrow_global_mut<ConcurrentSupply>(collection_addr);\n            aggregator_v2::sub(&mut supply.current_supply, 1);\n\n            event::emit(\n                Burn {\n                    collection: collection_addr,\n                    index: *option::borrow(&index),\n                    token,\n                    previous_owner,\n                },\n            );\n        } else if (exists<FixedSupply>(collection_addr)) {\n            let supply = borrow_global_mut<FixedSupply>(collection_addr);\n            supply.current_supply = supply.current_supply - 1;\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(\n                    Burn {\n                        collection: collection_addr,\n                        index: *option::borrow(&index),\n                        token,\n                        previous_owner,\n                    },\n                );\n            };\n            event::emit_event(\n                &mut supply.burn_events,\n                BurnEvent {\n                    index: *option::borrow(&index),\n                    token,\n                },\n            );\n        } else if (exists<UnlimitedSupply>(collection_addr)) {\n            let supply = borrow_global_mut<UnlimitedSupply>(collection_addr);\n            supply.current_supply = supply.current_supply - 1;\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(\n                    Burn {\n                        collection: collection_addr,\n                        index: *option::borrow(&index),\n                        token,\n                        previous_owner,\n                    },\n                );\n            };\n            event::emit_event(\n                &mut supply.burn_events,\n                BurnEvent {\n                    index: *option::borrow(&index),\n                    token,\n                },\n            );\n        }\n    }\n\n    /// Creates a MutatorRef, which gates the ability to mutate any fields that support mutation.\n    public fun generate_mutator_ref(ref: &ConstructorRef): MutatorRef {\n        let object = object::object_from_constructor_ref<Collection>(ref);\n        MutatorRef { self: object::object_address(&object) }\n    }\n\n    public fun upgrade_to_concurrent(\n        ref: &ExtendRef,\n    ) acquires FixedSupply, UnlimitedSupply {\n        let metadata_object_address = object::address_from_extend_ref(ref);\n        let metadata_object_signer = object::generate_signer_for_extending(ref);\n        assert!(features::concurrent_token_v2_enabled(), error::invalid_argument(ECONCURRENT_NOT_ENABLED));\n\n        let (supply, current_supply, total_minted, burn_events, mint_events) = if (exists<FixedSupply>(\n            metadata_object_address\n        )) {\n            let FixedSupply {\n                current_supply,\n                max_supply,\n                total_minted,\n                burn_events,\n                mint_events,\n            } = move_from<FixedSupply>(metadata_object_address);\n\n            let supply = ConcurrentSupply {\n                current_supply: aggregator_v2::create_aggregator(max_supply),\n                total_minted: aggregator_v2::create_unbounded_aggregator(),\n            };\n            (supply, current_supply, total_minted, burn_events, mint_events)\n        } else if (exists<UnlimitedSupply>(metadata_object_address)) {\n            let UnlimitedSupply {\n                current_supply,\n                total_minted,\n                burn_events,\n                mint_events,\n            } = move_from<UnlimitedSupply>(metadata_object_address);\n\n            let supply = ConcurrentSupply {\n                current_supply: aggregator_v2::create_unbounded_aggregator(),\n                total_minted: aggregator_v2::create_unbounded_aggregator(),\n            };\n            (supply, current_supply, total_minted, burn_events, mint_events)\n        } else {\n            // untracked collection is already concurrent, and other variants too.\n            abort error::invalid_argument(EALREADY_CONCURRENT)\n        };\n\n        // update current state:\n        aggregator_v2::add(&mut supply.current_supply, current_supply);\n        aggregator_v2::add(&mut supply.total_minted, total_minted);\n        move_to(&metadata_object_signer, supply);\n\n        event::destroy_handle(burn_events);\n        event::destroy_handle(mint_events);\n    }\n\n    // Accessors\n\n    inline fun check_collection_exists(addr: address) {\n        assert!(\n            exists<Collection>(addr),\n            error::not_found(ECOLLECTION_DOES_NOT_EXIST),\n        );\n    }\n\n    inline fun borrow<T: key>(collection: &Object<T>): &Collection {\n        let collection_address = object::object_address(collection);\n        check_collection_exists(collection_address);\n        borrow_global<Collection>(collection_address)\n    }\n\n    #[view]\n    /// Provides the count of the current selection if supply tracking is used\n    ///\n    /// Note: Calling this method from transaction that also mints/burns, prevents\n    /// it from being parallelized.\n    public fun count<T: key>(\n        collection: Object<T>\n    ): Option<u64> acquires FixedSupply, UnlimitedSupply, ConcurrentSupply {\n        let collection_address = object::object_address(&collection);\n        check_collection_exists(collection_address);\n\n        if (exists<ConcurrentSupply>(collection_address)) {\n            let supply = borrow_global_mut<ConcurrentSupply>(collection_address);\n            option::some(aggregator_v2::read(&supply.current_supply))\n        } else if (exists<FixedSupply>(collection_address)) {\n            let supply = borrow_global_mut<FixedSupply>(collection_address);\n            option::some(supply.current_supply)\n        } else if (exists<UnlimitedSupply>(collection_address)) {\n            let supply = borrow_global_mut<UnlimitedSupply>(collection_address);\n            option::some(supply.current_supply)\n        } else {\n            option::none()\n        }\n    }\n\n    #[view]\n    public fun creator<T: key>(collection: Object<T>): address acquires Collection {\n        borrow(&collection).creator\n    }\n\n    #[view]\n    public fun description<T: key>(collection: Object<T>): String acquires Collection {\n        borrow(&collection).description\n    }\n\n    #[view]\n    public fun name<T: key>(collection: Object<T>): String acquires Collection {\n        borrow(&collection).name\n    }\n\n    #[view]\n    public fun uri<T: key>(collection: Object<T>): String acquires Collection {\n        borrow(&collection).uri\n    }\n\n    // Mutators\n\n    inline fun borrow_mut(mutator_ref: &MutatorRef): &mut Collection {\n        check_collection_exists(mutator_ref.self);\n        borrow_global_mut<Collection>(mutator_ref.self)\n    }\n\n    /// Callers of this function must be aware that changing the name will change the calculated\n    /// collection's address when calling `create_collection_address`.\n    /// Once the collection has been created, the collection address should be saved for reference and\n    /// `create_collection_address` should not be used to derive the collection's address.\n    ///\n    /// After changing the collection's name, to create tokens - only call functions that accept the collection object as an argument.\n    public fun set_name(mutator_ref: &MutatorRef, name: String) acquires Collection {\n        assert!(string::length(&name) <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));\n        let collection = borrow_mut(mutator_ref);\n        event::emit(Mutation {\n            mutated_field_name: string::utf8(b\"name\") ,\n            collection: object::address_to_object(mutator_ref.self),\n            old_value: collection.name,\n            new_value: name,\n        });\n        collection.name = name;\n    }\n\n    public fun set_description(mutator_ref: &MutatorRef, description: String) acquires Collection {\n        assert!(string::length(&description) <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));\n        let collection = borrow_mut(mutator_ref);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Mutation {\n                mutated_field_name: string::utf8(b\"description\"),\n                collection: object::address_to_object(mutator_ref.self),\n                old_value: collection.description,\n                new_value: description,\n            });\n        };\n        collection.description = description;\n        event::emit_event(\n            &mut collection.mutation_events,\n            MutationEvent { mutated_field_name: string::utf8(b\"description\") },\n        );\n    }\n\n    public fun set_uri(mutator_ref: &MutatorRef, uri: String) acquires Collection {\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));\n        let collection = borrow_mut(mutator_ref);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Mutation {\n                mutated_field_name: string::utf8(b\"uri\"),\n                collection: object::address_to_object(mutator_ref.self),\n                old_value: collection.uri,\n                new_value: uri,\n            });\n        };\n        collection.uri = uri;\n        event::emit_event(\n            &mut collection.mutation_events,\n            MutationEvent { mutated_field_name: string::utf8(b\"uri\") },\n        );\n    }\n\n    public fun set_max_supply(mutator_ref: &MutatorRef, max_supply: u64) acquires ConcurrentSupply, FixedSupply {\n        let collection = object::address_to_object<Collection>(mutator_ref.self);\n        let collection_address = object::object_address(&collection);\n        let old_max_supply;\n\n        if (exists<ConcurrentSupply>(collection_address)) {\n            let supply = borrow_global_mut<ConcurrentSupply>(collection_address);\n            let current_supply = aggregator_v2::read(&supply.current_supply);\n            assert!(\n                max_supply >= current_supply,\n                error::out_of_range(EINVALID_MAX_SUPPLY),\n            );\n            old_max_supply = aggregator_v2::max_value(&supply.current_supply);\n            supply.current_supply = aggregator_v2::create_aggregator(max_supply);\n            aggregator_v2::add(&mut supply.current_supply, current_supply);\n        } else if (exists<FixedSupply>(collection_address)) {\n            let supply = borrow_global_mut<FixedSupply>(collection_address);\n            assert!(\n                max_supply >= supply.current_supply,\n                error::out_of_range(EINVALID_MAX_SUPPLY),\n            );\n            old_max_supply = supply.max_supply;\n            supply.max_supply = max_supply;\n        } else {\n            abort error::invalid_argument(ENO_MAX_SUPPLY_IN_COLLECTION)\n        };\n\n        event::emit(SetMaxSupply { collection, old_max_supply, new_max_supply: max_supply });\n    }\n\n    // Tests\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    fun test_create_mint_burn_for_unlimited(fx: &signer, creator: &signer) acquires FixedSupply, UnlimitedSupply, ConcurrentSupply {\n        let feature = features::get_concurrent_token_v2_feature();\n        features::change_feature_flags_for_testing(fx, vector[], vector[feature]);\n\n        let creator_address = signer::address_of(creator);\n        let name = string::utf8(b\"collection name\");\n        create_unlimited_collection(creator, string::utf8(b\"\"), name, option::none(), string::utf8(b\"\"));\n        let collection_address = create_collection_address(&creator_address, &name);\n        let collection = object::address_to_object<Collection>(collection_address);\n        assert!(count(collection) == option::some(0), 0);\n        let cid = aggregator_v2::read_snapshot(&option::destroy_some(increment_concurrent_supply(&collection, creator_address)));\n        assert!(count(collection) == option::some(1), 0);\n        assert!(event::counter(&borrow_global<UnlimitedSupply>(collection_address).mint_events) == 1, 0);\n        decrement_supply(&collection, creator_address, option::some(cid), creator_address);\n        assert!(count(collection) == option::some(0), 0);\n        assert!(event::counter(&borrow_global<UnlimitedSupply>(collection_address).burn_events) == 1, 0);\n    }\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    fun test_create_mint_burn_for_fixed(fx: &signer, creator: &signer) acquires FixedSupply, UnlimitedSupply, ConcurrentSupply {\n        let feature = features::get_concurrent_token_v2_feature();\n        features::change_feature_flags_for_testing(fx, vector[], vector[feature]);\n\n        let creator_address = signer::address_of(creator);\n        let name = string::utf8(b\"collection name\");\n        create_fixed_collection(creator, string::utf8(b\"\"), 1, name, option::none(), string::utf8(b\"\"));\n        let collection_address = create_collection_address(&creator_address, &name);\n        let collection = object::address_to_object<Collection>(collection_address);\n        assert!(count(collection) == option::some(0), 0);\n        let cid = aggregator_v2::read_snapshot(&option::destroy_some(increment_concurrent_supply(&collection, creator_address)));\n        assert!(count(collection) == option::some(1), 0);\n        assert!(event::counter(&borrow_global<FixedSupply>(collection_address).mint_events) == 1, 0);\n        decrement_supply(&collection, creator_address, option::some(cid), creator_address);\n        assert!(count(collection) == option::some(0), 0);\n        assert!(event::counter(&borrow_global<FixedSupply>(collection_address).burn_events) == 1, 0);\n    }\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    fun test_create_mint_burn_for_concurrent(\n        fx: &signer,\n        creator: &signer\n    ) acquires FixedSupply, UnlimitedSupply, ConcurrentSupply {\n        let feature = features::get_concurrent_token_v2_feature();\n        features::change_feature_flags_for_testing(fx, vector[feature], vector[]);\n\n        let creator_address = signer::address_of(creator);\n        let name = string::utf8(b\"collection name\");\n        create_fixed_collection(creator, string::utf8(b\"\"), 1, name, option::none(), string::utf8(b\"\"));\n        let collection_address = create_collection_address(&creator_address, &name);\n        let collection = object::address_to_object<Collection>(collection_address);\n        assert!(count(collection) == option::some(0), 0);\n        let cid = increment_concurrent_supply(&collection, creator_address);\n        event::was_event_emitted<Mint>(&Mint {\n            collection: collection_address,\n            index: aggregator_v2::create_snapshot(0),\n            token: creator_address,\n        });\n        assert!(cid == option::some(aggregator_v2::create_snapshot(1)), 1);\n        assert!(count(collection) == option::some(1), 0);\n        decrement_supply(&collection, creator_address, option::some(1), creator_address);\n        event::was_event_emitted<Burn>(&Burn {\n            collection: collection_address,\n            index: 1,\n            token: creator_address,\n            previous_owner: creator_address,\n        });\n        assert!(count(collection) == option::some(0), 0);\n    }\n\n    #[test(creator = @0x123, trader = @0x456)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::object)]\n    entry fun test_create_and_transfer(creator: &signer, trader: &signer) {\n        let creator_address = signer::address_of(creator);\n        let collection_name = string::utf8(b\"collection name\");\n        create_collection_helper(creator, collection_name);\n\n        let collection = object::address_to_object<Collection>(\n            create_collection_address(&creator_address, &collection_name),\n        );\n        assert!(object::owner(collection) == creator_address, 1);\n        object::transfer(creator, collection, signer::address_of(trader));\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x80001, location = aptos_framework::object)]\n    entry fun test_duplicate_collection(creator: &signer) {\n        let collection_name = string::utf8(b\"collection name\");\n        create_collection_helper(creator, collection_name);\n        create_collection_helper(creator, collection_name);\n    }\n\n    #[test(creator = @0x123)]\n    entry fun test_set_name(creator: &signer) acquires Collection {\n        let collection_name = string::utf8(b\"collection name\");\n        let constructor_ref = create_collection_helper(creator, collection_name);\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n        let collection = object::address_to_object<Collection>(\n            create_collection_address(&signer::address_of(creator), &collection_name),\n        );\n        let new_collection_name = string::utf8(b\"new collection name\");\n        assert!(new_collection_name != name(collection), 0);\n        set_name(&mutator_ref, new_collection_name);\n        assert!(new_collection_name == name(collection), 1);\n        event::was_event_emitted(&Mutation {\n            mutated_field_name: string::utf8(b\"name\"),\n            collection,\n            old_value: collection_name,\n            new_value: new_collection_name,\n        });\n    }\n\n    #[test(creator = @0x123)]\n    entry fun test_set_description(creator: &signer) acquires Collection {\n        let collection_name = string::utf8(b\"collection name\");\n        let constructor_ref = create_collection_helper(creator, collection_name);\n        let collection = object::address_to_object<Collection>(\n            create_collection_address(&signer::address_of(creator), &collection_name),\n        );\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n        let description = string::utf8(b\"no fail\");\n        assert!(description != description(collection), 0);\n        set_description(&mutator_ref, description);\n        assert!(description == description(collection), 1);\n    }\n\n    #[test(creator = @0x123)]\n    entry fun test_set_uri(creator: &signer) acquires Collection {\n        let collection_name = string::utf8(b\"collection name\");\n        let constructor_ref = create_collection_helper(creator, collection_name);\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n        let collection = object::address_to_object<Collection>(\n            create_collection_address(&signer::address_of(creator), &collection_name),\n        );\n        let uri = string::utf8(b\"no fail\");\n        assert!(uri != uri(collection), 0);\n        set_uri(&mutator_ref, uri);\n        assert!(uri == uri(collection), 1);\n    }\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    entry fun test_set_max_supply_concurrent(creator: &signer, fx: &signer) acquires ConcurrentSupply, FixedSupply {\n        let feature = features::get_concurrent_token_v2_feature();\n        features::change_feature_flags_for_testing(fx, vector[feature], vector[]);\n\n        let collection_name = string::utf8(b\"collection name\");\n        let max_supply = 100;\n        let constructor_ref = create_fixed_collection_helper(creator, collection_name, max_supply);\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n\n        let new_max_supply = 200;\n        set_max_supply(&mutator_ref, new_max_supply);\n\n        let collection_address = create_collection_address(&signer::address_of(creator), &collection_name);\n        let supply = borrow_global<ConcurrentSupply>(collection_address);\n        assert!(aggregator_v2::max_value(&supply.current_supply) == new_max_supply, 0);\n\n        event::was_event_emitted<SetMaxSupply>(&SetMaxSupply {\n            collection: object::address_to_object<Collection>(collection_address),\n            old_max_supply: max_supply,\n            new_max_supply,\n        });\n    }\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    entry fun test_set_max_supply_same_as_current_supply_fixed(\n        creator: &signer,\n        fx: &signer,\n    ) acquires ConcurrentSupply, FixedSupply, UnlimitedSupply {\n        let feature = features::get_concurrent_token_v2_feature();\n        features::change_feature_flags_for_testing(fx, vector[], vector[feature]);\n\n        let collection_name = string::utf8(b\"collection name\");\n        let max_supply = 10;\n        let constructor_ref = create_fixed_collection_helper(creator, collection_name, max_supply);\n        let collection = object::object_from_constructor_ref<Collection>(&constructor_ref);\n        let token_signer = create_token(creator);\n\n        let current_supply = 5;\n        let i = 0;\n        while (i < current_supply) {\n            increment_supply(&collection, signer::address_of(&token_signer));\n            i = i + 1;\n        };\n\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n        set_max_supply(&mutator_ref, current_supply);\n\n        let collection_address = create_collection_address(&signer::address_of(creator), &collection_name);\n        let supply = borrow_global<FixedSupply>(collection_address);\n        assert!(supply.max_supply == current_supply, EINVALID_MAX_SUPPLY);\n\n        event::was_event_emitted<SetMaxSupply>(&SetMaxSupply {\n            collection: object::address_to_object<Collection>(collection_address),\n            old_max_supply: current_supply,\n            new_max_supply: current_supply,\n        });\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x1000A, location = aptos_token_objects::collection)]\n    entry fun test_set_max_supply_none(creator: &signer) acquires ConcurrentSupply, FixedSupply {\n        let collection_name = string::utf8(b\"collection name\");\n        let constructor_ref = create_collection_helper(creator, collection_name);\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n        set_max_supply(&mutator_ref, 200);\n    }\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    #[expected_failure(abort_code = 0x20009, location = aptos_token_objects::collection)]\n    entry fun test_set_max_supply_too_low_fixed_supply(creator: &signer, fx: &signer) acquires ConcurrentSupply, FixedSupply, UnlimitedSupply {\n        let feature = features::get_concurrent_token_v2_feature();\n        features::change_feature_flags_for_testing(fx, vector[], vector[feature]);\n\n        let max_supply = 3;\n        let collection_name = string::utf8(b\"Low Supply Collection\");\n        let constructor_ref = create_fixed_collection_helper(creator, collection_name, max_supply);\n        let collection = object::object_from_constructor_ref<Collection>(&constructor_ref);\n        let token_signer = create_token(creator);\n\n        let i = 0;\n        while (i < max_supply) {\n            increment_supply(&collection, signer::address_of(&token_signer));\n            i = i + 1;\n        };\n\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n        let new_max_supply = 2;\n        set_max_supply(&mutator_ref, new_max_supply);\n    }\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    #[expected_failure(abort_code = 0x20009, location = aptos_token_objects::collection)]\n    entry fun test_set_max_supply_too_low_concurrent_supply(creator: &signer, fx: &signer) acquires ConcurrentSupply, FixedSupply, UnlimitedSupply {\n        let concurrent_feature = features::get_concurrent_token_v2_feature();\n        let aggregator_feature = features::get_aggregator_v2_api_feature();\n        features::change_feature_flags_for_testing(fx, vector[concurrent_feature, aggregator_feature], vector[]);\n\n        let collection_name = string::utf8(b\"Low Supply Collection\");\n        let max_supply = 3;\n        let constructor_ref = create_fixed_collection_helper(creator, collection_name, max_supply);\n        let collection = object::object_from_constructor_ref<Collection>(&constructor_ref);\n        let token_signer = create_token(creator);\n\n        let i = 0;\n        while (i < max_supply) {\n            increment_concurrent_supply(&collection, signer::address_of(&token_signer));\n            i = i + 1;\n        };\n\n        let mutator_ref = generate_mutator_ref(&constructor_ref);\n        let new_max_supply = 2;\n        set_max_supply(&mutator_ref, new_max_supply);\n    }\n\n    #[test_only]\n    fun create_collection_helper(creator: &signer, name: String): ConstructorRef {\n        create_untracked_collection(\n            creator,\n            string::utf8(b\"collection description\"),\n            name,\n            option::none(),\n            string::utf8(b\"collection uri\"),\n        )\n    }\n\n    #[test_only]\n    fun create_fixed_collection_helper(creator: &signer, name: String, max_supply: u64): ConstructorRef {\n        create_fixed_collection(\n            creator,\n            string::utf8(b\"description\"),\n            max_supply,\n            name,\n            option::none(),\n            string::utf8(b\"uri\"),\n        )\n    }\n\n    #[test_only]\n    /// Create a token as we cannot create a dependency cycle between collection and token modules.\n    fun create_token(creator: &signer): signer {\n        let token_constructor_ref = &object::create_object(signer::address_of(creator));\n        object::generate_signer(token_constructor_ref)\n    }\n}\n","name":"collection.move"},{"content":"/// `PropertyMap` provides generic metadata support for `AptosToken`. It is a specialization of\n/// `SimpleMap` that enforces strict typing with minimal storage use by using constant u64 to\n/// represent types and storing values in bcs format.\nmodule aptos_token_objects::property_map {\n    use std::bcs;\n    use std::vector;\n    use std::error;\n    use std::string::{Self, String};\n    use aptos_std::from_bcs;\n    use aptos_std::simple_map::{Self, SimpleMap};\n    use aptos_std::type_info;\n    use aptos_framework::object::{Self, ConstructorRef, Object, ExtendRef, ObjectCore};\n\n    // Errors\n    /// The property map does not exist\n    const EPROPERTY_MAP_DOES_NOT_EXIST: u64 = 1;\n    /// The property key already exists\n    const EKEY_ALREADY_EXISTS_IN_PROPERTY_MAP: u64 = 2;\n    /// The number of properties exceeds the maximum\n    const ETOO_MANY_PROPERTIES: u64 = 3;\n    /// Property key and value counts do not match\n    const EKEY_VALUE_COUNT_MISMATCH: u64 = 4;\n    /// Property key and type counts do not match\n    const EKEY_TYPE_COUNT_MISMATCH: u64 = 5;\n    /// Property value does not match expected type\n    const ETYPE_MISMATCH: u64 = 6;\n    /// Invalid value type specified\n    const ETYPE_INVALID: u64 = 7;\n    /// The key of the property is too long\n    const EPROPERTY_MAP_KEY_TOO_LONG: u64 = 8;\n\n    // Constants\n    /// Maximum number of items in a `PropertyMap`\n    const MAX_PROPERTY_MAP_SIZE: u64 = 1000;\n    /// Maximum number of characters in a property name\n    const MAX_PROPERTY_NAME_LENGTH: u64 = 128;\n\n    // PropertyValue::type\n    const BOOL: u8 = 0;\n    const U8: u8 = 1;\n    const U16: u8 = 2;\n    const U32: u8 = 3;\n    const U64: u8 = 4;\n    const U128: u8 = 5;\n    const U256: u8 = 6;\n    const ADDRESS: u8 = 7;\n    const BYTE_VECTOR: u8 = 8;\n    const STRING: u8 = 9;\n\n    // Structs\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// A Map for typed key to value mapping, the contract using it\n    /// should keep track of what keys are what types, and parse them accordingly.\n    struct PropertyMap has drop, key {\n        inner: SimpleMap<String, PropertyValue>,\n    }\n\n    /// A typed value for the `PropertyMap` to ensure that typing is always consistent\n    struct PropertyValue has drop, store {\n        type: u8,\n        value: vector<u8>,\n    }\n\n    /// A mutator ref that allows for mutation of the property map\n    struct MutatorRef has drop, store {\n        self: address,\n    }\n\n    public fun init(ref: &ConstructorRef, container: PropertyMap) {\n        let signer = object::generate_signer(ref);\n        move_to(&signer, container);\n    }\n\n    public fun extend(ref: &ExtendRef, container: PropertyMap) {\n        let signer = object::generate_signer_for_extending(ref);\n        move_to(&signer, container);\n    }\n\n    /// Burns the entire property map\n    public fun burn(ref: MutatorRef) acquires PropertyMap {\n        move_from<PropertyMap>(ref.self);\n    }\n\n    /// Helper for external entry functions to produce a valid container for property values.\n    public fun prepare_input(\n        keys: vector<String>,\n        types: vector<String>,\n        values: vector<vector<u8>>,\n    ): PropertyMap {\n        let length = vector::length(&keys);\n        assert!(length <= MAX_PROPERTY_MAP_SIZE, error::invalid_argument(ETOO_MANY_PROPERTIES));\n        assert!(length == vector::length(&values), error::invalid_argument(EKEY_VALUE_COUNT_MISMATCH));\n        assert!(length == vector::length(&types), error::invalid_argument(EKEY_TYPE_COUNT_MISMATCH));\n\n        let container = simple_map::create<String, PropertyValue>();\n        while (!vector::is_empty(&keys)) {\n            let key = vector::pop_back(&mut keys);\n            assert!(\n                string::length(&key) <= MAX_PROPERTY_NAME_LENGTH,\n                error::invalid_argument(EPROPERTY_MAP_KEY_TOO_LONG),\n            );\n\n            let value = vector::pop_back(&mut values);\n            let type = vector::pop_back(&mut types);\n\n            let new_type = to_internal_type(type);\n            validate_type(new_type, value);\n\n            simple_map::add(&mut container, key, PropertyValue { value, type: new_type });\n        };\n\n        PropertyMap { inner: container }\n    }\n\n    /// Maps `String` representation of types from their `u8` representation\n    inline fun to_external_type(type: u8): String {\n        if (type == BOOL) {\n            string::utf8(b\"bool\")\n        } else if (type == U8) {\n            string::utf8(b\"u8\")\n        } else if (type == U16) {\n            string::utf8(b\"u16\")\n        } else if (type == U32) {\n            string::utf8(b\"u32\")\n        } else if (type == U64) {\n            string::utf8(b\"u64\")\n        } else if (type == U128) {\n            string::utf8(b\"u128\")\n        } else if (type == U256) {\n            string::utf8(b\"u256\")\n        } else if (type == ADDRESS) {\n            string::utf8(b\"address\")\n        } else if (type == BYTE_VECTOR) {\n            string::utf8(b\"vector<u8>\")\n        } else if (type == STRING) {\n            string::utf8(b\"0x1::string::String\")\n        } else {\n            abort (error::invalid_argument(ETYPE_INVALID))\n        }\n    }\n\n    /// Maps the `String` representation of types to `u8`\n    inline fun to_internal_type(type: String): u8 {\n        if (type == string::utf8(b\"bool\")) {\n            BOOL\n        } else if (type == string::utf8(b\"u8\")) {\n            U8\n        } else if (type == string::utf8(b\"u16\")) {\n            U16\n        } else if (type == string::utf8(b\"u32\")) {\n            U32\n        } else if (type == string::utf8(b\"u64\")) {\n            U64\n        } else if (type == string::utf8(b\"u128\")) {\n            U128\n        } else if (type == string::utf8(b\"u256\")) {\n            U256\n        } else if (type == string::utf8(b\"address\")) {\n            ADDRESS\n        } else if (type == string::utf8(b\"vector<u8>\")) {\n            BYTE_VECTOR\n        } else if (type == string::utf8(b\"0x1::string::String\")) {\n            STRING\n        } else {\n            abort (error::invalid_argument(ETYPE_INVALID))\n        }\n    }\n\n    /// Maps Move type to `u8` representation\n    inline fun type_info_to_internal_type<T>(): u8 {\n        let type = type_info::type_name<T>();\n        to_internal_type(type)\n    }\n\n    /// Validates property value type against its expected type\n    inline fun validate_type(type: u8, value: vector<u8>) {\n        if (type == BOOL) {\n            from_bcs::to_bool(value);\n        } else if (type == U8) {\n            from_bcs::to_u8(value);\n        } else if (type == U16) {\n            from_bcs::to_u16(value);\n        } else if (type == U32) {\n            from_bcs::to_u32(value);\n        } else if (type == U64) {\n            from_bcs::to_u64(value);\n        } else if (type == U128) {\n            from_bcs::to_u128(value);\n        } else if (type == U256) {\n            from_bcs::to_u256(value);\n        } else if (type == ADDRESS) {\n            from_bcs::to_address(value);\n        } else if (type == BYTE_VECTOR) {\n            // nothing to validate...\n        } else if (type == STRING) {\n            from_bcs::to_string(value);\n        } else {\n            abort (error::invalid_argument(ETYPE_MISMATCH))\n        };\n    }\n\n    public fun generate_mutator_ref(ref: &ConstructorRef): MutatorRef {\n        MutatorRef { self: object::address_from_constructor_ref(ref) }\n    }\n\n    // Accessors\n\n    public fun contains_key<T: key>(object: &Object<T>, key: &String): bool acquires PropertyMap {\n        assert_exists(object::object_address(object));\n        let property_map = borrow_global<PropertyMap>(object::object_address(object));\n        simple_map::contains_key(&property_map.inner, key)\n    }\n\n    public fun length<T: key>(object: &Object<T>): u64 acquires PropertyMap {\n        assert_exists(object::object_address(object));\n        let property_map = borrow_global<PropertyMap>(object::object_address(object));\n        simple_map::length(&property_map.inner)\n    }\n\n    /// Read the property and get it's external type in it's bcs encoded format\n    ///\n    /// The preferred method is to use `read_<type>` where the type is already known.\n    public fun read<T: key>(object: &Object<T>, key: &String): (String, vector<u8>) acquires PropertyMap {\n        assert_exists(object::object_address(object));\n        let property_map = borrow_global<PropertyMap>(object::object_address(object));\n        let property_value = simple_map::borrow(&property_map.inner, key);\n        let new_type = to_external_type(property_value.type);\n        (new_type, property_value.value)\n    }\n\n    inline fun assert_exists(object: address) {\n        assert!(\n            exists<PropertyMap>(object),\n            error::not_found(EPROPERTY_MAP_DOES_NOT_EXIST),\n        );\n    }\n\n    /// Read a type and verify that the type is correct\n    inline fun read_typed<T: key, V>(object: &Object<T>, key: &String): vector<u8> acquires PropertyMap {\n        let (type, value) = read(object, key);\n        assert!(\n            type == type_info::type_name<V>(),\n            error::invalid_argument(ETYPE_MISMATCH),\n        );\n        value\n    }\n\n    public fun read_bool<T: key>(object: &Object<T>, key: &String): bool acquires PropertyMap {\n        let value = read_typed<T, bool>(object, key);\n        from_bcs::to_bool(value)\n    }\n\n    public fun read_u8<T: key>(object: &Object<T>, key: &String): u8 acquires PropertyMap {\n        let value = read_typed<T, u8>(object, key);\n        from_bcs::to_u8(value)\n    }\n\n    public fun read_u16<T: key>(object: &Object<T>, key: &String): u16 acquires PropertyMap {\n        let value = read_typed<T, u16>(object, key);\n        from_bcs::to_u16(value)\n    }\n\n    public fun read_u32<T: key>(object: &Object<T>, key: &String): u32 acquires PropertyMap {\n        let value = read_typed<T, u32>(object, key);\n        from_bcs::to_u32(value)\n    }\n\n    public fun read_u64<T: key>(object: &Object<T>, key: &String): u64 acquires PropertyMap {\n        let value = read_typed<T, u64>(object, key);\n        from_bcs::to_u64(value)\n    }\n\n    public fun read_u128<T: key>(object: &Object<T>, key: &String): u128 acquires PropertyMap {\n        let value = read_typed<T, u128>(object, key);\n        from_bcs::to_u128(value)\n    }\n\n    public fun read_u256<T: key>(object: &Object<T>, key: &String): u256 acquires PropertyMap {\n        let value = read_typed<T, u256>(object, key);\n        from_bcs::to_u256(value)\n    }\n\n    public fun read_address<T: key>(object: &Object<T>, key: &String): address acquires PropertyMap {\n        let value = read_typed<T, address>(object, key);\n        from_bcs::to_address(value)\n    }\n\n    public fun read_bytes<T: key>(object: &Object<T>, key: &String): vector<u8> acquires PropertyMap {\n        let value = read_typed<T, vector<u8>>(object, key);\n        from_bcs::to_bytes(value)\n    }\n\n    public fun read_string<T: key>(object: &Object<T>, key: &String): String acquires PropertyMap {\n        let value = read_typed<T, String>(object, key);\n        from_bcs::to_string(value)\n    }\n\n    // Mutators\n    /// Add a property, already bcs encoded as a `vector<u8>`\n    public fun add(ref: &MutatorRef, key: String, type: String, value: vector<u8>) acquires PropertyMap {\n        let new_type = to_internal_type(type);\n        validate_type(new_type, value);\n        add_internal(ref, key, new_type, value);\n    }\n\n    /// Add a property that isn't already encoded as a `vector<u8>`\n    public fun add_typed<T: drop>(ref: &MutatorRef, key: String, value: T) acquires PropertyMap {\n        let type = type_info_to_internal_type<T>();\n        add_internal(ref, key, type, bcs::to_bytes(&value));\n    }\n\n    inline fun add_internal(ref: &MutatorRef, key: String, type: u8, value: vector<u8>) acquires PropertyMap {\n        assert_exists(ref.self);\n        let property_map = borrow_global_mut<PropertyMap>(ref.self);\n        simple_map::add(&mut property_map.inner, key, PropertyValue { type, value });\n    }\n\n    /// Updates a property in place already bcs encoded\n    public fun update(ref: &MutatorRef, key: &String, type: String, value: vector<u8>) acquires PropertyMap {\n        let new_type = to_internal_type(type);\n        validate_type(new_type, value);\n        update_internal(ref, key, new_type, value);\n    }\n\n    /// Updates a property in place that is not already bcs encoded\n    public fun update_typed<T: drop>(ref: &MutatorRef, key: &String, value: T) acquires PropertyMap {\n        let type = type_info_to_internal_type<T>();\n        update_internal(ref, key, type, bcs::to_bytes(&value));\n    }\n\n    inline fun update_internal(ref: &MutatorRef, key: &String, type: u8, value: vector<u8>) acquires PropertyMap {\n        assert_exists(ref.self);\n        let property_map = borrow_global_mut<PropertyMap>(ref.self);\n        let old_value = simple_map::borrow_mut(&mut property_map.inner, key);\n        *old_value = PropertyValue { type, value };\n    }\n\n    /// Removes a property from the map, ensuring that it does in fact exist\n    public fun remove(ref: &MutatorRef, key: &String) acquires PropertyMap {\n        assert_exists(ref.self);\n        let property_map = borrow_global_mut<PropertyMap>(ref.self);\n        simple_map::remove(&mut property_map.inner, key);\n    }\n\n    // Tests\n    #[test(creator = @0x123)]\n    fun test_end_to_end(creator: &signer) acquires PropertyMap {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n        let object = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);\n\n        let input = end_to_end_input();\n        init(&constructor_ref, input);\n        let mutator = generate_mutator_ref(&constructor_ref);\n\n        assert_end_to_end_input(object);\n\n        test_end_to_end_update_typed(&mutator, &object);\n\n        assert!(length(&object) == 9, 19);\n\n        remove(&mutator, &string::utf8(b\"bool\"));\n        remove(&mutator, &string::utf8(b\"u8\"));\n        remove(&mutator, &string::utf8(b\"u16\"));\n        remove(&mutator, &string::utf8(b\"u32\"));\n        remove(&mutator, &string::utf8(b\"u64\"));\n        remove(&mutator, &string::utf8(b\"u128\"));\n        remove(&mutator, &string::utf8(b\"u256\"));\n        remove(&mutator, &string::utf8(b\"vector<u8>\"));\n        remove(&mutator, &string::utf8(b\"0x1::string::String\"));\n\n        assert!(length(&object) == 0, 20);\n\n        test_end_to_end_add_typed(&mutator, &object);\n\n        assert!(length(&object) == 9, 30);\n\n        remove(&mutator, &string::utf8(b\"bool\"));\n        remove(&mutator, &string::utf8(b\"u8\"));\n        remove(&mutator, &string::utf8(b\"u16\"));\n        remove(&mutator, &string::utf8(b\"u32\"));\n        remove(&mutator, &string::utf8(b\"u64\"));\n        remove(&mutator, &string::utf8(b\"u128\"));\n        remove(&mutator, &string::utf8(b\"u256\"));\n        remove(&mutator, &string::utf8(b\"vector<u8>\"));\n        remove(&mutator, &string::utf8(b\"0x1::string::String\"));\n\n        assert!(length(&object) == 0, 31);\n\n        add(&mutator, string::utf8(b\"bool\"), string::utf8(b\"bool\"), bcs::to_bytes<bool>(&true));\n        add(&mutator, string::utf8(b\"u8\"), string::utf8(b\"u8\"), bcs::to_bytes<u8>(&0x12));\n        add(&mutator, string::utf8(b\"u16\"), string::utf8(b\"u16\"), bcs::to_bytes<u16>(&0x1234));\n        add(&mutator, string::utf8(b\"u32\"), string::utf8(b\"u32\"), bcs::to_bytes<u32>(&0x12345678));\n        add(&mutator, string::utf8(b\"u64\"), string::utf8(b\"u64\"), bcs::to_bytes<u64>(&0x1234567812345678));\n        add(\n            &mutator,\n            string::utf8(b\"u128\"),\n            string::utf8(b\"u128\"),\n            bcs::to_bytes<u128>(&0x12345678123456781234567812345678)\n        );\n        add(\n            &mutator,\n            string::utf8(b\"u256\"),\n            string::utf8(b\"u256\"),\n            bcs::to_bytes<u256>(&0x1234567812345678123456781234567812345678123456781234567812345678)\n        );\n        add(\n            &mutator,\n            string::utf8(b\"vector<u8>\"),\n            string::utf8(b\"vector<u8>\"),\n            bcs::to_bytes<vector<u8>>(&vector[0x01])\n        );\n        add(\n            &mutator,\n            string::utf8(b\"0x1::string::String\"),\n            string::utf8(b\"0x1::string::String\"),\n            bcs::to_bytes<String>(&string::utf8(b\"a\"))\n        );\n\n        assert!(read_bool(&object, &string::utf8(b\"bool\")), 32);\n        assert!(read_u8(&object, &string::utf8(b\"u8\")) == 0x12, 33);\n        assert!(read_u16(&object, &string::utf8(b\"u16\")) == 0x1234, 34);\n        assert!(read_u32(&object, &string::utf8(b\"u32\")) == 0x12345678, 35);\n        assert!(read_u64(&object, &string::utf8(b\"u64\")) == 0x1234567812345678, 36);\n        assert!(read_u128(&object, &string::utf8(b\"u128\")) == 0x12345678123456781234567812345678, 37);\n        assert!(\n            read_u256(\n                &object,\n                &string::utf8(b\"u256\")\n            ) == 0x1234567812345678123456781234567812345678123456781234567812345678,\n            38\n        );\n        assert!(read_bytes(&object, &string::utf8(b\"vector<u8>\")) == vector[0x01], 39);\n        assert!(read_string(&object, &string::utf8(b\"0x1::string::String\")) == string::utf8(b\"a\"), 40);\n\n        assert!(length(&object) == 9, 41);\n\n        update(&mutator, &string::utf8(b\"bool\"), string::utf8(b\"bool\"), bcs::to_bytes<bool>(&false));\n        update(&mutator, &string::utf8(b\"u8\"), string::utf8(b\"u8\"), bcs::to_bytes<u8>(&0x21));\n        update(&mutator, &string::utf8(b\"u16\"), string::utf8(b\"u16\"), bcs::to_bytes<u16>(&0x22));\n        update(&mutator, &string::utf8(b\"u32\"), string::utf8(b\"u32\"), bcs::to_bytes<u32>(&0x23));\n        update(&mutator, &string::utf8(b\"u64\"), string::utf8(b\"u64\"), bcs::to_bytes<u64>(&0x24));\n        update(&mutator, &string::utf8(b\"u128\"), string::utf8(b\"u128\"), bcs::to_bytes<u128>(&0x25));\n        update(&mutator, &string::utf8(b\"u256\"), string::utf8(b\"u256\"), bcs::to_bytes<u256>(&0x26));\n        update(\n            &mutator,\n            &string::utf8(b\"vector<u8>\"),\n            string::utf8(b\"vector<u8>\"),\n            bcs::to_bytes<vector<u8>>(&vector[0x02])\n        );\n        update(\n            &mutator,\n            &string::utf8(b\"0x1::string::String\"),\n            string::utf8(b\"0x1::string::String\"),\n            bcs::to_bytes<String>(&string::utf8(b\"ha\"))\n        );\n\n        assert!(!read_bool(&object, &string::utf8(b\"bool\")), 10);\n        assert!(read_u8(&object, &string::utf8(b\"u8\")) == 0x21, 11);\n        assert!(read_u16(&object, &string::utf8(b\"u16\")) == 0x22, 12);\n        assert!(read_u32(&object, &string::utf8(b\"u32\")) == 0x23, 13);\n        assert!(read_u64(&object, &string::utf8(b\"u64\")) == 0x24, 14);\n        assert!(read_u128(&object, &string::utf8(b\"u128\")) == 0x25, 15);\n        assert!(read_u256(&object, &string::utf8(b\"u256\")) == 0x26, 16);\n        assert!(read_bytes(&object, &string::utf8(b\"vector<u8>\")) == vector[0x02], 17);\n        assert!(read_string(&object, &string::utf8(b\"0x1::string::String\")) == string::utf8(b\"ha\"), 18);\n    }\n\n    #[test_only]\n    fun test_end_to_end_update_typed(mutator: &MutatorRef, object: &Object<object::ObjectCore>) acquires PropertyMap {\n        update_typed<bool>(mutator, &string::utf8(b\"bool\"), false);\n        update_typed<u8>(mutator, &string::utf8(b\"u8\"), 0x21);\n        update_typed<u16>(mutator, &string::utf8(b\"u16\"), 0x22);\n        update_typed<u32>(mutator, &string::utf8(b\"u32\"), 0x23);\n        update_typed<u64>(mutator, &string::utf8(b\"u64\"), 0x24);\n        update_typed<u128>(mutator, &string::utf8(b\"u128\"), 0x25);\n        update_typed<u256>(mutator, &string::utf8(b\"u256\"), 0x26);\n        update_typed<vector<u8>>(mutator, &string::utf8(b\"vector<u8>\"), vector[0x02]);\n        update_typed<String>(mutator, &string::utf8(b\"0x1::string::String\"), string::utf8(b\"ha\"));\n\n        assert!(!read_bool(object, &string::utf8(b\"bool\")), 10);\n        assert!(read_u8(object, &string::utf8(b\"u8\")) == 0x21, 11);\n        assert!(read_u16(object, &string::utf8(b\"u16\")) == 0x22, 12);\n        assert!(read_u32(object, &string::utf8(b\"u32\")) == 0x23, 13);\n        assert!(read_u64(object, &string::utf8(b\"u64\")) == 0x24, 14);\n        assert!(read_u128(object, &string::utf8(b\"u128\")) == 0x25, 15);\n        assert!(read_u256(object, &string::utf8(b\"u256\")) == 0x26, 16);\n        assert!(read_bytes(object, &string::utf8(b\"vector<u8>\")) == vector[0x02], 17);\n        assert!(read_string(object, &string::utf8(b\"0x1::string::String\")) == string::utf8(b\"ha\"), 18);\n    }\n\n    #[test_only]\n    fun test_end_to_end_add_typed(mutator: &MutatorRef, object: &Object<object::ObjectCore>) acquires PropertyMap {\n        add_typed<bool>(mutator, string::utf8(b\"bool\"), false);\n        add_typed<u8>(mutator, string::utf8(b\"u8\"), 0x21);\n        add_typed<u16>(mutator, string::utf8(b\"u16\"), 0x22);\n        add_typed<u32>(mutator, string::utf8(b\"u32\"), 0x23);\n        add_typed<u64>(mutator, string::utf8(b\"u64\"), 0x24);\n        add_typed<u128>(mutator, string::utf8(b\"u128\"), 0x25);\n        add_typed<u256>(mutator, string::utf8(b\"u256\"), 0x26);\n        add_typed<vector<u8>>(mutator, string::utf8(b\"vector<u8>\"), vector[0x02]);\n        add_typed<String>(mutator, string::utf8(b\"0x1::string::String\"), string::utf8(b\"ha\"));\n\n        assert!(!read_bool(object, &string::utf8(b\"bool\")), 21);\n        assert!(read_u8(object, &string::utf8(b\"u8\")) == 0x21, 22);\n        assert!(read_u16(object, &string::utf8(b\"u16\")) == 0x22, 23);\n        assert!(read_u32(object, &string::utf8(b\"u32\")) == 0x23, 24);\n        assert!(read_u64(object, &string::utf8(b\"u64\")) == 0x24, 25);\n        assert!(read_u128(object, &string::utf8(b\"u128\")) == 0x25, 26);\n        assert!(read_u256(object, &string::utf8(b\"u256\")) == 0x26, 27);\n        assert!(read_bytes(object, &string::utf8(b\"vector<u8>\")) == vector[0x02], 28);\n        assert!(read_string(object, &string::utf8(b\"0x1::string::String\")) == string::utf8(b\"ha\"), 29);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_extend_property_map(creator: &signer) acquires PropertyMap {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n        let extend_ref = object::generate_extend_ref(&constructor_ref);\n        extend(&extend_ref, end_to_end_input());\n\n        let object = object::object_from_constructor_ref<ObjectCore>(&constructor_ref);\n        assert_end_to_end_input(object);\n    }\n\n    #[test_only]\n    fun end_to_end_input(): PropertyMap {\n        prepare_input(\n            vector[\n                string::utf8(b\"bool\"),\n                string::utf8(b\"u8\"),\n                string::utf8(b\"u16\"),\n                string::utf8(b\"u32\"),\n                string::utf8(b\"u64\"),\n                string::utf8(b\"u128\"),\n                string::utf8(b\"u256\"),\n                string::utf8(b\"vector<u8>\"),\n                string::utf8(b\"0x1::string::String\"),\n            ],\n            vector[\n                string::utf8(b\"bool\"),\n                string::utf8(b\"u8\"),\n                string::utf8(b\"u16\"),\n                string::utf8(b\"u32\"),\n                string::utf8(b\"u64\"),\n                string::utf8(b\"u128\"),\n                string::utf8(b\"u256\"),\n                string::utf8(b\"vector<u8>\"),\n                string::utf8(b\"0x1::string::String\"),\n            ],\n            vector[\n                bcs::to_bytes<bool>(&true),\n                bcs::to_bytes<u8>(&0x12),\n                bcs::to_bytes<u16>(&0x1234),\n                bcs::to_bytes<u32>(&0x12345678),\n                bcs::to_bytes<u64>(&0x1234567812345678),\n                bcs::to_bytes<u128>(&0x12345678123456781234567812345678),\n                bcs::to_bytes<u256>(&0x1234567812345678123456781234567812345678123456781234567812345678),\n                bcs::to_bytes<vector<u8>>(&vector[0x01]),\n                bcs::to_bytes<String>(&string::utf8(b\"a\")),\n            ],\n        )\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10001, location = aptos_std::from_bcs)]\n    fun test_invalid_init(creator: &signer) {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n\n        let input = prepare_input(\n            vector[string::utf8(b\"bool\")],\n            vector[string::utf8(b\"u16\")],\n            vector[bcs::to_bytes<bool>(&true)],\n        );\n        init(&constructor_ref, input);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10004, location = Self)]\n    fun test_init_wrong_values(creator: &signer) {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n\n        let input = prepare_input(\n            vector[string::utf8(b\"bool\"), string::utf8(b\"u8\")],\n            vector[string::utf8(b\"bool\"), string::utf8(b\"u8\")],\n            vector[bcs::to_bytes<bool>(&true)],\n        );\n        init(&constructor_ref, input);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10005, location = Self)]\n    fun test_init_wrong_types(creator: &signer) {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n\n        let input = prepare_input(\n            vector[string::utf8(b\"bool\"), string::utf8(b\"u8\")],\n            vector[string::utf8(b\"bool\")],\n            vector[bcs::to_bytes<bool>(&true), bcs::to_bytes<u8>(&0x2)],\n        );\n        init(&constructor_ref, input);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10001, location = aptos_std::from_bcs)]\n    fun test_invalid_add(creator: &signer) acquires PropertyMap {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n\n        let input = prepare_input(\n            vector[string::utf8(b\"bool\")],\n            vector[string::utf8(b\"bool\")],\n            vector[bcs::to_bytes<bool>(&true)],\n        );\n        init(&constructor_ref, input);\n        let mutator = generate_mutator_ref(&constructor_ref);\n\n        update(&mutator, &string::utf8(b\"u16\"), string::utf8(b\"bool\"), bcs::to_bytes<u16>(&0x1234));\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10001, location = aptos_std::from_bcs)]\n    fun test_invalid_update(creator: &signer) acquires PropertyMap {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n\n        let input = prepare_input(\n            vector[string::utf8(b\"bool\")],\n            vector[string::utf8(b\"bool\")],\n            vector[bcs::to_bytes<bool>(&true)],\n        );\n        init(&constructor_ref, input);\n        let mutator = generate_mutator_ref(&constructor_ref);\n\n        update(&mutator, &string::utf8(b\"bool\"), string::utf8(b\"bool\"), bcs::to_bytes<u16>(&0x1234));\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10006, location = Self)]\n    fun test_invalid_read(creator: &signer) acquires PropertyMap {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n        let object = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);\n\n        let input = prepare_input(\n            vector[string::utf8(b\"bool\")],\n            vector[string::utf8(b\"bool\")],\n            vector[bcs::to_bytes<bool>(&true)],\n        );\n        init(&constructor_ref, input);\n        read_u8(&object, &string::utf8(b\"bool\"));\n    }\n\n    fun assert_end_to_end_input(object: Object<ObjectCore>) acquires PropertyMap {\n        assert!(read_bool(&object, &string::utf8(b\"bool\")), 0);\n        assert!(read_u8(&object, &string::utf8(b\"u8\")) == 0x12, 1);\n        assert!(read_u16(&object, &string::utf8(b\"u16\")) == 0x1234, 2);\n        assert!(read_u32(&object, &string::utf8(b\"u32\")) == 0x12345678, 3);\n        assert!(read_u64(&object, &string::utf8(b\"u64\")) == 0x1234567812345678, 4);\n        assert!(read_u128(&object, &string::utf8(b\"u128\")) == 0x12345678123456781234567812345678, 5);\n        assert!(\n            read_u256(\n                &object,\n                &string::utf8(b\"u256\")\n            ) == 0x1234567812345678123456781234567812345678123456781234567812345678,\n            6\n        );\n        assert!(read_bytes(&object, &string::utf8(b\"vector<u8>\")) == vector[0x01], 7);\n        assert!(read_string(&object, &string::utf8(b\"0x1::string::String\")) == string::utf8(b\"a\"), 8);\n\n        assert!(length(&object) == 9, 9);\n    }\n}\n","name":"property_map.move"},{"content":"/// This defines an object-based Royalty. The royalty can be applied to either a collection or a\n/// token. Applications should read the royalty from the token, as it will read the appropriate\n/// royalty.\nmodule aptos_token_objects::royalty {\n    use std::error;\n    use std::option::{Self, Option};\n    use aptos_framework::object::{Self, ConstructorRef, ExtendRef, Object};\n\n    friend aptos_token_objects::token;\n\n    /// Royalty does not exist\n    const EROYALTY_DOES_NOT_EXIST: u64 = 1;\n    /// The royalty cannot be greater than 100%\n    const EROYALTY_EXCEEDS_MAXIMUM: u64 = 2;\n    /// The royalty denominator cannot be 0\n    const EROYALTY_DENOMINATOR_IS_ZERO: u64 = 3;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// The royalty of a token within this collection\n    ///\n    /// Royalties are optional for a collection.  Royalty percentage is calculated\n    /// by (numerator / denominator) * 100%\n    struct Royalty has copy, drop, key {\n        numerator: u64,\n        denominator: u64,\n        /// The recipient of royalty payments. See the `shared_account` for how to handle multiple\n        /// creators.\n        payee_address: address,\n    }\n\n    /// This enables creating or overwriting a `MutatorRef`.\n    struct MutatorRef has drop, store {\n        inner: ExtendRef,\n    }\n\n    /// Add a royalty, given a ConstructorRef.\n    public fun init(ref: &ConstructorRef, royalty: Royalty) {\n        let signer = object::generate_signer(ref);\n        move_to(&signer, royalty);\n    }\n\n    /// Set the royalty if it does not exist, replace it otherwise.\n    public fun update(mutator_ref: &MutatorRef, royalty: Royalty) acquires Royalty {\n        let addr = object::address_from_extend_ref(&mutator_ref.inner);\n        if (exists<Royalty>(addr)) {\n            move_from<Royalty>(addr);\n        };\n\n        let signer = object::generate_signer_for_extending(&mutator_ref.inner);\n        move_to(&signer, royalty);\n    }\n\n    /// Creates a new royalty, verifying that it is a valid percentage\n    public fun create(numerator: u64, denominator: u64, payee_address: address): Royalty {\n        assert!(denominator != 0, error::out_of_range(EROYALTY_DENOMINATOR_IS_ZERO));\n        assert!(numerator <= denominator, error::out_of_range(EROYALTY_EXCEEDS_MAXIMUM));\n\n        Royalty { numerator, denominator, payee_address }\n    }\n\n    public fun generate_mutator_ref(ref: ExtendRef): MutatorRef {\n        MutatorRef { inner: ref }\n    }\n\n    public fun exists_at(addr: address): bool {\n        exists<Royalty>(addr)\n    }\n\n    public(friend) fun delete(addr: address) acquires Royalty {\n        assert!(exists<Royalty>(addr), error::not_found(EROYALTY_DOES_NOT_EXIST));\n        move_from<Royalty>(addr);\n    }\n\n    // Accessors\n    public fun get<T: key>(maybe_royalty: Object<T>): Option<Royalty> acquires Royalty {\n        let obj_addr = object::object_address(&maybe_royalty);\n        if (exists<Royalty>(obj_addr)) {\n            option::some(*borrow_global<Royalty>(obj_addr))\n        } else {\n            option::none()\n        }\n    }\n\n    public fun denominator(royalty: &Royalty): u64 {\n        royalty.denominator\n    }\n\n    public fun numerator(royalty: &Royalty): u64 {\n        royalty.numerator\n    }\n\n    public fun payee_address(royalty: &Royalty): address {\n        royalty.payee_address\n    }\n\n    #[test(creator = @0x123)]\n    fun test_none(creator: &signer) acquires Royalty {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n        let object = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);\n        assert!(option::none() == get(object), 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_init_and_update(creator: &signer) acquires Royalty {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n        let object = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);\n        let init_royalty = create(1, 2, @0x123);\n        init(&constructor_ref, init_royalty);\n        assert!(option::some(init_royalty) == get(object), 0);\n        assert!(numerator(&init_royalty) == 1, 1);\n        assert!(denominator(&init_royalty) == 2, 2);\n        assert!(payee_address(&init_royalty) == @0x123, 3);\n\n        let mutator_ref = generate_mutator_ref(object::generate_extend_ref(&constructor_ref));\n        let update_royalty = create(2, 5, @0x456);\n        update(&mutator_ref, update_royalty);\n        assert!(option::some(update_royalty) == get(object), 4);\n        assert!(numerator(&update_royalty) == 2, 5);\n        assert!(denominator(&update_royalty) == 5, 6);\n        assert!(payee_address(&update_royalty) == @0x456, 7);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_update_only(creator: &signer) acquires Royalty {\n        let constructor_ref = object::create_named_object(creator, b\"\");\n        let object = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);\n        assert!(option::none() == get(object), 0);\n\n        let mutator_ref = generate_mutator_ref(object::generate_extend_ref(&constructor_ref));\n        let update_royalty = create(1, 5, @0x123);\n        update(&mutator_ref, update_royalty);\n        assert!(option::some(update_royalty) == get(object), 1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x60001, location = Self)]\n    fun test_does_not_exist() acquires Royalty {\n        delete(@0x1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x20002, location = Self)]\n    fun test_exceeds_maximum() {\n        create(6, 5, @0x1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x20003, location = Self)]\n    fun test_invalid_denominator() {\n        create(6, 0, @0x1);\n    }\n}\n","name":"royalty.move"},{"content":"/// This defines an object-based Token. The key differentiating features from the Aptos standard\n/// token are:\n/// * Decoupled token ownership from token data.\n/// * Explicit data model for token metadata via adjacent resources\n/// * Extensible framework for tokens\n///\nmodule aptos_token_objects::token {\n    use std::error;\n    use std::option::{Self, Option};\n    use std::features;\n    use std::string::{Self, String};\n    use std::signer;\n    use std::vector;\n    use aptos_framework::aggregator_v2::{Self, AggregatorSnapshot, DerivedStringSnapshot};\n    use aptos_framework::event;\n    use aptos_framework::object::{Self, ConstructorRef, Object};\n    use aptos_std::string_utils::{to_string};\n    use aptos_token_objects::collection::{Self, Collection};\n    use aptos_token_objects::royalty::{Self, Royalty};\n\n    #[test_only]\n    use aptos_framework::object::ExtendRef;\n\n    /// The token does not exist\n    const ETOKEN_DOES_NOT_EXIST: u64 = 1;\n    /// The provided signer is not the creator\n    const ENOT_CREATOR: u64 = 2;\n    /// The field being changed is not mutable\n    const EFIELD_NOT_MUTABLE: u64 = 3;\n    /// The token name is over the maximum length\n    const ETOKEN_NAME_TOO_LONG: u64 = 4;\n    /// The URI is over the maximum length\n    const EURI_TOO_LONG: u64 = 5;\n    /// The description is over the maximum length\n    const EDESCRIPTION_TOO_LONG: u64 = 6;\n    /// The seed is over the maximum length\n    const ESEED_TOO_LONG: u64 = 7;\n\n    const MAX_TOKEN_NAME_LENGTH: u64 = 128;\n    const MAX_TOKEN_SEED_LENGTH: u64 = 128;\n    const MAX_URI_LENGTH: u64 = 512;\n    const MAX_DESCRIPTION_LENGTH: u64 = 2048;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Represents the common fields to all tokens.\n    struct Token has key {\n        /// The collection from which this token resides.\n        collection: Object<Collection>,\n        /// Deprecated in favor of `index` inside TokenIdentifiers.\n        /// Will be populated until concurrent_token_v2_enabled feature flag is enabled.\n        ///\n        /// Unique identifier within the collection, optional, 0 means unassigned\n        index: u64,\n        // DEPRECATED\n        /// A brief description of the token.\n        description: String,\n        /// Deprecated in favor of `name` inside TokenIdentifiers.\n        /// Will be populated until concurrent_token_v2_enabled feature flag is enabled.\n        ///\n        /// The name of the token, which should be unique within the collection; the length of name\n        /// should be smaller than 128, characters, eg: \"Aptos Animal #1234\"\n        name: String,\n        // DEPRECATED\n        /// The Uniform Resource Identifier (uri) pointing to the JSON file stored in off-chain\n        /// storage; the URL length will likely need a maximum any suggestions?\n        uri: String,\n        /// Emitted upon any mutation of the token.\n        mutation_events: event::EventHandle<MutationEvent>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Represents first addition to the common fields for all tokens\n    /// Starts being populated once aggregator_v2_api_enabled is enabled.\n    struct TokenIdentifiers has key {\n        /// Unique identifier within the collection, optional, 0 means unassigned\n        index: AggregatorSnapshot<u64>,\n        /// The name of the token, which should be unique within the collection; the length of name\n        /// should be smaller than 128, characters, eg: \"Aptos Animal #1234\"\n        name: DerivedStringSnapshot,\n    }\n\n    // DEPRECATED, NEVER USED\n    #[deprecated]\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct ConcurrentTokenIdentifiers has key {\n        index: AggregatorSnapshot<u64>,\n        name: AggregatorSnapshot<String>,\n    }\n\n    /// This enables burning an NFT, if possible, it will also delete the object. Note, the data\n    /// in inner and self occupies 32-bytes each, rather than have both, this data structure makes\n    /// a small optimization to support either and take a fixed amount of 34-bytes.\n    struct BurnRef has drop, store {\n        inner: Option<object::DeleteRef>,\n        self: Option<address>,\n    }\n\n    /// This enables mutating description and URI by higher level services.\n    struct MutatorRef has drop, store {\n        self: address,\n    }\n\n    /// Contains the mutated fields name. This makes the life of indexers easier, so that they can\n    /// directly understand the behavior in a writeset.\n    struct MutationEvent has drop, store {\n        mutated_field_name: String,\n        old_value: String,\n        new_value: String\n    }\n\n    #[event]\n    struct Mutation has drop, store {\n        token_address: address,\n        mutated_field_name: String,\n        old_value: String,\n        new_value: String\n    }\n\n    inline fun create_common(\n        constructor_ref: &ConstructorRef,\n        creator_address: address,\n        collection_name: String,\n        description: String,\n        name_prefix: String,\n        // If option::some, numbered token is created - i.e. index is appended to the name.\n        // If option::none, name_prefix is the full name of the token.\n        name_with_index_suffix: Option<String>,\n        royalty: Option<Royalty>,\n        uri: String,\n    ) {\n        let collection_addr = collection::create_collection_address(&creator_address, &collection_name);\n        let collection = object::address_to_object<Collection>(collection_addr);\n\n        create_common_with_collection(\n            constructor_ref,\n            collection,\n            description,\n            name_prefix,\n            name_with_index_suffix,\n            royalty,\n            uri\n        )\n    }\n\n    inline fun create_common_with_collection(\n        constructor_ref: &ConstructorRef,\n        collection: Object<Collection>,\n        description: String,\n        name_prefix: String,\n        // If option::some, numbered token is created - i.e. index is appended to the name.\n        // If option::none, name_prefix is the full name of the token.\n        name_with_index_suffix: Option<String>,\n        royalty: Option<Royalty>,\n        uri: String,\n    ) {\n        if (option::is_some(&name_with_index_suffix)) {\n            // Be conservative, as we don't know what length the index will be, and assume worst case (20 chars in MAX_U64)\n            assert!(\n                string::length(&name_prefix) + 20 + string::length(\n                    option::borrow(&name_with_index_suffix)\n                ) <= MAX_TOKEN_NAME_LENGTH,\n                error::out_of_range(ETOKEN_NAME_TOO_LONG)\n            );\n        } else {\n            assert!(string::length(&name_prefix) <= MAX_TOKEN_NAME_LENGTH, error::out_of_range(ETOKEN_NAME_TOO_LONG));\n        };\n        assert!(string::length(&description) <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));\n\n        let object_signer = object::generate_signer(constructor_ref);\n\n        // TODO[agg_v2](cleanup) once this flag is enabled, cleanup code for aggregator_api_enabled = false.\n        // Flag which controls whether any functions from aggregator_v2 module can be called.\n        let aggregator_api_enabled = features::aggregator_v2_api_enabled();\n        // Flag which controls whether we are going to still continue writing to deprecated fields.\n        let concurrent_token_v2_enabled = features::concurrent_token_v2_enabled();\n\n        let (deprecated_index, deprecated_name) = if (aggregator_api_enabled) {\n            let index = option::destroy_with_default(\n                collection::increment_concurrent_supply(&collection, signer::address_of(&object_signer)),\n                aggregator_v2::create_snapshot<u64>(0)\n            );\n\n            // If create_numbered_token called us, add index to the name.\n            let name = if (option::is_some(&name_with_index_suffix)) {\n                aggregator_v2::derive_string_concat(name_prefix, &index, option::extract(&mut name_with_index_suffix))\n            } else {\n                aggregator_v2::create_derived_string(name_prefix)\n            };\n\n            // Until concurrent_token_v2_enabled is enabled, we still need to write to deprecated fields.\n            // Otherwise we put empty values there.\n            // (we need to do these calls before creating token_concurrent, to avoid copying objects)\n            let deprecated_index = if (concurrent_token_v2_enabled) {\n                0\n            } else {\n                aggregator_v2::read_snapshot(&index)\n            };\n            let deprecated_name = if (concurrent_token_v2_enabled) {\n                string::utf8(b\"\")\n            } else {\n                aggregator_v2::read_derived_string(&name)\n            };\n\n            // If aggregator_api_enabled, we always populate newly added fields\n            let token_concurrent = TokenIdentifiers {\n                index,\n                name,\n            };\n            move_to(&object_signer, token_concurrent);\n\n            (deprecated_index, deprecated_name)\n        } else {\n            // If aggregator_api_enabled is disabled, we cannot use increment_concurrent_supply or\n            // create TokenIdentifiers, so we fallback to the old behavior.\n            let id = collection::increment_supply(&collection, signer::address_of(&object_signer));\n            let index = option::get_with_default(&mut id, 0);\n\n            // If create_numbered_token called us, add index to the name.\n            let name = if (option::is_some(&name_with_index_suffix)) {\n                let name = name_prefix;\n                string::append(&mut name, to_string<u64>(&index));\n                string::append(&mut name, option::extract(&mut name_with_index_suffix));\n                name\n            } else {\n                name_prefix\n            };\n\n            (index, name)\n        };\n\n        let token = Token {\n            collection,\n            index: deprecated_index,\n            description,\n            name: deprecated_name,\n            uri,\n            mutation_events: object::new_event_handle(&object_signer),\n        };\n        move_to(&object_signer, token);\n\n        if (option::is_some(&royalty)) {\n            royalty::init(constructor_ref, option::extract(&mut royalty))\n        };\n    }\n\n    /// Creates a new token object with a unique address and returns the ConstructorRef\n    /// for additional specialization.\n    /// This takes in the collection object instead of the collection name.\n    /// This function must be called if the collection name has been previously changed.\n    public fun create_token(\n        creator: &signer,\n        collection: Object<Collection>,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let creator_address = signer::address_of(creator);\n        let constructor_ref = object::create_object(creator_address);\n        create_common_with_collection(\n            &constructor_ref,\n            collection,\n            description,\n            name,\n            option::none(),\n            royalty,\n            uri\n        );\n        constructor_ref\n    }\n\n    /// Creates a new token object with a unique address and returns the ConstructorRef\n    /// for additional specialization.\n    public fun create(\n        creator: &signer,\n        collection_name: String,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let creator_address = signer::address_of(creator);\n        let constructor_ref = object::create_object(creator_address);\n        create_common(\n            &constructor_ref,\n            creator_address,\n            collection_name,\n            description,\n            name,\n            option::none(),\n            royalty,\n            uri\n        );\n        constructor_ref\n    }\n\n    /// Creates a new token object with a unique address and returns the ConstructorRef\n    /// for additional specialization.\n    /// The name is created by concatenating the (name_prefix, index, name_suffix).\n    /// After flag concurrent_token_v2_enabled is enabled, this function will allow\n    /// creating tokens in parallel, from the same collection, while providing sequential names.\n    ///\n    /// This takes in the collection object instead of the collection name.\n    /// This function must be called if the collection name has been previously changed.\n    public fun create_numbered_token_object(\n        creator: &signer,\n        collection: Object<Collection>,\n        description: String,\n        name_with_index_prefix: String,\n        name_with_index_suffix: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let creator_address = signer::address_of(creator);\n        let constructor_ref = object::create_object(creator_address);\n        create_common_with_collection(\n            &constructor_ref,\n            collection,\n            description,\n            name_with_index_prefix,\n            option::some(name_with_index_suffix),\n            royalty,\n            uri\n        );\n        constructor_ref\n    }\n\n    /// Creates a new token object with a unique address and returns the ConstructorRef\n    /// for additional specialization.\n    /// The name is created by concatenating the (name_prefix, index, name_suffix).\n    /// After flag concurrent_token_v2_enabled is enabled, this function will allow\n    /// creating tokens in parallel, from the same collection, while providing sequential names.\n    public fun create_numbered_token(\n        creator: &signer,\n        collection_name: String,\n        description: String,\n        name_with_index_prefix: String,\n        name_with_index_suffix: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let creator_address = signer::address_of(creator);\n        let constructor_ref = object::create_object(creator_address);\n        create_common(\n            &constructor_ref,\n            creator_address,\n            collection_name,\n            description,\n            name_with_index_prefix,\n            option::some(name_with_index_suffix),\n            royalty,\n            uri\n        );\n        constructor_ref\n    }\n\n    /// Creates a new token object from a token name and returns the ConstructorRef for\n    /// additional specialization.\n    /// This function must be called if the collection name has been previously changed.\n    public fun create_named_token_object(\n        creator: &signer,\n        collection: Object<Collection>,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let seed = create_token_seed(&collection::name(collection), &name);\n        let constructor_ref = object::create_named_object(creator, seed);\n        create_common_with_collection(\n            &constructor_ref,\n            collection,\n            description,\n            name,\n            option::none(),\n            royalty,\n            uri\n        );\n        constructor_ref\n    }\n\n    /// Creates a new token object from a token name and returns the ConstructorRef for\n    /// additional specialization.\n    public fun create_named_token(\n        creator: &signer,\n        collection_name: String,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let creator_address = signer::address_of(creator);\n        let seed = create_token_seed(&collection_name, &name);\n\n        let constructor_ref = object::create_named_object(creator, seed);\n        create_common(\n            &constructor_ref,\n            creator_address,\n            collection_name,\n            description,\n            name,\n            option::none(),\n            royalty,\n            uri\n        );\n        constructor_ref\n    }\n\n    /// Creates a new token object from a token name and seed.\n    /// Returns the ConstructorRef for additional specialization.\n    /// This function must be called if the collection name has been previously changed.\n    public fun create_named_token_from_seed(\n        creator: &signer,\n        collection: Object<Collection>,\n        description: String,\n        name: String,\n        seed: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let seed = create_token_name_with_seed(&collection::name(collection), &name, &seed);\n        let constructor_ref = object::create_named_object(creator, seed);\n        create_common_with_collection(&constructor_ref, collection, description, name, option::none(), royalty, uri);\n        constructor_ref\n    }\n\n    #[deprecated]\n    /// DEPRECATED: Use `create` instead for identical behavior.\n    ///\n    /// Creates a new token object from an account GUID and returns the ConstructorRef for\n    /// additional specialization.\n    public fun create_from_account(\n        creator: &signer,\n        collection_name: String,\n        description: String,\n        name: String,\n        royalty: Option<Royalty>,\n        uri: String,\n    ): ConstructorRef {\n        let creator_address = signer::address_of(creator);\n        let constructor_ref = object::create_object_from_account(creator);\n        create_common(\n            &constructor_ref,\n            creator_address,\n            collection_name,\n            description,\n            name,\n            option::none(),\n            royalty,\n            uri\n        );\n        constructor_ref\n    }\n\n    /// Generates the token's address based upon the creator's address, the collection's name and the token's name.\n    public fun create_token_address(creator: &address, collection: &String, name: &String): address {\n        object::create_object_address(creator, create_token_seed(collection, name))\n    }\n\n    #[view]\n    /// Generates the token's address based upon the creator's address, the collection object and the token's name and seed.\n    public fun create_token_address_with_seed(creator: address, collection: String, name: String, seed: String): address {\n        let seed = create_token_name_with_seed(&collection, &name, &seed);\n        object::create_object_address(&creator, seed)\n    }\n\n    /// Named objects are derived from a seed, the token's seed is its name appended to the collection's name.\n    public fun create_token_seed(collection: &String, name: &String): vector<u8> {\n        assert!(string::length(name) <= MAX_TOKEN_NAME_LENGTH, error::out_of_range(ETOKEN_NAME_TOO_LONG));\n        let seed = *string::bytes(collection);\n        vector::append(&mut seed, b\"::\");\n        vector::append(&mut seed, *string::bytes(name));\n        seed\n    }\n\n    public fun create_token_name_with_seed(collection: &String, name: &String, seed: &String): vector<u8> {\n        assert!(string::length(seed) <= MAX_TOKEN_SEED_LENGTH, error::out_of_range(ESEED_TOO_LONG));\n        let seeds = create_token_seed(collection, name);\n        vector::append(&mut seeds, *string::bytes(seed));\n        seeds\n    }\n\n    /// Creates a MutatorRef, which gates the ability to mutate any fields that support mutation.\n    public fun generate_mutator_ref(ref: &ConstructorRef): MutatorRef {\n        let object = object::object_from_constructor_ref<Token>(ref);\n        MutatorRef { self: object::object_address(&object) }\n    }\n\n    /// Creates a BurnRef, which gates the ability to burn the given token.\n    public fun generate_burn_ref(ref: &ConstructorRef): BurnRef {\n        let (inner, self) = if (object::can_generate_delete_ref(ref)) {\n            let delete_ref = object::generate_delete_ref(ref);\n            (option::some(delete_ref), option::none())\n        } else {\n            let addr = object::address_from_constructor_ref(ref);\n            (option::none(), option::some(addr))\n        };\n        BurnRef { self, inner }\n    }\n\n    /// Extracts the tokens address from a BurnRef.\n    public fun address_from_burn_ref(ref: &BurnRef): address {\n        if (option::is_some(&ref.inner)) {\n            object::address_from_delete_ref(option::borrow(&ref.inner))\n        } else {\n            *option::borrow(&ref.self)\n        }\n    }\n\n    // Accessors\n\n    inline fun borrow<T: key>(token: &Object<T>): &Token acquires Token {\n        let token_address = object::object_address(token);\n        assert!(\n            exists<Token>(token_address),\n            error::not_found(ETOKEN_DOES_NOT_EXIST),\n        );\n        borrow_global<Token>(token_address)\n    }\n\n    #[view]\n    public fun creator<T: key>(token: Object<T>): address acquires Token {\n        collection::creator(borrow(&token).collection)\n    }\n\n    #[view]\n    public fun collection_name<T: key>(token: Object<T>): String acquires Token {\n        collection::name(borrow(&token).collection)\n    }\n\n    #[view]\n    public fun collection_object<T: key>(token: Object<T>): Object<Collection> acquires Token {\n        borrow(&token).collection\n    }\n\n    #[view]\n    public fun description<T: key>(token: Object<T>): String acquires Token {\n        borrow(&token).description\n    }\n\n    // To be added if/when needed - i.e. if there is a need to access name of the numbered token\n    // within the transaction that creates it, to set additional application-specific fields.\n    //\n    // /// This method allows minting to happen in parallel, making it efficient.\n    // fun name_snapshot<T: key>(token: &Object<T>): AggregatorSnapshot<String> acquires Token, TokenIdentifiers {\n    //     let token_address = object::object_address(token);\n    //     if (exists<TokenIdentifiers>(token_address)) {\n    //         aggregator_v2::copy_snapshot(&borrow_global<TokenIdentifiers>(token_address).name)\n    //     } else {\n    //         aggregator_v2::create_snapshot(borrow(token).name)\n    //     }\n    // }\n\n    #[view]\n    /// Avoid this method in the same transaction as the token is minted\n    /// as that would prohibit transactions to be executed in parallel.\n    public fun name<T: key>(token: Object<T>): String acquires Token, TokenIdentifiers {\n        let token_address = object::object_address(&token);\n        if (exists<TokenIdentifiers>(token_address)) {\n            aggregator_v2::read_derived_string(&borrow_global<TokenIdentifiers>(token_address).name)\n        } else {\n            borrow(&token).name\n        }\n    }\n\n    #[view]\n    public fun uri<T: key>(token: Object<T>): String acquires Token {\n        borrow(&token).uri\n    }\n\n    #[view]\n    public fun royalty<T: key>(token: Object<T>): Option<Royalty> acquires Token {\n        borrow(&token);\n        let royalty = royalty::get(token);\n        if (option::is_some(&royalty)) {\n            royalty\n        } else {\n            let creator = creator(token);\n            let collection_name = collection_name(token);\n            let collection_address = collection::create_collection_address(&creator, &collection_name);\n            let collection = object::address_to_object<collection::Collection>(collection_address);\n            royalty::get(collection)\n        }\n    }\n\n    // To be added if/when needed - i.e. if there is a need to access index of the token\n    // within the transaction that creates it, to set additional application-specific fields.\n    //\n    // /// This method allows minting to happen in parallel, making it efficient.\n    // fun index_snapshot<T: key>(token: &Object<T>): AggregatorSnapshot<u64> acquires Token, TokenIdentifiers {\n    //     let token_address = object::object_address(token);\n    //     if (exists<TokenIdentifiers>(token_address)) {\n    //         aggregator_v2::copy_snapshot(&borrow_global<TokenIdentifiers>(token_address).index)\n    //     } else {\n    //         aggregator_v2::create_snapshot(borrow(token).index)\n    //     }\n    // }\n\n    #[view]\n    /// Avoid this method in the same transaction as the token is minted\n    /// as that would prohibit transactions to be executed in parallel.\n    public fun index<T: key>(token: Object<T>): u64 acquires Token, TokenIdentifiers {\n        let token_address = object::object_address(&token);\n        if (exists<TokenIdentifiers>(token_address)) {\n            aggregator_v2::read_snapshot(&borrow_global<TokenIdentifiers>(token_address).index)\n        } else {\n            borrow(&token).index\n        }\n    }\n\n    // Mutators\n\n    inline fun borrow_mut(mutator_ref: &MutatorRef): &mut Token acquires Token {\n        assert!(\n            exists<Token>(mutator_ref.self),\n            error::not_found(ETOKEN_DOES_NOT_EXIST),\n        );\n        borrow_global_mut<Token>(mutator_ref.self)\n    }\n\n    public fun burn(burn_ref: BurnRef) acquires Token, TokenIdentifiers {\n        let (addr, previous_owner) = if (option::is_some(&burn_ref.inner)) {\n            let delete_ref = option::extract(&mut burn_ref.inner);\n            let addr = object::address_from_delete_ref(&delete_ref);\n            let previous_owner = object::owner(object::address_to_object<Token>(addr));\n            object::delete(delete_ref);\n            (addr, previous_owner)\n        } else {\n            let addr = option::extract(&mut burn_ref.self);\n            let previous_owner = object::owner(object::address_to_object<Token>(addr));\n            (addr, previous_owner)\n        };\n\n        if (royalty::exists_at(addr)) {\n            royalty::delete(addr)\n        };\n\n        let Token {\n            collection,\n            index: deprecated_index,\n            description: _,\n            name: _,\n            uri: _,\n            mutation_events,\n        } = move_from<Token>(addr);\n\n        let index = if (exists<TokenIdentifiers>(addr)) {\n            let TokenIdentifiers {\n                index,\n                name: _,\n            } = move_from<TokenIdentifiers>(addr);\n            aggregator_v2::read_snapshot(&index)\n        } else {\n            deprecated_index\n        };\n\n        event::destroy_handle(mutation_events);\n        collection::decrement_supply(&collection, addr, option::some(index), previous_owner);\n    }\n\n    public fun set_description(mutator_ref: &MutatorRef, description: String) acquires Token {\n        assert!(string::length(&description) <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));\n        let token = borrow_mut(mutator_ref);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Mutation {\n                token_address: mutator_ref.self,\n                mutated_field_name: string::utf8(b\"description\"),\n                old_value: token.description,\n                new_value: description\n            })\n        };\n        event::emit_event(\n            &mut token.mutation_events,\n            MutationEvent {\n                mutated_field_name: string::utf8(b\"description\"),\n                old_value: token.description,\n                new_value: description\n            },\n        );\n        token.description = description;\n    }\n\n    public fun set_name(mutator_ref: &MutatorRef, name: String) acquires Token, TokenIdentifiers {\n        assert!(string::length(&name) <= MAX_TOKEN_NAME_LENGTH, error::out_of_range(ETOKEN_NAME_TOO_LONG));\n\n        let token = borrow_mut(mutator_ref);\n\n        let old_name = if (exists<TokenIdentifiers>(mutator_ref.self)) {\n            let token_concurrent = borrow_global_mut<TokenIdentifiers>(mutator_ref.self);\n            let old_name = aggregator_v2::read_derived_string(&token_concurrent.name);\n            token_concurrent.name = aggregator_v2::create_derived_string(name);\n            old_name\n        } else {\n            let old_name = token.name;\n            token.name = name;\n            old_name\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Mutation {\n                token_address: mutator_ref.self,\n                mutated_field_name: string::utf8(b\"name\"),\n                old_value: old_name,\n                new_value: name\n            })\n        };\n        event::emit_event(\n            &mut token.mutation_events,\n            MutationEvent {\n                mutated_field_name: string::utf8(b\"name\"),\n                old_value: old_name,\n                new_value: name\n            },\n        );\n    }\n\n    public fun set_uri(mutator_ref: &MutatorRef, uri: String) acquires Token {\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));\n        let token = borrow_mut(mutator_ref);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Mutation {\n                token_address: mutator_ref.self,\n                mutated_field_name: string::utf8(b\"uri\"),\n                old_value: token.uri,\n                new_value: uri,\n            })\n        };\n        event::emit_event(\n            &mut token.mutation_events,\n            MutationEvent {\n                mutated_field_name: string::utf8(b\"uri\"),\n                old_value: token.uri,\n                new_value: uri,\n            },\n        );\n        token.uri = uri;\n    }\n\n    #[test(creator = @0x123, trader = @0x456)]\n    fun test_create_and_transfer(creator: &signer, trader: &signer) acquires Token {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        create_token_helper(creator, collection_name, token_name);\n\n        let creator_address = signer::address_of(creator);\n        let token_addr = create_token_address(&creator_address, &collection_name, &token_name);\n        let token = object::address_to_object<Token>(token_addr);\n        assert!(object::owner(token) == creator_address, 1);\n        object::transfer(creator, token, signer::address_of(trader));\n        assert!(object::owner(token) == signer::address_of(trader), 1);\n\n        let expected_royalty = royalty::create(25, 10000, creator_address);\n        assert!(option::some(expected_royalty) == royalty(token), 2);\n    }\n\n    #[test(creator = @0x123, trader = @0x456)]\n    fun test_create_and_transfer_token_with_seed(creator: &signer, trader: &signer) acquires Token {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        let extend_ref = create_collection_helper(creator, collection_name, 1);\n        let collection = get_collection_from_ref(&extend_ref);\n        let seed = string::utf8(b\"seed\");\n        create_token_object_with_seed_helper(creator, collection, token_name, seed);\n\n        let creator_address = signer::address_of(creator);\n        // Calculate the token address with collection, token name and seed.\n        let token_addr = create_token_address_with_seed(creator_address, collection_name, token_name, seed);\n        let token = object::address_to_object<Token>(token_addr);\n        assert!(object::owner(token) == creator_address, 1);\n        object::transfer(creator, token, signer::address_of(trader));\n        assert!(object::owner(token) == signer::address_of(trader), 1);\n\n        let expected_royalty = royalty::create(25, 10000, creator_address);\n        assert!(option::some(expected_royalty) == royalty(token), 2);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_collection_royalty(creator: &signer) acquires Token {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        let creator_address = signer::address_of(creator);\n        let expected_royalty = royalty::create(10, 1000, creator_address);\n        let constructor_ref = collection::create_fixed_collection(\n            creator,\n            string::utf8(b\"collection description\"),\n            5,\n            collection_name,\n            option::some(expected_royalty),\n            string::utf8(b\"collection uri\"),\n        );\n\n        let collection = object::object_from_constructor_ref<Collection>(&constructor_ref);\n        create_named_token_object(\n            creator,\n            collection,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::none(),\n            string::utf8(b\"token uri\"),\n        );\n\n        let token_addr = create_token_address(&creator_address, &collection_name, &token_name);\n        let token = object::address_to_object<Token>(token_addr);\n        assert!(option::some(expected_royalty) == royalty(token), 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_no_royalty(creator: &signer) acquires Token {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        collection::create_unlimited_collection(\n            creator,\n            string::utf8(b\"collection description\"),\n            collection_name,\n            option::none(),\n            string::utf8(b\"collection uri\"),\n        );\n\n        create_named_token(\n            creator,\n            collection_name,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::none(),\n            string::utf8(b\"token uri\"),\n        );\n\n        let creator_address = signer::address_of(creator);\n        let token_addr = create_token_address(&creator_address, &collection_name, &token_name);\n        let token = object::address_to_object<Token>(token_addr);\n        assert!(option::none() == royalty(token), 0);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x20002, location = aptos_token_objects::collection)]\n    fun test_too_many_tokens(creator: &signer) {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        create_token_helper(creator, collection_name, token_name);\n        create_token_helper(creator, collection_name, string::utf8(b\"bad\"));\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x80001, location = aptos_framework::object)]\n    fun test_duplicate_tokens(creator: &signer) {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 2);\n        create_token_helper(creator, collection_name, token_name);\n        create_token_helper(creator, collection_name, token_name);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_description(creator: &signer) acquires Token {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        let mutator_ref = create_token_with_mutation_ref(creator, collection_name, token_name);\n        let token = object::address_to_object<Token>(\n            create_token_address(&signer::address_of(creator), &collection_name, &token_name),\n        );\n\n        let description = string::utf8(b\"no fail\");\n        assert!(description != description(token), 0);\n        set_description(&mutator_ref, description);\n        assert!(description == description(token), 1);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_name(creator: &signer) acquires Token, TokenIdentifiers {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        let mutator_ref = create_token_with_mutation_ref(creator, collection_name, token_name);\n        let token = object::address_to_object<Token>(\n            create_token_address(&signer::address_of(creator), &collection_name, &token_name),\n        );\n\n        let name = string::utf8(b\"no fail\");\n        assert!(name != name(token), 0);\n        set_name(&mutator_ref, name);\n        assert!(name == name(token), 2);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_set_uri(creator: &signer) acquires Token {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        let mutator_ref = create_token_with_mutation_ref(creator, collection_name, token_name);\n        let token = object::address_to_object<Token>(\n            create_token_address(&signer::address_of(creator), &collection_name, &token_name),\n        );\n\n        let uri = string::utf8(b\"no fail\");\n        assert!(uri != uri(token), 0);\n        set_uri(&mutator_ref, uri);\n        assert!(uri == uri(token), 1);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_burn_without_royalty(creator: &signer) acquires Token, TokenIdentifiers {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        let constructor_ref = create_named_token(\n            creator,\n            collection_name,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::none(),\n            string::utf8(b\"token uri\"),\n        );\n        let burn_ref = generate_burn_ref(&constructor_ref);\n        let token_addr = object::address_from_constructor_ref(&constructor_ref);\n        assert!(exists<Token>(token_addr), 0);\n        assert!(!royalty::exists_at(token_addr), 3);\n        burn(burn_ref);\n        assert!(!exists<Token>(token_addr), 2);\n        assert!(!royalty::exists_at(token_addr), 3);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_burn_with_royalty(creator: &signer) acquires Token, TokenIdentifiers {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        let constructor_ref = create_named_token(\n            creator,\n            collection_name,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::some(royalty::create(1, 1, signer::address_of(creator))),\n            string::utf8(b\"token uri\"),\n        );\n        let burn_ref = generate_burn_ref(&constructor_ref);\n        let token_addr = object::address_from_constructor_ref(&constructor_ref);\n        assert!(exists<Token>(token_addr), 0);\n        assert!(royalty::exists_at(token_addr), 1);\n        burn(burn_ref);\n        assert!(!exists<Token>(token_addr), 2);\n        assert!(!royalty::exists_at(token_addr), 3);\n        assert!(object::is_object(token_addr), 4);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_create_from_account_burn_and_delete(creator: &signer) acquires Token, TokenIdentifiers {\n        use aptos_framework::account;\n\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        create_collection_helper(creator, collection_name, 1);\n        account::create_account_for_test(signer::address_of(creator));\n        let constructor_ref = create_from_account(\n            creator,\n            collection_name,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::none(),\n            string::utf8(b\"token uri\"),\n        );\n        let burn_ref = generate_burn_ref(&constructor_ref);\n        let token_addr = object::address_from_constructor_ref(&constructor_ref);\n        assert!(exists<Token>(token_addr), 0);\n        burn(burn_ref);\n        assert!(!exists<Token>(token_addr), 1);\n        assert!(!object::is_object(token_addr), 2);\n    }\n\n    #[test(creator = @0x123, fx = @std)]\n    fun test_create_burn_and_delete(creator: &signer, fx: signer) acquires Token, TokenIdentifiers {\n        use aptos_framework::account;\n        use std::features;\n\n        let feature = features::get_auids();\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        let extend_ref = create_collection_helper(creator, collection_name, 1);\n        let collection = get_collection_from_ref(&extend_ref);\n        account::create_account_for_test(signer::address_of(creator));\n        let constructor_ref = create_token(\n            creator,\n            collection,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::none(),\n            string::utf8(b\"token uri\"),\n        );\n        let burn_ref = generate_burn_ref(&constructor_ref);\n        let token_addr = object::address_from_constructor_ref(&constructor_ref);\n        assert!(exists<Token>(token_addr), 0);\n        burn(burn_ref);\n        assert!(!exists<Token>(token_addr), 1);\n        assert!(!object::is_object(token_addr), 2);\n    }\n\n    #[test(fx = @aptos_framework, creator = @0x123)]\n    fun test_upgrade_to_concurrent_and_numbered_tokens(fx: &signer, creator: &signer) acquires Token, TokenIdentifiers {\n        use std::debug;\n\n        let feature = features::get_concurrent_token_v2_feature();\n        let agg_feature = features::get_aggregator_v2_api_feature();\n        let auid_feature = features::get_auids();\n        let module_event_feature = features::get_module_event_feature();\n        features::change_feature_flags_for_testing(fx, vector[auid_feature, module_event_feature], vector[feature, agg_feature]);\n\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        let extend_ref = create_collection_helper(creator, collection_name, 2);\n        let collection = get_collection_from_ref(&extend_ref);\n        let token_1_ref = create_numbered_token_helper(creator, collection, token_name);\n        let token_1_name = name(object::object_from_constructor_ref<Token>(&token_1_ref));\n        debug::print(&token_1_name);\n        assert!(token_1_name == std::string::utf8(b\"token name1\"), 1);\n\n        features::change_feature_flags_for_testing(fx, vector[feature, agg_feature], vector[]);\n        collection::upgrade_to_concurrent(&extend_ref);\n\n        let token_2_ref = create_numbered_token_helper(creator, collection, token_name);\n        assert!(name(object::object_from_constructor_ref<Token>(&token_2_ref)) == std::string::utf8(b\"token name2\"), 1);\n        assert!(vector::length(&event::emitted_events<collection::Mint>()) == 2, 0);\n\n        let burn_ref = generate_burn_ref(&token_2_ref);\n        let token_addr = object::address_from_constructor_ref(&token_2_ref);\n        assert!(exists<Token>(token_addr), 0);\n        burn(burn_ref);\n        assert!(vector::length(&event::emitted_events<collection::Burn>()) == 1, 0);\n    }\n\n    #[test(creator = @0x123)]\n    /// This test verifies that once the collection name can be changed, tokens can still be be minted from the collection.\n    fun test_change_collection_name(creator: &signer) {\n        let collection_name = string::utf8(b\"collection name\");\n        let token_name = string::utf8(b\"token name\");\n\n        let constructor_ref = &create_fixed_collection(creator, collection_name, 5);\n        let collection = get_collection_from_ref(&object::generate_extend_ref(constructor_ref));\n        let mutator_ref = collection::generate_mutator_ref(constructor_ref);\n\n        create_token_with_collection_helper(creator, collection, token_name);\n        collection::set_name(&mutator_ref, string::utf8(b\"new collection name\"));\n        create_token_with_collection_helper(creator, collection, token_name);\n\n        assert!(collection::count(collection) == option::some(2), 0);\n    }\n\n    #[test_only]\n    fun create_collection_helper(creator: &signer, collection_name: String, max_supply: u64): ExtendRef {\n        let constructor_ref = create_fixed_collection(creator, collection_name, max_supply);\n        object::generate_extend_ref(&constructor_ref)\n    }\n\n    #[test_only]\n    fun create_fixed_collection(creator: &signer, collection_name: String, max_supply: u64): ConstructorRef {\n        collection::create_fixed_collection(\n            creator,\n            string::utf8(b\"collection description\"),\n            max_supply,\n            collection_name,\n            option::none(),\n            string::utf8(b\"collection uri\"),\n        )\n    }\n\n    #[test_only]\n    fun create_token_helper(creator: &signer, collection_name: String, token_name: String): ConstructorRef {\n        create_named_token(\n            creator,\n            collection_name,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::some(royalty::create(25, 10000, signer::address_of(creator))),\n            string::utf8(b\"uri\"),\n        )\n    }\n\n    #[test_only]\n    fun create_token_with_collection_helper(creator: &signer, collection: Object<Collection>, token_name: String): ConstructorRef {\n        create_named_token_object(\n            creator,\n            collection,\n            string::utf8(b\"token description\"),\n            token_name,\n            option::some(royalty::create(25, 10000, signer::address_of(creator))),\n            string::utf8(b\"uri\"),\n        )\n    }\n\n    #[test_only]\n    fun create_token_object_with_seed_helper(creator: &signer, collection: Object<Collection>, token_name: String, seed: String): ConstructorRef {\n        create_named_token_from_seed(\n            creator,\n            collection,\n            string::utf8(b\"token description\"),\n            token_name,\n            seed,\n            option::some(royalty::create(25, 10000, signer::address_of(creator))),\n            string::utf8(b\"uri\"),\n        )\n    }\n\n    #[test_only]\n    fun create_numbered_token_helper(creator: &signer, collection: Object<Collection>, token_prefix: String): ConstructorRef {\n        create_numbered_token_object(\n            creator,\n            collection,\n            string::utf8(b\"token description\"),\n            token_prefix,\n            string::utf8(b\"\"),\n            option::some(royalty::create(25, 10000, signer::address_of(creator))),\n            string::utf8(b\"uri\"),\n        )\n    }\n\n    #[test_only]\n    fun create_token_with_mutation_ref(\n        creator: &signer,\n        collection_name: String,\n        token_name: String,\n    ): MutatorRef {\n        let constructor_ref = create_token_helper(creator, collection_name, token_name);\n        generate_mutator_ref(&constructor_ref)\n    }\n\n    #[test_only]\n    fun get_collection_from_ref(extend_ref: &ExtendRef): Object<Collection> {\n        let collection_address = signer::address_of(&object::generate_signer_for_extending(extend_ref));\n        object::address_to_object<Collection>(collection_address)\n    }\n}\n","name":"token.move"}]