export default [{"content":"/// PropertyMap is a specialization of SimpleMap for Tokens.\n/// It maps a String key to a PropertyValue that consists of type (string) and value (vector<u8>)\n/// It provides basic on-chain serialization of primitive and string to property value with type information\n/// It also supports deserializing property value to it original type.\nmodule aptos_token::property_map {\n    use std::bcs;\n    use std::vector;\n    use std::error;\n    use std::string::{Self, String};\n    use aptos_std::from_bcs;\n    use aptos_std::simple_map::{Self, SimpleMap};\n    use aptos_std::type_info::type_name;\n\n    //\n    // Constants\n    //\n    /// The maximal number of property that can be stored in property map\n    const MAX_PROPERTY_MAP_SIZE: u64 = 1000;\n    const MAX_PROPERTY_NAME_LENGTH: u64 = 128;\n\n\n    //\n    // Errors.\n    //\n    /// The property key already exists\n    const EKEY_AREADY_EXIST_IN_PROPERTY_MAP: u64 = 1;\n\n    /// The number of property exceeds the limit\n    const EPROPERTY_NUMBER_EXCEED_LIMIT: u64 = 2;\n\n    /// The property doesn't exist\n    const EPROPERTY_NOT_EXIST: u64 = 3;\n\n    /// Property key and value count don't match\n    const EKEY_COUNT_NOT_MATCH_VALUE_COUNT: u64 = 4;\n\n    /// Property key and type count don't match\n    const EKEY_COUNT_NOT_MATCH_TYPE_COUNT: u64 = 5;\n\n    /// Property type doesn't match\n    const ETYPE_NOT_MATCH: u64 = 6;\n\n    /// The name (key) of the property is too long\n    const EPROPERTY_MAP_NAME_TOO_LONG: u64 = 7;\n\n\n    //\n    // Structs\n    //\n\n    struct PropertyMap has copy, drop, store {\n        map: SimpleMap<String, PropertyValue>,\n    }\n\n    struct PropertyValue has store, copy, drop {\n        value: vector<u8>,\n        type: String,\n    }\n\n    public fun new(\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>\n    ): PropertyMap {\n        let length = vector::length(&keys);\n        assert!(length <= MAX_PROPERTY_MAP_SIZE, error::invalid_argument(EPROPERTY_NUMBER_EXCEED_LIMIT));\n        assert!(length == vector::length(&values), error::invalid_argument(EKEY_COUNT_NOT_MATCH_VALUE_COUNT));\n        assert!(length == vector::length(&types), error::invalid_argument(EKEY_COUNT_NOT_MATCH_TYPE_COUNT));\n\n        let properties = empty();\n\n        let i = 0;\n        while (i < length) {\n            let key = *vector::borrow(&keys, i);\n            assert!(string::length(&key) <= MAX_PROPERTY_NAME_LENGTH, error::invalid_argument(EPROPERTY_MAP_NAME_TOO_LONG));\n            simple_map::add(\n                &mut properties.map,\n                key,\n                PropertyValue { value: *vector::borrow(&values, i), type: *vector::borrow(&types, i) }\n            );\n            i = i + 1;\n        };\n        properties\n    }\n\n    /// Create property map directly from key and property value\n    public fun new_with_key_and_property_value(\n        keys: vector<String>,\n        values: vector<PropertyValue>\n    ): PropertyMap {\n        let length = vector::length(&keys);\n        assert!(length <= MAX_PROPERTY_MAP_SIZE, error::invalid_argument(EPROPERTY_NUMBER_EXCEED_LIMIT));\n        assert!(length == vector::length(&values), error::invalid_argument(EKEY_COUNT_NOT_MATCH_VALUE_COUNT));\n\n        let properties = empty();\n\n        let i = 0;\n        while (i < length) {\n            let key = *vector::borrow(&keys, i);\n            let val = *vector::borrow(&values, i);\n            assert!(string::length(&key) <= MAX_PROPERTY_NAME_LENGTH, error::invalid_argument(EPROPERTY_MAP_NAME_TOO_LONG));\n            add(&mut properties, key, val);\n            i = i + 1;\n        };\n        properties\n    }\n\n    public fun empty(): PropertyMap {\n        PropertyMap {\n            map: simple_map::create<String, PropertyValue>(),\n        }\n    }\n\n    public fun contains_key(map: &PropertyMap, key: &String): bool {\n        simple_map::contains_key(&map.map, key)\n    }\n\n    public fun add(map: &mut PropertyMap, key: String, value: PropertyValue) {\n        assert!(string::length(&key) <= MAX_PROPERTY_NAME_LENGTH, error::invalid_argument(EPROPERTY_MAP_NAME_TOO_LONG));\n        assert!(simple_map::length(&map.map) < MAX_PROPERTY_MAP_SIZE, error::invalid_state(EPROPERTY_NUMBER_EXCEED_LIMIT));\n        simple_map::add(&mut map.map, key, value);\n    }\n\n    public fun length(map: &PropertyMap): u64 {\n        simple_map::length(&map.map)\n    }\n\n    public fun borrow(map: &PropertyMap, key: &String): &PropertyValue {\n        let found = contains_key(map, key);\n        assert!(found, EPROPERTY_NOT_EXIST);\n        simple_map::borrow(&map.map, key)\n    }\n\n    /// Return all the keys in the property map in the order they are added.\n    public fun keys(map: &PropertyMap): vector<String> {\n        simple_map::keys(&map.map)\n    }\n\n    /// Return the types of all properties in the property map in the order they are added.\n    public fun types(map: &PropertyMap): vector<String> {\n        vector::map_ref(&simple_map::values(&map.map), |v| {\n            let v: &PropertyValue = v;\n            v.type\n        })\n    }\n\n    /// Return the values of all properties in the property map in the order they are added.\n    public fun values(map: &PropertyMap): vector<vector<u8>> {\n        vector::map_ref(&simple_map::values(&map.map), |v| {\n            let v: &PropertyValue = v;\n            v.value\n        })\n    }\n\n    public fun read_string(map: &PropertyMap, key: &String): String {\n        let prop = borrow(map, key);\n        assert!(prop.type == string::utf8(b\"0x1::string::String\"), error::invalid_state(ETYPE_NOT_MATCH));\n        from_bcs::to_string(prop.value)\n    }\n\n    public fun read_u8(map: &PropertyMap, key: &String): u8 {\n        let prop = borrow(map, key);\n        assert!(prop.type == string::utf8(b\"u8\"), error::invalid_state(ETYPE_NOT_MATCH));\n        from_bcs::to_u8(prop.value)\n    }\n\n    public fun read_u64(map: &PropertyMap, key: &String): u64 {\n        let prop = borrow(map, key);\n        assert!(prop.type == string::utf8(b\"u64\"), error::invalid_state(ETYPE_NOT_MATCH));\n        from_bcs::to_u64(prop.value)\n    }\n\n    public fun read_address(map: &PropertyMap, key: &String): address {\n        let prop = borrow(map, key);\n        assert!(prop.type == string::utf8(b\"address\"), error::invalid_state(ETYPE_NOT_MATCH));\n        from_bcs::to_address(prop.value)\n    }\n\n    public fun read_u128(map: &PropertyMap, key: &String): u128 {\n        let prop = borrow(map, key);\n        assert!(prop.type == string::utf8(b\"u128\"), error::invalid_state(ETYPE_NOT_MATCH));\n        from_bcs::to_u128(prop.value)\n    }\n\n    public fun read_bool(map: &PropertyMap, key: &String): bool {\n        let prop = borrow(map, key);\n        assert!(prop.type == string::utf8(b\"bool\"), error::invalid_state(ETYPE_NOT_MATCH));\n        from_bcs::to_bool(prop.value)\n    }\n\n    public fun borrow_value(property: &PropertyValue): vector<u8> {\n        property.value\n    }\n\n    public fun borrow_type(property: &PropertyValue): String {\n        property.type\n    }\n\n    public fun remove(\n        map: &mut PropertyMap,\n        key: &String\n    ): (String, PropertyValue) {\n        let found = contains_key(map, key);\n        assert!(found, error::not_found(EPROPERTY_NOT_EXIST));\n        simple_map::remove(&mut map.map, key)\n    }\n\n    /// Update the property in the existing property map\n    /// Allow updating existing keys' value and add new key-value pairs\n    public fun update_property_map(\n        map: &mut PropertyMap,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>,\n    ) {\n        let key_len = vector::length(&keys);\n        let val_len = vector::length(&values);\n        let typ_len = vector::length(&types);\n        assert!(key_len == val_len, error::invalid_state(EKEY_COUNT_NOT_MATCH_VALUE_COUNT));\n        assert!(key_len == typ_len, error::invalid_state(EKEY_COUNT_NOT_MATCH_TYPE_COUNT));\n\n        let i = 0;\n        while (i < key_len) {\n            let key = vector::borrow(&keys, i);\n            let prop_val = PropertyValue {\n                value: *vector::borrow(&values, i),\n                type: *vector::borrow(&types, i),\n            };\n            if (contains_key(map, key)) {\n                update_property_value(map, key, prop_val);\n            } else {\n                add(map, *key, prop_val);\n            };\n            i = i + 1;\n        }\n    }\n\n    public fun update_property_value(\n        map: &mut PropertyMap,\n        key: &String,\n        value: PropertyValue\n    ) {\n        let property_val = simple_map::borrow_mut(&mut map.map, key);\n        *property_val = value;\n    }\n\n    public fun create_property_value_raw(\n        value: vector<u8>,\n        type: String\n    ): PropertyValue {\n        PropertyValue {\n            value,\n            type,\n        }\n    }\n\n    /// create a property value from generic type data\n    public fun create_property_value<T: copy>(data: &T): PropertyValue {\n        let name = type_name<T>();\n        if (\n            name == string::utf8(b\"bool\") ||\n                name == string::utf8(b\"u8\") ||\n                name == string::utf8(b\"u64\") ||\n                name == string::utf8(b\"u128\") ||\n                name == string::utf8(b\"address\") ||\n                name == string::utf8(b\"0x1::string::String\")\n        ) {\n            create_property_value_raw(bcs::to_bytes<T>(data), name)\n        } else {\n            create_property_value_raw(bcs::to_bytes<T>(data), string::utf8(b\"vector<u8>\"))\n        }\n    }\n\n    #[test_only]\n    use std::string::utf8;\n\n    #[test_only]\n    fun test_keys(): vector<String> {\n        vector[ utf8(b\"attack\"), utf8(b\"durability\"), utf8(b\"type\") ]\n    }\n\n    #[test_only]\n    fun test_values(): vector<vector<u8>> {\n        vector[ b\"10\", b\"5\", b\"weapon\" ]\n    }\n\n    #[test_only]\n    fun test_types(): vector<String> {\n        vector[ utf8(b\"integer\"), utf8(b\"integer\"), utf8(b\"String\") ]\n    }\n\n    #[test_only]\n    fun create_property_list(): PropertyMap {\n        new(test_keys(), test_values(), test_types())\n    }\n\n    #[test]\n    fun test_add_property(): PropertyMap {\n        let properties = create_property_list();\n        add(\n            &mut properties, utf8(b\"level\"),\n            PropertyValue {\n                value: b\"1\",\n                type: utf8(b\"integer\")\n            });\n        assert!(\n            borrow(&properties, &utf8(b\"level\")).value == b\"1\",\n            EPROPERTY_NOT_EXIST);\n        properties\n    }\n\n    #[test]\n    fun test_get_property_keys() {\n        assert!(keys(&create_property_list()) == test_keys(), 0);\n    }\n\n    #[test]\n    fun test_get_property_types() {\n        assert!(types(&create_property_list()) == test_types(), 0);\n    }\n\n    #[test]\n    fun test_get_property_values() {\n        assert!(values(&create_property_list()) == test_values(), 0);\n    }\n\n    #[test]\n    fun test_update_property(): PropertyMap {\n        let properties = create_property_list();\n        update_property_value(&mut properties, &utf8(b\"attack\"), PropertyValue { value: b\"7\", type: utf8(b\"integer\") });\n        assert!(\n            borrow(&properties, &utf8(b\"attack\")).value == b\"7\",\n            1\n        );\n        properties\n    }\n\n    #[test]\n    fun test_remove_property(): PropertyMap {\n        let properties = create_property_list();\n        assert!(length(&mut properties) == 3, 1);\n        let (_, _) = remove(&mut properties, &utf8(b\"attack\"));\n        assert!(length(&properties) == 2, 1);\n        properties\n    }\n\n    #[test_only]\n    public fun test_create_property_value(type: String, value: vector<u8>): PropertyValue {\n        PropertyValue {\n            type,\n            value\n        }\n    }\n\n    #[test]\n    fun test_read_value_with_type() {\n        let keys = vector<String>[ utf8(b\"attack\"), utf8(b\"mutable\")];\n        let values = vector<vector<u8>>[ bcs::to_bytes<u8>(&10), bcs::to_bytes<bool>(&false) ];\n        let types = vector<String>[ utf8(b\"u8\"), utf8(b\"bool\")];\n        let plist = new(keys, values, types);\n        assert!(!read_bool(&plist, &utf8(b\"mutable\")), 1);\n        assert!(read_u8(&plist, &utf8(b\"attack\")) == 10, 1);\n    }\n\n    #[test]\n    fun test_generate_property_value_convert_back() {\n        let data: address = @0xcafe;\n        let pv = create_property_value(&data);\n        let pm = create_property_list();\n        add(&mut pm, string::utf8(b\"addr\"), pv);\n        assert!(read_address(&pm, &string::utf8(b\"addr\")) == data, 1)\n    }\n\n    #[test]\n    fun test_create_property_map_from_key_value_pairs() {\n        let data1: address = @0xcafe;\n        let data2: bool = false;\n        let pvs = vector<PropertyValue>[create_property_value(&data1), create_property_value(&data2)];\n        let keys = vector<String>[string::utf8(b\"addr\"), string::utf8(b\"flag\")];\n        let pm = new_with_key_and_property_value(keys, pvs);\n        assert!(length(&pm) == 2, 1);\n    }\n}\n","name":"property_map.move"},{"content":"/// This module provides the foundation for Tokens.\n/// Checkout our developer doc on our token standard https://aptos.dev/standards\nmodule aptos_token::token {\n    use std::error;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::string::{Self, String};\n    use std::vector;\n\n    use aptos_framework::account;\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::timestamp;\n    use aptos_std::table::{Self, Table};\n    use aptos_token::property_map::{Self, PropertyMap, PropertyValue};\n    use aptos_token::token_event_store;\n\n    //\n    // Constants\n    //\n\n    const TOKEN_MAX_MUTABLE_IND: u64 = 0;\n    const TOKEN_URI_MUTABLE_IND: u64 = 1;\n    const TOKEN_ROYALTY_MUTABLE_IND: u64 = 2;\n    const TOKEN_DESCRIPTION_MUTABLE_IND: u64 = 3;\n    const TOKEN_PROPERTY_MUTABLE_IND: u64 = 4;\n    const TOKEN_PROPERTY_VALUE_MUTABLE_IND: u64 = 5;\n\n    const COLLECTION_DESCRIPTION_MUTABLE_IND: u64 = 0;\n    const COLLECTION_URI_MUTABLE_IND: u64 = 1;\n    const COLLECTION_MAX_MUTABLE_IND: u64 = 2;\n\n    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;\n    const MAX_NFT_NAME_LENGTH: u64 = 128;\n    const MAX_URI_LENGTH: u64 = 512;\n\n    // Property key stored in default_properties controlling who can burn the token.\n    // the corresponding property value is BCS serialized bool.\n    const BURNABLE_BY_CREATOR: vector<u8> = b\"TOKEN_BURNABLE_BY_CREATOR\";\n    const BURNABLE_BY_OWNER: vector<u8> = b\"TOKEN_BURNABLE_BY_OWNER\";\n    const TOKEN_PROPERTY_MUTABLE: vector<u8> = b\"TOKEN_PROPERTY_MUTATBLE\";\n\n    //\n    // Errors\n    //\n    /// The token has balance and cannot be initialized\n    const EALREADY_HAS_BALANCE: u64 = 0;\n\n    /// There isn't any collection under this account\n    const ECOLLECTIONS_NOT_PUBLISHED: u64 = 1;\n\n    /// Cannot find collection in creator's account\n    const ECOLLECTION_NOT_PUBLISHED: u64 = 2;\n\n    /// The collection already exists\n    const ECOLLECTION_ALREADY_EXISTS: u64 = 3;\n\n    /// Exceeds the collection's maximal number of token_data\n    const ECREATE_WOULD_EXCEED_COLLECTION_MAXIMUM: u64 = 4;\n\n    /// Insufficient token balance\n    const EINSUFFICIENT_BALANCE: u64 = 5;\n\n    /// Cannot merge the two tokens with different token id\n    const EINVALID_TOKEN_MERGE: u64 = 6;\n\n    /// Exceed the token data maximal allowed\n    const EMINT_WOULD_EXCEED_TOKEN_MAXIMUM: u64 = 7;\n\n    /// No burn capability\n    const ENO_BURN_CAPABILITY: u64 = 8;\n\n    /// TokenData already exists\n    const ETOKEN_DATA_ALREADY_EXISTS: u64 = 9;\n\n    /// TokenData not published\n    const ETOKEN_DATA_NOT_PUBLISHED: u64 = 10;\n\n    /// TokenStore doesn't exist\n    const ETOKEN_STORE_NOT_PUBLISHED: u64 = 11;\n\n    /// Cannot split token to an amount larger than its amount\n    const ETOKEN_SPLIT_AMOUNT_LARGER_OR_EQUAL_TO_TOKEN_AMOUNT: u64 = 12;\n\n    /// The field is not mutable\n    const EFIELD_NOT_MUTABLE: u64 = 13;\n\n    /// Not authorized to mutate\n    const ENO_MUTATE_CAPABILITY: u64 = 14;\n\n    /// Token not in the token store\n    const ENO_TOKEN_IN_TOKEN_STORE: u64 = 15;\n\n    /// User didn't opt-in direct transfer\n    const EUSER_NOT_OPT_IN_DIRECT_TRANSFER: u64 = 16;\n\n    /// Cannot withdraw 0 token\n    const EWITHDRAW_ZERO: u64 = 17;\n\n    /// Cannot split a token that only has 1 amount\n    const ENFT_NOT_SPLITABLE: u64 = 18;\n\n    /// No mint capability\n    const ENO_MINT_CAPABILITY: u64 = 19;\n\n    /// The collection name is too long\n    const ECOLLECTION_NAME_TOO_LONG: u64 = 25;\n\n    /// The NFT name is too long\n    const ENFT_NAME_TOO_LONG: u64 = 26;\n\n    /// The URI is too long\n    const EURI_TOO_LONG: u64 = 27;\n\n    /// Cannot deposit a Token with 0 amount\n    const ENO_DEPOSIT_TOKEN_WITH_ZERO_AMOUNT: u64 = 28;\n\n    /// Cannot burn 0 Token\n    const ENO_BURN_TOKEN_WITH_ZERO_AMOUNT: u64 = 29;\n\n    /// Token is not burnable by owner\n    const EOWNER_CANNOT_BURN_TOKEN: u64 = 30;\n\n    /// Token is not burnable by creator\n    const ECREATOR_CANNOT_BURN_TOKEN: u64 = 31;\n\n    /// Reserved fields for token contract\n    /// Cannot be updated by user\n    const ECANNOT_UPDATE_RESERVED_PROPERTY: u64 = 32;\n\n    /// TOKEN with 0 amount is not allowed\n    const ETOKEN_CANNOT_HAVE_ZERO_AMOUNT: u64 = 33;\n\n    /// Royalty invalid if the numerator is larger than the denominator\n    const EINVALID_ROYALTY_NUMERATOR_DENOMINATOR: u64 = 34;\n\n    /// Royalty payee account does not exist\n    const EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST: u64 = 35;\n\n    /// Collection or tokendata maximum must be larger than supply\n    const EINVALID_MAXIMUM: u64 = 36;\n\n    /// Token Properties count doesn't match\n    const ETOKEN_PROPERTIES_COUNT_NOT_MATCH: u64 = 37;\n\n\n    /// Withdraw capability doesn't have sufficient amount\n    const EINSUFFICIENT_WITHDRAW_CAPABILITY_AMOUNT: u64 = 38;\n\n    /// Withdraw proof expires\n    const EWITHDRAW_PROOF_EXPIRES: u64 = 39;\n\n    /// The property is reserved by token standard\n    const EPROPERTY_RESERVED_BY_STANDARD: u64 = 40;\n\n    //\n    // Core data structures for holding tokens\n    //\n    struct Token has store {\n        id: TokenId,\n        /// the amount of tokens. Only property_version = 0 can have a value bigger than 1.\n        amount: u64,\n        /// The properties with this token.\n        /// when property_version = 0, the token_properties are the same as default_properties in TokenData, we don't store it.\n        /// when the property_map mutates, a new property_version is assigned to the token.\n        token_properties: PropertyMap,\n    }\n\n    /// global unique identifier of a token\n    struct TokenId has store, copy, drop {\n        /// the id to the common token data shared by token with different property_version\n        token_data_id: TokenDataId,\n        /// The version of the property map; when a fungible token is mutated, a new property version is created and assigned to the token to make it an NFT\n        property_version: u64,\n    }\n\n    /// globally unique identifier of tokendata\n    struct TokenDataId has copy, drop, store {\n        /// The address of the creator, eg: 0xcafe\n        creator: address,\n        /// The name of collection; this is unique under the same account, eg: \"Aptos Animal Collection\"\n        collection: String,\n        /// The name of the token; this is the same as the name field of TokenData\n        name: String,\n    }\n\n    /// The shared TokenData by tokens with different property_version\n    struct TokenData has store {\n        /// The maximal number of tokens that can be minted under this TokenData; if the maximum is 0, there is no limit\n        maximum: u64,\n        /// The current largest property version of all tokens with this TokenData\n        largest_property_version: u64,\n        /// The number of tokens with this TokenData. Supply is only tracked for the limited token whose maximum is not 0\n        supply: u64,\n        /// The Uniform Resource Identifier (uri) pointing to the JSON file stored in off-chain storage; the URL length should be less than 512 characters, eg: https://arweave.net/Fmmn4ul-7Mv6vzm7JwE69O-I-vd6Bz2QriJO1niwCh4\n        uri: String,\n        /// The denominator and numerator for calculating the royalty fee; it also contains payee account address for depositing the Royalty\n        royalty: Royalty,\n        /// The name of the token, which should be unique within the collection; the length of name should be smaller than 128, characters, eg: \"Aptos Animal #1234\"\n        name: String,\n        /// Describes this Token\n        description: String,\n        /// The properties are stored in the TokenData that are shared by all tokens\n        default_properties: PropertyMap,\n        /// Control the TokenData field mutability\n        mutability_config: TokenMutabilityConfig,\n    }\n\n    /// The royalty of a token\n    struct Royalty has copy, drop, store {\n        royalty_points_numerator: u64,\n        royalty_points_denominator: u64,\n        /// if the token is jointly owned by multiple creators, the group of creators should create a shared account.\n        /// the payee_address will be the shared account address.\n        payee_address: address,\n    }\n\n    /// This config specifies which fields in the TokenData are mutable\n    struct TokenMutabilityConfig has copy, store, drop {\n        /// control if the token maximum is mutable\n        maximum: bool,\n        /// control if the token uri is mutable\n        uri: bool,\n        /// control if the token royalty is mutable\n        royalty: bool,\n        /// control if the token description is mutable\n        description: bool,\n        /// control if the property map is mutable\n        properties: bool,\n    }\n\n    /// Represents token resources owned by token owner\n    struct TokenStore has key {\n        /// the tokens owned by a token owner\n        tokens: Table<TokenId, Token>,\n        direct_transfer: bool,\n        deposit_events: EventHandle<DepositEvent>,\n        withdraw_events: EventHandle<WithdrawEvent>,\n        burn_events: EventHandle<BurnTokenEvent>,\n        mutate_token_property_events: EventHandle<MutateTokenPropertyMapEvent>,\n    }\n\n    /// This config specifies which fields in the Collection are mutable\n    struct CollectionMutabilityConfig has copy, store, drop {\n        /// control if description is mutable\n        description: bool,\n        /// control if uri is mutable\n        uri: bool,\n        /// control if collection maxium is mutable\n        maximum: bool,\n    }\n\n    /// Represent collection and token metadata for a creator\n    struct Collections has key {\n        collection_data: Table<String, CollectionData>,\n        token_data: Table<TokenDataId, TokenData>,\n        create_collection_events: EventHandle<CreateCollectionEvent>,\n        create_token_data_events: EventHandle<CreateTokenDataEvent>,\n        mint_token_events: EventHandle<MintTokenEvent>,\n    }\n\n    /// Represent the collection metadata\n    struct CollectionData has store {\n        /// A description for the token collection Eg: \"Aptos Toad Overload\"\n        description: String,\n        /// The collection name, which should be unique among all collections by the creator; the name should also be smaller than 128 characters, eg: \"Animal Collection\"\n        name: String,\n        /// The URI for the collection; its length should be smaller than 512 characters\n        uri: String,\n        /// The number of different TokenData entries in this collection\n        supply: u64,\n        /// If maximal is a non-zero value, the number of created TokenData entries should be smaller or equal to this maximum\n        /// If maximal is 0, Aptos doesn't track the supply of this collection, and there is no limit\n        maximum: u64,\n        /// control which collectionData field is mutable\n        mutability_config: CollectionMutabilityConfig,\n    }\n\n    /// capability to withdraw without signer, this struct should be non-copyable\n    struct WithdrawCapability has drop, store {\n        token_owner: address,\n        token_id: TokenId,\n        amount: u64,\n        expiration_sec: u64,\n    }\n\n    /// Set of data sent to the event stream during a receive\n    struct DepositEvent has drop, store {\n        id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    /// Set of data sent to the event stream during a receive\n    struct Deposit has drop, store {\n        id: TokenId,\n        amount: u64,\n    }\n\n    /// Set of data sent to the event stream during a withdrawal\n    struct WithdrawEvent has drop, store {\n        id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    /// Set of data sent to the event stream during a withdrawal\n    struct Withdraw has drop, store {\n        id: TokenId,\n        amount: u64,\n    }\n\n    /// token creation event id of token created\n    struct CreateTokenDataEvent has drop, store {\n        id: TokenDataId,\n        description: String,\n        maximum: u64,\n        uri: String,\n        royalty_payee_address: address,\n        royalty_points_denominator: u64,\n        royalty_points_numerator: u64,\n        name: String,\n        mutability_config: TokenMutabilityConfig,\n        property_keys: vector<String>,\n        property_values: vector<vector<u8>>,\n        property_types: vector<String>,\n    }\n\n    #[event]\n    struct CreateTokenData has drop, store {\n        id: TokenDataId,\n        description: String,\n        maximum: u64,\n        uri: String,\n        royalty_payee_address: address,\n        royalty_points_denominator: u64,\n        royalty_points_numerator: u64,\n        name: String,\n        mutability_config: TokenMutabilityConfig,\n        property_keys: vector<String>,\n        property_values: vector<vector<u8>>,\n        property_types: vector<String>,\n    }\n\n    /// mint token event. This event triggered when creator adds more supply to existing token\n    struct MintTokenEvent has drop, store {\n        id: TokenDataId,\n        amount: u64,\n    }\n\n    #[event]\n    struct MintToken has drop, store {\n        id: TokenDataId,\n        amount: u64,\n    }\n\n    ///\n    struct BurnTokenEvent has drop, store {\n        id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    struct BurnToken has drop, store {\n        id: TokenId,\n        amount: u64,\n    }\n\n    ///\n    struct MutateTokenPropertyMapEvent has drop, store {\n        old_id: TokenId,\n        new_id: TokenId,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>,\n    }\n\n    #[event]\n    struct MutateTokenPropertyMap has drop, store {\n        old_id: TokenId,\n        new_id: TokenId,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>,\n    }\n\n    /// create collection event with creator address and collection name\n    struct CreateCollectionEvent has drop, store {\n        creator: address,\n        collection_name: String,\n        uri: String,\n        description: String,\n        maximum: u64,\n    }\n\n    #[event]\n    struct CreateCollection has drop, store {\n        creator: address,\n        collection_name: String,\n        uri: String,\n        description: String,\n        maximum: u64,\n    }\n\n    //\n    // Creator Entry functions\n    //\n\n    /// create a empty token collection with parameters\n    public entry fun create_collection_script(\n        creator: &signer,\n        name: String,\n        description: String,\n        uri: String,\n        maximum: u64,\n        mutate_setting: vector<bool>,\n    ) acquires Collections {\n        create_collection(\n            creator,\n            name,\n            description,\n            uri,\n            maximum,\n            mutate_setting\n        );\n    }\n\n    /// create token with raw inputs\n    public entry fun create_token_script(\n        account: &signer,\n        collection: String,\n        name: String,\n        description: String,\n        balance: u64,\n        maximum: u64,\n        uri: String,\n        royalty_payee_address: address,\n        royalty_points_denominator: u64,\n        royalty_points_numerator: u64,\n        mutate_setting: vector<bool>,\n        property_keys: vector<String>,\n        property_values: vector<vector<u8>>,\n        property_types: vector<String>\n    ) acquires Collections, TokenStore {\n        let token_mut_config = create_token_mutability_config(&mutate_setting);\n        let tokendata_id = create_tokendata(\n            account,\n            collection,\n            name,\n            description,\n            maximum,\n            uri,\n            royalty_payee_address,\n            royalty_points_denominator,\n            royalty_points_numerator,\n            token_mut_config,\n            property_keys,\n            property_values,\n            property_types\n        );\n\n        mint_token(\n            account,\n            tokendata_id,\n            balance,\n        );\n    }\n\n    /// Mint more token from an existing token_data. Mint only adds more token to property_version 0\n    public entry fun mint_script(\n        account: &signer,\n        token_data_address: address,\n        collection: String,\n        name: String,\n        amount: u64,\n    ) acquires Collections, TokenStore {\n        let token_data_id = create_token_data_id(\n            token_data_address,\n            collection,\n            name,\n        );\n        // only creator of the tokendata can mint more tokens for now\n        assert!(token_data_id.creator == signer::address_of(account), error::permission_denied(ENO_MINT_CAPABILITY));\n        mint_token(\n            account,\n            token_data_id,\n            amount,\n        );\n    }\n\n    /// mutate the token property and save the new property in TokenStore\n    /// if the token property_version is 0, we will create a new property_version per token to generate a new token_id per token\n    /// if the token property_version is not 0, we will just update the propertyMap and use the existing token_id (property_version)\n    public entry fun mutate_token_properties(\n        account: &signer,\n        token_owner: address,\n        creator: address,\n        collection_name: String,\n        token_name: String,\n        token_property_version: u64,\n        amount: u64,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>,\n    ) acquires Collections, TokenStore {\n        assert!(signer::address_of(account) == creator, error::not_found(ENO_MUTATE_CAPABILITY));\n        let i = 0;\n        let token_id = create_token_id_raw(\n            creator,\n            collection_name,\n            token_name,\n            token_property_version,\n        );\n        // give a new property_version for each token\n        while (i < amount) {\n            mutate_one_token(account, token_owner, token_id, keys, values, types);\n            i = i + 1;\n        };\n    }\n\n    //\n    // Transaction Entry functions\n    //\n\n    public entry fun direct_transfer_script(\n        sender: &signer,\n        receiver: &signer,\n        creators_address: address,\n        collection: String,\n        name: String,\n        property_version: u64,\n        amount: u64,\n    ) acquires TokenStore {\n        let token_id = create_token_id_raw(creators_address, collection, name, property_version);\n        direct_transfer(sender, receiver, token_id, amount);\n    }\n\n    public entry fun opt_in_direct_transfer(account: &signer, opt_in: bool) acquires TokenStore {\n        let addr = signer::address_of(account);\n        initialize_token_store(account);\n        let opt_in_flag = &mut borrow_global_mut<TokenStore>(addr).direct_transfer;\n        *opt_in_flag = opt_in;\n        token_event_store::emit_token_opt_in_event(account, opt_in);\n    }\n\n    /// Transfers `amount` of tokens from `from` to `to`.\n    /// The receiver `to` has to opt-in direct transfer first\n    public entry fun transfer_with_opt_in(\n        from: &signer,\n        creator: address,\n        collection_name: String,\n        token_name: String,\n        token_property_version: u64,\n        to: address,\n        amount: u64,\n    ) acquires TokenStore {\n        let token_id = create_token_id_raw(creator, collection_name, token_name, token_property_version);\n        transfer(from, token_id, to, amount);\n    }\n\n    /// Burn a token by creator when the token's BURNABLE_BY_CREATOR is true\n    /// The token is owned at address owner\n    public entry fun burn_by_creator(\n        creator: &signer,\n        owner: address,\n        collection: String,\n        name: String,\n        property_version: u64,\n        amount: u64,\n    ) acquires Collections, TokenStore {\n        let creator_address = signer::address_of(creator);\n        assert!(amount > 0, error::invalid_argument(ENO_BURN_TOKEN_WITH_ZERO_AMOUNT));\n        let token_id = create_token_id_raw(creator_address, collection, name, property_version);\n        let creator_addr = token_id.token_data_id.creator;\n        assert!(\n            exists<Collections>(creator_addr),\n            error::not_found(ECOLLECTIONS_NOT_PUBLISHED),\n        );\n\n        let collections = borrow_global_mut<Collections>(creator_address);\n        assert!(\n            table::contains(&collections.token_data, token_id.token_data_id),\n            error::not_found(ETOKEN_DATA_NOT_PUBLISHED),\n        );\n\n        let token_data = table::borrow_mut(\n            &mut collections.token_data,\n            token_id.token_data_id,\n        );\n\n        // The property should be explicitly set in the property_map for creator to burn the token\n        assert!(\n            property_map::contains_key(&token_data.default_properties, &string::utf8(BURNABLE_BY_CREATOR)),\n            error::permission_denied(ECREATOR_CANNOT_BURN_TOKEN)\n        );\n\n        let burn_by_creator_flag = property_map::read_bool(&token_data.default_properties, &string::utf8(BURNABLE_BY_CREATOR));\n        assert!(burn_by_creator_flag, error::permission_denied(ECREATOR_CANNOT_BURN_TOKEN));\n\n        // Burn the tokens.\n        let Token { id: _, amount: burned_amount, token_properties: _ } = withdraw_with_event_internal(owner, token_id, amount);\n        let token_store = borrow_global_mut<TokenStore>(owner);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(BurnToken { id: token_id, amount: burned_amount });\n        };\n        event::emit_event<BurnTokenEvent>(\n            &mut token_store.burn_events,\n            BurnTokenEvent { id: token_id, amount: burned_amount }\n        );\n\n        if (token_data.maximum > 0) {\n            token_data.supply = token_data.supply - burned_amount;\n\n            // Delete the token_data if supply drops to 0.\n            if (token_data.supply == 0) {\n                destroy_token_data(table::remove(&mut collections.token_data, token_id.token_data_id));\n\n                // update the collection supply\n                let collection_data = table::borrow_mut(\n                    &mut collections.collection_data,\n                    token_id.token_data_id.collection\n                );\n                if (collection_data.maximum > 0) {\n                    collection_data.supply = collection_data.supply - 1;\n                    // delete the collection data if the collection supply equals 0\n                    if (collection_data.supply == 0) {\n                        destroy_collection_data(table::remove(&mut collections.collection_data, collection_data.name));\n                    };\n                };\n            };\n        };\n    }\n\n    /// Burn a token by the token owner\n    public entry fun burn(\n        owner: &signer,\n        creators_address: address,\n        collection: String,\n        name: String,\n        property_version: u64,\n        amount: u64\n    ) acquires Collections, TokenStore {\n        assert!(amount > 0, error::invalid_argument(ENO_BURN_TOKEN_WITH_ZERO_AMOUNT));\n        let token_id = create_token_id_raw(creators_address, collection, name, property_version);\n        let creator_addr = token_id.token_data_id.creator;\n        assert!(\n            exists<Collections>(creator_addr),\n            error::not_found(ECOLLECTIONS_NOT_PUBLISHED),\n        );\n\n        let collections = borrow_global_mut<Collections>(creator_addr);\n        assert!(\n            table::contains(&collections.token_data, token_id.token_data_id),\n            error::not_found(ETOKEN_DATA_NOT_PUBLISHED),\n        );\n\n        let token_data = table::borrow_mut(\n            &mut collections.token_data,\n            token_id.token_data_id,\n        );\n\n        assert!(\n            property_map::contains_key(&token_data.default_properties, &string::utf8(BURNABLE_BY_OWNER)),\n            error::permission_denied(EOWNER_CANNOT_BURN_TOKEN)\n        );\n        let burn_by_owner_flag = property_map::read_bool(&token_data.default_properties, &string::utf8(BURNABLE_BY_OWNER));\n        assert!(burn_by_owner_flag, error::permission_denied(EOWNER_CANNOT_BURN_TOKEN));\n\n        // Burn the tokens.\n        let Token { id: _, amount: burned_amount, token_properties: _ } = withdraw_token(owner, token_id, amount);\n        let token_store = borrow_global_mut<TokenStore>(signer::address_of(owner));\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(BurnToken { id: token_id, amount: burned_amount });\n        };\n        event::emit_event<BurnTokenEvent>(\n            &mut token_store.burn_events,\n            BurnTokenEvent { id: token_id, amount: burned_amount }\n        );\n\n        // Decrease the supply correspondingly by the amount of tokens burned.\n        let token_data = table::borrow_mut(\n            &mut collections.token_data,\n            token_id.token_data_id,\n        );\n\n        // only update the supply if we tracking the supply and maximal\n        // maximal == 0 is reserved for unlimited token and collection with no tracking info.\n        if (token_data.maximum > 0) {\n            token_data.supply = token_data.supply - burned_amount;\n\n            // Delete the token_data if supply drops to 0.\n            if (token_data.supply == 0) {\n                destroy_token_data(table::remove(&mut collections.token_data, token_id.token_data_id));\n\n                // update the collection supply\n                let collection_data = table::borrow_mut(\n                    &mut collections.collection_data,\n                    token_id.token_data_id.collection\n                );\n\n                // only update and check the supply for unlimited collection\n                if (collection_data.maximum > 0){\n                    collection_data.supply = collection_data.supply - 1;\n                    // delete the collection data if the collection supply equals 0\n                    if (collection_data.supply == 0) {\n                        destroy_collection_data(table::remove(&mut collections.collection_data, collection_data.name));\n                    };\n                };\n            };\n        };\n    }\n\n    //\n    // Public functions for creating and maintaining tokens\n    //\n\n    // Functions for mutating CollectionData fields\n    public fun mutate_collection_description(creator: &signer, collection_name: String, description: String) acquires Collections {\n        let creator_address = signer::address_of(creator);\n        assert_collection_exists(creator_address, collection_name);\n        let collection_data = table::borrow_mut(&mut borrow_global_mut<Collections>(creator_address).collection_data, collection_name);\n        assert!(collection_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));\n        token_event_store::emit_collection_description_mutate_event(creator, collection_name, collection_data.description, description);\n        collection_data.description = description;\n    }\n\n    public fun mutate_collection_uri(creator: &signer, collection_name: String, uri: String) acquires Collections {\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));\n        let creator_address = signer::address_of(creator);\n        assert_collection_exists(creator_address, collection_name);\n        let collection_data = table::borrow_mut(&mut borrow_global_mut<Collections>(creator_address).collection_data, collection_name);\n        assert!(collection_data.mutability_config.uri, error::permission_denied(EFIELD_NOT_MUTABLE));\n        token_event_store::emit_collection_uri_mutate_event(creator, collection_name, collection_data.uri , uri);\n        collection_data.uri = uri;\n    }\n\n    public fun mutate_collection_maximum(creator: &signer, collection_name: String, maximum: u64) acquires Collections {\n        let creator_address = signer::address_of(creator);\n        assert_collection_exists(creator_address, collection_name);\n        let collection_data = table::borrow_mut(&mut borrow_global_mut<Collections>(creator_address).collection_data, collection_name);\n        // cannot change maximum from 0 and cannot change maximum to 0\n        assert!(collection_data.maximum != 0 && maximum != 0, error::invalid_argument(EINVALID_MAXIMUM));\n        assert!(maximum >= collection_data.supply, error::invalid_argument(EINVALID_MAXIMUM));\n        assert!(collection_data.mutability_config.maximum, error::permission_denied(EFIELD_NOT_MUTABLE));\n        token_event_store::emit_collection_maximum_mutate_event(creator, collection_name, collection_data.maximum, maximum);\n        collection_data.maximum = maximum;\n    }\n\n    // Functions for mutating TokenData fields\n    public fun mutate_tokendata_maximum(creator: &signer, token_data_id: TokenDataId, maximum: u64) acquires Collections {\n        assert_tokendata_exists(creator, token_data_id);\n        let all_token_data = &mut borrow_global_mut<Collections>(token_data_id.creator).token_data;\n        let token_data = table::borrow_mut(all_token_data, token_data_id);\n        // cannot change maximum from 0 and cannot change maximum to 0\n        assert!(token_data.maximum != 0 && maximum != 0, error::invalid_argument(EINVALID_MAXIMUM));\n        assert!(maximum >= token_data.supply, error::invalid_argument(EINVALID_MAXIMUM));\n        assert!(token_data.mutability_config.maximum, error::permission_denied(EFIELD_NOT_MUTABLE));\n        token_event_store::emit_token_maximum_mutate_event(creator, token_data_id.collection, token_data_id.name, token_data.maximum, maximum);\n        token_data.maximum = maximum;\n    }\n\n    public fun mutate_tokendata_uri(\n        creator: &signer,\n        token_data_id: TokenDataId,\n        uri: String\n    ) acquires Collections {\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));\n        assert_tokendata_exists(creator, token_data_id);\n\n        let all_token_data = &mut borrow_global_mut<Collections>(token_data_id.creator).token_data;\n        let token_data = table::borrow_mut(all_token_data, token_data_id);\n        assert!(token_data.mutability_config.uri, error::permission_denied(EFIELD_NOT_MUTABLE));\n        token_event_store::emit_token_uri_mutate_event(creator, token_data_id.collection, token_data_id.name, token_data.uri ,uri);\n        token_data.uri = uri;\n    }\n\n    public fun mutate_tokendata_royalty(creator: &signer, token_data_id: TokenDataId, royalty: Royalty) acquires Collections {\n        assert_tokendata_exists(creator, token_data_id);\n\n        let all_token_data = &mut borrow_global_mut<Collections>(token_data_id.creator).token_data;\n        let token_data = table::borrow_mut(all_token_data, token_data_id);\n        assert!(token_data.mutability_config.royalty, error::permission_denied(EFIELD_NOT_MUTABLE));\n\n        token_event_store::emit_token_royalty_mutate_event(\n            creator,\n            token_data_id.collection,\n            token_data_id.name,\n            token_data.royalty.royalty_points_numerator,\n            token_data.royalty.royalty_points_denominator,\n            token_data.royalty.payee_address,\n            royalty.royalty_points_numerator,\n            royalty.royalty_points_denominator,\n            royalty.payee_address\n        );\n        token_data.royalty = royalty;\n    }\n\n    public fun mutate_tokendata_description(creator: &signer, token_data_id: TokenDataId, description: String) acquires Collections {\n        assert_tokendata_exists(creator, token_data_id);\n\n        let all_token_data = &mut borrow_global_mut<Collections>(token_data_id.creator).token_data;\n        let token_data = table::borrow_mut(all_token_data, token_data_id);\n        assert!(token_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));\n        token_event_store::emit_token_descrition_mutate_event(creator, token_data_id.collection, token_data_id.name, token_data.description, description);\n        token_data.description = description;\n    }\n\n    /// Allow creator to mutate the default properties in TokenData\n    public fun mutate_tokendata_property(\n        creator: &signer,\n        token_data_id: TokenDataId,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>,\n    ) acquires Collections {\n        assert_tokendata_exists(creator, token_data_id);\n        let key_len = vector::length(&keys);\n        let val_len = vector::length(&values);\n        let typ_len = vector::length(&types);\n        assert!(key_len == val_len, error::invalid_state(ETOKEN_PROPERTIES_COUNT_NOT_MATCH));\n        assert!(key_len == typ_len, error::invalid_state(ETOKEN_PROPERTIES_COUNT_NOT_MATCH));\n\n        let all_token_data = &mut borrow_global_mut<Collections>(token_data_id.creator).token_data;\n        let token_data = table::borrow_mut(all_token_data, token_data_id);\n        assert!(token_data.mutability_config.properties, error::permission_denied(EFIELD_NOT_MUTABLE));\n        let i: u64 = 0;\n        let old_values: vector<Option<PropertyValue>> = vector::empty();\n        let new_values: vector<PropertyValue> = vector::empty();\n        assert_non_standard_reserved_property(&keys);\n        while (i < vector::length(&keys)){\n            let key = vector::borrow(&keys, i);\n            let old_pv = if (property_map::contains_key(&token_data.default_properties, key)) {\n                option::some(*property_map::borrow(&token_data.default_properties, key))\n            } else {\n                option::none<PropertyValue>()\n            };\n            vector::push_back(&mut old_values, old_pv);\n            let new_pv = property_map::create_property_value_raw(*vector::borrow(&values, i), *vector::borrow(&types, i));\n            vector::push_back(&mut new_values, new_pv);\n            if (option::is_some(&old_pv)) {\n                property_map::update_property_value(&mut token_data.default_properties, key, new_pv);\n            } else {\n                property_map::add(&mut token_data.default_properties, *key, new_pv);\n            };\n            i = i + 1;\n        };\n        token_event_store::emit_default_property_mutate_event(creator, token_data_id.collection, token_data_id.name, keys, old_values, new_values);\n    }\n\n    /// Mutate the token_properties of one token.\n    public fun mutate_one_token(\n        account: &signer,\n        token_owner: address,\n        token_id: TokenId,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>,\n    ): TokenId acquires Collections, TokenStore {\n        let creator = token_id.token_data_id.creator;\n        assert!(signer::address_of(account) == creator, error::permission_denied(ENO_MUTATE_CAPABILITY));\n        // validate if the properties is mutable\n        assert!(exists<Collections>(creator), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &mut borrow_global_mut<Collections>(\n            creator\n        ).token_data;\n\n        assert!(table::contains(all_token_data, token_id.token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n        let token_data = table::borrow_mut(all_token_data, token_id.token_data_id);\n\n        // if default property is mutatable, token property is alwasy mutable\n        // we only need to check TOKEN_PROPERTY_MUTABLE when default property is immutable\n        if (!token_data.mutability_config.properties) {\n            assert!(\n                property_map::contains_key(&token_data.default_properties, &string::utf8(TOKEN_PROPERTY_MUTABLE)),\n                error::permission_denied(EFIELD_NOT_MUTABLE)\n            );\n\n            let token_prop_mutable = property_map::read_bool(&token_data.default_properties, &string::utf8(TOKEN_PROPERTY_MUTABLE));\n            assert!(token_prop_mutable, error::permission_denied(EFIELD_NOT_MUTABLE));\n        };\n\n        // check if the property_version is 0 to determine if we need to update the property_version\n        if (token_id.property_version == 0) {\n            let token = withdraw_with_event_internal(token_owner, token_id, 1);\n            // give a new property_version for each token\n            let cur_property_version = token_data.largest_property_version + 1;\n            let new_token_id = create_token_id(token_id.token_data_id, cur_property_version);\n            let new_token = Token {\n                id: new_token_id,\n                amount: 1,\n                token_properties: token_data.default_properties,\n            };\n            direct_deposit(token_owner, new_token);\n            update_token_property_internal(token_owner, new_token_id, keys, values, types);\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(MutateTokenPropertyMap {\n                    old_id: token_id,\n                    new_id: new_token_id,\n                    keys,\n                    values,\n                    types\n                });\n            };\n            event::emit_event<MutateTokenPropertyMapEvent>(\n                &mut borrow_global_mut<TokenStore>(token_owner).mutate_token_property_events,\n                MutateTokenPropertyMapEvent {\n                    old_id: token_id,\n                    new_id: new_token_id,\n                    keys,\n                    values,\n                    types\n                },\n            );\n\n            token_data.largest_property_version = cur_property_version;\n            // burn the orignial property_version 0 token after mutation\n            let Token { id: _, amount: _, token_properties: _ } = token;\n            new_token_id\n        } else {\n            // only 1 copy for the token with property verion bigger than 0\n            update_token_property_internal(token_owner, token_id, keys, values, types);\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(MutateTokenPropertyMap {\n                    old_id: token_id,\n                    new_id: token_id,\n                    keys,\n                    values,\n                    types\n                });\n            };\n            event::emit_event<MutateTokenPropertyMapEvent>(\n                &mut borrow_global_mut<TokenStore>(token_owner).mutate_token_property_events,\n                MutateTokenPropertyMapEvent {\n                    old_id: token_id,\n                    new_id: token_id,\n                    keys,\n                    values,\n                    types\n                },\n            );\n            token_id\n        }\n    }\n\n    public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {\n        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));\n        assert!(account::exists_at(payee_address), error::invalid_argument(EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST));\n        Royalty {\n            royalty_points_numerator,\n            royalty_points_denominator,\n            payee_address\n        }\n    }\n\n    /// Deposit the token balance into the owner's account and emit an event.\n    public fun deposit_token(account: &signer, token: Token) acquires TokenStore {\n        let account_addr = signer::address_of(account);\n        initialize_token_store(account);\n        direct_deposit(account_addr, token)\n    }\n\n    /// direct deposit if user opt in direct transfer\n    public fun direct_deposit_with_opt_in(account_addr: address, token: Token) acquires TokenStore {\n        let opt_in_transfer = borrow_global<TokenStore>(account_addr).direct_transfer;\n        assert!(opt_in_transfer, error::permission_denied(EUSER_NOT_OPT_IN_DIRECT_TRANSFER));\n        direct_deposit(account_addr, token);\n    }\n\n    public fun direct_transfer(\n        sender: &signer,\n        receiver: &signer,\n        token_id: TokenId,\n        amount: u64,\n    ) acquires TokenStore {\n        let token = withdraw_token(sender, token_id, amount);\n        deposit_token(receiver, token);\n    }\n\n    public fun initialize_token_store(account: &signer) {\n        if (!exists<TokenStore>(signer::address_of(account))) {\n            move_to(\n                account,\n                TokenStore {\n                    tokens: table::new(),\n                    direct_transfer: false,\n                    deposit_events: account::new_event_handle<DepositEvent>(account),\n                    withdraw_events: account::new_event_handle<WithdrawEvent>(account),\n                    burn_events: account::new_event_handle<BurnTokenEvent>(account),\n                    mutate_token_property_events: account::new_event_handle<MutateTokenPropertyMapEvent>(account),\n                },\n            );\n        }\n    }\n\n    public fun merge(dst_token: &mut Token, source_token: Token) {\n        assert!(&dst_token.id == &source_token.id, error::invalid_argument(EINVALID_TOKEN_MERGE));\n        dst_token.amount = dst_token.amount + source_token.amount;\n        let Token { id: _, amount: _, token_properties: _ } = source_token;\n    }\n\n    public fun split(dst_token: &mut Token, amount: u64): Token {\n        assert!(dst_token.id.property_version == 0, error::invalid_state(ENFT_NOT_SPLITABLE));\n        assert!(dst_token.amount > amount, error::invalid_argument(ETOKEN_SPLIT_AMOUNT_LARGER_OR_EQUAL_TO_TOKEN_AMOUNT));\n        assert!(amount > 0, error::invalid_argument(ETOKEN_CANNOT_HAVE_ZERO_AMOUNT));\n        dst_token.amount = dst_token.amount - amount;\n        Token {\n            id: dst_token.id,\n            amount,\n            token_properties: property_map::empty(),\n        }\n    }\n\n    public fun token_id(token: &Token): &TokenId {\n        &token.id\n    }\n\n    /// Transfers `amount` of tokens from `from` to `to`.\n    public fun transfer(\n        from: &signer,\n        id: TokenId,\n        to: address,\n        amount: u64,\n    ) acquires TokenStore {\n        let opt_in_transfer = borrow_global<TokenStore>(to).direct_transfer;\n        assert!(opt_in_transfer, error::permission_denied(EUSER_NOT_OPT_IN_DIRECT_TRANSFER));\n        let token = withdraw_token(from, id, amount);\n        direct_deposit(to, token);\n    }\n\n\n    /// Token owner can create this one-time withdraw capability with an expiration time\n    public fun create_withdraw_capability(\n        owner: &signer,\n        token_id: TokenId,\n        amount: u64,\n        expiration_sec: u64,\n    ): WithdrawCapability {\n        WithdrawCapability {\n            token_owner: signer::address_of(owner),\n            token_id,\n            amount,\n            expiration_sec,\n        }\n    }\n\n    /// Withdraw the token with a capability\n    public fun withdraw_with_capability(\n        withdraw_proof: WithdrawCapability,\n    ): Token acquires TokenStore {\n        // verify the delegation hasn't expired yet\n        assert!(timestamp::now_seconds() <= withdraw_proof.expiration_sec, error::invalid_argument(EWITHDRAW_PROOF_EXPIRES));\n\n        withdraw_with_event_internal(\n            withdraw_proof.token_owner,\n            withdraw_proof.token_id,\n            withdraw_proof.amount,\n        )\n    }\n\n    /// Withdraw the token with a capability.\n    public fun partial_withdraw_with_capability(\n        withdraw_proof: WithdrawCapability,\n        withdraw_amount: u64,\n    ): (Token, Option<WithdrawCapability>) acquires TokenStore {\n        // verify the delegation hasn't expired yet\n        assert!(timestamp::now_seconds() <= withdraw_proof.expiration_sec, error::invalid_argument(EWITHDRAW_PROOF_EXPIRES));\n\n        assert!(withdraw_amount <= withdraw_proof.amount, error::invalid_argument(EINSUFFICIENT_WITHDRAW_CAPABILITY_AMOUNT));\n\n        let res: Option<WithdrawCapability> = if (withdraw_amount == withdraw_proof.amount) {\n            option::none<WithdrawCapability>()\n        } else {\n            option::some(\n                WithdrawCapability {\n                    token_owner: withdraw_proof.token_owner,\n                    token_id: withdraw_proof.token_id,\n                    amount: withdraw_proof.amount - withdraw_amount,\n                    expiration_sec: withdraw_proof.expiration_sec,\n                }\n            )\n        };\n\n        (\n            withdraw_with_event_internal(\n                withdraw_proof.token_owner,\n                withdraw_proof.token_id,\n                withdraw_amount,\n            ),\n            res\n        )\n\n    }\n\n    public fun withdraw_token(\n        account: &signer,\n        id: TokenId,\n        amount: u64,\n    ): Token acquires TokenStore {\n        let account_addr = signer::address_of(account);\n        withdraw_with_event_internal(account_addr, id, amount)\n    }\n\n    /// Create a new collection to hold tokens\n    public fun create_collection(\n        creator: &signer,\n        name: String,\n        description: String,\n        uri: String,\n        maximum: u64,\n        mutate_setting: vector<bool>\n    ) acquires Collections {\n        assert!(string::length(&name) <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));\n        let account_addr = signer::address_of(creator);\n        if (!exists<Collections>(account_addr)) {\n            move_to(\n                creator,\n                Collections {\n                    collection_data: table::new(),\n                    token_data: table::new(),\n                    create_collection_events: account::new_event_handle<CreateCollectionEvent>(creator),\n                    create_token_data_events: account::new_event_handle<CreateTokenDataEvent>(creator),\n                    mint_token_events: account::new_event_handle<MintTokenEvent>(creator),\n                },\n            )\n        };\n\n        let collection_data = &mut borrow_global_mut<Collections>(account_addr).collection_data;\n\n        assert!(\n            !table::contains(collection_data, name),\n            error::already_exists(ECOLLECTION_ALREADY_EXISTS),\n        );\n\n        let mutability_config = create_collection_mutability_config(&mutate_setting);\n        let collection = CollectionData {\n            description,\n            name: name,\n            uri,\n            supply: 0,\n            maximum,\n            mutability_config\n        };\n\n        table::add(collection_data, name, collection);\n        let collection_handle = borrow_global_mut<Collections>(account_addr);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                CreateCollection {\n                    creator: account_addr,\n                    collection_name: name,\n                    uri,\n                    description,\n                    maximum,\n                }\n            );\n        };\n        event::emit_event<CreateCollectionEvent>(\n            &mut collection_handle.create_collection_events,\n            CreateCollectionEvent {\n                creator: account_addr,\n                collection_name: name,\n                uri,\n                description,\n                maximum,\n            }\n        );\n    }\n\n    public fun check_collection_exists(creator: address, name: String): bool acquires Collections {\n        assert!(\n            exists<Collections>(creator),\n            error::not_found(ECOLLECTIONS_NOT_PUBLISHED),\n        );\n\n        let collection_data = &borrow_global<Collections>(creator).collection_data;\n        table::contains(collection_data, name)\n    }\n\n    public fun check_tokendata_exists(creator: address, collection_name: String, token_name: String): bool acquires Collections {\n        assert!(\n            exists<Collections>(creator),\n            error::not_found(ECOLLECTIONS_NOT_PUBLISHED),\n        );\n\n        let token_data = &borrow_global<Collections>(creator).token_data;\n        let token_data_id = create_token_data_id(creator, collection_name, token_name);\n        table::contains(token_data, token_data_id)\n    }\n\n    public fun create_tokendata(\n        account: &signer,\n        collection: String,\n        name: String,\n        description: String,\n        maximum: u64,\n        uri: String,\n        royalty_payee_address: address,\n        royalty_points_denominator: u64,\n        royalty_points_numerator: u64,\n        token_mutate_config: TokenMutabilityConfig,\n        property_keys: vector<String>,\n        property_values: vector<vector<u8>>,\n        property_types: vector<String>\n    ): TokenDataId acquires Collections {\n        assert!(string::length(&name) <= MAX_NFT_NAME_LENGTH, error::invalid_argument(ENFT_NAME_TOO_LONG));\n        assert!(string::length(&collection) <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));\n        assert!(string::length(&uri) <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));\n        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));\n\n        let account_addr = signer::address_of(account);\n        assert!(\n            exists<Collections>(account_addr),\n            error::not_found(ECOLLECTIONS_NOT_PUBLISHED),\n        );\n        let collections = borrow_global_mut<Collections>(account_addr);\n\n        let token_data_id = create_token_data_id(account_addr, collection, name);\n\n        assert!(\n            table::contains(&collections.collection_data, token_data_id.collection),\n            error::not_found(ECOLLECTION_NOT_PUBLISHED),\n        );\n        assert!(\n            !table::contains(&collections.token_data, token_data_id),\n            error::already_exists(ETOKEN_DATA_ALREADY_EXISTS),\n        );\n\n        let collection = table::borrow_mut(&mut collections.collection_data, token_data_id.collection);\n\n        // if collection maximum == 0, user don't want to enforce supply constraint.\n        // we don't track supply to make token creation parallelizable\n        if (collection.maximum > 0) {\n            collection.supply = collection.supply + 1;\n            assert!(\n                collection.maximum >= collection.supply,\n                error::invalid_argument(ECREATE_WOULD_EXCEED_COLLECTION_MAXIMUM),\n            );\n        };\n\n        let token_data = TokenData {\n            maximum,\n            largest_property_version: 0,\n            supply: 0,\n            uri,\n            royalty: create_royalty(royalty_points_numerator, royalty_points_denominator, royalty_payee_address),\n            name,\n            description,\n            default_properties: property_map::new(property_keys, property_values, property_types),\n            mutability_config: token_mutate_config,\n        };\n\n        table::add(&mut collections.token_data, token_data_id, token_data);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                CreateTokenData {\n                    id: token_data_id,\n                    description,\n                    maximum,\n                    uri,\n                    royalty_payee_address,\n                    royalty_points_denominator,\n                    royalty_points_numerator,\n                    name,\n                    mutability_config: token_mutate_config,\n                    property_keys,\n                    property_values,\n                    property_types,\n                }\n            );\n        };\n\n        event::emit_event<CreateTokenDataEvent>(\n            &mut collections.create_token_data_events,\n            CreateTokenDataEvent {\n                id: token_data_id,\n                description,\n                maximum,\n                uri,\n                royalty_payee_address,\n                royalty_points_denominator,\n                royalty_points_numerator,\n                name,\n                mutability_config: token_mutate_config,\n                property_keys,\n                property_values,\n                property_types,\n            },\n        );\n        token_data_id\n    }\n\n    /// return the number of distinct token_data_id created under this collection\n    public fun get_collection_supply(creator_address: address, collection_name: String): Option<u64> acquires Collections {\n        assert_collection_exists(creator_address, collection_name);\n        let collection_data = table::borrow_mut(&mut borrow_global_mut<Collections>(creator_address).collection_data, collection_name);\n\n        if (collection_data.maximum > 0) {\n            option::some(collection_data.supply)\n        } else {\n            option::none()\n        }\n    }\n\n    public fun get_collection_description(creator_address: address, collection_name: String): String acquires Collections {\n        assert_collection_exists(creator_address, collection_name);\n        let collection_data = table::borrow_mut(&mut borrow_global_mut<Collections>(creator_address).collection_data, collection_name);\n        collection_data.description\n    }\n\n    public fun get_collection_uri(creator_address: address, collection_name: String): String acquires Collections {\n        assert_collection_exists(creator_address, collection_name);\n        let collection_data = table::borrow_mut(&mut borrow_global_mut<Collections>(creator_address).collection_data, collection_name);\n        collection_data.uri\n    }\n\n    public fun get_collection_maximum(creator_address: address, collection_name: String): u64 acquires Collections {\n        assert_collection_exists(creator_address, collection_name);\n        let collection_data = table::borrow_mut(&mut borrow_global_mut<Collections>(creator_address).collection_data, collection_name);\n        collection_data.maximum\n    }\n\n    /// return the number of distinct token_id created under this TokenData\n    public fun get_token_supply(creator_address: address, token_data_id: TokenDataId): Option<u64> acquires Collections {\n        assert!(exists<Collections>(creator_address), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &borrow_global<Collections>(creator_address).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n        let token_data = table::borrow(all_token_data, token_data_id);\n\n        if (token_data.maximum > 0) {\n            option::some(token_data.supply)\n        } else {\n            option::none<u64>()\n        }\n    }\n\n    /// return the largest_property_version of this TokenData\n    public fun get_tokendata_largest_property_version(creator_address: address, token_data_id: TokenDataId): u64 acquires Collections {\n        assert!(exists<Collections>(creator_address), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &borrow_global<Collections>(creator_address).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n        table::borrow(all_token_data, token_data_id).largest_property_version\n    }\n\n    /// return the TokenId for a given Token\n    public fun get_token_id(token: &Token): TokenId {\n        token.id\n    }\n\n    public fun get_direct_transfer(receiver: address): bool acquires TokenStore {\n        if (!exists<TokenStore>(receiver)) {\n            return false\n        };\n\n        borrow_global<TokenStore>(receiver).direct_transfer\n    }\n\n    public fun create_token_mutability_config(mutate_setting: &vector<bool>): TokenMutabilityConfig {\n        TokenMutabilityConfig {\n            maximum: *vector::borrow(mutate_setting, TOKEN_MAX_MUTABLE_IND),\n            uri: *vector::borrow(mutate_setting, TOKEN_URI_MUTABLE_IND),\n            royalty: *vector::borrow(mutate_setting, TOKEN_ROYALTY_MUTABLE_IND),\n            description: *vector::borrow(mutate_setting, TOKEN_DESCRIPTION_MUTABLE_IND),\n            properties: *vector::borrow(mutate_setting, TOKEN_PROPERTY_MUTABLE_IND),\n        }\n    }\n\n    public fun create_collection_mutability_config(mutate_setting: &vector<bool>): CollectionMutabilityConfig {\n        CollectionMutabilityConfig {\n            description: *vector::borrow(mutate_setting, COLLECTION_DESCRIPTION_MUTABLE_IND),\n            uri: *vector::borrow(mutate_setting, COLLECTION_URI_MUTABLE_IND),\n            maximum: *vector::borrow(mutate_setting, COLLECTION_MAX_MUTABLE_IND),\n        }\n    }\n\n    public fun mint_token(\n        account: &signer,\n        token_data_id: TokenDataId,\n        amount: u64,\n    ): TokenId acquires Collections, TokenStore {\n        assert!(token_data_id.creator == signer::address_of(account), error::permission_denied(ENO_MINT_CAPABILITY));\n        let creator_addr = token_data_id.creator;\n        let all_token_data = &mut borrow_global_mut<Collections>(creator_addr).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n        let token_data = table::borrow_mut(all_token_data, token_data_id);\n\n        if (token_data.maximum > 0) {\n            assert!(token_data.supply + amount <= token_data.maximum, error::invalid_argument(EMINT_WOULD_EXCEED_TOKEN_MAXIMUM));\n            token_data.supply = token_data.supply + amount;\n        };\n\n        // we add more tokens with property_version 0\n        let token_id = create_token_id(token_data_id, 0);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(MintToken { id: token_data_id, amount })\n        };\n        event::emit_event<MintTokenEvent>(\n            &mut borrow_global_mut<Collections>(creator_addr).mint_token_events,\n            MintTokenEvent {\n                id: token_data_id,\n                amount,\n            }\n        );\n\n        deposit_token(account,\n            Token {\n                id: token_id,\n                amount,\n                token_properties: property_map::empty(), // same as default properties no need to store\n            }\n        );\n\n        token_id\n    }\n\n    /// create tokens and directly deposite to receiver's address. The receiver should opt-in direct transfer\n    public fun mint_token_to(\n        account: &signer,\n        receiver: address,\n        token_data_id: TokenDataId,\n        amount: u64,\n    ) acquires Collections, TokenStore {\n        assert!(exists<TokenStore>(receiver), error::not_found(ETOKEN_STORE_NOT_PUBLISHED));\n        let opt_in_transfer = borrow_global<TokenStore>(receiver).direct_transfer;\n        assert!(opt_in_transfer, error::permission_denied(EUSER_NOT_OPT_IN_DIRECT_TRANSFER));\n\n        assert!(token_data_id.creator == signer::address_of(account), error::permission_denied(ENO_MINT_CAPABILITY));\n        let creator_addr = token_data_id.creator;\n        let all_token_data = &mut borrow_global_mut<Collections>(creator_addr).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n        let token_data = table::borrow_mut(all_token_data, token_data_id);\n\n        if (token_data.maximum > 0) {\n            assert!(token_data.supply + amount <= token_data.maximum, error::invalid_argument(EMINT_WOULD_EXCEED_TOKEN_MAXIMUM));\n            token_data.supply = token_data.supply + amount;\n        };\n\n        // we add more tokens with property_version 0\n        let token_id = create_token_id(token_data_id, 0);\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(MintToken { id: token_data_id, amount })\n        };\n        event::emit_event<MintTokenEvent>(\n            &mut borrow_global_mut<Collections>(creator_addr).mint_token_events,\n            MintTokenEvent {\n                id: token_data_id,\n                amount,\n            }\n        );\n\n        direct_deposit(receiver,\n            Token {\n                id: token_id,\n                amount,\n                token_properties: property_map::empty(), // same as default properties no need to store\n            }\n        );\n    }\n\n    public fun create_token_id(token_data_id: TokenDataId, property_version: u64): TokenId {\n        TokenId {\n            token_data_id,\n            property_version,\n        }\n    }\n\n    public fun create_token_data_id(\n        creator: address,\n        collection: String,\n        name: String,\n    ): TokenDataId {\n        assert!(string::length(&collection) <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));\n        assert!(string::length(&name) <= MAX_NFT_NAME_LENGTH, error::invalid_argument(ENFT_NAME_TOO_LONG));\n        TokenDataId { creator, collection, name }\n    }\n\n    public fun create_token_id_raw(\n        creator: address,\n        collection: String,\n        name: String,\n        property_version: u64,\n    ): TokenId {\n        TokenId {\n            token_data_id: create_token_data_id(creator, collection, name),\n            property_version,\n        }\n    }\n\n    public fun balance_of(owner: address, id: TokenId): u64 acquires TokenStore {\n        if (!exists<TokenStore>(owner)) {\n            return 0\n        };\n        let token_store = borrow_global<TokenStore>(owner);\n        if (table::contains(&token_store.tokens, id)) {\n            table::borrow(&token_store.tokens, id).amount\n        } else {\n            0\n        }\n    }\n\n    public fun has_token_store(owner: address): bool {\n        exists<TokenStore>(owner)\n    }\n\n    public fun get_royalty(token_id: TokenId): Royalty acquires Collections {\n        let token_data_id = token_id.token_data_id;\n        get_tokendata_royalty(token_data_id)\n    }\n\n    public fun get_royalty_numerator(royalty: &Royalty): u64 {\n        royalty.royalty_points_numerator\n    }\n\n    public fun get_royalty_denominator(royalty: &Royalty): u64 {\n        royalty.royalty_points_denominator\n    }\n\n    public fun get_royalty_payee(royalty: &Royalty): address {\n        royalty.payee_address\n    }\n\n    public fun get_token_amount(token: &Token): u64 {\n        token.amount\n    }\n\n    /// return the creator address, collection name, token name and property_version\n    public fun get_token_id_fields(token_id: &TokenId): (address, String, String, u64) {\n        (\n            token_id.token_data_id.creator,\n            token_id.token_data_id.collection,\n            token_id.token_data_id.name,\n            token_id.property_version,\n        )\n    }\n\n    public fun get_token_data_id_fields(token_data_id: &TokenDataId): (address, String, String) {\n        (\n            token_data_id.creator,\n            token_data_id.collection,\n            token_data_id.name,\n        )\n    }\n\n    /// return a copy of the token property map.\n    /// if property_version = 0, return the default property map\n    /// if property_version > 0, return the property value stored at owner's token store\n    public fun get_property_map(owner: address, token_id: TokenId): PropertyMap acquires Collections, TokenStore {\n        assert!(balance_of(owner, token_id) > 0, error::not_found(EINSUFFICIENT_BALANCE));\n        // if property_version = 0, return default property map\n        if (token_id.property_version == 0) {\n            let creator_addr = token_id.token_data_id.creator;\n            let all_token_data = &borrow_global<Collections>(creator_addr).token_data;\n            assert!(table::contains(all_token_data, token_id.token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n            let token_data = table::borrow(all_token_data, token_id.token_data_id);\n            token_data.default_properties\n        } else {\n            let tokens = &borrow_global<TokenStore>(owner).tokens;\n            table::borrow(tokens, token_id).token_properties\n        }\n    }\n\n    public fun get_tokendata_maximum(token_data_id: TokenDataId): u64 acquires Collections {\n        let creator_address = token_data_id.creator;\n        assert!(exists<Collections>(creator_address), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &borrow_global<Collections>(creator_address).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n\n        let token_data = table::borrow(all_token_data, token_data_id);\n        token_data.maximum\n    }\n\n    public fun get_tokendata_uri(creator: address, token_data_id: TokenDataId): String acquires Collections {\n        assert!(exists<Collections>(creator), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &borrow_global<Collections>(creator).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n\n        let token_data = table::borrow(all_token_data, token_data_id);\n        token_data.uri\n    }\n\n    public fun get_tokendata_description(token_data_id: TokenDataId): String acquires Collections {\n        let creator_address = token_data_id.creator;\n        assert!(exists<Collections>(creator_address), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &borrow_global<Collections>(creator_address).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n\n        let token_data = table::borrow(all_token_data, token_data_id);\n        token_data.description\n    }\n\n    public fun get_tokendata_royalty(token_data_id: TokenDataId): Royalty acquires Collections {\n        let creator_address = token_data_id.creator;\n        assert!(exists<Collections>(creator_address), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &borrow_global<Collections>(creator_address).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n\n        let token_data = table::borrow(all_token_data, token_data_id);\n        token_data.royalty\n    }\n\n    /// return the token_data_id from the token_id\n    public fun get_tokendata_id(token_id: TokenId): TokenDataId {\n        token_id.token_data_id\n    }\n\n    /// return the mutation setting of the token\n    public fun get_tokendata_mutability_config(token_data_id: TokenDataId): TokenMutabilityConfig acquires Collections {\n        let creator_addr = token_data_id.creator;\n        assert!(exists<Collections>(creator_addr), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &borrow_global<Collections>(creator_addr).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n        table::borrow(all_token_data, token_data_id).mutability_config\n    }\n\n    /// return if the token's maximum is mutable\n    public fun get_token_mutability_maximum(config: &TokenMutabilityConfig): bool {\n        config.maximum\n    }\n\n    /// return if the token royalty is mutable with a token mutability config\n    public fun get_token_mutability_royalty(config: &TokenMutabilityConfig): bool {\n        config.royalty\n    }\n\n    /// return if the token uri is mutable with a token mutability config\n    public fun get_token_mutability_uri(config: &TokenMutabilityConfig): bool {\n        config.uri\n    }\n\n    /// return if the token description is mutable with a token mutability config\n    public fun get_token_mutability_description(config: &TokenMutabilityConfig): bool {\n        config.description\n    }\n\n    /// return if the tokendata's default properties is mutable with a token mutability config\n    public fun get_token_mutability_default_properties(config: &TokenMutabilityConfig): bool {\n        config.properties\n    }\n\n    #[view]\n    /// return the collection mutation setting\n    public fun get_collection_mutability_config(\n        creator: address,\n        collection_name: String\n    ): CollectionMutabilityConfig acquires Collections {\n        assert!(exists<Collections>(creator), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_collection_data = &borrow_global<Collections>(creator).collection_data;\n        assert!(table::contains(all_collection_data, collection_name), error::not_found(ECOLLECTION_NOT_PUBLISHED));\n        table::borrow(all_collection_data, collection_name).mutability_config\n    }\n\n    /// return if the collection description is mutable with a collection mutability config\n    public fun get_collection_mutability_description(config: &CollectionMutabilityConfig): bool {\n        config.description\n    }\n\n    /// return if the collection uri is mutable with a collection mutability config\n    public fun get_collection_mutability_uri(config: &CollectionMutabilityConfig): bool {\n        config.uri\n    }\n    /// return if the collection maximum is mutable with collection mutability config\n    public fun get_collection_mutability_maximum(config: &CollectionMutabilityConfig): bool {\n        config.maximum\n    }\n\n    //\n    // Private functions\n    //\n    fun destroy_token_data(token_data: TokenData) {\n        let TokenData {\n            maximum: _,\n            largest_property_version: _,\n            supply: _,\n            uri: _,\n            royalty: _,\n            name: _,\n            description: _,\n            default_properties: _,\n            mutability_config: _,\n        } = token_data;\n    }\n\n    fun destroy_collection_data(collection_data: CollectionData) {\n        let CollectionData {\n            description: _,\n            name: _,\n            uri: _,\n            supply: _,\n            maximum: _,\n            mutability_config: _,\n        } = collection_data;\n    }\n\n    fun withdraw_with_event_internal(\n        account_addr: address,\n        id: TokenId,\n        amount: u64,\n    ): Token acquires TokenStore {\n        // It does not make sense to withdraw 0 tokens.\n        assert!(amount > 0, error::invalid_argument(EWITHDRAW_ZERO));\n        // Make sure the account has sufficient tokens to withdraw.\n        assert!(balance_of(account_addr, id) >= amount, error::invalid_argument(EINSUFFICIENT_BALANCE));\n\n        assert!(\n            exists<TokenStore>(account_addr),\n            error::not_found(ETOKEN_STORE_NOT_PUBLISHED),\n        );\n\n        let token_store = borrow_global_mut<TokenStore>(account_addr);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Withdraw { id, amount })\n        };\n        event::emit_event<WithdrawEvent>(\n            &mut token_store.withdraw_events,\n            WithdrawEvent { id, amount }\n        );\n        let tokens = &mut borrow_global_mut<TokenStore>(account_addr).tokens;\n        assert!(\n            table::contains(tokens, id),\n            error::not_found(ENO_TOKEN_IN_TOKEN_STORE),\n        );\n        // balance > amount and amount > 0 indirectly asserted that balance > 0.\n        let balance = &mut table::borrow_mut(tokens, id).amount;\n        if (*balance > amount) {\n            *balance = *balance - amount;\n            Token { id, amount, token_properties: property_map::empty() }\n        } else {\n            table::remove(tokens, id)\n        }\n    }\n\n    fun update_token_property_internal(\n        token_owner: address,\n        token_id: TokenId,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        types: vector<String>,\n    ) acquires TokenStore {\n        let tokens = &mut borrow_global_mut<TokenStore>(token_owner).tokens;\n        assert!(table::contains(tokens, token_id), error::not_found(ENO_TOKEN_IN_TOKEN_STORE));\n\n        let value = &mut table::borrow_mut(tokens, token_id).token_properties;\n        assert_non_standard_reserved_property(&keys);\n        property_map::update_property_map(value, keys, values, types);\n    }\n\n    /// Deposit the token balance into the recipients account and emit an event.\n    fun direct_deposit(account_addr: address, token: Token) acquires TokenStore {\n        assert!(token.amount > 0, error::invalid_argument(ETOKEN_CANNOT_HAVE_ZERO_AMOUNT));\n        let token_store = borrow_global_mut<TokenStore>(account_addr);\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Deposit { id: token.id, amount: token.amount });\n        };\n        event::emit_event<DepositEvent>(\n            &mut token_store.deposit_events,\n            DepositEvent { id: token.id, amount: token.amount },\n        );\n\n        assert!(\n            exists<TokenStore>(account_addr),\n            error::not_found(ETOKEN_STORE_NOT_PUBLISHED),\n        );\n\n        if (!table::contains(&token_store.tokens, token.id)) {\n            table::add(&mut token_store.tokens, token.id, token);\n        } else {\n            let recipient_token = table::borrow_mut(&mut token_store.tokens, token.id);\n            merge(recipient_token, token);\n        };\n    }\n\n    fun assert_collection_exists(creator_address: address, collection_name: String) acquires Collections {\n        assert!(exists<Collections>(creator_address), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_collection_data = &borrow_global<Collections>(creator_address).collection_data;\n        assert!(table::contains(all_collection_data, collection_name), error::not_found(ECOLLECTION_NOT_PUBLISHED));\n    }\n\n    fun assert_tokendata_exists(creator: &signer, token_data_id: TokenDataId) acquires Collections {\n        let creator_addr = token_data_id.creator;\n        assert!(signer::address_of(creator) == creator_addr, error::permission_denied(ENO_MUTATE_CAPABILITY));\n        assert!(exists<Collections>(creator_addr), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));\n        let all_token_data = &mut borrow_global_mut<Collections>(creator_addr).token_data;\n        assert!(table::contains(all_token_data, token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));\n    }\n\n    fun assert_non_standard_reserved_property(keys: &vector<String>) {\n        vector::for_each_ref(keys, |key| {\n            let key: &String = key;\n            let length = string::length(key);\n            if (length >= 6) {\n                let prefix = string::sub_string(&*key, 0, 6);\n                assert!(prefix != string::utf8(b\"TOKEN_\"), error::permission_denied(EPROPERTY_RESERVED_BY_STANDARD));\n            };\n        });\n    }\n\n    // ****************** TEST-ONLY FUNCTIONS **************\n\n    #[test(creator = @0x1, owner = @0x2)]\n    public fun create_withdraw_deposit_token(\n        creator: signer,\n        owner: signer\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(&creator));\n        account::create_account_for_test(signer::address_of(&owner));\n        let token_id = create_collection_and_token(\n            &creator,\n            1,\n            1,\n            1,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        let token = withdraw_token(&creator, token_id, 1);\n        deposit_token(&owner, token);\n    }\n\n    #[test(creator = @0xCC, owner = @0xCB)]\n    public fun create_withdraw_deposit(\n        creator: signer,\n        owner: signer\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(&creator));\n        account::create_account_for_test(signer::address_of(&owner));\n        let token_id = create_collection_and_token(\n            &creator,\n            2,\n            5,\n            5,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        let token_0 = withdraw_token(&creator, token_id, 1);\n        let token_1 = withdraw_token(&creator, token_id, 1);\n        deposit_token(&owner, token_0);\n        deposit_token(&creator, token_1);\n        let token_2 = withdraw_token(&creator, token_id, 1);\n        deposit_token(&owner, token_2);\n    }\n\n    #[test(creator = @0x1)]\n    #[expected_failure]\n    public entry fun test_collection_maximum(creator: signer) acquires Collections, TokenStore {\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(&creator));\n        let token_id = create_collection_and_token(\n            &creator,\n            2,\n            2,\n            1,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        let default_keys = vector<String>[ string::utf8(b\"attack\"), string::utf8(b\"num_of_use\") ];\n        let default_vals = vector<vector<u8>>[ bcs::to_bytes<u64>(&10), bcs::to_bytes<u64>(&5) ];\n        let default_types = vector<String>[ string::utf8(b\"u64\"), string::utf8(b\"u64\") ];\n        let mutate_setting = vector<bool>[ false, false, false, false, false, false ];\n        create_token_script(\n            &creator,\n            token_id.token_data_id.collection,\n            string::utf8(b\"Token\"),\n            string::utf8(b\"Hello, Token\"),\n            100,\n            2,\n            string::utf8(b\"https://aptos.dev\"),\n            signer::address_of(&creator),\n            100,\n            0,\n            mutate_setting,\n            default_keys,\n            default_vals,\n            default_types,\n        );\n    }\n\n    #[test(creator = @0xFA, owner = @0xAF)]\n    public entry fun direct_transfer_test(\n        creator: signer,\n        owner: signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(&creator));\n        account::create_account_for_test(signer::address_of(&owner));\n        let token_id = create_collection_and_token(\n            &creator,\n            2,\n            2,\n            2,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        assert!(balance_of(signer::address_of(&owner), token_id) == 0, 1);\n\n        direct_transfer(&creator, &owner, token_id, 1);\n        let token = withdraw_token(&owner, token_id, 1);\n        deposit_token(&creator, token);\n    }\n\n    #[test_only]\n    public fun get_collection_name(): String {\n        use std::string;\n        string::utf8(b\"Hello, World\")\n    }\n\n    #[test_only]\n    public fun get_token_name(): String {\n        use std::string;\n        string::utf8(b\"Token\")\n    }\n\n    #[test_only]\n    public fun create_collection_and_token(\n        creator: &signer,\n        amount: u64,\n        collection_max: u64,\n        token_max: u64,\n        property_keys: vector<String>,\n        property_values: vector<vector<u8>>,\n        property_types: vector<String>,\n        collection_mutate_setting: vector<bool>,\n        token_mutate_setting: vector<bool>,\n    ): TokenId acquires Collections, TokenStore {\n        use std::string;\n        use std::bcs;\n        let mutate_setting = collection_mutate_setting;\n\n        create_collection(\n            creator,\n            get_collection_name(),\n            string::utf8(b\"Collection: Hello, World\"),\n            string::utf8(b\"https://aptos.dev\"),\n            collection_max,\n            mutate_setting\n        );\n\n        let default_keys = if (vector::length<String>(&property_keys) == 0) { vector<String>[string::utf8(b\"attack\"), string::utf8(b\"num_of_use\")] } else { property_keys };\n        let default_vals = if (vector::length<vector<u8>>(&property_values) == 0) { vector<vector<u8>>[bcs::to_bytes<u64>(&10), bcs::to_bytes<u64>(&5)] } else { property_values };\n        let default_types = if (vector::length<String>(&property_types) == 0) { vector<String>[string::utf8(b\"u64\"), string::utf8(b\"u64\")] } else { property_types };\n        let mutate_setting = token_mutate_setting;\n        create_token_script(\n            creator,\n            get_collection_name(),\n            get_token_name(),\n            string::utf8(b\"Hello, Token\"),\n            amount,\n            token_max,\n            string::utf8(b\"https://aptos.dev\"),\n            signer::address_of(creator),\n            100,\n            0,\n            mutate_setting,\n            default_keys,\n            default_vals,\n            default_types,\n        );\n        create_token_id_raw(signer::address_of(creator), get_collection_name(), get_token_name(), 0)\n    }\n\n    #[test(creator = @0xFF)]\n    fun test_create_events_generation(creator: signer) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(&creator));\n        create_collection_and_token(\n            &creator,\n            1,\n            2,\n            1,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        let collections = borrow_global<Collections>(signer::address_of(&creator));\n        assert!(event::counter(&collections.create_collection_events) == 1, 1);\n    }\n\n    #[test(creator = @0xAF)]\n    fun test_mint_token_from_tokendata(creator: &signer) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n\n        create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        let token_data_id = create_token_data_id(\n            signer::address_of(creator),\n            get_collection_name(),\n            get_token_name());\n\n        let token_id = mint_token(\n            creator,\n            token_data_id,\n            1,\n        );\n\n        assert!(balance_of(signer::address_of(creator), token_id) == 3, 1);\n    }\n\n    #[test(creator = @0xAF, owner = @0xBB)]\n    fun test_mutate_token_property_upsert(creator: &signer) acquires Collections, TokenStore {\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(creator));\n\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[string::utf8(TOKEN_PROPERTY_MUTABLE)],\n            vector<vector<u8>>[bcs::to_bytes<bool>(&true)],\n            vector<String>[string::utf8(b\"bool\")],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        assert!(token_id.property_version == 0, 1);\n        // only be able to mutate the attributed defined when creating the token\n        let new_keys = vector<String>[\n            string::utf8(b\"attack\"), string::utf8(b\"num_of_use\"), string::utf8(b\"new_attribute\")\n        ];\n        let new_vals = vector<vector<u8>>[\n            bcs::to_bytes<u64>(&1), bcs::to_bytes<u64>(&1), bcs::to_bytes<u64>(&1)\n        ];\n        let new_types = vector<String>[\n            string::utf8(b\"u64\"), string::utf8(b\"u64\"), string::utf8(b\"u64\")\n        ];\n\n        mutate_token_properties(\n            creator,\n            token_id.token_data_id.creator,\n            token_id.token_data_id.creator,\n            token_id.token_data_id.collection,\n            token_id.token_data_id.name,\n            token_id.property_version,\n            2,\n            new_keys,\n            new_vals,\n            new_types,\n        );\n    }\n\n    #[test(creator = @0xAF, owner = @0xBB)]\n    fun test_get_property_map_should_not_update_source_value(creator: &signer) acquires Collections, TokenStore {\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(creator));\n\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, true],\n        );\n        assert!(token_id.property_version == 0, 1);\n        // only be able to mutate the attributed defined when creating the token\n        let new_keys = vector<String>[\n            string::utf8(b\"attack\"), string::utf8(b\"num_of_use\")\n        ];\n        let new_vals = vector<vector<u8>>[\n            bcs::to_bytes<u64>(&1), bcs::to_bytes<u64>(&1)\n        ];\n        let new_types = vector<String>[\n            string::utf8(b\"u64\"), string::utf8(b\"u64\")\n        ];\n        let pm = get_property_map(signer::address_of(creator), token_id);\n        assert!(property_map::length(&pm) == 2, 1);\n        let new_token_id = mutate_one_token(\n            creator,\n            signer::address_of(creator),\n            token_id,\n            new_keys,\n            new_vals,\n            new_types,\n        );\n        let updated_pm = get_property_map(signer::address_of(creator), new_token_id);\n        assert!(property_map::length(&updated_pm) == 2, 1);\n        property_map::update_property_value(\n            &mut updated_pm,\n            &string::utf8(b\"attack\"),\n            property_map::create_property_value<u64>(&2),\n        );\n\n        assert!(property_map::read_u64(&updated_pm, &string::utf8(b\"attack\")) == 2, 1);\n        let og_pm = get_property_map(signer::address_of(creator), new_token_id);\n        assert!(property_map::read_u64(&og_pm, &string::utf8(b\"attack\")) == 1, 1);\n    }\n\n    #[test(framework = @0x1, creator = @0xcafe)]\n    fun test_withdraw_with_proof(creator: &signer, framework: &signer): Token acquires TokenStore, Collections {\n        timestamp::set_time_has_started_for_testing(framework);\n        account::create_account_for_test(signer::address_of(creator));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        timestamp::update_global_time_for_test(1000000);\n\n        // provide the proof to the account\n        let cap = create_withdraw_capability(\n            creator, // ask user to provide address to avoid ambiguity from rotated keys\n            token_id,\n            1,\n            2000000,\n        );\n\n        withdraw_with_capability(cap)\n    }\n\n    #[test(creator = @0xcafe, another_creator = @0xde)]\n    fun test_burn_token_from_both_limited_and_unlimited(\n        creator: &signer,\n        another_creator: &signer,\n    )acquires Collections, TokenStore {\n        // create limited token and collection\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(another_creator));\n\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[string::utf8(BURNABLE_BY_CREATOR)],\n            vector<vector<u8>>[bcs::to_bytes<bool>(&true)],\n            vector<String>[string::utf8(b\"bool\")],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        // burn token from limited token\n        let creator_addr = signer::address_of(creator);\n        let pre_amount = &mut get_token_supply(creator_addr, token_id.token_data_id);\n        burn_by_creator(creator, creator_addr, get_collection_name(), get_token_name(), 0, 1);\n        let aft_amount = &mut get_token_supply(creator_addr, token_id.token_data_id);\n        assert!((option::extract<u64>(pre_amount) - option::extract<u64>(aft_amount)) == 1, 1);\n\n        // create unlimited token and collection\n        let new_addr = signer::address_of(another_creator);\n        let new_token_id = create_collection_and_token(\n            another_creator,\n            2,\n            0,\n            0,\n            vector<String>[string::utf8(BURNABLE_BY_OWNER)],\n            vector<vector<u8>>[bcs::to_bytes<bool>(&true)],\n            vector<String>[string::utf8(b\"bool\")],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        let pre = balance_of(new_addr, new_token_id);\n        // burn token from unlimited token and collection\n        burn(another_creator, new_addr, get_collection_name(), get_token_name(), 0, 1);\n        let aft = balance_of(new_addr, new_token_id);\n        assert!(pre - aft == 1, 1);\n    }\n\n    #[test(creator = @0xcafe, owner = @0xafe)]\n    fun test_mint_token_to_different_address(\n        creator: &signer,\n        owner: &signer,\n    )acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(owner));\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        let owner_addr = signer::address_of(owner);\n        opt_in_direct_transfer(owner, true);\n        mint_token_to(creator, owner_addr, token_id.token_data_id, 1);\n        assert!(balance_of(owner_addr, token_id) == 1, 1);\n    }\n\n    #[test(creator = @0xcafe, owner = @0xafe)]\n    #[expected_failure(abort_code = 327696, location = Self)]\n    fun test_opt_in_direct_transfer_fail(\n        creator: &signer,\n        owner: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(owner));\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        let owner_addr = signer::address_of(owner);\n        initialize_token_store(owner);\n        transfer(creator, token_id, owner_addr, 1);\n    }\n\n    #[test(creator = @0xcafe, owner = @0xafe)]\n    #[expected_failure(abort_code = 327696, location = Self)]\n    fun test_opt_in_direct_deposit_fail(\n        creator: &signer,\n        owner: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(owner));\n\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        let owner_addr = signer::address_of(owner);\n        let token = withdraw_token(creator, token_id, 2);\n        initialize_token_store(owner);\n        direct_deposit_with_opt_in(owner_addr, token);\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        opt_in_direct_transfer(owner, true);\n        initialize_token_store(owner);\n        transfer(creator, token_id, signer::address_of(owner), 2);\n        burn_by_creator(creator, signer::address_of(owner), get_collection_name(), get_token_name(), 0, 1);\n    }\n\n    #[test(creator = @0xcafe, owner = @0x456)]\n    #[expected_failure(abort_code = 327710, location = Self)]\n    fun test_burn_token_by_owner_without_burnable_config(\n        creator: &signer,\n        owner: &signer,\n    )acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(owner));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        opt_in_direct_transfer(owner, true);\n        initialize_token_store(owner);\n        transfer(creator, token_id, signer::address_of(owner), 2);\n\n        burn(owner, signer::address_of(creator), get_collection_name(), get_token_name(), 0, 1);\n    }\n\n    #[test(creator = @0xcafe, owner = @0x456)]\n    fun test_burn_token_by_owner_and_creator(\n        creator: &signer,\n        owner: &signer,\n    ) acquires TokenStore, Collections {\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(owner));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[string::utf8(BURNABLE_BY_CREATOR), string::utf8(BURNABLE_BY_OWNER)],\n            vector<vector<u8>>[bcs::to_bytes<bool>(&true), bcs::to_bytes<bool>(&true)],\n            vector<String>[string::utf8(b\"bool\"), string::utf8(b\"bool\")],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n        opt_in_direct_transfer(owner, true);\n        initialize_token_store(owner);\n        transfer(creator, token_id, signer::address_of(owner), 2);\n        burn_by_creator(creator, signer::address_of(owner), get_collection_name(), get_token_name(), 0, 1);\n        burn(owner, signer::address_of(creator), get_collection_name(), get_token_name(), 0, 1);\n        assert!(balance_of(signer::address_of(owner), token_id) == 0, 1);\n\n        // The corresponding token_data and collection_data should be deleted\n        let collections = borrow_global<Collections>(signer::address_of(creator));\n        assert!(!table::contains(&collections.collection_data, token_id.token_data_id.name), 1);\n        assert!(!table::contains(&collections.token_data, token_id.token_data_id), 1);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_mutate_collection_description(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        let creator_address = signer::address_of(creator);\n        account::create_account_for_test(creator_address);\n        create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[true, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        let description = string::utf8(b\"test\");\n        let collection_name = get_collection_name();\n        mutate_collection_description(creator, collection_name, description);\n        assert!(get_collection_description(creator_address, collection_name) == description, 1);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_mutate_collection_uri(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        let creator_address = signer::address_of(creator);\n        account::create_account_for_test(creator_address);\n        create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, true, false],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        let uri = string::utf8(b\"\");\n        let collection_name = get_collection_name();\n        mutate_collection_uri(creator, collection_name, uri);\n        assert!(get_collection_uri(creator_address, collection_name) == uri, 1);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_mutate_collection_maximum(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        let creator_address = signer::address_of(creator);\n        account::create_account_for_test(creator_address);\n        create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, true],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        let collection_name = get_collection_name();\n        mutate_collection_maximum(creator, collection_name, 10);\n        assert!(get_collection_maximum(creator_address, collection_name) == 10, 1);\n    }\n\n    #[test(creator = @0xcafe, owner = @0x456)]\n    fun test_mutate_default_token_properties(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(creator));\n\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, true],\n        );\n        assert!(token_id.property_version == 0, 1);\n        let new_keys = vector<String>[\n            string::utf8(b\"attack\"), string::utf8(b\"num_of_use\")\n        ];\n        let new_vals = vector<vector<u8>>[\n            bcs::to_bytes<u64>(&1), bcs::to_bytes<u64>(&1)\n        ];\n        let new_types = vector<String>[\n            string::utf8(b\"u64\"), string::utf8(b\"u64\")\n        ];\n\n        mutate_tokendata_property(\n            creator,\n            token_id.token_data_id,\n            new_keys,\n            new_vals,\n            new_types,\n        );\n\n        let all_token_data = &borrow_global<Collections>(signer::address_of(creator)).token_data;\n        assert!(table::contains(all_token_data, token_id.token_data_id), 1);\n        let props = &table::borrow(all_token_data, token_id.token_data_id).default_properties;\n        assert!(property_map::read_u64(props, &string::utf8(b\"attack\")) == 1, 1);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_mutate_tokendata_maximum(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[true, false, false, false, false],\n        );\n        mutate_tokendata_maximum(creator, token_id.token_data_id, 10);\n        assert!(get_tokendata_maximum(token_id.token_data_id) == 10, 1);\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 65572, location = Self)]\n    fun test_mutate_tokendata_maximum_from_zero(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[true, false, false, false, false],\n        );\n        mutate_tokendata_maximum(creator, token_id.token_data_id, 0);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_mutate_tokendata_uri(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, true, false, false, false],\n        );\n        mutate_tokendata_uri(creator, token_id.token_data_id, string::utf8(b\"\"));\n        assert!(get_tokendata_uri(signer::address_of(creator), token_id.token_data_id) == string::utf8(b\"\"), 1);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_mutate_tokendata_royalty(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, true, false, false],\n        );\n\n        let royalty = create_royalty(1, 3, signer::address_of(creator));\n        mutate_tokendata_royalty(creator, token_id.token_data_id, royalty);\n        assert!(get_tokendata_royalty(token_id.token_data_id) == royalty, 1);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_mutate_tokendata_description(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, true, false],\n        );\n\n        let description = string::utf8(b\"test\");\n        mutate_tokendata_description(creator, token_id.token_data_id, description);\n        assert!(get_tokendata_description(token_id.token_data_id) == description, 1);\n    }\n\n    #[test(creator = @0xAF, owner = @0xBB)]\n    fun test_mutate_token_property(creator: &signer, owner: &signer) acquires Collections, TokenStore {\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(owner));\n\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, true],\n        );\n        assert!(token_id.property_version == 0, 1);\n        let new_keys = vector<String>[\n        string::utf8(b\"attack\"), string::utf8(b\"num_of_use\")\n        ];\n        let new_vals = vector<vector<u8>>[\n        bcs::to_bytes<u64>(&1), bcs::to_bytes<u64>(&1)\n        ];\n        let new_types = vector<String>[\n        string::utf8(b\"u64\"), string::utf8(b\"u64\")\n        ];\n\n        mutate_token_properties(\n            creator,\n            token_id.token_data_id.creator,\n            token_id.token_data_id.creator,\n            token_id.token_data_id.collection,\n            token_id.token_data_id.name,\n            token_id.property_version,\n            2,\n            new_keys,\n            new_vals,\n            new_types,\n        );\n\n        // should have two new property_version from the orignal two tokens\n        let largest_property_version = get_tokendata_largest_property_version(signer::address_of(creator), token_id.token_data_id);\n        assert!(largest_property_version == 2, largest_property_version);\n\n        let new_id_1 = create_token_id(token_id.token_data_id, 1);\n        let new_id_2 = create_token_id(token_id.token_data_id, 2);\n        let new_id_3 = create_token_id(token_id.token_data_id, 3);\n\n        assert!(balance_of(signer::address_of(creator), new_id_1) == 1, 1);\n        assert!(balance_of(signer::address_of(creator), new_id_2) == 1, 1);\n        assert!(balance_of(signer::address_of(creator), token_id) == 0, 1);\n\n        let creator_props = &borrow_global<TokenStore>(signer::address_of(creator)).tokens;\n        let token = table::borrow(creator_props, new_id_1);\n\n        assert!(property_map::length(&token.token_properties) == 2, property_map::length(&token.token_properties));\n        // mutate token with property_version > 0 should not generate new property_version\n        mutate_token_properties(\n            creator,\n            signer::address_of(creator),\n            new_id_1.token_data_id.creator,\n            new_id_1.token_data_id.collection,\n            new_id_1.token_data_id.name,\n            new_id_1.property_version,\n            1,\n            new_keys,\n            new_vals,\n            new_types\n        );\n        assert!(balance_of(signer::address_of(creator), new_id_3) == 0, 1);\n        // transfer token with property_version > 0 also transfer the token properties\n        direct_transfer(creator, owner, new_id_1, 1);\n\n        let props = &borrow_global<TokenStore>(signer::address_of(owner)).tokens;\n        assert!(table::contains(props, new_id_1), 1);\n        let token = table::borrow(props, new_id_1);\n        assert!(property_map::length(&token.token_properties) == 2, property_map::length(&token.token_properties));\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 65569, location = Self)]\n    fun test_no_zero_balance_token_deposit(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        // token owner mutate the token property\n        create_collection_and_token(\n            creator,\n            0,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, true, false, false, false],\n        );\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 65548, location = Self)]\n    fun test_split_out_zero_token(\n        creator: &signer,\n    ) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            1,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, true, false, false, false],\n        );\n        let token = withdraw_token(creator, token_id, 1);\n        let split_token = split(&mut token, 1);\n        let Token {\n            id: _,\n            amount: _,\n            token_properties: _,\n        } = split_token;\n        let Token {\n            id: _,\n            amount: _,\n            token_properties: _,\n        } = token;\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 65570, location = Self)]\n    public fun test_enter_illegal_royalty(){\n        create_royalty(101, 100, @0xcafe);\n    }\n\n    #[test(framework = @0x1, creator = @0xcafe)]\n    fun test_partial_withdraw_with_proof(creator: &signer, framework: &signer): Token acquires TokenStore, Collections {\n        timestamp::set_time_has_started_for_testing(framework);\n        account::create_account_for_test(signer::address_of(creator));\n        let token_id = create_collection_and_token(\n            creator,\n            4,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, false],\n        );\n\n        timestamp::update_global_time_for_test(1000000);\n\n        // provide the proof to the account\n        let cap = create_withdraw_capability(\n            creator, // ask user to provide address to avoid ambiguity from rotated keys\n            token_id,\n            3,\n            2000000,\n        );\n\n        let (token, capability) = partial_withdraw_with_capability(cap, 1);\n        assert!(option::borrow<WithdrawCapability>(&capability).amount == 2, 1);\n        let (token_1, cap) = partial_withdraw_with_capability(option::extract(&mut capability), 2);\n        assert!(option::is_none(&cap), 1);\n        merge(&mut token, token_1);\n        token\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_get_collection_mutability_config(creator: &signer) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n\n        // token owner mutate the token property\n        create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, true],\n        );\n\n        get_collection_mutability_config(@0xcafe, get_collection_name());\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_get_tokendata_mutability_config(creator: &signer) acquires Collections, TokenStore {\n        account::create_account_for_test(signer::address_of(creator));\n\n        // token owner mutate the token property\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[],\n            vector<vector<u8>>[],\n            vector<String>[],\n            vector<bool>[false, false, false],\n            vector<bool>[false, false, false, false, true],\n        );\n\n        get_tokendata_mutability_config(token_id.token_data_id);\n    }\n\n    #[test(creator = @0xcafe, owner = @0x456)]\n    #[expected_failure(abort_code = 327720, location = Self)]\n    fun test_fail_to_add_burn_flag(\n        creator: &signer,\n        owner: &signer,\n    ) acquires TokenStore, Collections {\n        use std::bcs;\n        account::create_account_for_test(signer::address_of(creator));\n        account::create_account_for_test(signer::address_of(owner));\n        let token_id = create_collection_and_token(\n            creator,\n            2,\n            4,\n            4,\n            vector<String>[string::utf8(BURNABLE_BY_OWNER)],\n            vector<vector<u8>>[bcs::to_bytes<bool>(&true)],\n            vector<String>[string::utf8(b\"bool\")],\n            vector<bool>[false, false, false],\n            vector<bool>[true, true, true, true, true],\n        );\n        let new_keys = vector<String>[\n            string::utf8(BURNABLE_BY_CREATOR),\n        ];\n        let new_vals = vector<vector<u8>>[\n            bcs::to_bytes<bool>(&true),\n        ];\n        let new_types = vector<String>[\n            string::utf8(b\"bool\"),\n        ];\n        mutate_tokendata_property(\n            creator,\n            token_id.token_data_id,\n            new_keys,\n            new_vals,\n            new_types,\n        );\n    }\n\n    //\n    // Deprecated functions\n    //\n\n    public entry fun initialize_token_script(_account: &signer) {\n        abort 0\n    }\n\n    public fun initialize_token(_account: &signer, _token_id: TokenId) {\n        abort 0\n    }\n}\n","name":"token.move"},{"content":"/// Deprecated module\nmodule aptos_token::token_coin_swap {\n    use std::string::String;\n    use std::error;\n    use aptos_std::table::Table;\n    use aptos_std::type_info::TypeInfo;\n    use aptos_framework::event::EventHandle;\n    use aptos_token::token::{Token, TokenId};\n\n    //\n    // Errors.\n    //\n\n    /// Token already listed\n    const ETOKEN_ALREADY_LISTED: u64 = 1;\n\n    /// Token listing no longer exists\n    const ETOKEN_LISTING_NOT_EXIST: u64 = 2;\n\n    /// Token is not in escrow\n    const ETOKEN_NOT_IN_ESCROW: u64 = 3;\n\n    /// Token cannot be moved out of escrow before the lockup time\n    const ETOKEN_CANNOT_MOVE_OUT_OF_ESCROW_BEFORE_LOCKUP_TIME: u64 = 4;\n\n    /// Token buy price doesn't match listing price\n    const ETOKEN_MIN_PRICE_NOT_MATCH: u64 = 5;\n\n    /// Token buy amount doesn't match listing amount\n    const ETOKEN_AMOUNT_NOT_MATCH: u64 = 6;\n\n    /// Not enough coin to buy token\n    const ENOT_ENOUGH_COIN: u64 = 7;\n\n    /// Deprecated module\n    const EDEPRECATED_MODULE: u64 = 8;\n\n    /// TokenCoinSwap records a swap ask for swapping token_amount with CoinType with a minimal price per token\n    struct TokenCoinSwap<phantom CoinType> has store, drop {\n        token_amount: u64,\n        min_price_per_token: u64,\n    }\n\n    /// The listing of all tokens for swapping stored at token owner's account\n    struct TokenListings<phantom CoinType> has key {\n        // key is the token id for swapping and value is the min price of target coin type.\n        listings: Table<TokenId, TokenCoinSwap<CoinType>>,\n        listing_events: EventHandle<TokenListingEvent>,\n        swap_events: EventHandle<TokenSwapEvent>,\n    }\n\n    /// TokenEscrow holds the tokens that cannot be withdrawn or transferred\n    struct TokenEscrow has store {\n        token: Token,\n        // until the locked time runs out, the owner cannot move the token out of the escrow\n        // the default value is 0 meaning the owner can move the coin out anytime\n        locked_until_secs: u64,\n    }\n\n    /// TokenStoreEscrow holds a map of token id to their tokenEscrow\n    struct TokenStoreEscrow has key {\n        token_escrows: Table<TokenId, TokenEscrow>,\n    }\n\n    struct TokenListingEvent has drop, store {\n        token_id: TokenId,\n        amount: u64,\n        min_price: u64,\n        locked_until_secs: u64,\n        coin_type_info: TypeInfo,\n    }\n\n    struct TokenSwapEvent has drop, store {\n        token_id: TokenId,\n        token_buyer: address,\n        token_amount: u64,\n        coin_amount: u64,\n        coin_type_info: TypeInfo,\n    }\n\n    public fun does_listing_exist<CoinType>(\n        _token_owner: address,\n        _token_id: TokenId\n    ): bool {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Coin owner withdraw coin to swap with tokens listed for swapping at the token owner's address.\n    public fun exchange_coin_for_token<CoinType>(\n        _coin_owner: &signer,\n        _coin_amount: u64,\n        _token_owner: address,\n        _creators_address: address,\n        _collection: String,\n        _name: String,\n        _property_version: u64,\n        _token_amount: u64,\n    ) {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Token owner lists their token for swapping\n    public entry fun list_token_for_swap<CoinType>(\n        _token_owner: &signer,\n        _creators_address: address,\n        _collection: String,\n        _name: String,\n        _property_version: u64,\n        _token_amount: u64,\n        _min_coin_per_token: u64,\n        _locked_until_secs: u64\n    ) {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Initalize the token listing for a token owner\n    fun initialize_token_listing<CoinType>(_token_owner: &signer) {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Intialize the token escrow\n    fun initialize_token_store_escrow(_token_owner: &signer) {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Put the token into escrow that cannot be transferred or withdrawed by the owner.\n    public fun deposit_token_to_escrow(\n        _token_owner: &signer,\n        _token_id: TokenId,\n        _tokens: Token,\n        _locked_until_secs: u64\n    ) {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Private function for withdraw tokens from an escrow stored in token owner address\n    fun withdraw_token_from_escrow_internal(\n        _token_owner_addr: address,\n        _token_id: TokenId,\n        _amount: u64\n    ): Token {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Withdraw tokens from the token escrow. It needs a signer to authorize\n    public fun withdraw_token_from_escrow(\n        _token_owner: &signer,\n        _token_id: TokenId,\n        _amount: u64\n    ): Token {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n\n    /// Cancel token listing for a fixed amount\n    public fun cancel_token_listing<CoinType>(\n        _token_owner: &signer,\n        _token_id: TokenId,\n        _token_amount: u64,\n    ) {\n        abort error::invalid_argument(EDEPRECATED_MODULE)\n    }\n}\n","name":"token_coin_swap.move"},{"content":"/// This module provides utils to add and emit new token events that are not in token.move\nmodule aptos_token::token_event_store {\n    use std::string::String;\n    use std::signer;\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::account;\n    use std::option::Option;\n    use aptos_std::any::Any;\n    use std::option;\n    use aptos_token::property_map::PropertyValue;\n\n    friend aptos_token::token;\n\n    //\n    // Collection mutation events\n    //\n\n    /// Event emitted when collection description is mutated\n    struct CollectionDescriptionMutateEvent has drop, store {\n        creator_addr: address,\n        collection_name: String,\n        old_description: String,\n        new_description: String,\n    }\n\n    #[event]\n    /// Event emitted when collection description is mutated\n    struct CollectionDescriptionMutate has drop, store {\n        creator_addr: address,\n        collection_name: String,\n        old_description: String,\n        new_description: String,\n    }\n\n    /// Event emitted when collection uri is mutated\n    struct CollectionUriMutateEvent has drop, store {\n        creator_addr: address,\n        collection_name: String,\n        old_uri: String,\n        new_uri: String,\n    }\n\n    #[event]\n    /// Event emitted when collection uri is mutated\n    struct CollectionUriMutate has drop, store {\n        creator_addr: address,\n        collection_name: String,\n        old_uri: String,\n        new_uri: String,\n    }\n\n    /// Event emitted when the collection maximum is mutated\n    struct CollectionMaxiumMutateEvent has drop, store {\n        creator_addr: address,\n        collection_name: String,\n        old_maximum: u64,\n        new_maximum: u64,\n    }\n\n    #[event]\n    /// Event emitted when the collection maximum is mutated\n    struct CollectionMaxiumMutate has drop, store {\n        creator_addr: address,\n        collection_name: String,\n        old_maximum: u64,\n        new_maximum: u64,\n    }\n\n    //\n    // Token transfer related events\n    //\n\n    /// Event emitted when an user opt-in the direct transfer\n    struct OptInTransferEvent has drop, store {\n        /// True if the user opt in, false if the user opt-out\n        opt_in: bool\n    }\n\n    #[event]\n    /// Event emitted when an user opt-in the direct transfer\n    struct OptInTransfer has drop, store {\n        account_address: address,\n        /// True if the user opt in, false if the user opt-out\n        opt_in: bool\n    }\n\n    //\n    // Token mutation events\n    //\n\n    /// Event emitted when the tokendata uri mutates\n    struct UriMutationEvent has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_uri: String,\n        new_uri: String,\n    }\n\n    #[event]\n    /// Event emitted when the tokendata uri mutates\n    struct UriMutation has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_uri: String,\n        new_uri: String,\n    }\n\n    /// Event emitted when mutating the default the token properties stored at tokendata\n    struct DefaultPropertyMutateEvent has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        keys: vector<String>,\n        /// we allow upsert so the old values might be none\n        old_values: vector<Option<PropertyValue>>,\n        new_values: vector<PropertyValue>,\n    }\n\n    #[event]\n    /// Event emitted when mutating the default the token properties stored at tokendata\n    struct DefaultPropertyMutate has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        keys: vector<String>,\n        /// we allow upsert so the old values might be none\n        old_values: vector<Option<PropertyValue>>,\n        new_values: vector<PropertyValue>,\n    }\n\n    /// Event emitted when the tokendata description is mutated\n    struct DescriptionMutateEvent has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_description: String,\n        new_description: String,\n    }\n\n    #[event]\n    /// Event emitted when the tokendata description is mutated\n    struct DescriptionMutate has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_description: String,\n        new_description: String,\n    }\n\n    /// Event emitted when the token royalty is mutated\n    struct RoyaltyMutateEvent has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_royalty_numerator: u64,\n        old_royalty_denominator: u64,\n        old_royalty_payee_addr: address,\n        new_royalty_numerator: u64,\n        new_royalty_denominator: u64,\n        new_royalty_payee_addr: address,\n    }\n\n    #[event]\n    /// Event emitted when the token royalty is mutated\n    struct RoyaltyMutate has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_royalty_numerator: u64,\n        old_royalty_denominator: u64,\n        old_royalty_payee_addr: address,\n        new_royalty_numerator: u64,\n        new_royalty_denominator: u64,\n        new_royalty_payee_addr: address,\n    }\n\n    /// Event emitted when the token maximum is mutated\n    struct MaxiumMutateEvent has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_maximum: u64,\n        new_maximum: u64,\n    }\n\n    #[event]\n    /// Event emitted when the token maximum is mutated\n    struct MaximumMutate has drop, store {\n        creator: address,\n        collection: String,\n        token: String,\n        old_maximum: u64,\n        new_maximum: u64,\n    }\n\n    struct TokenEventStoreV1 has key {\n        /// collection mutation events\n        collection_uri_mutate_events: EventHandle<CollectionUriMutateEvent>,\n        collection_maximum_mutate_events: EventHandle<CollectionMaxiumMutateEvent>,\n        collection_description_mutate_events: EventHandle<CollectionDescriptionMutateEvent>,\n        /// token transfer opt-in event\n        opt_in_events: EventHandle<OptInTransferEvent>,\n        /// token mutation events\n        uri_mutate_events: EventHandle<UriMutationEvent>,\n        default_property_mutate_events: EventHandle<DefaultPropertyMutateEvent>,\n        description_mutate_events: EventHandle<DescriptionMutateEvent>,\n        royalty_mutate_events: EventHandle<RoyaltyMutateEvent>,\n        maximum_mutate_events: EventHandle<MaxiumMutateEvent>,\n        /// This is for adding new events in future\n        extension: Option<Any>,\n    }\n\n    fun initialize_token_event_store(acct: &signer){\n        if (!exists<TokenEventStoreV1>(signer::address_of(acct))) {\n            move_to(acct, TokenEventStoreV1 {\n                collection_uri_mutate_events: account::new_event_handle<CollectionUriMutateEvent>(acct),\n                collection_maximum_mutate_events: account::new_event_handle<CollectionMaxiumMutateEvent>(acct),\n                collection_description_mutate_events: account::new_event_handle<CollectionDescriptionMutateEvent>(acct),\n                opt_in_events: account::new_event_handle<OptInTransferEvent>(acct),\n                uri_mutate_events: account::new_event_handle<UriMutationEvent>(acct),\n                default_property_mutate_events: account::new_event_handle<DefaultPropertyMutateEvent>(acct),\n                description_mutate_events: account::new_event_handle<DescriptionMutateEvent>(acct),\n                royalty_mutate_events: account::new_event_handle<RoyaltyMutateEvent>(acct),\n                maximum_mutate_events: account::new_event_handle<MaxiumMutateEvent>(acct),\n                extension: option::none<Any>(),\n            });\n        };\n    }\n\n    /// Emit the collection uri mutation event\n    public(friend) fun emit_collection_uri_mutate_event(creator: &signer, collection: String, old_uri: String, new_uri: String) acquires TokenEventStoreV1 {\n        let event = CollectionUriMutateEvent {\n            creator_addr: signer::address_of(creator),\n            collection_name: collection,\n            old_uri,\n            new_uri,\n        };\n        initialize_token_event_store(creator);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(signer::address_of(creator));\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                CollectionUriMutate {\n                    creator_addr: signer::address_of(creator),\n                    collection_name: collection,\n                    old_uri,\n                    new_uri,\n                }\n            );\n        };\n        event::emit_event<CollectionUriMutateEvent>(\n            &mut token_event_store.collection_uri_mutate_events,\n            event,\n        );\n    }\n\n    /// Emit the collection description mutation event\n    public(friend) fun emit_collection_description_mutate_event(creator: &signer, collection: String, old_description: String, new_description: String) acquires TokenEventStoreV1 {\n        let event = CollectionDescriptionMutateEvent {\n            creator_addr: signer::address_of(creator),\n            collection_name: collection,\n            old_description,\n            new_description,\n        };\n        initialize_token_event_store(creator);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(signer::address_of(creator));\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                CollectionDescriptionMutate {\n                    creator_addr: signer::address_of(creator),\n                    collection_name: collection,\n                    old_description,\n                    new_description,\n                }\n            );\n        };\n        event::emit_event<CollectionDescriptionMutateEvent>(\n            &mut token_event_store.collection_description_mutate_events,\n            event,\n        );\n    }\n\n    /// Emit the collection maximum mutation event\n    public(friend) fun emit_collection_maximum_mutate_event(creator: &signer, collection: String, old_maximum: u64, new_maximum: u64) acquires TokenEventStoreV1 {\n        let event = CollectionMaxiumMutateEvent {\n            creator_addr: signer::address_of(creator),\n            collection_name: collection,\n            old_maximum,\n            new_maximum,\n        };\n        initialize_token_event_store(creator);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(signer::address_of(creator));\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                CollectionMaxiumMutate {\n                    creator_addr: signer::address_of(creator),\n                    collection_name: collection,\n                    old_maximum,\n                    new_maximum,\n                }\n            );\n        };\n        event::emit_event<CollectionMaxiumMutateEvent>(\n            &mut token_event_store.collection_maximum_mutate_events,\n            event,\n        );\n    }\n\n    /// Emit the direct opt-in event\n    public(friend) fun emit_token_opt_in_event(account: &signer, opt_in: bool) acquires TokenEventStoreV1 {\n        let opt_in_event = OptInTransferEvent {\n          opt_in,\n        };\n        initialize_token_event_store(account);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(signer::address_of(account));\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                OptInTransfer {\n                    account_address: signer::address_of(account),\n                    opt_in,\n                });\n        };\n        event::emit_event<OptInTransferEvent>(\n            &mut token_event_store.opt_in_events,\n            opt_in_event,\n        );\n    }\n\n    /// Emit URI mutation event\n    public(friend) fun emit_token_uri_mutate_event(\n        creator: &signer,\n        collection: String,\n        token: String,\n        old_uri: String,\n        new_uri: String,\n    ) acquires TokenEventStoreV1 {\n        let creator_addr = signer::address_of(creator);\n\n        let event = UriMutationEvent {\n            creator: creator_addr,\n            collection,\n            token,\n            old_uri,\n            new_uri,\n        };\n\n        initialize_token_event_store(creator);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(creator_addr);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                UriMutation {\n                    creator: creator_addr,\n                    collection,\n                    token,\n                    old_uri,\n                    new_uri,\n                });\n        };\n        event::emit_event<UriMutationEvent>(\n            &mut token_event_store.uri_mutate_events,\n            event,\n        );\n    }\n\n    /// Emit tokendata property map mutation event\n    public(friend) fun emit_default_property_mutate_event(\n        creator: &signer,\n        collection: String,\n        token: String,\n        keys: vector<String>,\n        old_values: vector<Option<PropertyValue>>,\n        new_values: vector<PropertyValue>,\n    ) acquires TokenEventStoreV1 {\n        let creator_addr = signer::address_of(creator);\n\n        let event = DefaultPropertyMutateEvent {\n            creator: creator_addr,\n            collection,\n            token,\n            keys,\n            old_values,\n            new_values,\n        };\n\n        initialize_token_event_store(creator);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(creator_addr);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                DefaultPropertyMutate {\n                    creator: creator_addr,\n                    collection,\n                    token,\n                    keys,\n                    old_values,\n                    new_values,\n                });\n        };\n        event::emit_event<DefaultPropertyMutateEvent>(\n            &mut token_event_store.default_property_mutate_events,\n            event,\n        );\n    }\n\n    /// Emit description mutation event\n    public(friend) fun emit_token_descrition_mutate_event(\n        creator: &signer,\n        collection: String,\n        token: String,\n        old_description: String,\n        new_description: String,\n    ) acquires TokenEventStoreV1 {\n        let creator_addr = signer::address_of(creator);\n\n        let event = DescriptionMutateEvent {\n            creator: creator_addr,\n            collection,\n            token,\n            old_description,\n            new_description,\n        };\n\n        initialize_token_event_store(creator);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(creator_addr);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                DescriptionMutate {\n                    creator: creator_addr,\n                    collection,\n                    token,\n                    old_description,\n                    new_description,\n                });\n        };\n        event::emit_event<DescriptionMutateEvent>(\n            &mut token_event_store.description_mutate_events,\n            event,\n        );\n    }\n\n    /// Emit royalty mutation event\n    public(friend) fun emit_token_royalty_mutate_event(\n        creator: &signer,\n        collection: String,\n        token: String,\n        old_royalty_numerator: u64,\n        old_royalty_denominator: u64,\n        old_royalty_payee_addr: address,\n        new_royalty_numerator: u64,\n        new_royalty_denominator: u64,\n        new_royalty_payee_addr: address,\n    ) acquires TokenEventStoreV1 {\n        let creator_addr = signer::address_of(creator);\n        let event = RoyaltyMutateEvent {\n            creator: creator_addr,\n            collection,\n            token,\n            old_royalty_numerator,\n            old_royalty_denominator,\n            old_royalty_payee_addr,\n            new_royalty_numerator,\n            new_royalty_denominator,\n            new_royalty_payee_addr,\n        };\n\n        initialize_token_event_store(creator);\n        let token_event_store = borrow_global_mut<TokenEventStoreV1>(creator_addr);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                RoyaltyMutate {\n                    creator: creator_addr,\n                    collection,\n                    token,\n                    old_royalty_numerator,\n                    old_royalty_denominator,\n                    old_royalty_payee_addr,\n                    new_royalty_numerator,\n                    new_royalty_denominator,\n                    new_royalty_payee_addr,\n                });\n        };\n        event::emit_event<RoyaltyMutateEvent>(\n            &mut token_event_store.royalty_mutate_events,\n            event,\n        );\n    }\n\n    /// Emit maximum mutation event\n    public(friend) fun emit_token_maximum_mutate_event(\n        creator: &signer,\n        collection: String,\n        token: String,\n        old_maximum: u64,\n        new_maximum: u64,\n    ) acquires TokenEventStoreV1 {\n        let creator_addr = signer::address_of(creator);\n\n        let event = MaxiumMutateEvent {\n            creator: creator_addr,\n            collection,\n            token,\n            old_maximum,\n            new_maximum,\n        };\n\n        initialize_token_event_store(creator);\n        let token_event_store =  borrow_global_mut<TokenEventStoreV1>(creator_addr);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                MaximumMutate {\n                    creator: creator_addr,\n                    collection,\n                    token,\n                    old_maximum,\n                    new_maximum,\n                });\n        };\n        event::emit_event<MaxiumMutateEvent>(\n            &mut token_event_store.maximum_mutate_events,\n            event,\n        );\n    }\n}\n","name":"token_event_store.move"},{"content":"/// This module provides the foundation for transferring of Tokens\nmodule aptos_token::token_transfers {\n    use std::signer;\n    use std::string::String;\n    use std::error;\n    use aptos_std::table::{Self, Table};\n    use aptos_token::token::{Self, Token, TokenId};\n    use aptos_framework::account;\n    use aptos_framework::event::{Self, EventHandle};\n\n    //\n    // Errors.\n    //\n\n    /// Token offer doesn't exist\n    const ETOKEN_OFFER_NOT_EXIST: u64 = 1;\n\n    struct PendingClaims has key {\n        pending_claims: Table<TokenOfferId, Token>,\n        offer_events: EventHandle<TokenOfferEvent>,\n        cancel_offer_events: EventHandle<TokenCancelOfferEvent>,\n        claim_events: EventHandle<TokenClaimEvent>,\n    }\n\n    #[event]\n    struct TokenOfferId has copy, drop, store {\n        to_addr: address,\n        token_id: TokenId,\n    }\n\n    #[event]\n    struct TokenOffer has drop, store {\n        to_address: address,\n        token_id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    struct TokenOfferEvent has drop, store {\n        to_address: address,\n        token_id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    struct TokenCancelOfferEvent has drop, store {\n        to_address: address,\n        token_id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    struct TokenCancelOffer has drop, store {\n        to_address: address,\n        token_id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    struct TokenClaimEvent has drop, store {\n        to_address: address,\n        token_id: TokenId,\n        amount: u64,\n    }\n\n    #[event]\n    struct TokenClaim has drop, store {\n        to_address: address,\n        token_id: TokenId,\n        amount: u64,\n    }\n\n    fun initialize_token_transfers(account: &signer) {\n        move_to(\n            account,\n            PendingClaims {\n                pending_claims: table::new<TokenOfferId, Token>(),\n                offer_events: account::new_event_handle<TokenOfferEvent>(account),\n                cancel_offer_events: account::new_event_handle<TokenCancelOfferEvent>(account),\n                claim_events: account::new_event_handle<TokenClaimEvent>(account),\n            }\n        )\n    }\n\n    fun create_token_offer_id(to_addr: address, token_id: TokenId): TokenOfferId {\n        TokenOfferId {\n            to_addr,\n            token_id\n        }\n    }\n\n    public entry fun offer_script(\n        sender: signer,\n        receiver: address,\n        creator: address,\n        collection: String,\n        name: String,\n        property_version: u64,\n        amount: u64,\n    ) acquires PendingClaims {\n        let token_id = token::create_token_id_raw(creator, collection, name, property_version);\n        offer(&sender, receiver, token_id, amount);\n    }\n\n    public fun offer(\n        sender: &signer,\n        receiver: address,\n        token_id: TokenId,\n        amount: u64,\n    ) acquires PendingClaims {\n        let sender_addr = signer::address_of(sender);\n        if (!exists<PendingClaims>(sender_addr)) {\n            initialize_token_transfers(sender)\n        };\n\n        let pending_claims =\n            &mut borrow_global_mut<PendingClaims>(sender_addr).pending_claims;\n        let token_offer_id = create_token_offer_id(receiver, token_id);\n        let token = token::withdraw_token(sender, token_id, amount);\n        if (!table::contains(pending_claims, token_offer_id)) {\n            table::add(pending_claims, token_offer_id, token);\n        } else {\n            let dst_token = table::borrow_mut(pending_claims, token_offer_id);\n            token::merge(dst_token, token);\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                TokenOffer {\n                    to_address: receiver,\n                    token_id,\n                    amount,\n                }\n            )\n        };\n        event::emit_event<TokenOfferEvent>(\n            &mut borrow_global_mut<PendingClaims>(sender_addr).offer_events,\n            TokenOfferEvent {\n                to_address: receiver,\n                token_id,\n                amount,\n            },\n        );\n    }\n\n    public entry fun claim_script(\n        receiver: signer,\n        sender: address,\n        creator: address,\n        collection: String,\n        name: String,\n        property_version: u64,\n    ) acquires PendingClaims {\n        let token_id = token::create_token_id_raw(creator, collection, name, property_version);\n        claim(&receiver, sender, token_id);\n    }\n\n    public fun claim(\n        receiver: &signer,\n        sender: address,\n        token_id: TokenId,\n    ) acquires PendingClaims {\n        assert!(exists<PendingClaims>(sender), ETOKEN_OFFER_NOT_EXIST);\n        let pending_claims =\n            &mut borrow_global_mut<PendingClaims>(sender).pending_claims;\n        let token_offer_id = create_token_offer_id(signer::address_of(receiver), token_id);\n        assert!(table::contains(pending_claims, token_offer_id), error::not_found(ETOKEN_OFFER_NOT_EXIST));\n        let tokens = table::remove(pending_claims, token_offer_id);\n        let amount = token::get_token_amount(&tokens);\n        token::deposit_token(receiver, tokens);\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                TokenClaim {\n                    to_address: signer::address_of(receiver),\n                    token_id,\n                    amount,\n                }\n            )\n        };\n        event::emit_event<TokenClaimEvent>(\n            &mut borrow_global_mut<PendingClaims>(sender).claim_events,\n            TokenClaimEvent {\n                to_address: signer::address_of(receiver),\n                token_id,\n                amount,\n            },\n        );\n    }\n\n    public entry fun cancel_offer_script(\n        sender: signer,\n        receiver: address,\n        creator: address,\n        collection: String,\n        name: String,\n        property_version: u64,\n    ) acquires PendingClaims {\n        let token_id = token::create_token_id_raw(creator, collection, name, property_version);\n        cancel_offer(&sender, receiver, token_id);\n    }\n\n    // Extra from our pending_claims and return to gallery\n    public fun cancel_offer(\n        sender: &signer,\n        receiver: address,\n        token_id: TokenId,\n    ) acquires PendingClaims {\n        let sender_addr = signer::address_of(sender);\n        let token_offer_id = create_token_offer_id(receiver, token_id);\n        assert!(exists<PendingClaims>(sender_addr), ETOKEN_OFFER_NOT_EXIST);\n        let pending_claims =\n            &mut borrow_global_mut<PendingClaims>(sender_addr).pending_claims;\n        let token = table::remove(pending_claims, token_offer_id);\n        let amount = token::get_token_amount(&token);\n        token::deposit_token(sender, token);\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                TokenCancelOffer {\n                    to_address: receiver,\n                    token_id,\n                    amount,\n                },\n            )\n        };\n        event::emit_event<TokenCancelOfferEvent>(\n            &mut borrow_global_mut<PendingClaims>(sender_addr).cancel_offer_events,\n            TokenCancelOfferEvent {\n                to_address: receiver,\n                token_id,\n                amount,\n            },\n        );\n    }\n\n    #[test(creator = @0x1, owner = @0x2)]\n    public fun test_nft(creator: signer, owner: signer) acquires PendingClaims {\n        let token_id = create_token(&creator, 1);\n\n        let creator_addr = signer::address_of(&creator);\n        let owner_addr = signer::address_of(&owner);\n        aptos_framework::account::create_account_for_test(owner_addr);\n        offer(&creator, owner_addr, token_id, 1);\n        claim(&owner, creator_addr, token_id);\n\n\n        offer(&owner, creator_addr, token_id, 1);\n        cancel_offer(&owner, creator_addr, token_id);\n    }\n\n    #[test(creator = @0x1, owner0 = @0x2, owner1 = @0x3)]\n    public fun test_editions(\n        creator: signer,\n        owner0: signer,\n        owner1: signer,\n    ) acquires PendingClaims {\n        let token_id = create_token(&creator, 2);\n\n        let creator_addr = signer::address_of(&creator);\n        let owner0_addr = signer::address_of(&owner0);\n        aptos_framework::account::create_account_for_test(owner0_addr);\n        let owner1_addr = signer::address_of(&owner1);\n        aptos_framework::account::create_account_for_test(owner1_addr);\n\n        offer(&creator, owner0_addr, token_id, 1);\n        offer(&creator, owner1_addr, token_id, 1);\n\n        assert!(token::balance_of(signer::address_of(&creator), token_id) == 0, 1);\n        claim(&owner0, creator_addr, token_id);\n        assert!(token::balance_of(signer::address_of(&owner0), token_id) == 1, 1);\n        claim(&owner1, creator_addr, token_id);\n        assert!(token::balance_of(signer::address_of(&owner1), token_id) == 1, 1);\n\n        offer(&owner0, owner1_addr, token_id, 1);\n        claim(&owner1, owner0_addr, token_id);\n\n        offer(&owner1, creator_addr, token_id, 1);\n        offer(&owner1, creator_addr, token_id, 1);\n        claim(&creator, owner1_addr, token_id);\n    }\n\n    #[test_only]\n    public fun create_token(creator: &signer, amount: u64): TokenId {\n        use std::string::{Self, String};\n\n        let collection_name = string::utf8(b\"Hello, World\");\n        let collection_mutation_setting = vector<bool>[false, false, false];\n        aptos_framework::account::create_account_for_test(signer::address_of(creator));\n\n        token::create_collection(\n            creator,\n            collection_name,\n            string::utf8(b\"Collection: Hello, World\"),\n            string::utf8(b\"https://aptos.dev\"),\n            1,\n            collection_mutation_setting,\n        );\n\n        let token_mutation_setting = vector<bool>[false, false, false, false, true];\n        let default_keys = vector<String>[string::utf8(b\"attack\"), string::utf8(b\"num_of_use\")];\n        let default_vals = vector<vector<u8>>[b\"10\", b\"5\"];\n        let default_types = vector<String>[string::utf8(b\"integer\"), string::utf8(b\"integer\")];\n        token::create_token_script(\n            creator,\n            collection_name,\n            string::utf8(b\"Token: Hello, Token\"),\n            string::utf8(b\"Hello, Token\"),\n            amount,\n            amount,\n            string::utf8(b\"https://aptos.dev\"),\n            signer::address_of(creator),\n            100,\n            0,\n            token_mutation_setting,\n            default_keys,\n            default_vals,\n            default_types,\n        );\n        token::create_token_id_raw(\n            signer::address_of(creator),\n            collection_name,\n            string::utf8(b\"Token: Hello, Token\"),\n            0\n        )\n    }\n}\n","name":"token_transfers.move"}]