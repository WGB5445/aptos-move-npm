export default [{"content":"module aptos_framework::account {\n    use std::bcs;\n    use std::error;\n    use std::hash;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::vector;\n    use aptos_framework::chain_id;\n    use aptos_framework::create_signer::create_signer;\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::guid;\n    use aptos_framework::system_addresses;\n    use aptos_std::ed25519;\n    use aptos_std::from_bcs;\n    use aptos_std::multi_ed25519;\n    use aptos_std::table::{Self, Table};\n    use aptos_std::type_info::{Self, TypeInfo};\n\n    friend aptos_framework::aptos_account;\n    friend aptos_framework::coin;\n    friend aptos_framework::genesis;\n    friend aptos_framework::multisig_account;\n    friend aptos_framework::resource_account;\n    friend aptos_framework::transaction_validation;\n\n    #[event]\n    struct KeyRotation has drop, store {\n        account: address,\n        old_authentication_key: vector<u8>,\n        new_authentication_key: vector<u8>,\n    }\n\n    /// Resource representing an account.\n    struct Account has key, store {\n        authentication_key: vector<u8>,\n        sequence_number: u64,\n        guid_creation_num: u64,\n        coin_register_events: EventHandle<CoinRegisterEvent>,\n        key_rotation_events: EventHandle<KeyRotationEvent>,\n        rotation_capability_offer: CapabilityOffer<RotationCapability>,\n        signer_capability_offer: CapabilityOffer<SignerCapability>,\n    }\n\n    struct KeyRotationEvent has drop, store {\n        old_authentication_key: vector<u8>,\n        new_authentication_key: vector<u8>,\n    }\n\n    struct CoinRegisterEvent has drop, store {\n        type_info: TypeInfo,\n    }\n\n    struct CapabilityOffer<phantom T> has store { for: Option<address> }\n\n    struct RotationCapability has drop, store { account: address }\n\n    struct SignerCapability has drop, store { account: address }\n\n    /// It is easy to fetch the authentication key of an address by simply reading it from the `Account` struct at that address.\n    /// The table in this struct makes it possible to do a reverse lookup: it maps an authentication key, to the address of the account which has that authentication key set.\n    ///\n    /// This mapping is needed when recovering wallets for accounts whose authentication key has been rotated.\n    ///\n    /// For example, imagine a freshly-created wallet with address `a` and thus also with authentication key `a`, derived from a PK `pk_a` with corresponding SK `sk_a`.\n    /// It is easy to recover such a wallet given just the secret key `sk_a`, since the PK can be derived from the SK, the authentication key can then be derived from the PK, and the address equals the authentication key (since there was no key rotation).\n    ///\n    /// However, if such a wallet rotates its authentication key to `b` derived from a different PK `pk_b` with SK `sk_b`, how would account recovery work?\n    /// The recovered address would no longer be 'a'; it would be `b`, which is incorrect.\n    /// This struct solves this problem by mapping the new authentication key `b` to the original address `a` and thus helping the wallet software during recovery find the correct address.\n    struct OriginatingAddress has key {\n        address_map: Table<address, address>,\n    }\n\n    /// This structs stores the challenge message that should be signed during key rotation. First, this struct is\n    /// signed by the account owner's current public key, which proves possession of a capability to rotate the key.\n    /// Second, this struct is signed by the new public key that the account owner wants to rotate to, which proves\n    /// knowledge of this new public key's associated secret key. These two signatures cannot be replayed in another\n    /// context because they include the TXN's unique sequence number.\n    struct RotationProofChallenge has copy, drop {\n        sequence_number: u64,\n        // the sequence number of the account whose key is being rotated\n        originator: address,\n        // the address of the account whose key is being rotated\n        current_auth_key: address,\n        // the current authentication key of the account whose key is being rotated\n        new_public_key: vector<u8>,\n        // the new public key that the account owner wants to rotate to\n    }\n\n    /// Deprecated struct - newest version is `RotationCapabilityOfferProofChallengeV2`\n    struct RotationCapabilityOfferProofChallenge has drop {\n        sequence_number: u64,\n        recipient_address: address,\n    }\n\n    /// Deprecated struct - newest version is `SignerCapabilityOfferProofChallengeV2`\n    struct SignerCapabilityOfferProofChallenge has drop {\n        sequence_number: u64,\n        recipient_address: address,\n    }\n\n    /// This struct stores the challenge message that should be signed by the source account, when the source account\n    /// is delegating its rotation capability to the `recipient_address`.\n    /// This V2 struct adds the `chain_id` and `source_address` to the challenge message, which prevents replaying the challenge message.\n    struct RotationCapabilityOfferProofChallengeV2 has drop {\n        chain_id: u8,\n        sequence_number: u64,\n        source_address: address,\n        recipient_address: address,\n    }\n\n    struct SignerCapabilityOfferProofChallengeV2 has copy, drop {\n        sequence_number: u64,\n        source_address: address,\n        recipient_address: address,\n    }\n\n    const MAX_U64: u128 = 18446744073709551615;\n    const ZERO_AUTH_KEY: vector<u8> = x\"0000000000000000000000000000000000000000000000000000000000000000\";\n\n    /// Scheme identifier for Ed25519 signatures used to derive authentication keys for Ed25519 public keys.\n    const ED25519_SCHEME: u8 = 0;\n    /// Scheme identifier for MultiEd25519 signatures used to derive authentication keys for MultiEd25519 public keys.\n    const MULTI_ED25519_SCHEME: u8 = 1;\n    /// Scheme identifier used when hashing an account's address together with a seed to derive the address (not the\n    /// authentication key) of a resource account. This is an abuse of the notion of a scheme identifier which, for now,\n    /// serves to domain separate hashes used to derive resource account addresses from hashes used to derive\n    /// authentication keys. Without such separation, an adversary could create (and get a signer for) a resource account\n    /// whose address matches an existing address of a MultiEd25519 wallet.\n    const DERIVE_RESOURCE_ACCOUNT_SCHEME: u8 = 255;\n\n    /// Account already exists\n    const EACCOUNT_ALREADY_EXISTS: u64 = 1;\n    /// Account does not exist\n    const EACCOUNT_DOES_NOT_EXIST: u64 = 2;\n    /// Sequence number exceeds the maximum value for a u64\n    const ESEQUENCE_NUMBER_TOO_BIG: u64 = 3;\n    /// The provided authentication key has an invalid length\n    const EMALFORMED_AUTHENTICATION_KEY: u64 = 4;\n    /// Cannot create account because address is reserved\n    const ECANNOT_RESERVED_ADDRESS: u64 = 5;\n    /// Transaction exceeded its allocated max gas\n    const EOUT_OF_GAS: u64 = 6;\n    /// Specified current public key is not correct\n    const EWRONG_CURRENT_PUBLIC_KEY: u64 = 7;\n    /// Specified proof of knowledge required to prove ownership of a public key is invalid\n    const EINVALID_PROOF_OF_KNOWLEDGE: u64 = 8;\n    /// The caller does not have a digital-signature-based capability to call this function\n    const ENO_CAPABILITY: u64 = 9;\n    /// The caller does not have a valid rotation capability offer from the other account\n    const EINVALID_ACCEPT_ROTATION_CAPABILITY: u64 = 10;\n    /// Address to create is not a valid reserved address for Aptos framework\n    const ENO_VALID_FRAMEWORK_RESERVED_ADDRESS: u64 = 11;\n    /// Specified scheme required to proceed with the smart contract operation - can only be ED25519_SCHEME(0) OR MULTI_ED25519_SCHEME(1)\n    const EINVALID_SCHEME: u64 = 12;\n    /// Abort the transaction if the expected originating address is different from the originating address on-chain\n    const EINVALID_ORIGINATING_ADDRESS: u64 = 13;\n    /// The signer capability offer doesn't exist at the given address\n    const ENO_SUCH_SIGNER_CAPABILITY: u64 = 14;\n    /// An attempt to create a resource account on a claimed account\n    const ERESOURCE_ACCCOUNT_EXISTS: u64 = 15;\n    /// An attempt to create a resource account on an account that has a committed transaction\n    const EACCOUNT_ALREADY_USED: u64 = 16;\n    /// Offerer address doesn't exist\n    const EOFFERER_ADDRESS_DOES_NOT_EXIST: u64 = 17;\n    /// The specified rotation capablity offer does not exist at the specified offerer address\n    const ENO_SUCH_ROTATION_CAPABILITY_OFFER: u64 = 18;\n    // The signer capability is not offered to any address\n    const ENO_SIGNER_CAPABILITY_OFFERED: u64 = 19;\n    // This account has exceeded the allocated GUIDs it can create. It should be impossible to reach this number for real applications.\n    const EEXCEEDED_MAX_GUID_CREATION_NUM: u64 = 20;\n\n    /// Explicitly separate the GUID space between Object and Account to prevent accidental overlap.\n    const MAX_GUID_CREATION_NUM: u64 = 0x4000000000000;\n\n    #[test_only]\n    /// Create signer for testing, independently of an Aptos-style `Account`.\n    public fun create_signer_for_test(addr: address): signer { create_signer(addr) }\n\n    /// Only called during genesis to initialize system resources for this module.\n    public(friend) fun initialize(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        move_to(aptos_framework, OriginatingAddress {\n            address_map: table::new(),\n        });\n    }\n\n    public fun create_account_if_does_not_exist(account_address: address) {\n        if (!exists<Account>(account_address)) {\n            create_account(account_address);\n        }\n    }\n\n    /// Publishes a new `Account` resource under `new_address`. A signer representing `new_address`\n    /// is returned. This way, the caller of this function can publish additional resources under\n    /// `new_address`.\n    public(friend) fun create_account(new_address: address): signer {\n        // there cannot be an Account resource under new_addr already.\n        assert!(!exists<Account>(new_address), error::already_exists(EACCOUNT_ALREADY_EXISTS));\n\n        // NOTE: @core_resources gets created via a `create_account` call, so we do not include it below.\n        assert!(\n            new_address != @vm_reserved && new_address != @aptos_framework && new_address != @aptos_token,\n            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)\n        );\n\n        create_account_unchecked(new_address)\n    }\n\n    fun create_account_unchecked(new_address: address): signer {\n        let new_account = create_signer(new_address);\n        let authentication_key = bcs::to_bytes(&new_address);\n        assert!(\n            vector::length(&authentication_key) == 32,\n            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)\n        );\n\n        let guid_creation_num = 0;\n\n        let guid_for_coin = guid::create(new_address, &mut guid_creation_num);\n        let coin_register_events = event::new_event_handle<CoinRegisterEvent>(guid_for_coin);\n\n        let guid_for_rotation = guid::create(new_address, &mut guid_creation_num);\n        let key_rotation_events = event::new_event_handle<KeyRotationEvent>(guid_for_rotation);\n\n        move_to(\n            &new_account,\n            Account {\n                authentication_key,\n                sequence_number: 0,\n                guid_creation_num,\n                coin_register_events,\n                key_rotation_events,\n                rotation_capability_offer: CapabilityOffer { for: option::none() },\n                signer_capability_offer: CapabilityOffer { for: option::none() },\n            }\n        );\n\n        new_account\n    }\n\n    #[view]\n    public fun exists_at(addr: address): bool {\n        exists<Account>(addr)\n    }\n\n    #[view]\n    public fun get_guid_next_creation_num(addr: address): u64 acquires Account {\n        borrow_global<Account>(addr).guid_creation_num\n    }\n\n    #[view]\n    public fun get_sequence_number(addr: address): u64 acquires Account {\n        borrow_global<Account>(addr).sequence_number\n    }\n\n    public(friend) fun increment_sequence_number(addr: address) acquires Account {\n        let sequence_number = &mut borrow_global_mut<Account>(addr).sequence_number;\n\n        assert!(\n            (*sequence_number as u128) < MAX_U64,\n            error::out_of_range(ESEQUENCE_NUMBER_TOO_BIG)\n        );\n\n        *sequence_number = *sequence_number + 1;\n    }\n\n    #[view]\n    public fun get_authentication_key(addr: address): vector<u8> acquires Account {\n        borrow_global<Account>(addr).authentication_key\n    }\n\n    /// This function is used to rotate a resource account's authentication key to `new_auth_key`. This is done in\n    /// many contexts:\n    /// 1. During normal key rotation via `rotate_authentication_key` or `rotate_authentication_key_call`\n    /// 2. During resource account initialization so that no private key can control the resource account\n    /// 3. During multisig_v2 account creation\n    public(friend) fun rotate_authentication_key_internal(account: &signer, new_auth_key: vector<u8>) acquires Account {\n        let addr = signer::address_of(account);\n        assert!(exists_at(addr), error::not_found(EACCOUNT_DOES_NOT_EXIST));\n        assert!(\n            vector::length(&new_auth_key) == 32,\n            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)\n        );\n        let account_resource = borrow_global_mut<Account>(addr);\n        account_resource.authentication_key = new_auth_key;\n    }\n\n    /// Private entry function for key rotation that allows the signer to update their authentication key.\n    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not \"verified\": it\n    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to\n    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in\n    /// the format expected in `rotate_authentication_key`.\n    entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account {\n        rotate_authentication_key_internal(account, new_auth_key);\n    }\n\n    /// Generic authentication key rotation function that allows the user to rotate their authentication key from any scheme to any scheme.\n    /// To authorize the rotation, we need two signatures:\n    /// - the first signature `cap_rotate_key` refers to the signature by the account owner's current key on a valid `RotationProofChallenge`,\n    /// demonstrating that the user intends to and has the capability to rotate the authentication key of this account;\n    /// - the second signature `cap_update_table` refers to the signature by the new key (that the account owner wants to rotate to) on a\n    /// valid `RotationProofChallenge`, demonstrating that the user owns the new private key, and has the authority to update the\n    /// `OriginatingAddress` map with the new address mapping `<new_address, originating_address>`.\n    /// To verify these two signatures, we need their corresponding public key and public key scheme: we use `from_scheme` and `from_public_key_bytes`\n    /// to verify `cap_rotate_key`, and `to_scheme` and `to_public_key_bytes` to verify `cap_update_table`.\n    /// A scheme of 0 refers to an Ed25519 key and a scheme of 1 refers to Multi-Ed25519 keys.\n    /// `originating address` refers to an account's original/first address.\n    ///\n    /// Here is an example attack if we don't ask for the second signature `cap_update_table`:\n    /// Alice has rotated her account `addr_a` to `new_addr_a`. As a result, the following entry is created, to help Alice when recovering her wallet:\n    /// `OriginatingAddress[new_addr_a]` -> `addr_a`\n    /// Alice has had bad day: her laptop blew up and she needs to reset her account on a new one.\n    /// (Fortunately, she still has her secret key `new_sk_a` associated with her new address `new_addr_a`, so she can do this.)\n    ///\n    /// But Bob likes to mess with Alice.\n    /// Bob creates an account `addr_b` and maliciously rotates it to Alice's new address `new_addr_a`. Since we are no longer checking a PoK,\n    /// Bob can easily do this.\n    ///\n    /// Now, the table will be updated to make Alice's new address point to Bob's address: `OriginatingAddress[new_addr_a]` -> `addr_b`.\n    /// When Alice recovers her account, her wallet will display the attacker's address (Bob's) `addr_b` as her address.\n    /// Now Alice will give `addr_b` to everyone to pay her, but the money will go to Bob.\n    ///\n    /// Because we ask for a valid `cap_update_table`, this kind of attack is not possible. Bob would not have the secret key of Alice's address\n    /// to rotate his address to Alice's address in the first place.\n    public entry fun rotate_authentication_key(\n        account: &signer,\n        from_scheme: u8,\n        from_public_key_bytes: vector<u8>,\n        to_scheme: u8,\n        to_public_key_bytes: vector<u8>,\n        cap_rotate_key: vector<u8>,\n        cap_update_table: vector<u8>,\n    ) acquires Account, OriginatingAddress {\n        let addr = signer::address_of(account);\n        assert!(exists_at(addr), error::not_found(EACCOUNT_DOES_NOT_EXIST));\n        let account_resource = borrow_global_mut<Account>(addr);\n\n        // Verify the given `from_public_key_bytes` matches this account's current authentication key.\n        if (from_scheme == ED25519_SCHEME) {\n            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);\n            let from_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);\n            assert!(\n                account_resource.authentication_key == from_auth_key,\n                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)\n            );\n        } else if (from_scheme == MULTI_ED25519_SCHEME) {\n            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);\n            let from_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);\n            assert!(\n                account_resource.authentication_key == from_auth_key,\n                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)\n            );\n        } else {\n            abort error::invalid_argument(EINVALID_SCHEME)\n        };\n\n        // Construct a valid `RotationProofChallenge` that `cap_rotate_key` and `cap_update_table` will validate against.\n        let curr_auth_key_as_address = from_bcs::to_address(account_resource.authentication_key);\n        let challenge = RotationProofChallenge {\n            sequence_number: account_resource.sequence_number,\n            originator: addr,\n            current_auth_key: curr_auth_key_as_address,\n            new_public_key: to_public_key_bytes,\n        };\n\n        // Assert the challenges signed by the current and new keys are valid\n        assert_valid_rotation_proof_signature_and_get_auth_key(\n            from_scheme,\n            from_public_key_bytes,\n            cap_rotate_key,\n            &challenge\n        );\n        let new_auth_key = assert_valid_rotation_proof_signature_and_get_auth_key(\n            to_scheme,\n            to_public_key_bytes,\n            cap_update_table,\n            &challenge\n        );\n\n        // Update the `OriginatingAddress` table.\n        update_auth_key_and_originating_address_table(addr, account_resource, new_auth_key);\n    }\n\n    public entry fun rotate_authentication_key_with_rotation_capability(\n        delegate_signer: &signer,\n        rotation_cap_offerer_address: address,\n        new_scheme: u8,\n        new_public_key_bytes: vector<u8>,\n        cap_update_table: vector<u8>\n    ) acquires Account, OriginatingAddress {\n        assert!(exists_at(rotation_cap_offerer_address), error::not_found(EOFFERER_ADDRESS_DOES_NOT_EXIST));\n\n        // Check that there exists a rotation capability offer at the offerer's account resource for the delegate.\n        let delegate_address = signer::address_of(delegate_signer);\n        let offerer_account_resource = borrow_global<Account>(rotation_cap_offerer_address);\n        assert!(\n            option::contains(&offerer_account_resource.rotation_capability_offer.for, &delegate_address),\n            error::not_found(ENO_SUCH_ROTATION_CAPABILITY_OFFER)\n        );\n\n        let curr_auth_key = from_bcs::to_address(offerer_account_resource.authentication_key);\n        let challenge = RotationProofChallenge {\n            sequence_number: get_sequence_number(delegate_address),\n            originator: rotation_cap_offerer_address,\n            current_auth_key: curr_auth_key,\n            new_public_key: new_public_key_bytes,\n        };\n\n        // Verifies that the `RotationProofChallenge` from above is signed under the new public key that we are rotating to.        l\n        let new_auth_key = assert_valid_rotation_proof_signature_and_get_auth_key(\n            new_scheme,\n            new_public_key_bytes,\n            cap_update_table,\n            &challenge\n        );\n\n        // Update the `OriginatingAddress` table, so we can find the originating address using the new address.\n        let offerer_account_resource = borrow_global_mut<Account>(rotation_cap_offerer_address);\n        update_auth_key_and_originating_address_table(\n            rotation_cap_offerer_address,\n            offerer_account_resource,\n            new_auth_key\n        );\n    }\n\n    /// Offers rotation capability on behalf of `account` to the account at address `recipient_address`.\n    /// An account can delegate its rotation capability to only one other address at one time. If the account\n    /// has an existing rotation capability offer, calling this function will update the rotation capability offer with\n    /// the new `recipient_address`.\n    /// Here, `rotation_capability_sig_bytes` signature indicates that this key rotation is authorized by the account owner,\n    /// and prevents the classic \"time-of-check time-of-use\" attack.\n    /// For example, users usually rely on what the wallet displays to them as the transaction's outcome. Consider a contract that with 50% probability\n    /// (based on the current timestamp in Move), rotates somebody's key. The wallet might be unlucky and get an outcome where nothing is rotated,\n    /// incorrectly telling the user nothing bad will happen. But when the transaction actually gets executed, the attacker gets lucky and\n    /// the execution path triggers the account key rotation.\n    /// We prevent such attacks by asking for this extra signature authorizing the key rotation.\n    ///\n    /// @param rotation_capability_sig_bytes is the signature by the account owner's key on `RotationCapabilityOfferProofChallengeV2`.\n    /// @param account_scheme is the scheme of the account (ed25519 or multi_ed25519).\n    /// @param account_public_key_bytes is the public key of the account owner.\n    /// @param recipient_address is the address of the recipient of the rotation capability - note that if there's an existing rotation capability\n    /// offer, calling this function will replace the previous `recipient_address` upon successful verification.\n    public entry fun offer_rotation_capability(\n        account: &signer,\n        rotation_capability_sig_bytes: vector<u8>,\n        account_scheme: u8,\n        account_public_key_bytes: vector<u8>,\n        recipient_address: address,\n    ) acquires Account {\n        let addr = signer::address_of(account);\n        assert!(exists_at(recipient_address), error::not_found(EACCOUNT_DOES_NOT_EXIST));\n\n        // proof that this account intends to delegate its rotation capability to another account\n        let account_resource = borrow_global_mut<Account>(addr);\n        let proof_challenge = RotationCapabilityOfferProofChallengeV2 {\n            chain_id: chain_id::get(),\n            sequence_number: account_resource.sequence_number,\n            source_address: addr,\n            recipient_address,\n        };\n\n        // verify the signature on `RotationCapabilityOfferProofChallengeV2` by the account owner\n        if (account_scheme == ED25519_SCHEME) {\n            let pubkey = ed25519::new_unvalidated_public_key_from_bytes(account_public_key_bytes);\n            let expected_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&pubkey);\n            assert!(\n                account_resource.authentication_key == expected_auth_key,\n                error::invalid_argument(EWRONG_CURRENT_PUBLIC_KEY)\n            );\n\n            let rotation_capability_sig = ed25519::new_signature_from_bytes(rotation_capability_sig_bytes);\n            assert!(\n                ed25519::signature_verify_strict_t(&rotation_capability_sig, &pubkey, proof_challenge),\n                error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE)\n            );\n        } else if (account_scheme == MULTI_ED25519_SCHEME) {\n            let pubkey = multi_ed25519::new_unvalidated_public_key_from_bytes(account_public_key_bytes);\n            let expected_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&pubkey);\n            assert!(\n                account_resource.authentication_key == expected_auth_key,\n                error::invalid_argument(EWRONG_CURRENT_PUBLIC_KEY)\n            );\n\n            let rotation_capability_sig = multi_ed25519::new_signature_from_bytes(rotation_capability_sig_bytes);\n            assert!(\n                multi_ed25519::signature_verify_strict_t(&rotation_capability_sig, &pubkey, proof_challenge),\n                error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE)\n            );\n        } else {\n            abort error::invalid_argument(EINVALID_SCHEME)\n        };\n\n        // update the existing rotation capability offer or put in a new rotation capability offer for the current account\n        option::swap_or_fill(&mut account_resource.rotation_capability_offer.for, recipient_address);\n    }\n\n    #[view]\n    /// Returns true if the account at `account_addr` has a rotation capability offer.\n    public fun is_rotation_capability_offered(account_addr: address): bool acquires Account {\n        let account_resource = borrow_global<Account>(account_addr);\n        option::is_some(&account_resource.rotation_capability_offer.for)\n    }\n\n    #[view]\n    /// Returns the address of the account that has a rotation capability offer from the account at `account_addr`.\n    public fun get_rotation_capability_offer_for(account_addr: address): address acquires Account {\n        let account_resource = borrow_global<Account>(account_addr);\n        assert!(\n            option::is_some(&account_resource.rotation_capability_offer.for),\n            error::not_found(ENO_SIGNER_CAPABILITY_OFFERED),\n        );\n        *option::borrow(&account_resource.rotation_capability_offer.for)\n    }\n\n    /// Revoke the rotation capability offer given to `to_be_revoked_recipient_address` from `account`\n    public entry fun revoke_rotation_capability(account: &signer, to_be_revoked_address: address) acquires Account {\n        assert!(exists_at(to_be_revoked_address), error::not_found(EACCOUNT_DOES_NOT_EXIST));\n        let addr = signer::address_of(account);\n        let account_resource = borrow_global_mut<Account>(addr);\n        assert!(\n            option::contains(&account_resource.rotation_capability_offer.for, &to_be_revoked_address),\n            error::not_found(ENO_SUCH_ROTATION_CAPABILITY_OFFER)\n        );\n        revoke_any_rotation_capability(account);\n    }\n\n    /// Revoke any rotation capability offer in the specified account.\n    public entry fun revoke_any_rotation_capability(account: &signer) acquires Account {\n        let account_resource = borrow_global_mut<Account>(signer::address_of(account));\n        option::extract(&mut account_resource.rotation_capability_offer.for);\n    }\n\n    /// Offers signer capability on behalf of `account` to the account at address `recipient_address`.\n    /// An account can delegate its signer capability to only one other address at one time.\n    /// `signer_capability_key_bytes` is the `SignerCapabilityOfferProofChallengeV2` signed by the account owner's key\n    /// `account_scheme` is the scheme of the account (ed25519 or multi_ed25519).\n    /// `account_public_key_bytes` is the public key of the account owner.\n    /// `recipient_address` is the address of the recipient of the signer capability - note that if there's an existing\n    /// `recipient_address` in the account owner's `SignerCapabilityOffer`, this will replace the\n    /// previous `recipient_address` upon successful verification (the previous recipient will no longer have access\n    /// to the account owner's signer capability).\n    public entry fun offer_signer_capability(\n        account: &signer,\n        signer_capability_sig_bytes: vector<u8>,\n        account_scheme: u8,\n        account_public_key_bytes: vector<u8>,\n        recipient_address: address\n    ) acquires Account {\n        let source_address = signer::address_of(account);\n        assert!(exists_at(recipient_address), error::not_found(EACCOUNT_DOES_NOT_EXIST));\n\n        // Proof that this account intends to delegate its signer capability to another account.\n        let proof_challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: get_sequence_number(source_address),\n            source_address,\n            recipient_address,\n        };\n        verify_signed_message(\n            source_address, account_scheme, account_public_key_bytes, signer_capability_sig_bytes, proof_challenge);\n\n        // Update the existing signer capability offer or put in a new signer capability offer for the recipient.\n        let account_resource = borrow_global_mut<Account>(source_address);\n        option::swap_or_fill(&mut account_resource.signer_capability_offer.for, recipient_address);\n    }\n\n    #[view]\n    /// Returns true if the account at `account_addr` has a signer capability offer.\n    public fun is_signer_capability_offered(account_addr: address): bool acquires Account {\n        let account_resource = borrow_global<Account>(account_addr);\n        option::is_some(&account_resource.signer_capability_offer.for)\n    }\n\n    #[view]\n    /// Returns the address of the account that has a signer capability offer from the account at `account_addr`.\n    public fun get_signer_capability_offer_for(account_addr: address): address acquires Account {\n        let account_resource = borrow_global<Account>(account_addr);\n        assert!(\n            option::is_some(&account_resource.signer_capability_offer.for),\n            error::not_found(ENO_SIGNER_CAPABILITY_OFFERED),\n        );\n        *option::borrow(&account_resource.signer_capability_offer.for)\n    }\n\n    /// Revoke the account owner's signer capability offer for `to_be_revoked_address` (i.e., the address that\n    /// has a signer capability offer from `account` but will be revoked in this function).\n    public entry fun revoke_signer_capability(account: &signer, to_be_revoked_address: address) acquires Account {\n        assert!(exists_at(to_be_revoked_address), error::not_found(EACCOUNT_DOES_NOT_EXIST));\n        let addr = signer::address_of(account);\n        let account_resource = borrow_global_mut<Account>(addr);\n        assert!(\n            option::contains(&account_resource.signer_capability_offer.for, &to_be_revoked_address),\n            error::not_found(ENO_SUCH_SIGNER_CAPABILITY)\n        );\n        revoke_any_signer_capability(account);\n    }\n\n    /// Revoke any signer capability offer in the specified account.\n    public entry fun revoke_any_signer_capability(account: &signer) acquires Account {\n        let account_resource = borrow_global_mut<Account>(signer::address_of(account));\n        option::extract(&mut account_resource.signer_capability_offer.for);\n    }\n\n    /// Return an authorized signer of the offerer, if there's an existing signer capability offer for `account`\n    /// at the offerer's address.\n    public fun create_authorized_signer(account: &signer, offerer_address: address): signer acquires Account {\n        assert!(exists_at(offerer_address), error::not_found(EOFFERER_ADDRESS_DOES_NOT_EXIST));\n\n        // Check if there's an existing signer capability offer from the offerer.\n        let account_resource = borrow_global<Account>(offerer_address);\n        let addr = signer::address_of(account);\n        assert!(\n            option::contains(&account_resource.signer_capability_offer.for, &addr),\n            error::not_found(ENO_SUCH_SIGNER_CAPABILITY)\n        );\n\n        create_signer(offerer_address)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    /// Helper functions for authentication key rotation.\n    ///////////////////////////////////////////////////////////////////////////\n    fun assert_valid_rotation_proof_signature_and_get_auth_key(\n        scheme: u8,\n        public_key_bytes: vector<u8>,\n        signature: vector<u8>,\n        challenge: &RotationProofChallenge\n    ): vector<u8> {\n        if (scheme == ED25519_SCHEME) {\n            let pk = ed25519::new_unvalidated_public_key_from_bytes(public_key_bytes);\n            let sig = ed25519::new_signature_from_bytes(signature);\n            assert!(\n                ed25519::signature_verify_strict_t(&sig, &pk, *challenge),\n                std::error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE)\n            );\n            ed25519::unvalidated_public_key_to_authentication_key(&pk)\n        } else if (scheme == MULTI_ED25519_SCHEME) {\n            let pk = multi_ed25519::new_unvalidated_public_key_from_bytes(public_key_bytes);\n            let sig = multi_ed25519::new_signature_from_bytes(signature);\n            assert!(\n                multi_ed25519::signature_verify_strict_t(&sig, &pk, *challenge),\n                std::error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE)\n            );\n            multi_ed25519::unvalidated_public_key_to_authentication_key(&pk)\n        } else {\n            abort error::invalid_argument(EINVALID_SCHEME)\n        }\n    }\n\n    /// Update the `OriginatingAddress` table, so that we can find the originating address using the latest address\n    /// in the event of key recovery.\n    fun update_auth_key_and_originating_address_table(\n        originating_addr: address,\n        account_resource: &mut Account,\n        new_auth_key_vector: vector<u8>,\n    ) acquires OriginatingAddress {\n        let address_map = &mut borrow_global_mut<OriginatingAddress>(@aptos_framework).address_map;\n        let curr_auth_key = from_bcs::to_address(account_resource.authentication_key);\n\n        // Checks `OriginatingAddress[curr_auth_key]` is either unmapped, or mapped to `originating_address`.\n        // If it's mapped to the originating address, removes that mapping.\n        // Otherwise, abort if it's mapped to a different address.\n        if (table::contains(address_map, curr_auth_key)) {\n            // If account_a with address_a is rotating its keypair from keypair_a to keypair_b, we expect\n            // the address of the account to stay the same, while its keypair updates to keypair_b.\n            // Here, by asserting that we're calling from the account with the originating address, we enforce\n            // the standard of keeping the same address and updating the keypair at the contract level.\n            // Without this assertion, the dapps could also update the account's address to address_b (the address that\n            // is programmatically related to keypaier_b) and update the keypair to keypair_b. This causes problems\n            // for interoperability because different dapps can implement this in different ways.\n            // If the account with address b calls this function with two valid signatures, it will abort at this step,\n            // because address b is not the account's originating address.\n            assert!(\n                originating_addr == table::remove(address_map, curr_auth_key),\n                error::not_found(EINVALID_ORIGINATING_ADDRESS)\n            );\n        };\n\n        // Set `OriginatingAddress[new_auth_key] = originating_address`.\n        let new_auth_key = from_bcs::to_address(new_auth_key_vector);\n        table::add(address_map, new_auth_key, originating_addr);\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(KeyRotation {\n                account: originating_addr,\n                old_authentication_key: account_resource.authentication_key,\n                new_authentication_key: new_auth_key_vector,\n            });\n        };\n        event::emit_event<KeyRotationEvent>(\n            &mut account_resource.key_rotation_events,\n            KeyRotationEvent {\n                old_authentication_key: account_resource.authentication_key,\n                new_authentication_key: new_auth_key_vector,\n            }\n        );\n\n        // Update the account resource's authentication key.\n        account_resource.authentication_key = new_auth_key_vector;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    /// Basic account creation methods.\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// This is a helper function to compute resource addresses. Computation of the address\n    /// involves the use of a cryptographic hash operation and should be use thoughtfully.\n    public fun create_resource_address(source: &address, seed: vector<u8>): address {\n        let bytes = bcs::to_bytes(source);\n        vector::append(&mut bytes, seed);\n        vector::push_back(&mut bytes, DERIVE_RESOURCE_ACCOUNT_SCHEME);\n        from_bcs::to_address(hash::sha3_256(bytes))\n    }\n\n    /// A resource account is used to manage resources independent of an account managed by a user.\n    /// In Aptos a resource account is created based upon the sha3 256 of the source's address and additional seed data.\n    /// A resource account can only be created once, this is designated by setting the\n    /// `Account::signer_capability_offer::for` to the address of the resource account. While an entity may call\n    /// `create_account` to attempt to claim an account ahead of the creation of a resource account, if found Aptos will\n    /// transition ownership of the account over to the resource account. This is done by validating that the account has\n    /// yet to execute any transactions and that the `Account::signer_capability_offer::for` is none. The probability of a\n    /// collision where someone has legitimately produced a private key that maps to a resource account address is less\n    /// than `(1/2)^(256)`.\n    public fun create_resource_account(source: &signer, seed: vector<u8>): (signer, SignerCapability) acquires Account {\n        let resource_addr = create_resource_address(&signer::address_of(source), seed);\n        let resource = if (exists_at(resource_addr)) {\n            let account = borrow_global<Account>(resource_addr);\n            assert!(\n                option::is_none(&account.signer_capability_offer.for),\n                error::already_exists(ERESOURCE_ACCCOUNT_EXISTS),\n            );\n            assert!(\n                account.sequence_number == 0,\n                error::invalid_state(EACCOUNT_ALREADY_USED),\n            );\n            create_signer(resource_addr)\n        } else {\n            create_account_unchecked(resource_addr)\n        };\n\n        // By default, only the SignerCapability should have control over the resource account and not the auth key.\n        // If the source account wants direct control via auth key, they would need to explicitly rotate the auth key\n        // of the resource account using the SignerCapability.\n        rotate_authentication_key_internal(&resource, ZERO_AUTH_KEY);\n\n        let account = borrow_global_mut<Account>(resource_addr);\n        account.signer_capability_offer.for = option::some(resource_addr);\n        let signer_cap = SignerCapability { account: resource_addr };\n        (resource, signer_cap)\n    }\n\n    /// create the account for system reserved addresses\n    public(friend) fun create_framework_reserved_account(addr: address): (signer, SignerCapability) {\n        assert!(\n            addr == @0x1 ||\n                addr == @0x2 ||\n                addr == @0x3 ||\n                addr == @0x4 ||\n                addr == @0x5 ||\n                addr == @0x6 ||\n                addr == @0x7 ||\n                addr == @0x8 ||\n                addr == @0x9 ||\n                addr == @0xa,\n            error::permission_denied(ENO_VALID_FRAMEWORK_RESERVED_ADDRESS),\n        );\n        let signer = create_account_unchecked(addr);\n        let signer_cap = SignerCapability { account: addr };\n        (signer, signer_cap)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    /// GUID management methods.\n    ///////////////////////////////////////////////////////////////////////////\n\n    public fun create_guid(account_signer: &signer): guid::GUID acquires Account {\n        let addr = signer::address_of(account_signer);\n        let account = borrow_global_mut<Account>(addr);\n        let guid = guid::create(addr, &mut account.guid_creation_num);\n        assert!(\n            account.guid_creation_num < MAX_GUID_CREATION_NUM,\n            error::out_of_range(EEXCEEDED_MAX_GUID_CREATION_NUM),\n        );\n        guid\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    /// GUID management methods.\n    ///////////////////////////////////////////////////////////////////////////\n\n    public fun new_event_handle<T: drop + store>(account: &signer): EventHandle<T> acquires Account {\n        event::new_event_handle(create_guid(account))\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    /// Coin management methods.\n    ///////////////////////////////////////////////////////////////////////////\n\n    public(friend) fun register_coin<CoinType>(account_addr: address) acquires Account {\n        let account = borrow_global_mut<Account>(account_addr);\n        event::emit_event<CoinRegisterEvent>(\n            &mut account.coin_register_events,\n            CoinRegisterEvent {\n                type_info: type_info::type_of<CoinType>(),\n            },\n        );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Test-only create signerCapabilityOfferProofChallengeV2 and return it\n    ///////////////////////////////////////////////////////////////////////////\n\n    #[test_only]\n    public fun get_signer_capability_offer_proof_challenge_v2(\n        source_address: address,\n        recipient_address: address,\n    ): SignerCapabilityOfferProofChallengeV2 acquires Account {\n        SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: borrow_global_mut<Account>(source_address).sequence_number,\n            source_address,\n            recipient_address,\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    /// Capability based functions for efficient use.\n    ///////////////////////////////////////////////////////////////////////////\n\n    public fun create_signer_with_capability(capability: &SignerCapability): signer {\n        let addr = &capability.account;\n        create_signer(*addr)\n    }\n\n    public fun get_signer_capability_address(capability: &SignerCapability): address {\n        capability.account\n    }\n\n    public fun verify_signed_message<T: drop>(\n        account: address,\n        account_scheme: u8,\n        account_public_key: vector<u8>,\n        signed_message_bytes: vector<u8>,\n        message: T,\n    ) acquires Account {\n        let account_resource = borrow_global_mut<Account>(account);\n        // Verify that the `SignerCapabilityOfferProofChallengeV2` has the right information and is signed by the account owner's key\n        if (account_scheme == ED25519_SCHEME) {\n            let pubkey = ed25519::new_unvalidated_public_key_from_bytes(account_public_key);\n            let expected_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&pubkey);\n            assert!(\n                account_resource.authentication_key == expected_auth_key,\n                error::invalid_argument(EWRONG_CURRENT_PUBLIC_KEY),\n            );\n\n            let signer_capability_sig = ed25519::new_signature_from_bytes(signed_message_bytes);\n            assert!(\n                ed25519::signature_verify_strict_t(&signer_capability_sig, &pubkey, message),\n                error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE),\n            );\n        } else if (account_scheme == MULTI_ED25519_SCHEME) {\n            let pubkey = multi_ed25519::new_unvalidated_public_key_from_bytes(account_public_key);\n            let expected_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&pubkey);\n            assert!(\n                account_resource.authentication_key == expected_auth_key,\n                error::invalid_argument(EWRONG_CURRENT_PUBLIC_KEY),\n            );\n\n            let signer_capability_sig = multi_ed25519::new_signature_from_bytes(signed_message_bytes);\n            assert!(\n                multi_ed25519::signature_verify_strict_t(&signer_capability_sig, &pubkey, message),\n                error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE),\n            );\n        } else {\n            abort error::invalid_argument(EINVALID_SCHEME)\n        };\n    }\n\n    #[test_only]\n    public fun create_account_for_test(new_address: address): signer {\n        // Make this easier by just allowing the account to be created again in a test\n        if (!exists_at(new_address)) {\n            create_account_unchecked(new_address)\n        } else {\n            create_signer_for_test(new_address)\n        }\n    }\n\n    #[test]\n    /// Assert correct signer creation.\n    fun test_create_signer_for_test() {\n        assert!(signer::address_of(&create_signer_for_test(@aptos_framework)) == @0x1, 0);\n        assert!(signer::address_of(&create_signer_for_test(@0x123)) == @0x123, 0);\n    }\n\n    #[test(user = @0x1)]\n    public entry fun test_create_resource_account(user: signer) acquires Account {\n        let (resource_account, resource_account_cap) = create_resource_account(&user, x\"01\");\n        let resource_addr = signer::address_of(&resource_account);\n        assert!(resource_addr != signer::address_of(&user), 0);\n        assert!(resource_addr == get_signer_capability_address(&resource_account_cap), 1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_cannot_control_resource_account_via_auth_key() acquires Account {\n        let alice_pk = x\"4141414141414141414141414141414141414141414141414141414141414145\";\n        let alice = create_account_from_ed25519_public_key(alice_pk);\n        let alice_auth = get_authentication_key(signer::address_of(&alice)); // must look like a valid public key\n\n        let (eve_sk, eve_pk) = ed25519::generate_keys();\n        let eve_pk_bytes = ed25519::validated_public_key_to_bytes(&eve_pk);\n        let eve = create_account_from_ed25519_public_key(eve_pk_bytes);\n        let recipient_address = signer::address_of(&eve);\n\n        let seed = eve_pk_bytes; // multisig public key\n        vector::push_back(&mut seed, 1); // multisig threshold\n        vector::push_back(&mut seed, 1); // signature scheme id\n        let (resource, _) = create_resource_account(&alice, seed);\n\n        let resource_addr = signer::address_of(&resource);\n        let proof_challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: borrow_global_mut<Account>(resource_addr).sequence_number,\n            source_address: resource_addr,\n            recipient_address,\n        };\n\n        let eve_sig = ed25519::sign_struct(&eve_sk, copy proof_challenge);\n\n        // Construct a malicious 1-out-of-2 multisig PK over Alice's authentication key and Eve's Ed25519 PK.\n        let account_public_key_bytes = alice_auth;\n        vector::append(&mut account_public_key_bytes, eve_pk_bytes);\n        vector::push_back(&mut account_public_key_bytes, 1); // Multisig verification threshold.\n        let fake_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(account_public_key_bytes);\n\n        // Construct a multisig for `proof_challenge` as if it is signed by the signers behind `fake_pk`,\n        // Eve being the only participant.\n        let signer_capability_sig_bytes = x\"\";\n        vector::append(&mut signer_capability_sig_bytes, ed25519::signature_to_bytes(&eve_sig));\n        vector::append(&mut signer_capability_sig_bytes, x\"40000000\"); // Signers bitmap.\n        let fake_sig = multi_ed25519::new_signature_from_bytes(signer_capability_sig_bytes);\n\n        assert!(\n            multi_ed25519::signature_verify_strict_t(&fake_sig, &fake_pk, proof_challenge),\n            error::invalid_state(EINVALID_PROOF_OF_KNOWLEDGE)\n        );\n        offer_signer_capability(\n            &resource,\n            signer_capability_sig_bytes,\n            MULTI_ED25519_SCHEME,\n            account_public_key_bytes,\n            recipient_address\n        );\n    }\n\n    #[test_only]\n    struct DummyResource has key {}\n\n    #[test(user = @0x1)]\n    public entry fun test_module_capability(user: signer) acquires Account, DummyResource {\n        let (resource_account, signer_cap) = create_resource_account(&user, x\"01\");\n        assert!(signer::address_of(&resource_account) != signer::address_of(&user), 0);\n\n        let resource_account_from_cap = create_signer_with_capability(&signer_cap);\n        assert!(&resource_account == &resource_account_from_cap, 1);\n\n        move_to(&resource_account_from_cap, DummyResource {});\n        borrow_global<DummyResource>(signer::address_of(&resource_account));\n    }\n\n    #[test(user = @0x1)]\n    public entry fun test_resource_account_and_create_account(user: signer) acquires Account {\n        let resource_addr = create_resource_address(&@0x1, x\"01\");\n        create_account_unchecked(resource_addr);\n\n        create_resource_account(&user, x\"01\");\n    }\n\n    #[test(user = @0x1)]\n    #[expected_failure(abort_code = 0x8000f, location = Self)]\n    public entry fun test_duplice_create_resource_account(user: signer) acquires Account {\n        create_resource_account(&user, x\"01\");\n        create_resource_account(&user, x\"01\");\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Test-only sequence number mocking for extant Account resource\n    ///////////////////////////////////////////////////////////////////////////\n\n    #[test_only]\n    /// Increment sequence number of account at address `addr`\n    public fun increment_sequence_number_for_test(\n        addr: address,\n    ) acquires Account {\n        let acct = borrow_global_mut<Account>(addr);\n        acct.sequence_number = acct.sequence_number + 1;\n    }\n\n    #[test_only]\n    /// Update address `addr` to have `s` as its sequence number\n    public fun set_sequence_number(\n        addr: address,\n        s: u64\n    ) acquires Account {\n        borrow_global_mut<Account>(addr).sequence_number = s;\n    }\n\n    #[test_only]\n    public fun create_test_signer_cap(account: address): SignerCapability {\n        SignerCapability { account }\n    }\n\n    #[test_only]\n    public fun set_signer_capability_offer(offerer: address, receiver: address) acquires Account {\n        let account_resource = borrow_global_mut<Account>(offerer);\n        option::swap_or_fill(&mut account_resource.signer_capability_offer.for, receiver);\n    }\n\n    #[test_only]\n    public fun set_rotation_capability_offer(offerer: address, receiver: address) acquires Account {\n        let account_resource = borrow_global_mut<Account>(offerer);\n        option::swap_or_fill(&mut account_resource.rotation_capability_offer.for, receiver);\n    }\n\n    #[test]\n    /// Verify test-only sequence number mocking\n    public entry fun mock_sequence_numbers()\n    acquires Account {\n        let addr: address = @0x1234; // Define test address\n        create_account(addr); // Initialize account resource\n        // Assert sequence number intializes to 0\n        assert!(borrow_global<Account>(addr).sequence_number == 0, 0);\n        increment_sequence_number_for_test(addr); // Increment sequence number\n        // Assert correct mock value post-increment\n        assert!(borrow_global<Account>(addr).sequence_number == 1, 1);\n        set_sequence_number(addr, 10); // Set mock sequence number\n        // Assert correct mock value post-modification\n        assert!(borrow_global<Account>(addr).sequence_number == 10, 2);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Test account helpers\n    ///////////////////////////////////////////////////////////////////////////\n\n    #[test(alice = @0xa11ce)]\n    #[expected_failure(abort_code = 65537, location = aptos_framework::ed25519)]\n    public entry fun test_empty_public_key(alice: signer) acquires Account, OriginatingAddress {\n        create_account(signer::address_of(&alice));\n        let pk = vector::empty<u8>();\n        let sig = x\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        rotate_authentication_key(&alice, ED25519_SCHEME, pk, ED25519_SCHEME, pk, sig, sig);\n    }\n\n    #[test(alice = @0xa11ce)]\n    #[expected_failure(abort_code = 262151, location = Self)]\n    public entry fun test_empty_signature(alice: signer) acquires Account, OriginatingAddress {\n        create_account(signer::address_of(&alice));\n        let test_signature = vector::empty<u8>();\n        let pk = x\"0000000000000000000000000000000000000000000000000000000000000000\";\n        rotate_authentication_key(&alice, ED25519_SCHEME, pk, ED25519_SCHEME, pk, test_signature, test_signature);\n    }\n\n    #[test_only]\n    public fun create_account_from_ed25519_public_key(pk_bytes: vector<u8>): signer {\n        let pk = ed25519::new_unvalidated_public_key_from_bytes(pk_bytes);\n        let curr_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&pk);\n        let alice_address = from_bcs::to_address(curr_auth_key);\n        let alice = create_account_unchecked(alice_address);\n        alice\n    }\n\n    //\n    // Tests for offering & revoking signer capabilities\n    //\n\n    #[test(bob = @0x345)]\n    #[expected_failure(abort_code = 65544, location = Self)]\n    public entry fun test_invalid_offer_signer_capability(bob: signer) acquires Account {\n        let (_alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: borrow_global<Account>(alice_addr).sequence_number,\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let sig = ed25519::sign_struct(&_alice_sk, challenge);\n\n        // Maul the signature and make sure the call would fail\n        let invalid_signature = ed25519::signature_to_bytes(&sig);\n        let first_sig_byte = vector::borrow_mut(&mut invalid_signature, 0);\n        *first_sig_byte = *first_sig_byte ^ 1;\n\n        offer_signer_capability(&alice, invalid_signature, 0, alice_pk_bytes, bob_addr);\n    }\n\n    #[test(bob = @0x345)]\n    public entry fun test_valid_check_signer_capability_and_create_authorized_signer(bob: signer) acquires Account {\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: borrow_global<Account>(alice_addr).sequence_number,\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_signer_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_signer_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_signer_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            bob_addr\n        );\n\n        assert!(option::contains(&borrow_global<Account>(alice_addr).signer_capability_offer.for, &bob_addr), 0);\n\n        let signer = create_authorized_signer(&bob, alice_addr);\n        assert!(signer::address_of(&signer) == signer::address_of(&alice), 0);\n    }\n\n    #[test(bob = @0x345)]\n    public entry fun test_get_signer_cap_and_is_signer_cap(bob: signer) acquires Account {\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: borrow_global<Account>(alice_addr).sequence_number,\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_signer_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_signer_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_signer_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            bob_addr\n        );\n\n        assert!(is_signer_capability_offered(alice_addr), 0);\n        assert!(get_signer_capability_offer_for(alice_addr) == bob_addr, 0);\n    }\n\n\n    #[test(bob = @0x345, charlie = @0x567)]\n    #[expected_failure(abort_code = 393230, location = Self)]\n    public entry fun test_invalid_check_signer_capability_and_create_authorized_signer(\n        bob: signer,\n        charlie: signer\n    ) acquires Account {\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: borrow_global<Account>(alice_addr).sequence_number,\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_signer_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_signer_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_signer_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            bob_addr\n        );\n\n        let alice_account_resource = borrow_global_mut<Account>(alice_addr);\n        assert!(option::contains(&alice_account_resource.signer_capability_offer.for, &bob_addr), 0);\n\n        create_authorized_signer(&charlie, alice_addr);\n    }\n\n    #[test(bob = @0x345)]\n    public entry fun test_valid_revoke_signer_capability(bob: signer) acquires Account {\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: borrow_global<Account>(alice_addr).sequence_number,\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_signer_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_signer_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_signer_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            bob_addr\n        );\n        revoke_signer_capability(&alice, bob_addr);\n    }\n\n    #[test(bob = @0x345, charlie = @0x567)]\n    #[expected_failure(abort_code = 393230, location = Self)]\n    public entry fun test_invalid_revoke_signer_capability(bob: signer, charlie: signer) acquires Account {\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n        let alice_account_resource = borrow_global<Account>(alice_addr);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let charlie_addr = signer::address_of(&charlie);\n        create_account(charlie_addr);\n\n        let challenge = SignerCapabilityOfferProofChallengeV2 {\n            sequence_number: alice_account_resource.sequence_number,\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n        let alice_signer_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n        offer_signer_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_signer_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            bob_addr\n        );\n        revoke_signer_capability(&alice, charlie_addr);\n    }\n\n    //\n    // Tests for offering rotation capabilities\n    //\n    #[test(bob = @0x345, framework = @aptos_framework)]\n    public entry fun test_valid_offer_rotation_capability(bob: signer, framework: signer) acquires Account {\n        chain_id::initialize_for_test(&framework, 4);\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = RotationCapabilityOfferProofChallengeV2 {\n            chain_id: chain_id::get(),\n            sequence_number: get_sequence_number(alice_addr),\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_rotation_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_rotation_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_rotation_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            bob_addr\n        );\n\n        let alice_resource = borrow_global_mut<Account>(signer::address_of(&alice));\n        assert!(option::contains(&alice_resource.rotation_capability_offer.for, &bob_addr), 0);\n    }\n\n    #[test(bob = @0x345, framework = @aptos_framework)]\n    #[expected_failure(abort_code = 65544, location = Self)]\n    public entry fun test_invalid_offer_rotation_capability(bob: signer, framework: signer) acquires Account {\n        chain_id::initialize_for_test(&framework, 4);\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = RotationCapabilityOfferProofChallengeV2 {\n            chain_id: chain_id::get(),\n            // Intentionally make the signature invalid.\n            sequence_number: 2,\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_rotation_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_rotation_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_rotation_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            signer::address_of(&bob)\n        );\n    }\n\n    #[test(bob = @0x345, framework = @aptos_framework)]\n    public entry fun test_valid_revoke_rotation_capability(bob: signer, framework: signer) acquires Account {\n        chain_id::initialize_for_test(&framework, 4);\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n\n        let challenge = RotationCapabilityOfferProofChallengeV2 {\n            chain_id: chain_id::get(),\n            sequence_number: get_sequence_number(alice_addr),\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_rotation_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_rotation_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_rotation_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            signer::address_of(&bob)\n        );\n        revoke_rotation_capability(&alice, signer::address_of(&bob));\n    }\n\n    #[test(bob = @0x345, charlie = @0x567, framework = @aptos_framework)]\n    #[expected_failure(abort_code = 393234, location = Self)]\n    public entry fun test_invalid_revoke_rotation_capability(\n        bob: signer,\n        charlie: signer,\n        framework: signer\n    ) acquires Account {\n        chain_id::initialize_for_test(&framework, 4);\n        let (alice_sk, alice_pk) = ed25519::generate_keys();\n        let alice_pk_bytes = ed25519::validated_public_key_to_bytes(&alice_pk);\n        let alice = create_account_from_ed25519_public_key(alice_pk_bytes);\n        let alice_addr = signer::address_of(&alice);\n\n        let bob_addr = signer::address_of(&bob);\n        create_account(bob_addr);\n        create_account(signer::address_of(&charlie));\n\n        let challenge = RotationCapabilityOfferProofChallengeV2 {\n            chain_id: chain_id::get(),\n            sequence_number: get_sequence_number(alice_addr),\n            source_address: alice_addr,\n            recipient_address: bob_addr,\n        };\n\n        let alice_rotation_capability_offer_sig = ed25519::sign_struct(&alice_sk, challenge);\n\n        offer_rotation_capability(\n            &alice,\n            ed25519::signature_to_bytes(&alice_rotation_capability_offer_sig),\n            0,\n            alice_pk_bytes,\n            signer::address_of(&bob)\n        );\n        revoke_rotation_capability(&alice, signer::address_of(&charlie));\n    }\n\n    //\n    // Tests for key rotation\n    //\n\n    #[test(account = @aptos_framework)]\n    public entry fun test_valid_rotate_authentication_key_multi_ed25519_to_multi_ed25519(\n        account: signer\n    ) acquires Account, OriginatingAddress {\n        initialize(&account);\n        let (curr_sk, curr_pk) = multi_ed25519::generate_keys(2, 3);\n        let curr_pk_unvalidated = multi_ed25519::public_key_to_unvalidated(&curr_pk);\n        let curr_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&curr_pk_unvalidated);\n        let alice_addr = from_bcs::to_address(curr_auth_key);\n        let alice = create_account_unchecked(alice_addr);\n\n        let (new_sk, new_pk) = multi_ed25519::generate_keys(4, 5);\n        let new_pk_unvalidated = multi_ed25519::public_key_to_unvalidated(&new_pk);\n        let new_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&new_pk_unvalidated);\n        let new_address = from_bcs::to_address(new_auth_key);\n\n        let challenge = RotationProofChallenge {\n            sequence_number: borrow_global<Account>(alice_addr).sequence_number,\n            originator: alice_addr,\n            current_auth_key: alice_addr,\n            new_public_key: multi_ed25519::unvalidated_public_key_to_bytes(&new_pk_unvalidated),\n        };\n\n        let from_sig = multi_ed25519::sign_struct(&curr_sk, challenge);\n        let to_sig = multi_ed25519::sign_struct(&new_sk, challenge);\n\n        rotate_authentication_key(\n            &alice,\n            MULTI_ED25519_SCHEME,\n            multi_ed25519::unvalidated_public_key_to_bytes(&curr_pk_unvalidated),\n            MULTI_ED25519_SCHEME,\n            multi_ed25519::unvalidated_public_key_to_bytes(&new_pk_unvalidated),\n            multi_ed25519::signature_to_bytes(&from_sig),\n            multi_ed25519::signature_to_bytes(&to_sig),\n        );\n        let address_map = &mut borrow_global_mut<OriginatingAddress>(@aptos_framework).address_map;\n        let expected_originating_address = table::borrow(address_map, new_address);\n        assert!(*expected_originating_address == alice_addr, 0);\n        assert!(borrow_global<Account>(alice_addr).authentication_key == new_auth_key, 0);\n    }\n\n    #[test(account = @aptos_framework)]\n    public entry fun test_valid_rotate_authentication_key_multi_ed25519_to_ed25519(\n        account: signer\n    ) acquires Account, OriginatingAddress {\n        initialize(&account);\n\n        let (curr_sk, curr_pk) = multi_ed25519::generate_keys(2, 3);\n        let curr_pk_unvalidated = multi_ed25519::public_key_to_unvalidated(&curr_pk);\n        let curr_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&curr_pk_unvalidated);\n        let alice_addr = from_bcs::to_address(curr_auth_key);\n        let alice = create_account_unchecked(alice_addr);\n\n        let account_resource = borrow_global_mut<Account>(alice_addr);\n\n        let (new_sk, new_pk) = ed25519::generate_keys();\n        let new_pk_unvalidated = ed25519::public_key_to_unvalidated(&new_pk);\n        let new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&new_pk_unvalidated);\n        let new_addr = from_bcs::to_address(new_auth_key);\n\n        let challenge = RotationProofChallenge {\n            sequence_number: account_resource.sequence_number,\n            originator: alice_addr,\n            current_auth_key: alice_addr,\n            new_public_key: ed25519::unvalidated_public_key_to_bytes(&new_pk_unvalidated),\n        };\n\n        let from_sig = multi_ed25519::sign_struct(&curr_sk, challenge);\n        let to_sig = ed25519::sign_struct(&new_sk, challenge);\n\n        rotate_authentication_key(\n            &alice,\n            MULTI_ED25519_SCHEME,\n            multi_ed25519::unvalidated_public_key_to_bytes(&curr_pk_unvalidated),\n            ED25519_SCHEME,\n            ed25519::unvalidated_public_key_to_bytes(&new_pk_unvalidated),\n            multi_ed25519::signature_to_bytes(&from_sig),\n            ed25519::signature_to_bytes(&to_sig),\n        );\n\n        let address_map = &mut borrow_global_mut<OriginatingAddress>(@aptos_framework).address_map;\n        let expected_originating_address = table::borrow(address_map, new_addr);\n        assert!(*expected_originating_address == alice_addr, 0);\n        assert!(borrow_global<Account>(alice_addr).authentication_key == new_auth_key, 0);\n    }\n\n\n    #[test(account = @aptos_framework)]\n    public entry fun test_simple_rotation(account: &signer) acquires Account {\n        initialize(account);\n\n        let alice_addr = @0x1234;\n        let alice = create_account_unchecked(alice_addr);\n\n        let (_new_sk, new_pk) = ed25519::generate_keys();\n        let new_pk_unvalidated = ed25519::public_key_to_unvalidated(&new_pk);\n        let new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&new_pk_unvalidated);\n        let _new_addr = from_bcs::to_address(new_auth_key);\n\n        rotate_authentication_key_call(&alice, new_auth_key);\n        assert!(borrow_global<Account>(alice_addr).authentication_key == new_auth_key, 0);\n    }\n\n\n    #[test(account = @aptos_framework)]\n    #[expected_failure(abort_code = 0x20014, location = Self)]\n    public entry fun test_max_guid(account: &signer) acquires Account {\n        let addr = signer::address_of(account);\n        create_account_unchecked(addr);\n        let account_state = borrow_global_mut<Account>(addr);\n        account_state.guid_creation_num = MAX_GUID_CREATION_NUM - 1;\n        create_guid(account);\n    }\n\n    #[test_only]\n    struct FakeCoin {}\n\n    #[test_only]\n    struct SadFakeCoin {}\n\n    #[test(account = @0x1234)]\n    fun test_events(account: &signer) acquires Account {\n        let addr = signer::address_of(account);\n        create_account_unchecked(addr);\n        register_coin<FakeCoin>(addr);\n\n        let eventhandle = &borrow_global<Account>(addr).coin_register_events;\n        let event = CoinRegisterEvent { type_info: type_info::type_of<FakeCoin>() };\n\n        let events = event::emitted_events_by_handle(eventhandle);\n        assert!(vector::length(&events) == 1, 0);\n        assert!(vector::borrow(&events, 0) == &event, 1);\n        assert!(event::was_event_emitted_by_handle(eventhandle, &event), 2);\n\n        let event = CoinRegisterEvent { type_info: type_info::type_of<SadFakeCoin>() };\n        assert!(!event::was_event_emitted_by_handle(eventhandle, &event), 3);\n    }\n}\n","name":"account.move"},{"content":"/// This module provides an interface for aggregators. Aggregators are similar to\n/// unsigned integers and support addition and subtraction (aborting on underflow\n/// or on overflowing a custom upper limit). The difference from integers is that\n/// aggregators allow to perform both additions and subtractions in parallel across\n/// multiple transactions, enabling parallel execution. For example, if the first\n/// transaction is doing `add(X, 1)` for aggregator resource `X`, and the second\n/// is doing `sub(X,3)`, they can be executed in parallel avoiding a read-modify-write\n/// dependency.\n/// However, reading the aggregator value (i.e. calling `read(X)`) is an expensive\n/// operation and should be avoided as much as possible because it reduces the\n/// parallelism. Moreover, **aggregators can only be created by Aptos Framework (0x1)\n/// at the moment.**\nmodule aptos_framework::aggregator {\n\n    /// The value of aggregator overflows. Raised by native code.\n    const EAGGREGATOR_OVERFLOW: u64 = 1;\n\n    /// The value of aggregator underflows (goes below zero). Raised by native code.\n    const EAGGREGATOR_UNDERFLOW: u64 = 2;\n\n    /// Aggregator feature is not supported. Raised by native code.\n    const ENOT_SUPPORTED: u64 = 3;\n\n    /// Represents an integer which supports parallel additions and subtractions\n    /// across multiple transactions. See the module description for more details.\n    struct Aggregator has store {\n        handle: address,\n        key: address,\n        limit: u128,\n    }\n\n    /// Returns `limit` exceeding which aggregator overflows.\n    public fun limit(aggregator: &Aggregator): u128 {\n        aggregator.limit\n    }\n\n    /// Adds `value` to aggregator. Aborts on overflowing the limit.\n    public native fun add(aggregator: &mut Aggregator, value: u128);\n\n    /// Subtracts `value` from aggregator. Aborts on going below zero.\n    public native fun sub(aggregator: &mut Aggregator, value: u128);\n\n    /// Returns a value stored in this aggregator.\n    public native fun read(aggregator: &Aggregator): u128;\n\n    /// Destroys an aggregator and removes it from its `AggregatorFactory`.\n    public native fun destroy(aggregator: Aggregator);\n}\n","name":"aggregator.move"},{"content":"/// This module provides foundations to create aggregators. Currently only\n/// Aptos Framework (0x1) can create them, so this module helps to wrap\n/// the constructor of `Aggregator` struct so that only a system account\n/// can initialize one. In the future, this might change and aggregators\n/// can be enabled for the public.\nmodule aptos_framework::aggregator_factory {\n    use std::error;\n\n    use aptos_framework::system_addresses;\n    use aptos_framework::aggregator::Aggregator;\n    use aptos_std::table::{Self, Table};\n\n    friend aptos_framework::genesis;\n    friend aptos_framework::optional_aggregator;\n\n    /// Aggregator factory is not published yet.\n    const EAGGREGATOR_FACTORY_NOT_FOUND: u64 = 1;\n\n    /// Creates new aggregators. Used to control the numbers of aggregators in the\n    /// system and who can create them. At the moment, only Aptos Framework (0x1)\n    /// account can.\n    struct AggregatorFactory has key {\n        phantom_table: Table<address, u128>,\n    }\n\n    /// Creates a new factory for aggregators. Can only be called during genesis.\n    public(friend) fun initialize_aggregator_factory(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        let aggregator_factory = AggregatorFactory {\n            phantom_table: table::new()\n        };\n        move_to(aptos_framework, aggregator_factory);\n    }\n\n    /// Creates a new aggregator instance which overflows on exceeding a `limit`.\n    public(friend) fun create_aggregator_internal(limit: u128): Aggregator acquires AggregatorFactory {\n        assert!(\n            exists<AggregatorFactory>(@aptos_framework),\n            error::not_found(EAGGREGATOR_FACTORY_NOT_FOUND)\n        );\n\n        let aggregator_factory = borrow_global_mut<AggregatorFactory>(@aptos_framework);\n        new_aggregator(aggregator_factory, limit)\n    }\n\n    /// This is currently a function closed for public. This can be updated in the future by on-chain governance\n    /// to allow any signer to call.\n    public fun create_aggregator(account: &signer, limit: u128): Aggregator acquires AggregatorFactory {\n        // Only Aptos Framework (0x1) account can call this for now.\n        system_addresses::assert_aptos_framework(account);\n        create_aggregator_internal(limit)\n    }\n\n    /// Returns a new aggregator.\n    native fun new_aggregator(aggregator_factory: &mut AggregatorFactory, limit: u128): Aggregator;\n\n    #[test_only]\n    public fun initialize_aggregator_factory_for_test(aptos_framework: &signer) {\n        initialize_aggregator_factory(aptos_framework);\n    }\n\n    #[test_only]\n    public fun aggregator_factory_exists_for_testing(): bool {\n        exists<AggregatorFactory>(@aptos_framework)\n    }\n}\n","name":"aggregator_factory.move"},{"content":"/// This module provides an interface to aggregate integers either via\n/// aggregator (parallelizable) or via normal integers.\nmodule aptos_framework::optional_aggregator {\n    use std::error;\n    use std::option::{Self, Option};\n\n    use aptos_framework::aggregator_factory;\n    use aptos_framework::aggregator::{Self, Aggregator};\n\n    friend aptos_framework::coin;\n    friend aptos_framework::fungible_asset;\n\n    /// The value of aggregator underflows (goes below zero). Raised by native code.\n    const EAGGREGATOR_OVERFLOW: u64 = 1;\n\n    /// Aggregator feature is not supported. Raised by native code.\n    const EAGGREGATOR_UNDERFLOW: u64 = 2;\n\n    /// Wrapper around integer with a custom overflow limit. Supports add, subtract and read just like `Aggregator`.\n    struct Integer has store {\n        value: u128,\n        limit: u128,\n    }\n\n    /// Creates a new integer which overflows on exceeding a `limit`.\n    fun new_integer(limit: u128): Integer {\n        Integer {\n            value: 0,\n            limit,\n        }\n    }\n\n    /// Adds `value` to integer. Aborts on overflowing the limit.\n    fun add_integer(integer: &mut Integer, value: u128) {\n        assert!(\n            value <= (integer.limit - integer.value),\n            error::out_of_range(EAGGREGATOR_OVERFLOW)\n        );\n        integer.value = integer.value + value;\n    }\n\n    /// Subtracts `value` from integer. Aborts on going below zero.\n    fun sub_integer(integer: &mut Integer, value: u128) {\n        assert!(value <= integer.value, error::out_of_range(EAGGREGATOR_UNDERFLOW));\n        integer.value = integer.value - value;\n    }\n\n    /// Returns an overflow limit of integer.\n    fun limit(integer: &Integer): u128 {\n        integer.limit\n    }\n\n    /// Returns a value stored in this integer.\n    fun read_integer(integer: &Integer): u128 {\n        integer.value\n    }\n\n    /// Destroys an integer.\n    fun destroy_integer(integer: Integer) {\n        let Integer { value: _, limit: _ } = integer;\n    }\n\n    /// Contains either an aggregator or a normal integer, both overflowing on limit.\n    struct OptionalAggregator has store {\n        // Parallelizable.\n        aggregator: Option<Aggregator>,\n        // Non-parallelizable.\n        integer: Option<Integer>,\n    }\n\n    /// Creates a new optional aggregator.\n    public(friend) fun new(limit: u128, parallelizable: bool): OptionalAggregator {\n        if (parallelizable) {\n            OptionalAggregator {\n                aggregator: option::some(aggregator_factory::create_aggregator_internal(limit)),\n                integer: option::none(),\n            }\n        } else {\n            OptionalAggregator {\n                aggregator: option::none(),\n                integer: option::some(new_integer(limit)),\n            }\n        }\n    }\n\n    /// Switches between parallelizable and non-parallelizable implementations.\n    public fun switch(optional_aggregator: &mut OptionalAggregator) {\n        let value = read(optional_aggregator);\n        switch_and_zero_out(optional_aggregator);\n        add(optional_aggregator, value);\n    }\n\n    /// Switches between parallelizable and non-parallelizable implementations, setting\n    /// the value of the new optional aggregator to zero.\n    fun switch_and_zero_out(optional_aggregator: &mut OptionalAggregator) {\n        if (is_parallelizable(optional_aggregator)) {\n            switch_to_integer_and_zero_out(optional_aggregator);\n        } else {\n            switch_to_aggregator_and_zero_out(optional_aggregator);\n        }\n    }\n\n    /// Switches from parallelizable to non-parallelizable implementation, zero-initializing\n    /// the value.\n    fun switch_to_integer_and_zero_out(\n        optional_aggregator: &mut OptionalAggregator\n    ): u128 {\n        let aggregator = option::extract(&mut optional_aggregator.aggregator);\n        let limit = aggregator::limit(&aggregator);\n        aggregator::destroy(aggregator);\n        let integer = new_integer(limit);\n        option::fill(&mut optional_aggregator.integer, integer);\n        limit\n    }\n\n    /// Switches from non-parallelizable to parallelizable implementation, zero-initializing\n    /// the value.\n    fun switch_to_aggregator_and_zero_out(\n        optional_aggregator: &mut OptionalAggregator\n    ): u128 {\n        let integer = option::extract(&mut optional_aggregator.integer);\n        let limit = limit(&integer);\n        destroy_integer(integer);\n        let aggregator = aggregator_factory::create_aggregator_internal(limit);\n        option::fill(&mut optional_aggregator.aggregator, aggregator);\n        limit\n    }\n\n    /// Destroys optional aggregator.\n    public fun destroy(optional_aggregator: OptionalAggregator) {\n        if (is_parallelizable(&optional_aggregator)) {\n            destroy_optional_aggregator(optional_aggregator);\n        } else {\n            destroy_optional_integer(optional_aggregator);\n        }\n    }\n\n    /// Destroys parallelizable optional aggregator and returns its limit.\n    fun destroy_optional_aggregator(optional_aggregator: OptionalAggregator): u128 {\n        let OptionalAggregator { aggregator, integer } = optional_aggregator;\n        let limit = aggregator::limit(option::borrow(&aggregator));\n        aggregator::destroy(option::destroy_some(aggregator));\n        option::destroy_none(integer);\n        limit\n    }\n\n    /// Destroys non-parallelizable optional aggregator and returns its limit.\n    fun destroy_optional_integer(optional_aggregator: OptionalAggregator): u128 {\n        let OptionalAggregator { aggregator, integer } = optional_aggregator;\n        let limit = limit(option::borrow(&integer));\n        destroy_integer(option::destroy_some(integer));\n        option::destroy_none(aggregator);\n        limit\n    }\n\n    /// Adds `value` to optional aggregator, aborting on exceeding the `limit`.\n    public fun add(optional_aggregator: &mut OptionalAggregator, value: u128) {\n        if (option::is_some(&optional_aggregator.aggregator)) {\n            let aggregator = option::borrow_mut(&mut optional_aggregator.aggregator);\n            aggregator::add(aggregator, value);\n        } else {\n            let integer = option::borrow_mut(&mut optional_aggregator.integer);\n            add_integer(integer, value);\n        }\n    }\n\n    /// Subtracts `value` from optional aggregator, aborting on going below zero.\n    public fun sub(optional_aggregator: &mut OptionalAggregator, value: u128) {\n        if (option::is_some(&optional_aggregator.aggregator)) {\n            let aggregator = option::borrow_mut(&mut optional_aggregator.aggregator);\n            aggregator::sub(aggregator, value);\n        } else {\n            let integer = option::borrow_mut(&mut optional_aggregator.integer);\n            sub_integer(integer, value);\n        }\n    }\n\n    /// Returns the value stored in optional aggregator.\n    public fun read(optional_aggregator: &OptionalAggregator): u128 {\n        if (option::is_some(&optional_aggregator.aggregator)) {\n            let aggregator = option::borrow(&optional_aggregator.aggregator);\n            aggregator::read(aggregator)\n        } else {\n            let integer = option::borrow(&optional_aggregator.integer);\n            read_integer(integer)\n        }\n    }\n\n    /// Returns true if optional aggregator uses parallelizable implementation.\n    public fun is_parallelizable(optional_aggregator: &OptionalAggregator): bool {\n        option::is_some(&optional_aggregator.aggregator)\n    }\n\n    #[test(account = @aptos_framework)]\n    fun optional_aggregator_test(account: signer) {\n        aggregator_factory::initialize_aggregator_factory(&account);\n\n        let aggregator = new(30, false);\n        assert!(!is_parallelizable(&aggregator), 0);\n\n        add(&mut aggregator, 12);\n        add(&mut aggregator, 3);\n        assert!(read(&aggregator) == 15, 0);\n\n        sub(&mut aggregator, 10);\n        assert!(read(&aggregator) == 5, 0);\n\n        // Switch to parallelizable aggregator and check the value is preserved.\n        switch(&mut aggregator);\n        assert!(is_parallelizable(&aggregator), 0);\n        assert!(read(&aggregator) == 5, 0);\n\n        add(&mut aggregator, 12);\n        add(&mut aggregator, 3);\n        assert!(read(&aggregator) == 20, 0);\n\n        sub(&mut aggregator, 10);\n        assert!(read(&aggregator) == 10, 0);\n\n        // Switch back!\n        switch(&mut aggregator);\n        assert!(!is_parallelizable(&aggregator), 0);\n        assert!(read(&aggregator) == 10, 0);\n\n        destroy(aggregator);\n    }\n\n    #[test(account = @aptos_framework)]\n    fun optional_aggregator_destroy_test(account: signer) {\n        aggregator_factory::initialize_aggregator_factory(&account);\n\n        let aggregator = new(30, false);\n        destroy(aggregator);\n\n        let aggregator = new(30, true);\n        destroy(aggregator);\n\n        let aggregator = new(12, false);\n        assert!(destroy_optional_integer(aggregator) == 12, 0);\n\n        let aggregator = new(21, true);\n        assert!(destroy_optional_aggregator(aggregator) == 21, 0);\n    }\n\n    #[test(account = @aptos_framework)]\n    #[expected_failure(abort_code = 0x020001, location = Self)]\n    fun non_parallelizable_aggregator_overflow_test(account: signer) {\n        aggregator_factory::initialize_aggregator_factory(&account);\n        let aggregator = new(15, false);\n\n        // Overflow!\n        add(&mut aggregator, 16);\n\n        destroy(aggregator);\n    }\n\n    #[test(account = @aptos_framework)]\n    #[expected_failure(abort_code = 0x020002, location = Self)]\n    fun non_parallelizable_aggregator_underflow_test(account: signer) {\n        aggregator_factory::initialize_aggregator_factory(&account);\n        let aggregator = new(100, false);\n\n        // Underflow!\n        sub(&mut aggregator, 100);\n        add(&mut aggregator, 100);\n\n        destroy(aggregator);\n    }\n\n    #[test(account = @aptos_framework)]\n    #[expected_failure(abort_code = 0x020001, location = aptos_framework::aggregator)]\n    fun parallelizable_aggregator_overflow_test(account: signer) {\n        aggregator_factory::initialize_aggregator_factory(&account);\n        let aggregator = new(15, true);\n\n        // Overflow!\n        add(&mut aggregator, 16);\n\n        destroy(aggregator);\n    }\n\n    #[test(account = @aptos_framework)]\n    #[expected_failure(abort_code = 0x020002, location = aptos_framework::aggregator)]\n    fun parallelizable_aggregator_underflow_test(account: signer) {\n        aggregator_factory::initialize_aggregator_factory(&account);\n        let aggregator = new(100, true);\n\n        // Underflow!\n        add(&mut aggregator, 99);\n        sub(&mut aggregator, 100);\n        add(&mut aggregator, 100);\n\n        destroy(aggregator);\n    }\n}\n","name":"optional_aggregator.move"},{"content":"/// This module provides an interface for aggregators (version 2). Aggregators are\n/// similar to unsigned integers and support addition and subtraction (aborting on\n/// underflow or on overflowing a custom upper limit). The difference from integers\n/// is that aggregators allow to perform both additions and subtractions in parallel\n/// across multiple transactions, enabling parallel execution. For example, if the\n/// first transaction is doing `try_add(X, 1)` for aggregator `X`, and the second is\n/// doing `try_sub(X,3)`, they can be executed in parallel avoiding a read-modify-write\n/// dependency.\n/// However, reading the aggregator value (i.e. calling `read(X)`) is a resource-intensive\n/// operation that also reduced parallelism, and should be avoided as much as possible.\nmodule aptos_framework::aggregator_v2 {\n    use std::error;\n    use std::string::String;\n\n    /// The value of aggregator overflows. Raised by uncoditional add() call\n    const EAGGREGATOR_OVERFLOW: u64 = 1;\n\n    /// The value of aggregator underflows (goes below zero). Raised by uncoditional sub() call\n    const EAGGREGATOR_UNDERFLOW: u64 = 2;\n\n    /// The generic type supplied to the aggregator snapshot is not supported.\n    const EUNSUPPORTED_AGGREGATOR_SNAPSHOT_TYPE: u64 = 5;\n\n    /// The aggregator api v2 feature flag is not enabled.\n    const EAGGREGATOR_API_V2_NOT_ENABLED: u64 = 6;\n\n    /// The generic type supplied to the aggregator is not supported.\n    const EUNSUPPORTED_AGGREGATOR_TYPE: u64 = 7;\n\n    /// Arguments passed to concat exceed max limit of 256 bytes (for prefix and suffix together).\n    const ECONCAT_STRING_LENGTH_TOO_LARGE: u64 = 8;\n\n    /// The native aggregator function, that is in the move file, is not yet supported.\n    /// and any calls will raise this error.\n    const EAGGREGATOR_FUNCTION_NOT_YET_SUPPORTED: u64 = 9;\n\n    /// Represents an integer which supports parallel additions and subtractions\n    /// across multiple transactions. See the module description for more details.\n    ///\n    /// Currently supported types for IntElement are u64 and u128.\n    struct Aggregator<IntElement> has store, drop {\n        value: IntElement,\n        max_value: IntElement,\n    }\n\n    /// Represents a constant value, that was derived from an aggregator at given instant in time.\n    /// Unlike read() and storing the value directly, this enables parallel execution of transactions,\n    /// while storing snapshot of aggregator state elsewhere.\n    struct AggregatorSnapshot<IntElement> has store, drop {\n        value: IntElement,\n    }\n\n    struct DerivedStringSnapshot has store, drop {\n        value: String,\n        padding: vector<u8>,\n    }\n\n    /// Returns `max_value` exceeding which aggregator overflows.\n    public fun max_value<IntElement: copy + drop>(aggregator: &Aggregator<IntElement>): IntElement {\n        aggregator.max_value\n    }\n\n    /// Creates new aggregator, with given 'max_value'.\n    ///\n    /// Currently supported types for IntElement are u64 and u128.\n    /// EAGGREGATOR_ELEMENT_TYPE_NOT_SUPPORTED raised if called with a different type.\n    public native fun create_aggregator<IntElement: copy + drop>(max_value: IntElement): Aggregator<IntElement>;\n\n    /// Creates new aggregator, without any 'max_value' on top of the implicit bound restriction\n    /// due to the width of the type (i.e. MAX_U64 for u64, MAX_U128 for u128).\n    ///\n    /// Currently supported types for IntElement are u64 and u128.\n    /// EAGGREGATOR_ELEMENT_TYPE_NOT_SUPPORTED raised if called with a different type.\n    public native fun create_unbounded_aggregator<IntElement: copy + drop>(): Aggregator<IntElement>;\n\n    /// Adds `value` to aggregator.\n    /// If addition would exceed the max_value, `false` is returned, and aggregator value is left unchanged.\n    public native fun try_add<IntElement>(aggregator: &mut Aggregator<IntElement>, value: IntElement): bool;\n\n    // Adds `value` to aggregator, uncoditionally.\n    // If addition would exceed the max_value, EAGGREGATOR_OVERFLOW exception will be thrown.\n    public fun add<IntElement>(aggregator: &mut Aggregator<IntElement>, value: IntElement) {\n        assert!(try_add(aggregator, value), error::out_of_range(EAGGREGATOR_OVERFLOW));\n    }\n\n    /// Subtracts `value` from aggregator.\n    /// If subtraction would result in a negative value, `false` is returned, and aggregator value is left unchanged.\n    public native fun try_sub<IntElement>(aggregator: &mut Aggregator<IntElement>, value: IntElement): bool;\n\n    // Subtracts `value` to aggregator, uncoditionally.\n    // If subtraction would result in a negative value, EAGGREGATOR_UNDERFLOW exception will be thrown.\n    public fun sub<IntElement>(aggregator: &mut Aggregator<IntElement>, value: IntElement) {\n        assert!(try_sub(aggregator, value), error::out_of_range(EAGGREGATOR_UNDERFLOW));\n    }\n\n    /// Returns a value stored in this aggregator.\n    /// Note: This operation is resource-intensive, and reduces parallelism.\n    /// (Especially if called in a transaction that also modifies the aggregator,\n    /// or has other read/write conflicts)\n    public native fun read<IntElement>(aggregator: &Aggregator<IntElement>): IntElement;\n\n    /// Returns a wrapper of a current value of an aggregator\n    /// Unlike read(), it is fast and avoids sequential dependencies.\n    public native fun snapshot<IntElement>(aggregator: &Aggregator<IntElement>): AggregatorSnapshot<IntElement>;\n\n    /// Creates a snapshot of a given value.\n    /// Useful for when object is sometimes created via snapshot() or string_concat(), and sometimes directly.\n    public native fun create_snapshot<IntElement: copy + drop>(value: IntElement): AggregatorSnapshot<IntElement>;\n\n    /// Returns a value stored in this snapshot.\n    /// Note: This operation is resource-intensive, and reduces parallelism.\n    /// (Especially if called in a transaction that also modifies the aggregator,\n    /// or has other read/write conflicts)\n    public native fun read_snapshot<IntElement>(snapshot: &AggregatorSnapshot<IntElement>): IntElement;\n\n    /// Returns a value stored in this DerivedStringSnapshot.\n    /// Note: This operation is resource-intensive, and reduces parallelism.\n    /// (Especially if called in a transaction that also modifies the aggregator,\n    /// or has other read/write conflicts)\n    public native fun read_derived_string(snapshot: &DerivedStringSnapshot): String;\n\n    /// Creates a DerivedStringSnapshot of a given value.\n    /// Useful for when object is sometimes created via string_concat(), and sometimes directly.\n    public native fun create_derived_string(value: String): DerivedStringSnapshot;\n\n    /// Concatenates `before`, `snapshot` and `after` into a single string.\n    /// snapshot passed needs to have integer type - currently supported types are u64 and u128.\n    /// Raises EUNSUPPORTED_AGGREGATOR_SNAPSHOT_TYPE if called with another type.\n    /// If length of prefix and suffix together exceed 256 bytes, ECONCAT_STRING_LENGTH_TOO_LARGE is raised.\n    public native fun derive_string_concat<IntElement>(before: String, snapshot: &AggregatorSnapshot<IntElement>, after: String): DerivedStringSnapshot;\n\n    // ===== DEPRECATE/NOT YET IMPLEMENTED ====\n\n    #[deprecated]\n    /// NOT YET IMPLEMENTED, always raises EAGGREGATOR_FUNCTION_NOT_YET_SUPPORTED.\n    public native fun copy_snapshot<IntElement: copy + drop>(snapshot: &AggregatorSnapshot<IntElement>): AggregatorSnapshot<IntElement>;\n\n    #[deprecated]\n    /// DEPRECATED, use derive_string_concat() instead. always raises EAGGREGATOR_FUNCTION_NOT_YET_SUPPORTED.\n    public native fun string_concat<IntElement>(before: String, snapshot: &AggregatorSnapshot<IntElement>, after: String): AggregatorSnapshot<String>;\n\n    // ========================================\n\n    #[test]\n    fun test_aggregator() {\n        let agg = create_aggregator(10);\n        assert!(try_add(&mut agg, 5), 1);\n        assert!(try_add(&mut agg, 5), 2);\n        assert!(read(&agg) == 10, 3);\n        assert!(!try_add(&mut agg, 5), 4);\n        assert!(read(&agg) == 10, 5);\n        assert!(try_sub(&mut agg, 5), 6);\n        assert!(read(&agg) == 5, 7);\n\n        let snap = snapshot(&agg);\n        assert!(try_add(&mut agg, 2), 8);\n        assert!(read(&agg) == 7, 9);\n        assert!(read_snapshot(&snap) == 5, 10);\n    }\n\n    #[test]\n    fun test_correct_read() {\n        let snapshot = create_snapshot(42);\n        assert!(read_snapshot(&snapshot) == 42, 0);\n\n        let derived = create_derived_string(std::string::utf8(b\"42\"));\n        assert!(read_derived_string(&derived) == std::string::utf8(b\"42\"), 0);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x030009, location = Self)]\n    fun test_copy_not_yet_supported() {\n        let snapshot = create_snapshot(42);\n        copy_snapshot(&snapshot);\n    }\n\n    #[test]\n    fun test_string_concat1() {\n        let snapshot = create_snapshot(42);\n        let derived = derive_string_concat(std::string::utf8(b\"before\"), &snapshot, std::string::utf8(b\"after\"));\n        assert!(read_derived_string(&derived) == std::string::utf8(b\"before42after\"), 0);\n    }\n\n    // Tests commented out, as flag used in rust cannot be disabled.\n\n    // #[test(fx = @std)]\n    // #[expected_failure(abort_code = 0x030006, location = Self)]\n    // fun test_snapshot_feature_not_enabled(fx: &signer) {\n    //     use std::features;\n    //     use aptos_framework::reconfiguration;\n    //     let feature = features::get_aggregator_v2_api_feature();\n    //     features::change_feature_flags(fx, vector[], vector[feature]);\n    //     reconfiguration::reconfigure_for_test();\n    //     create_snapshot(42);\n    // }\n\n    // #[test(fx = @std)]\n    // #[expected_failure(abort_code = 0x030006, location = Self)]\n    // fun test_aggregator_feature_not_enabled(fx: &signer) {\n    //     use std::features;\n    //     use aptos_framework::reconfiguration;\n    //     let feature = features::get_aggregator_v2_api_feature();\n    //     features::change_feature_flags(fx, vector[], vector[feature]);\n    //     reconfiguration::reconfigure_for_test();\n    //     create_aggregator(42);\n    // }\n\n    #[test]\n    #[expected_failure(abort_code = 0x030007, location = Self)]\n    fun test_aggregator_invalid_type1() {\n        create_unbounded_aggregator<u8>();\n    }\n\n    #[test]\n    fun test_aggregator_valid_type() {\n        create_unbounded_aggregator<u64>();\n        create_unbounded_aggregator<u128>();\n        create_aggregator<u64>(5);\n        create_aggregator<u128>(5);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x030005, location = Self)]\n    fun test_snpashot_invalid_type1() {\n        use std::option;\n        create_snapshot(option::some(42));\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x030005, location = Self)]\n    fun test_snpashot_invalid_type2() {\n        create_snapshot(vector[42]);\n    }\n}\n","name":"aggregator_v2.move"},{"content":"module aptos_framework::aptos_account {\n    use aptos_framework::account::{Self, new_event_handle};\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::coin::{Self, Coin};\n    use aptos_framework::create_signer::create_signer;\n    use aptos_framework::event::{EventHandle, emit_event, emit};\n    use std::error;\n    use std::signer;\n    use std::vector;\n\n    friend aptos_framework::genesis;\n    friend aptos_framework::resource_account;\n\n    /// Account does not exist.\n    const EACCOUNT_NOT_FOUND: u64 = 1;\n    /// Account is not registered to receive APT.\n    const EACCOUNT_NOT_REGISTERED_FOR_APT: u64 = 2;\n    /// Account opted out of receiving coins that they did not register to receive.\n    const EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS: u64 = 3;\n    /// Account opted out of directly receiving NFT tokens.\n    const EACCOUNT_DOES_NOT_ACCEPT_DIRECT_TOKEN_TRANSFERS: u64 = 4;\n    /// The lengths of the recipients and amounts lists don't match.\n    const EMISMATCHING_RECIPIENTS_AND_AMOUNTS_LENGTH: u64 = 5;\n\n    /// Configuration for whether an account can receive direct transfers of coins that they have not registered.\n    ///\n    /// By default, this is enabled. Users can opt-out by disabling at any time.\n    struct DirectTransferConfig has key {\n        allow_arbitrary_coin_transfers: bool,\n        update_coin_transfer_events: EventHandle<DirectCoinTransferConfigUpdatedEvent>,\n    }\n\n    /// Event emitted when an account's direct coins transfer config is updated.\n    struct DirectCoinTransferConfigUpdatedEvent has drop, store {\n        new_allow_direct_transfers: bool,\n    }\n\n    #[event]\n    struct DirectCoinTransferConfigUpdated has drop, store {\n        account: address,\n        new_allow_direct_transfers: bool,\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    /// Basic account creation methods.\n    ///////////////////////////////////////////////////////////////////////////\n\n    public entry fun create_account(auth_key: address) {\n        let signer = account::create_account(auth_key);\n        coin::register<AptosCoin>(&signer);\n    }\n\n    /// Batch version of APT transfer.\n    public entry fun batch_transfer(source: &signer, recipients: vector<address>, amounts: vector<u64>) {\n        let recipients_len = vector::length(&recipients);\n        assert!(\n            recipients_len == vector::length(&amounts),\n            error::invalid_argument(EMISMATCHING_RECIPIENTS_AND_AMOUNTS_LENGTH),\n        );\n\n        vector::enumerate_ref(&recipients, |i, to| {\n            let amount = *vector::borrow(&amounts, i);\n            transfer(source, *to, amount);\n        });\n    }\n\n    /// Convenient function to transfer APT to a recipient account that might not exist.\n    /// This would create the recipient account first, which also registers it to receive APT, before transferring.\n    public entry fun transfer(source: &signer, to: address, amount: u64) {\n        if (!account::exists_at(to)) {\n            create_account(to)\n        };\n        // Resource accounts can be created without registering them to receive APT.\n        // This conveniently does the registration if necessary.\n        if (!coin::is_account_registered<AptosCoin>(to)) {\n            coin::register<AptosCoin>(&create_signer(to));\n        };\n        coin::transfer<AptosCoin>(source, to, amount)\n    }\n\n    /// Batch version of transfer_coins.\n    public entry fun batch_transfer_coins<CoinType>(\n        from: &signer, recipients: vector<address>, amounts: vector<u64>) acquires DirectTransferConfig {\n        let recipients_len = vector::length(&recipients);\n        assert!(\n            recipients_len == vector::length(&amounts),\n            error::invalid_argument(EMISMATCHING_RECIPIENTS_AND_AMOUNTS_LENGTH),\n        );\n\n        vector::enumerate_ref(&recipients, |i, to| {\n            let amount = *vector::borrow(&amounts, i);\n            transfer_coins<CoinType>(from, *to, amount);\n        });\n    }\n\n    /// Convenient function to transfer a custom CoinType to a recipient account that might not exist.\n    /// This would create the recipient account first and register it to receive the CoinType, before transferring.\n    public entry fun transfer_coins<CoinType>(from: &signer, to: address, amount: u64) acquires DirectTransferConfig {\n        deposit_coins(to, coin::withdraw<CoinType>(from, amount));\n    }\n\n    /// Convenient function to deposit a custom CoinType into a recipient account that might not exist.\n    /// This would create the recipient account first and register it to receive the CoinType, before transferring.\n    public fun deposit_coins<CoinType>(to: address, coins: Coin<CoinType>) acquires DirectTransferConfig {\n        if (!account::exists_at(to)) {\n            create_account(to);\n            spec {\n                assert coin::spec_is_account_registered<AptosCoin>(to);\n                assume aptos_std::type_info::type_of<CoinType>() == aptos_std::type_info::type_of<AptosCoin>() ==>\n                    coin::spec_is_account_registered<CoinType>(to);\n            };\n        };\n        if (!coin::is_account_registered<CoinType>(to)) {\n            assert!(\n                can_receive_direct_coin_transfers(to),\n                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS),\n            );\n            coin::register<CoinType>(&create_signer(to));\n        };\n        coin::deposit<CoinType>(to, coins)\n    }\n\n    public fun assert_account_exists(addr: address) {\n        assert!(account::exists_at(addr), error::not_found(EACCOUNT_NOT_FOUND));\n    }\n\n    public fun assert_account_is_registered_for_apt(addr: address) {\n        assert_account_exists(addr);\n        assert!(coin::is_account_registered<AptosCoin>(addr), error::not_found(EACCOUNT_NOT_REGISTERED_FOR_APT));\n    }\n\n    /// Set whether `account` can receive direct transfers of coins that they have not explicitly registered to receive.\n    public entry fun set_allow_direct_coin_transfers(account: &signer, allow: bool) acquires DirectTransferConfig {\n        let addr = signer::address_of(account);\n        if (exists<DirectTransferConfig>(addr)) {\n            let direct_transfer_config = borrow_global_mut<DirectTransferConfig>(addr);\n            // Short-circuit to avoid emitting an event if direct transfer config is not changing.\n            if (direct_transfer_config.allow_arbitrary_coin_transfers == allow) {\n                return\n            };\n\n            direct_transfer_config.allow_arbitrary_coin_transfers = allow;\n\n            if (std::features::module_event_migration_enabled()) {\n                emit(DirectCoinTransferConfigUpdated { account: addr, new_allow_direct_transfers: allow });\n            };\n            emit_event(\n                &mut direct_transfer_config.update_coin_transfer_events,\n                DirectCoinTransferConfigUpdatedEvent { new_allow_direct_transfers: allow });\n        } else {\n            let direct_transfer_config = DirectTransferConfig {\n                allow_arbitrary_coin_transfers: allow,\n                update_coin_transfer_events: new_event_handle<DirectCoinTransferConfigUpdatedEvent>(account),\n            };\n            if (std::features::module_event_migration_enabled()) {\n                emit(DirectCoinTransferConfigUpdated { account: addr, new_allow_direct_transfers: allow });\n            };\n            emit_event(\n                &mut direct_transfer_config.update_coin_transfer_events,\n                DirectCoinTransferConfigUpdatedEvent { new_allow_direct_transfers: allow });\n            move_to(account, direct_transfer_config);\n        };\n    }\n\n    #[view]\n    /// Return true if `account` can receive direct transfers of coins that they have not explicitly registered to\n    /// receive.\n    ///\n    /// By default, this returns true if an account has not explicitly set whether the can receive direct transfers.\n    public fun can_receive_direct_coin_transfers(account: address): bool acquires DirectTransferConfig {\n        !exists<DirectTransferConfig>(account) ||\n            borrow_global<DirectTransferConfig>(account).allow_arbitrary_coin_transfers\n    }\n\n    #[test_only]\n    use aptos_std::from_bcs;\n    #[test_only]\n    use std::string::utf8;\n    #[test_only]\n    use aptos_framework::account::create_account_for_test;\n\n    #[test_only]\n    struct FakeCoin {}\n\n    #[test(alice = @0xa11ce, core = @0x1)]\n    public fun test_transfer(alice: &signer, core: &signer) {\n        let bob = from_bcs::to_address(x\"0000000000000000000000000000000000000000000000000000000000000b0b\");\n        let carol = from_bcs::to_address(x\"00000000000000000000000000000000000000000000000000000000000ca501\");\n\n        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(core);\n        create_account(signer::address_of(alice));\n        coin::deposit(signer::address_of(alice), coin::mint(10000, &mint_cap));\n        transfer(alice, bob, 500);\n        assert!(coin::balance<AptosCoin>(bob) == 500, 0);\n        transfer(alice, carol, 500);\n        assert!(coin::balance<AptosCoin>(carol) == 500, 1);\n        transfer(alice, carol, 1500);\n        assert!(coin::balance<AptosCoin>(carol) == 2000, 2);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n    }\n\n    #[test(alice = @0xa11ce, core = @0x1)]\n    public fun test_transfer_to_resource_account(alice: &signer, core: &signer) {\n        let (resource_account, _) = account::create_resource_account(alice, vector[]);\n        let resource_acc_addr = signer::address_of(&resource_account);\n        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(core);\n        assert!(!coin::is_account_registered<AptosCoin>(resource_acc_addr), 0);\n\n        create_account(signer::address_of(alice));\n        coin::deposit(signer::address_of(alice), coin::mint(10000, &mint_cap));\n        transfer(alice, resource_acc_addr, 500);\n        assert!(coin::balance<AptosCoin>(resource_acc_addr) == 500, 1);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n    }\n\n    #[test(from = @0x123, core = @0x1, recipient_1 = @0x124, recipient_2 = @0x125)]\n    public fun test_batch_transfer(from: &signer, core: &signer, recipient_1: &signer, recipient_2: &signer) {\n        let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(core);\n        create_account(signer::address_of(from));\n        let recipient_1_addr = signer::address_of(recipient_1);\n        let recipient_2_addr = signer::address_of(recipient_2);\n        create_account(recipient_1_addr);\n        create_account(recipient_2_addr);\n        coin::deposit(signer::address_of(from), coin::mint(10000, &mint_cap));\n        batch_transfer(\n            from,\n            vector[recipient_1_addr, recipient_2_addr],\n            vector[100, 500],\n        );\n        assert!(coin::balance<AptosCoin>(recipient_1_addr) == 100, 0);\n        assert!(coin::balance<AptosCoin>(recipient_2_addr) == 500, 1);\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n    }\n\n    #[test(from = @0x1, to = @0x12)]\n    public fun test_direct_coin_transfers(from: &signer, to: &signer) acquires DirectTransferConfig {\n        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<FakeCoin>(\n            from,\n            utf8(b\"FC\"),\n            utf8(b\"FC\"),\n            10,\n            true,\n        );\n        create_account_for_test(signer::address_of(from));\n        create_account_for_test(signer::address_of(to));\n        deposit_coins(signer::address_of(from), coin::mint(1000, &mint_cap));\n        // Recipient account did not explicit register for the coin.\n        let to_addr = signer::address_of(to);\n        transfer_coins<FakeCoin>(from, to_addr, 500);\n        assert!(coin::balance<FakeCoin>(to_addr) == 500, 0);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n        coin::destroy_freeze_cap(freeze_cap);\n    }\n\n    #[test(from = @0x1, recipient_1 = @0x124, recipient_2 = @0x125)]\n    public fun test_batch_transfer_coins(\n        from: &signer, recipient_1: &signer, recipient_2: &signer) acquires DirectTransferConfig {\n        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<FakeCoin>(\n            from,\n            utf8(b\"FC\"),\n            utf8(b\"FC\"),\n            10,\n            true,\n        );\n        create_account_for_test(signer::address_of(from));\n        let recipient_1_addr = signer::address_of(recipient_1);\n        let recipient_2_addr = signer::address_of(recipient_2);\n        create_account_for_test(recipient_1_addr);\n        create_account_for_test(recipient_2_addr);\n        deposit_coins(signer::address_of(from), coin::mint(1000, &mint_cap));\n        batch_transfer_coins<FakeCoin>(\n            from,\n            vector[recipient_1_addr, recipient_2_addr],\n            vector[100, 500],\n        );\n        assert!(coin::balance<FakeCoin>(recipient_1_addr) == 100, 0);\n        assert!(coin::balance<FakeCoin>(recipient_2_addr) == 500, 1);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n        coin::destroy_freeze_cap(freeze_cap);\n    }\n\n    #[test(user = @0x123)]\n    public fun test_set_allow_direct_coin_transfers(user: &signer) acquires DirectTransferConfig {\n        let addr = signer::address_of(user);\n        create_account_for_test(addr);\n        set_allow_direct_coin_transfers(user, true);\n        assert!(can_receive_direct_coin_transfers(addr), 0);\n        set_allow_direct_coin_transfers(user, false);\n        assert!(!can_receive_direct_coin_transfers(addr), 1);\n        set_allow_direct_coin_transfers(user, true);\n        assert!(can_receive_direct_coin_transfers(addr), 2);\n    }\n\n    #[test(from = @0x1, to = @0x12)]\n    public fun test_direct_coin_transfers_with_explicit_direct_coin_transfer_config(\n        from: &signer, to: &signer) acquires DirectTransferConfig {\n        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<FakeCoin>(\n            from,\n            utf8(b\"FC\"),\n            utf8(b\"FC\"),\n            10,\n            true,\n        );\n        create_account_for_test(signer::address_of(from));\n        create_account_for_test(signer::address_of(to));\n        set_allow_direct_coin_transfers(from, true);\n        deposit_coins(signer::address_of(from), coin::mint(1000, &mint_cap));\n        // Recipient account did not explicit register for the coin.\n        let to_addr = signer::address_of(to);\n        transfer_coins<FakeCoin>(from, to_addr, 500);\n        assert!(coin::balance<FakeCoin>(to_addr) == 500, 0);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n        coin::destroy_freeze_cap(freeze_cap);\n    }\n\n    #[test(from = @0x1, to = @0x12)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    public fun test_direct_coin_transfers_fail_if_recipient_opted_out(\n        from: &signer, to: &signer) acquires DirectTransferConfig {\n        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<FakeCoin>(\n            from,\n            utf8(b\"FC\"),\n            utf8(b\"FC\"),\n            10,\n            true,\n        );\n        create_account_for_test(signer::address_of(from));\n        create_account_for_test(signer::address_of(to));\n        set_allow_direct_coin_transfers(from, false);\n        deposit_coins(signer::address_of(from), coin::mint(1000, &mint_cap));\n        // This should fail as the to account has explicitly opted out of receiving arbitrary coins.\n        transfer_coins<FakeCoin>(from, signer::address_of(to), 500);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n        coin::destroy_freeze_cap(freeze_cap);\n    }\n}\n","name":"aptos_account.move"},{"content":"/// This module defines a minimal and generic Coin and Balance.\n/// modified from https://github.com/move-language/move/tree/main/language/documentation/tutorial\nmodule aptos_framework::aptos_coin {\n    use std::string;\n    use std::error;\n    use std::signer;\n    use std::vector;\n    use std::option::{Self, Option};\n\n    use aptos_framework::coin::{Self, BurnCapability, MintCapability};\n    use aptos_framework::system_addresses;\n\n    friend aptos_framework::genesis;\n\n    /// Account does not have mint capability\n    const ENO_CAPABILITIES: u64 = 1;\n    /// Mint capability has already been delegated to this specified address\n    const EALREADY_DELEGATED: u64 = 2;\n    /// Cannot find delegation of mint capability to this account\n    const EDELEGATION_NOT_FOUND: u64 = 3;\n\n    struct AptosCoin has key {}\n\n    struct MintCapStore has key {\n        mint_cap: MintCapability<AptosCoin>,\n    }\n\n    /// Delegation token created by delegator and can be claimed by the delegatee as MintCapability.\n    struct DelegatedMintCapability has store {\n        to: address\n    }\n\n    /// The container stores the current pending delegations.\n    struct Delegations has key {\n        inner: vector<DelegatedMintCapability>,\n    }\n\n    /// Can only called during genesis to initialize the Aptos coin.\n    public(friend) fun initialize(aptos_framework: &signer): (BurnCapability<AptosCoin>, MintCapability<AptosCoin>) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        let (burn_cap, freeze_cap, mint_cap) = coin::initialize_with_parallelizable_supply<AptosCoin>(\n            aptos_framework,\n            string::utf8(b\"Aptos Coin\"),\n            string::utf8(b\"APT\"),\n            8, // decimals\n            true, // monitor_supply\n        );\n\n        // Aptos framework needs mint cap to mint coins to initial validators. This will be revoked once the validators\n        // have been initialized.\n        move_to(aptos_framework, MintCapStore { mint_cap });\n\n        coin::destroy_freeze_cap(freeze_cap);\n        (burn_cap, mint_cap)\n    }\n\n    public fun has_mint_capability(account: &signer): bool {\n        exists<MintCapStore>(signer::address_of(account))\n    }\n\n    /// Only called during genesis to destroy the aptos framework account's mint capability once all initial validators\n    /// and accounts have been initialized during genesis.\n    public(friend) fun destroy_mint_cap(aptos_framework: &signer) acquires MintCapStore {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        let MintCapStore { mint_cap } = move_from<MintCapStore>(@aptos_framework);\n        coin::destroy_mint_cap(mint_cap);\n    }\n\n    /// Can only be called during genesis for tests to grant mint capability to aptos framework and core resources\n    /// accounts.\n    public(friend) fun configure_accounts_for_test(\n        aptos_framework: &signer,\n        core_resources: &signer,\n        mint_cap: MintCapability<AptosCoin>,\n    ) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        // Mint the core resource account AptosCoin for gas so it can execute system transactions.\n        coin::register<AptosCoin>(core_resources);\n        let coins = coin::mint<AptosCoin>(\n            18446744073709551615,\n            &mint_cap,\n        );\n        coin::deposit<AptosCoin>(signer::address_of(core_resources), coins);\n\n        move_to(core_resources, MintCapStore { mint_cap });\n        move_to(core_resources, Delegations { inner: vector::empty() });\n    }\n\n    /// Only callable in tests and testnets where the core resources account exists.\n    /// Create new coins and deposit them into dst_addr's account.\n    public entry fun mint(\n        account: &signer,\n        dst_addr: address,\n        amount: u64,\n    ) acquires MintCapStore {\n        let account_addr = signer::address_of(account);\n\n        assert!(\n            exists<MintCapStore>(account_addr),\n            error::not_found(ENO_CAPABILITIES),\n        );\n\n        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;\n        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);\n        coin::deposit<AptosCoin>(dst_addr, coins_minted);\n    }\n\n    /// Only callable in tests and testnets where the core resources account exists.\n    /// Create delegated token for the address so the account could claim MintCapability later.\n    public entry fun delegate_mint_capability(account: signer, to: address) acquires Delegations {\n        system_addresses::assert_core_resource(&account);\n        let delegations = &mut borrow_global_mut<Delegations>(@core_resources).inner;\n        vector::for_each_ref(delegations, |element| {\n            let element: &DelegatedMintCapability = element;\n            assert!(element.to != to, error::invalid_argument(EALREADY_DELEGATED));\n        });\n        vector::push_back(delegations, DelegatedMintCapability { to });\n    }\n\n    /// Only callable in tests and testnets where the core resources account exists.\n    /// Claim the delegated mint capability and destroy the delegated token.\n    public entry fun claim_mint_capability(account: &signer) acquires Delegations, MintCapStore {\n        let maybe_index = find_delegation(signer::address_of(account));\n        assert!(option::is_some(&maybe_index), EDELEGATION_NOT_FOUND);\n        let idx = *option::borrow(&maybe_index);\n        let delegations = &mut borrow_global_mut<Delegations>(@core_resources).inner;\n        let DelegatedMintCapability { to: _ } = vector::swap_remove(delegations, idx);\n\n        // Make a copy of mint cap and give it to the specified account.\n        let mint_cap = borrow_global<MintCapStore>(@core_resources).mint_cap;\n        move_to(account, MintCapStore { mint_cap });\n    }\n\n    fun find_delegation(addr: address): Option<u64> acquires Delegations {\n        let delegations = &borrow_global<Delegations>(@core_resources).inner;\n        let i = 0;\n        let len = vector::length(delegations);\n        let index = option::none();\n        while (i < len) {\n            let element = vector::borrow(delegations, i);\n            if (element.to == addr) {\n                index = option::some(i);\n                break\n            };\n            i = i + 1;\n        };\n        index\n    }\n\n    #[test_only]\n    use aptos_framework::account;\n    #[test_only]\n    use aptos_framework::aggregator_factory;\n    #[test_only]\n    use aptos_framework::fungible_asset::FungibleAsset;\n\n    #[test_only]\n    public fun mint_apt_fa_for_test(amount: u64): FungibleAsset acquires MintCapStore {\n        ensure_initialized_with_apt_fa_metadata_for_test();\n        coin::coin_to_fungible_asset(\n            coin::mint(\n                amount,\n                &borrow_global<MintCapStore>(@aptos_framework).mint_cap\n            )\n        )\n    }\n\n    #[test_only]\n    public fun ensure_initialized_with_apt_fa_metadata_for_test() {\n        let aptos_framework = account::create_signer_for_test(@aptos_framework);\n        if (!exists<MintCapStore>(@aptos_framework)) {\n            if (!aggregator_factory::aggregator_factory_exists_for_testing()) {\n                aggregator_factory::initialize_aggregator_factory_for_test(&aptos_framework);\n            };\n            let (burn_cap, mint_cap) = initialize(&aptos_framework);\n            coin::destroy_burn_cap(burn_cap);\n            coin::destroy_mint_cap(mint_cap);\n        };\n        coin::create_coin_conversion_map(&aptos_framework);\n        coin::create_pairing<AptosCoin>(&aptos_framework);\n    }\n\n    #[test_only]\n    public fun initialize_for_test(aptos_framework: &signer): (BurnCapability<AptosCoin>, MintCapability<AptosCoin>) {\n        aggregator_factory::initialize_aggregator_factory_for_test(aptos_framework);\n        let (burn_cap, mint_cap) = initialize(aptos_framework);\n        coin::create_coin_conversion_map(aptos_framework);\n        coin::create_pairing<AptosCoin>(aptos_framework);\n        (burn_cap, mint_cap)\n    }\n\n    // This is particularly useful if the aggregator_factory is already initialized via another call path.\n    #[test_only]\n    public fun initialize_for_test_without_aggregator_factory(\n        aptos_framework: &signer\n    ): (BurnCapability<AptosCoin>, MintCapability<AptosCoin>) {\n        let (burn_cap, mint_cap) = initialize(aptos_framework);\n        coin::create_coin_conversion_map(aptos_framework);\n        coin::create_pairing<AptosCoin>(aptos_framework);\n        (burn_cap, mint_cap)\n    }\n}\n","name":"aptos_coin.move"},{"content":"///\n/// AptosGovernance represents the on-chain governance of the Aptos network. Voting power is calculated based on the\n/// current epoch's voting power of the proposer or voter's backing stake pool. In addition, for it to count,\n/// the stake pool's lockup needs to be at least as long as the proposal's duration.\n///\n/// It provides the following flow:\n/// 1. Proposers can create a proposal by calling AptosGovernance::create_proposal. The proposer's backing stake pool\n/// needs to have the minimum proposer stake required. Off-chain components can subscribe to CreateProposalEvent to\n/// track proposal creation and proposal ids.\n/// 2. Voters can vote on a proposal. Their voting power is derived from the backing stake pool. A stake pool can vote\n/// on a proposal multiple times as long as the total voting power of these votes doesn't exceed its total voting power.\nmodule aptos_framework::aptos_governance {\n    use std::error;\n    use std::option;\n    use std::signer;\n    use std::string::{Self, String, utf8};\n    use std::vector;\n    use std::features;\n\n    use aptos_std::math64::min;\n    use aptos_std::simple_map::{Self, SimpleMap};\n    use aptos_std::smart_table::{Self, SmartTable};\n    use aptos_std::table::{Self, Table};\n\n    use aptos_framework::account::{Self, SignerCapability, create_signer_with_capability};\n    use aptos_framework::coin;\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::governance_proposal::{Self, GovernanceProposal};\n    use aptos_framework::stake;\n    use aptos_framework::staking_config;\n    use aptos_framework::system_addresses;\n    use aptos_framework::aptos_coin::{Self, AptosCoin};\n    use aptos_framework::consensus_config;\n    use aptos_framework::randomness_config;\n    use aptos_framework::reconfiguration_with_dkg;\n    use aptos_framework::timestamp;\n    use aptos_framework::voting;\n\n    /// The specified stake pool does not have sufficient stake to create a proposal\n    const EINSUFFICIENT_PROPOSER_STAKE: u64 = 1;\n    /// This account is not the designated voter of the specified stake pool\n    const ENOT_DELEGATED_VOTER: u64 = 2;\n    /// The specified stake pool does not have long enough remaining lockup to create a proposal or vote\n    const EINSUFFICIENT_STAKE_LOCKUP: u64 = 3;\n    /// The specified stake pool has already been used to vote on the same proposal\n    const EALREADY_VOTED: u64 = 4;\n    /// The specified stake pool must be part of the validator set\n    const ENO_VOTING_POWER: u64 = 5;\n    /// Proposal is not ready to be resolved. Waiting on time or votes\n    const EPROPOSAL_NOT_RESOLVABLE_YET: u64 = 6;\n    /// The proposal has not been resolved yet\n    const EPROPOSAL_NOT_RESOLVED_YET: u64 = 8;\n    /// Metadata location cannot be longer than 256 chars\n    const EMETADATA_LOCATION_TOO_LONG: u64 = 9;\n    /// Metadata hash cannot be longer than 256 chars\n    const EMETADATA_HASH_TOO_LONG: u64 = 10;\n    /// Account is not authorized to call this function.\n    const EUNAUTHORIZED: u64 = 11;\n    /// The stake pool is using voting power more than it has.\n    const EVOTING_POWER_OVERFLOW: u64 = 12;\n    /// Partial voting feature hasn't been properly initialized.\n    const EPARTIAL_VOTING_NOT_INITIALIZED: u64 = 13;\n    /// The proposal in the argument is not a partial voting proposal.\n    const ENOT_PARTIAL_VOTING_PROPOSAL: u64 = 14;\n\n    /// This matches the same enum const in voting. We have to duplicate it as Move doesn't have support for enums yet.\n    const PROPOSAL_STATE_SUCCEEDED: u64 = 1;\n\n    const MAX_U64: u64 = 18446744073709551615;\n\n    /// Proposal metadata attribute keys.\n    const METADATA_LOCATION_KEY: vector<u8> = b\"metadata_location\";\n    const METADATA_HASH_KEY: vector<u8> = b\"metadata_hash\";\n\n    /// Store the SignerCapabilities of accounts under the on-chain governance's control.\n    struct GovernanceResponsbility has key {\n        signer_caps: SimpleMap<address, SignerCapability>,\n    }\n\n    /// Configurations of the AptosGovernance, set during Genesis and can be updated by the same process offered\n    /// by this AptosGovernance module.\n    struct GovernanceConfig has key {\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n    }\n\n    struct RecordKey has copy, drop, store {\n        stake_pool: address,\n        proposal_id: u64,\n    }\n\n    /// Records to track the proposals each stake pool has been used to vote on.\n    struct VotingRecords has key {\n        votes: Table<RecordKey, bool>\n    }\n\n    /// Records to track the voting power usage of each stake pool on each proposal.\n    struct VotingRecordsV2 has key {\n        votes: SmartTable<RecordKey, u64>\n    }\n\n    /// Used to track which execution script hashes have been approved by governance.\n    /// This is required to bypass cases where the execution scripts exceed the size limit imposed by mempool.\n    struct ApprovedExecutionHashes has key {\n        hashes: SimpleMap<u64, vector<u8>>,\n    }\n\n    /// Events generated by interactions with the AptosGovernance module.\n    struct GovernanceEvents has key {\n        create_proposal_events: EventHandle<CreateProposalEvent>,\n        update_config_events: EventHandle<UpdateConfigEvent>,\n        vote_events: EventHandle<VoteEvent>,\n    }\n\n    /// Event emitted when a proposal is created.\n    struct CreateProposalEvent has drop, store {\n        proposer: address,\n        stake_pool: address,\n        proposal_id: u64,\n        execution_hash: vector<u8>,\n        proposal_metadata: SimpleMap<String, vector<u8>>,\n    }\n\n    /// Event emitted when there's a vote on a proposa;\n    struct VoteEvent has drop, store {\n        proposal_id: u64,\n        voter: address,\n        stake_pool: address,\n        num_votes: u64,\n        should_pass: bool,\n    }\n\n    /// Event emitted when the governance configs are updated.\n    struct UpdateConfigEvent has drop, store {\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n    }\n\n    #[event]\n    /// Event emitted when a proposal is created.\n    struct CreateProposal has drop, store {\n        proposer: address,\n        stake_pool: address,\n        proposal_id: u64,\n        execution_hash: vector<u8>,\n        proposal_metadata: SimpleMap<String, vector<u8>>,\n    }\n\n    #[event]\n    /// Event emitted when there's a vote on a proposa;\n    struct Vote has drop, store {\n        proposal_id: u64,\n        voter: address,\n        stake_pool: address,\n        num_votes: u64,\n        should_pass: bool,\n    }\n\n    #[event]\n    /// Event emitted when the governance configs are updated.\n    struct UpdateConfig has drop, store {\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n    }\n\n    /// Can be called during genesis or by the governance itself.\n    /// Stores the signer capability for a given address.\n    public fun store_signer_cap(\n        aptos_framework: &signer,\n        signer_address: address,\n        signer_cap: SignerCapability,\n    ) acquires GovernanceResponsbility {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        system_addresses::assert_framework_reserved(signer_address);\n\n        if (!exists<GovernanceResponsbility>(@aptos_framework)) {\n            move_to(\n                aptos_framework,\n                GovernanceResponsbility { signer_caps: simple_map::create<address, SignerCapability>() }\n            );\n        };\n\n        let signer_caps = &mut borrow_global_mut<GovernanceResponsbility>(@aptos_framework).signer_caps;\n        simple_map::add(signer_caps, signer_address, signer_cap);\n    }\n\n    /// Initializes the state for Aptos Governance. Can only be called during Genesis with a signer\n    /// for the aptos_framework (0x1) account.\n    /// This function is private because it's called directly from the vm.\n    fun initialize(\n        aptos_framework: &signer,\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n    ) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        voting::register<GovernanceProposal>(aptos_framework);\n        move_to(aptos_framework, GovernanceConfig {\n            voting_duration_secs,\n            min_voting_threshold,\n            required_proposer_stake,\n        });\n        move_to(aptos_framework, GovernanceEvents {\n            create_proposal_events: account::new_event_handle<CreateProposalEvent>(aptos_framework),\n            update_config_events: account::new_event_handle<UpdateConfigEvent>(aptos_framework),\n            vote_events: account::new_event_handle<VoteEvent>(aptos_framework),\n        });\n        move_to(aptos_framework, VotingRecords {\n            votes: table::new(),\n        });\n        move_to(aptos_framework, ApprovedExecutionHashes {\n            hashes: simple_map::create<u64, vector<u8>>(),\n        })\n    }\n\n    /// Update the governance configurations. This can only be called as part of resolving a proposal in this same\n    /// AptosGovernance.\n    public fun update_governance_config(\n        aptos_framework: &signer,\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n    ) acquires GovernanceConfig, GovernanceEvents {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        let governance_config = borrow_global_mut<GovernanceConfig>(@aptos_framework);\n        governance_config.voting_duration_secs = voting_duration_secs;\n        governance_config.min_voting_threshold = min_voting_threshold;\n        governance_config.required_proposer_stake = required_proposer_stake;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                UpdateConfig {\n                    min_voting_threshold,\n                    required_proposer_stake,\n                    voting_duration_secs\n                },\n            )\n        };\n        let events = borrow_global_mut<GovernanceEvents>(@aptos_framework);\n        event::emit_event<UpdateConfigEvent>(\n            &mut events.update_config_events,\n            UpdateConfigEvent {\n                min_voting_threshold,\n                required_proposer_stake,\n                voting_duration_secs\n            },\n        );\n    }\n\n    /// Initializes the state for Aptos Governance partial voting. Can only be called through Aptos governance\n    /// proposals with a signer for the aptos_framework (0x1) account.\n    public fun initialize_partial_voting(\n        aptos_framework: &signer,\n    ) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        move_to(aptos_framework, VotingRecordsV2 {\n            votes: smart_table::new(),\n        });\n    }\n\n    #[view]\n    public fun get_voting_duration_secs(): u64 acquires GovernanceConfig {\n        borrow_global<GovernanceConfig>(@aptos_framework).voting_duration_secs\n    }\n\n    #[view]\n    public fun get_min_voting_threshold(): u128 acquires GovernanceConfig {\n        borrow_global<GovernanceConfig>(@aptos_framework).min_voting_threshold\n    }\n\n    #[view]\n    public fun get_required_proposer_stake(): u64 acquires GovernanceConfig {\n        borrow_global<GovernanceConfig>(@aptos_framework).required_proposer_stake\n    }\n\n    #[view]\n    /// Return true if a stake pool has already voted on a proposal before partial governance voting is enabled.\n    public fun has_entirely_voted(stake_pool: address, proposal_id: u64): bool acquires VotingRecords {\n        let record_key = RecordKey {\n            stake_pool,\n            proposal_id,\n        };\n        // If a stake pool has already voted on a proposal before partial governance voting is enabled,\n        // there is a record in VotingRecords.\n        let voting_records = borrow_global<VotingRecords>(@aptos_framework);\n        table::contains(&voting_records.votes, record_key)\n    }\n\n    #[view]\n    /// Return remaining voting power of a stake pool on a proposal.\n    /// Note: a stake pool's voting power on a proposal could increase over time(e.g. rewards/new stake).\n    public fun get_remaining_voting_power(\n        stake_pool: address,\n        proposal_id: u64\n    ): u64 acquires VotingRecords, VotingRecordsV2 {\n        assert_voting_initialization();\n\n        let proposal_expiration = voting::get_proposal_expiration_secs<GovernanceProposal>(\n            @aptos_framework,\n            proposal_id\n        );\n        let lockup_until = stake::get_lockup_secs(stake_pool);\n        // The voter's stake needs to be locked up at least as long as the proposal's expiration.\n        // Also no one can vote on a expired proposal.\n        if (proposal_expiration > lockup_until || timestamp::now_seconds() > proposal_expiration) {\n            return 0\n        };\n\n        // If a stake pool has already voted on a proposal before partial governance voting is enabled, the stake pool\n        // cannot vote on the proposal even after partial governance voting is enabled.\n        if (has_entirely_voted(stake_pool, proposal_id)) {\n            return 0\n        };\n        let record_key = RecordKey {\n            stake_pool,\n            proposal_id,\n        };\n        let used_voting_power = 0u64;\n        if (features::partial_governance_voting_enabled()) {\n            let voting_records_v2 = borrow_global<VotingRecordsV2>(@aptos_framework);\n            used_voting_power = *smart_table::borrow_with_default(&voting_records_v2.votes, record_key, &0);\n        };\n        get_voting_power(stake_pool) - used_voting_power\n    }\n\n    /// Create a single-step proposal with the backing `stake_pool`.\n    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,\n    /// only the exact script with matching hash can be successfully executed.\n    public entry fun create_proposal(\n        proposer: &signer,\n        stake_pool: address,\n        execution_hash: vector<u8>,\n        metadata_location: vector<u8>,\n        metadata_hash: vector<u8>,\n    ) acquires GovernanceConfig, GovernanceEvents {\n        create_proposal_v2(proposer, stake_pool, execution_hash, metadata_location, metadata_hash, false);\n    }\n\n    /// Create a single-step or multi-step proposal with the backing `stake_pool`.\n    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,\n    /// only the exact script with matching hash can be successfully executed.\n    public entry fun create_proposal_v2(\n        proposer: &signer,\n        stake_pool: address,\n        execution_hash: vector<u8>,\n        metadata_location: vector<u8>,\n        metadata_hash: vector<u8>,\n        is_multi_step_proposal: bool,\n    ) acquires GovernanceConfig, GovernanceEvents {\n        create_proposal_v2_impl(\n            proposer,\n            stake_pool,\n            execution_hash,\n            metadata_location,\n            metadata_hash,\n            is_multi_step_proposal\n        );\n    }\n\n    /// Create a single-step or multi-step proposal with the backing `stake_pool`.\n    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,\n    /// only the exact script with matching hash can be successfully executed.\n    /// Return proposal_id when a proposal is successfully created.\n    public fun create_proposal_v2_impl(\n        proposer: &signer,\n        stake_pool: address,\n        execution_hash: vector<u8>,\n        metadata_location: vector<u8>,\n        metadata_hash: vector<u8>,\n        is_multi_step_proposal: bool,\n    ): u64 acquires GovernanceConfig, GovernanceEvents {\n        let proposer_address = signer::address_of(proposer);\n        assert!(\n            stake::get_delegated_voter(stake_pool) == proposer_address,\n            error::invalid_argument(ENOT_DELEGATED_VOTER)\n        );\n\n        // The proposer's stake needs to be at least the required bond amount.\n        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);\n        let stake_balance = get_voting_power(stake_pool);\n        assert!(\n            stake_balance >= governance_config.required_proposer_stake,\n            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),\n        );\n\n        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.\n        let current_time = timestamp::now_seconds();\n        let proposal_expiration = current_time + governance_config.voting_duration_secs;\n        assert!(\n            stake::get_lockup_secs(stake_pool) >= proposal_expiration,\n            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),\n        );\n\n        // Create and validate proposal metadata.\n        let proposal_metadata = create_proposal_metadata(metadata_location, metadata_hash);\n\n        // We want to allow early resolution of proposals if more than 50% of the total supply of the network coins\n        // has voted. This doesn't take into subsequent inflation/deflation (rewards are issued every epoch and gas fees\n        // are burnt after every transaction), but inflation/delation is very unlikely to have a major impact on total\n        // supply during the voting period.\n        let total_voting_token_supply = coin::supply<AptosCoin>();\n        let early_resolution_vote_threshold = option::none<u128>();\n        if (option::is_some(&total_voting_token_supply)) {\n            let total_supply = *option::borrow(&total_voting_token_supply);\n            // 50% + 1 to avoid rounding errors.\n            early_resolution_vote_threshold = option::some(total_supply / 2 + 1);\n        };\n\n        let proposal_id = voting::create_proposal_v2(\n            proposer_address,\n            @aptos_framework,\n            governance_proposal::create_proposal(),\n            execution_hash,\n            governance_config.min_voting_threshold,\n            proposal_expiration,\n            early_resolution_vote_threshold,\n            proposal_metadata,\n            is_multi_step_proposal,\n        );\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                CreateProposal {\n                    proposal_id,\n                    proposer: proposer_address,\n                    stake_pool,\n                    execution_hash,\n                    proposal_metadata,\n                },\n            );\n        };\n        let events = borrow_global_mut<GovernanceEvents>(@aptos_framework);\n        event::emit_event<CreateProposalEvent>(\n            &mut events.create_proposal_events,\n            CreateProposalEvent {\n                proposal_id,\n                proposer: proposer_address,\n                stake_pool,\n                execution_hash,\n                proposal_metadata,\n            },\n        );\n        proposal_id\n    }\n\n    /// Vote on proposal with `proposal_id` and all voting power from `stake_pool`.\n    public entry fun vote(\n        voter: &signer,\n        stake_pool: address,\n        proposal_id: u64,\n        should_pass: bool,\n    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        vote_internal(voter, stake_pool, proposal_id, MAX_U64, should_pass);\n    }\n\n    /// Vote on proposal with `proposal_id` and specified voting power from `stake_pool`.\n    public entry fun partial_vote(\n        voter: &signer,\n        stake_pool: address,\n        proposal_id: u64,\n        voting_power: u64,\n        should_pass: bool,\n    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        vote_internal(voter, stake_pool, proposal_id, voting_power, should_pass);\n    }\n\n    /// Vote on proposal with `proposal_id` and specified voting_power from `stake_pool`.\n    /// If voting_power is more than all the left voting power of `stake_pool`, use all the left voting power.\n    /// If a stake pool has already voted on a proposal before partial governance voting is enabled, the stake pool\n    /// cannot vote on the proposal even after partial governance voting is enabled.\n    fun vote_internal(\n        voter: &signer,\n        stake_pool: address,\n        proposal_id: u64,\n        voting_power: u64,\n        should_pass: bool,\n    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        let voter_address = signer::address_of(voter);\n        assert!(stake::get_delegated_voter(stake_pool) == voter_address, error::invalid_argument(ENOT_DELEGATED_VOTER));\n\n        // The voter's stake needs to be locked up at least as long as the proposal's expiration.\n        let proposal_expiration = voting::get_proposal_expiration_secs<GovernanceProposal>(\n            @aptos_framework,\n            proposal_id\n        );\n        assert!(\n            stake::get_lockup_secs(stake_pool) >= proposal_expiration,\n            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),\n        );\n\n        // If a stake pool has already voted on a proposal before partial governance voting is enabled,\n        // `get_remaining_voting_power` returns 0.\n        let staking_pool_voting_power = get_remaining_voting_power(stake_pool, proposal_id);\n        voting_power = min(voting_power, staking_pool_voting_power);\n\n        // Short-circuit if the voter has no voting power.\n        assert!(voting_power > 0, error::invalid_argument(ENO_VOTING_POWER));\n\n        voting::vote<GovernanceProposal>(\n            &governance_proposal::create_empty_proposal(),\n            @aptos_framework,\n            proposal_id,\n            voting_power,\n            should_pass,\n        );\n\n        let record_key = RecordKey {\n            stake_pool,\n            proposal_id,\n        };\n        if (features::partial_governance_voting_enabled()) {\n            let voting_records_v2 = borrow_global_mut<VotingRecordsV2>(@aptos_framework);\n            let used_voting_power = smart_table::borrow_mut_with_default(&mut voting_records_v2.votes, record_key, 0);\n            // This calculation should never overflow because the used voting cannot exceed the total voting power of this stake pool.\n            *used_voting_power = *used_voting_power + voting_power;\n        } else {\n            let voting_records = borrow_global_mut<VotingRecords>(@aptos_framework);\n            assert!(\n                !table::contains(&voting_records.votes, record_key),\n                error::invalid_argument(EALREADY_VOTED));\n            table::add(&mut voting_records.votes, record_key, true);\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                Vote {\n                    proposal_id,\n                    voter: voter_address,\n                    stake_pool,\n                    num_votes: voting_power,\n                    should_pass,\n                },\n            );\n        };\n        let events = borrow_global_mut<GovernanceEvents>(@aptos_framework);\n        event::emit_event<VoteEvent>(\n            &mut events.vote_events,\n            VoteEvent {\n                proposal_id,\n                voter: voter_address,\n                stake_pool,\n                num_votes: voting_power,\n                should_pass,\n            },\n        );\n\n        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);\n        if (proposal_state == PROPOSAL_STATE_SUCCEEDED) {\n            add_approved_script_hash(proposal_id);\n        }\n    }\n\n    public entry fun add_approved_script_hash_script(proposal_id: u64) acquires ApprovedExecutionHashes {\n        add_approved_script_hash(proposal_id)\n    }\n\n    /// Add the execution script hash of a successful governance proposal to the approved list.\n    /// This is needed to bypass the mempool transaction size limit for approved governance proposal transactions that\n    /// are too large (e.g. module upgrades).\n    public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {\n        let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);\n\n        // Ensure the proposal can be resolved.\n        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);\n        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_argument(EPROPOSAL_NOT_RESOLVABLE_YET));\n\n        let execution_hash = voting::get_execution_hash<GovernanceProposal>(@aptos_framework, proposal_id);\n\n        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.\n        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.\n        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {\n            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);\n            *current_execution_hash = execution_hash;\n        } else {\n            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);\n        }\n    }\n\n    /// Resolve a successful single-step proposal. This would fail if the proposal is not successful (not enough votes or more no\n    /// than yes).\n    public fun resolve(\n        proposal_id: u64,\n        signer_address: address\n    ): signer acquires ApprovedExecutionHashes, GovernanceResponsbility {\n        voting::resolve<GovernanceProposal>(@aptos_framework, proposal_id);\n        remove_approved_hash(proposal_id);\n        get_signer(signer_address)\n    }\n\n    /// Resolve a successful multi-step proposal. This would fail if the proposal is not successful.\n    public fun resolve_multi_step_proposal(\n        proposal_id: u64,\n        signer_address: address,\n        next_execution_hash: vector<u8>\n    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {\n        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);\n        // If the current step is the last step of this multi-step proposal,\n        // we will remove the execution hash from the ApprovedExecutionHashes map.\n        if (vector::length(&next_execution_hash) == 0) {\n            remove_approved_hash(proposal_id);\n        } else {\n            // If the current step is not the last step of this proposal,\n            // we replace the current execution hash with the next execution hash\n            // in the ApprovedExecutionHashes map.\n            add_approved_script_hash(proposal_id)\n        };\n        get_signer(signer_address)\n    }\n\n    /// Remove an approved proposal's execution script hash.\n    public fun remove_approved_hash(proposal_id: u64) acquires ApprovedExecutionHashes {\n        assert!(\n            voting::is_resolved<GovernanceProposal>(@aptos_framework, proposal_id),\n            error::invalid_argument(EPROPOSAL_NOT_RESOLVED_YET),\n        );\n\n        let approved_hashes = &mut borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework).hashes;\n        if (simple_map::contains_key(approved_hashes, &proposal_id)) {\n            simple_map::remove(approved_hashes, &proposal_id);\n        };\n    }\n\n    /// Manually reconfigure. Called at the end of a governance txn that alters on-chain configs.\n    ///\n    /// WARNING: this function always ensures a reconfiguration starts, but when the reconfiguration finishes depends.\n    /// - If feature `RECONFIGURE_WITH_DKG` is disabled, it finishes immediately.\n    ///   - At the end of the calling transaction, we will be in a new epoch.\n    /// - If feature `RECONFIGURE_WITH_DKG` is enabled, it starts DKG, and the new epoch will start in a block prologue after DKG finishes.\n    ///\n    /// This behavior affects when an update of an on-chain config (e.g. `ConsensusConfig`, `Features`) takes effect,\n    /// since such updates are applied whenever we enter an new epoch.\n    public entry fun reconfigure(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {\n            reconfiguration_with_dkg::try_start();\n        } else {\n            reconfiguration_with_dkg::finish(aptos_framework);\n        }\n    }\n\n    /// Change epoch immediately.\n    /// If `RECONFIGURE_WITH_DKG` is enabled and we are in the middle of a DKG,\n    /// stop waiting for DKG and enter the new epoch without randomness.\n    ///\n    /// WARNING: currently only used by tests. In most cases you should use `reconfigure()` instead.\n    /// TODO: migrate these tests to be aware of async reconfiguration.\n    public entry fun force_end_epoch(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        reconfiguration_with_dkg::finish(aptos_framework);\n    }\n\n    /// `force_end_epoch()` equivalent but only called in testnet,\n    /// where the core resources account exists and has been granted power to mint Aptos coins.\n    public entry fun force_end_epoch_test_only(aptos_framework: &signer) acquires GovernanceResponsbility {\n        let core_signer = get_signer_testnet_only(aptos_framework, @0x1);\n        system_addresses::assert_aptos_framework(&core_signer);\n        reconfiguration_with_dkg::finish(&core_signer);\n    }\n\n    /// Update feature flags and also trigger reconfiguration.\n    public fun toggle_features(aptos_framework: &signer, enable: vector<u64>, disable: vector<u64>) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        features::change_feature_flags_for_next_epoch(aptos_framework, enable, disable);\n        reconfigure(aptos_framework);\n    }\n\n    /// Only called in testnet where the core resources account exists and has been granted power to mint Aptos coins.\n    public fun get_signer_testnet_only(\n        core_resources: &signer, signer_address: address): signer acquires GovernanceResponsbility {\n        system_addresses::assert_core_resource(core_resources);\n        // Core resources account only has mint capability in tests/testnets.\n        assert!(aptos_coin::has_mint_capability(core_resources), error::unauthenticated(EUNAUTHORIZED));\n        get_signer(signer_address)\n    }\n\n    #[view]\n    /// Return the voting power a stake pool has with respect to governance proposals.\n    public fun get_voting_power(pool_address: address): u64 {\n        let allow_validator_set_change = staking_config::get_allow_validator_set_change(&staking_config::get());\n        if (allow_validator_set_change) {\n            let (active, _, pending_active, pending_inactive) = stake::get_stake(pool_address);\n            // We calculate the voting power as total non-inactive stakes of the pool. Even if the validator is not in the\n            // active validator set, as long as they have a lockup (separately checked in create_proposal and voting), their\n            // stake would still count in their voting power for governance proposals.\n            active + pending_active + pending_inactive\n        } else {\n            stake::get_current_epoch_voting_power(pool_address)\n        }\n    }\n\n    /// Return a signer for making changes to 0x1 as part of on-chain governance proposal process.\n    fun get_signer(signer_address: address): signer acquires GovernanceResponsbility {\n        let governance_responsibility = borrow_global<GovernanceResponsbility>(@aptos_framework);\n        let signer_cap = simple_map::borrow(&governance_responsibility.signer_caps, &signer_address);\n        create_signer_with_capability(signer_cap)\n    }\n\n    fun create_proposal_metadata(\n        metadata_location: vector<u8>,\n        metadata_hash: vector<u8>\n    ): SimpleMap<String, vector<u8>> {\n        assert!(string::length(&utf8(metadata_location)) <= 256, error::invalid_argument(EMETADATA_LOCATION_TOO_LONG));\n        assert!(string::length(&utf8(metadata_hash)) <= 256, error::invalid_argument(EMETADATA_HASH_TOO_LONG));\n\n        let metadata = simple_map::create<String, vector<u8>>();\n        simple_map::add(&mut metadata, utf8(METADATA_LOCATION_KEY), metadata_location);\n        simple_map::add(&mut metadata, utf8(METADATA_HASH_KEY), metadata_hash);\n        metadata\n    }\n\n    fun assert_voting_initialization() {\n        if (features::partial_governance_voting_enabled()) {\n            assert!(exists<VotingRecordsV2>(@aptos_framework), error::invalid_state(EPARTIAL_VOTING_NOT_INITIALIZED));\n        };\n    }\n\n    #[test_only]\n    public entry fun create_proposal_for_test(\n        proposer: &signer,\n        multi_step: bool,\n    ) acquires GovernanceConfig, GovernanceEvents {\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        if (multi_step) {\n            create_proposal_v2(\n                proposer,\n                signer::address_of(proposer),\n                execution_hash,\n                b\"\",\n                b\"\",\n                true,\n            );\n        } else {\n            create_proposal(\n                proposer,\n                signer::address_of(proposer),\n                execution_hash,\n                b\"\",\n                b\"\",\n            );\n        };\n    }\n\n    #[test_only]\n    public fun resolve_proposal_for_test(\n        proposal_id: u64,\n        signer_address: address,\n        multi_step: bool,\n        finish_multi_step_execution: bool\n    ): signer acquires ApprovedExecutionHashes, GovernanceResponsbility {\n        if (multi_step) {\n            let execution_hash = vector::empty<u8>();\n            vector::push_back(&mut execution_hash, 1);\n\n            if (finish_multi_step_execution) {\n                resolve_multi_step_proposal(proposal_id, signer_address, vector::empty<u8>())\n            } else {\n                resolve_multi_step_proposal(proposal_id, signer_address, execution_hash)\n            }\n        } else {\n            resolve(proposal_id, signer_address)\n        }\n    }\n\n    #[test_only]\n    /// Force reconfigure. To be called at the end of a proposal that alters on-chain configs.\n    public fun toggle_features_for_test(enable: vector<u64>, disable: vector<u64>) {\n        toggle_features(&account::create_signer_for_test(@0x1), enable, disable);\n    }\n\n    #[test_only]\n    public entry fun test_voting_generic(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n        multi_step: bool,\n        use_generic_resolve_function: bool,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_voting(&aptos_framework, &proposer, &yes_voter, &no_voter);\n\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n\n        create_proposal_for_test(&proposer, multi_step);\n\n        vote(&yes_voter, signer::address_of(&yes_voter), 0, true);\n        vote(&no_voter, signer::address_of(&no_voter), 0, false);\n\n        test_resolving_proposal_generic(aptos_framework, use_generic_resolve_function, execution_hash);\n    }\n\n    #[test_only]\n    public entry fun test_resolving_proposal_generic(\n        aptos_framework: signer,\n        use_generic_resolve_function: bool,\n        execution_hash: vector<u8>,\n    ) acquires ApprovedExecutionHashes, GovernanceResponsbility {\n        // Once expiration time has passed, the proposal should be considered resolve now as there are more yes votes\n        // than no.\n        timestamp::update_global_time_for_test(100001000000);\n        let proposal_state = voting::get_proposal_state<GovernanceProposal>(signer::address_of(&aptos_framework), 0);\n        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, proposal_state);\n\n        // Add approved script hash.\n        add_approved_script_hash(0);\n        let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;\n        assert!(*simple_map::borrow(&approved_hashes, &0) == execution_hash, 0);\n\n        // Resolve the proposal.\n        let account = resolve_proposal_for_test(0, @aptos_framework, use_generic_resolve_function, true);\n        assert!(signer::address_of(&account) == @aptos_framework, 1);\n        assert!(voting::is_resolved<GovernanceProposal>(@aptos_framework, 0), 2);\n        let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;\n        assert!(!simple_map::contains_key(&approved_hashes, &0), 3);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]\n    public entry fun test_voting(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        test_voting_generic(aptos_framework, proposer, yes_voter, no_voter, false, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]\n    public entry fun test_voting_multi_step(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        test_voting_generic(aptos_framework, proposer, yes_voter, no_voter, true, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]\n    #[expected_failure(abort_code = 0x5000a, location = aptos_framework::voting)]\n    public entry fun test_voting_multi_step_cannot_use_single_step_resolve(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        test_voting_generic(aptos_framework, proposer, yes_voter, no_voter, true, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]\n    public entry fun test_voting_single_step_can_use_generic_resolve_function(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        test_voting_generic(aptos_framework, proposer, yes_voter, no_voter, false, true);\n    }\n\n    #[test_only]\n    public entry fun test_can_remove_approved_hash_if_executed_directly_via_voting_generic(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n        multi_step: bool,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_voting(&aptos_framework, &proposer, &yes_voter, &no_voter);\n\n        create_proposal_for_test(&proposer, multi_step);\n        vote(&yes_voter, signer::address_of(&yes_voter), 0, true);\n        vote(&no_voter, signer::address_of(&no_voter), 0, false);\n\n        // Add approved script hash.\n        timestamp::update_global_time_for_test(100001000000);\n        add_approved_script_hash(0);\n\n        // Resolve the proposal.\n        if (multi_step) {\n            let execution_hash = vector::empty<u8>();\n            let next_execution_hash = vector::empty<u8>();\n            vector::push_back(&mut execution_hash, 1);\n            voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, 0, next_execution_hash);\n            assert!(voting::is_resolved<GovernanceProposal>(@aptos_framework, 0), 0);\n            if (vector::length(&next_execution_hash) == 0) {\n                remove_approved_hash(0);\n            } else {\n                add_approved_script_hash(0)\n            };\n        } else {\n            voting::resolve<GovernanceProposal>(@aptos_framework, 0);\n            assert!(voting::is_resolved<GovernanceProposal>(@aptos_framework, 0), 0);\n            remove_approved_hash(0);\n        };\n        let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;\n        assert!(!simple_map::contains_key(&approved_hashes, &0), 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]\n    public entry fun test_can_remove_approved_hash_if_executed_directly_via_voting(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        test_can_remove_approved_hash_if_executed_directly_via_voting_generic(\n            aptos_framework,\n            proposer,\n            yes_voter,\n            no_voter,\n            false\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]\n    public entry fun test_can_remove_approved_hash_if_executed_directly_via_voting_multi_step(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        test_can_remove_approved_hash_if_executed_directly_via_voting_generic(\n            aptos_framework,\n            proposer,\n            yes_voter,\n            no_voter,\n            true\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]\n    #[expected_failure(abort_code = 0x10004, location = aptos_framework::voting)]\n    public entry fun test_cannot_double_vote(\n        aptos_framework: signer,\n        proposer: signer,\n        voter_1: signer,\n        voter_2: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_voting(&aptos_framework, &proposer, &voter_1, &voter_2);\n\n        create_proposal(\n            &proposer,\n            signer::address_of(&proposer),\n            b\"\",\n            b\"\",\n            b\"\",\n        );\n\n        // Double voting should throw an error.\n        vote(&voter_1, signer::address_of(&voter_1), 0, true);\n        vote(&voter_1, signer::address_of(&voter_1), 0, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]\n    #[expected_failure(abort_code = 0x10004, location = aptos_framework::voting)]\n    public entry fun test_cannot_double_vote_with_different_voter_addresses(\n        aptos_framework: signer,\n        proposer: signer,\n        voter_1: signer,\n        voter_2: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_voting(&aptos_framework, &proposer, &voter_1, &voter_2);\n\n        create_proposal(\n            &proposer,\n            signer::address_of(&proposer),\n            b\"\",\n            b\"\",\n            b\"\",\n        );\n\n        // Double voting should throw an error for 2 different voters if they still use the same stake pool.\n        vote(&voter_1, signer::address_of(&voter_1), 0, true);\n        stake::set_delegated_voter(&voter_1, signer::address_of(&voter_2));\n        vote(&voter_2, signer::address_of(&voter_1), 0, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]\n    public entry fun test_stake_pool_can_vote_on_partial_voting_proposal_many_times(\n        aptos_framework: signer,\n        proposer: signer,\n        voter_1: signer,\n        voter_2: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let proposer_addr = signer::address_of(&proposer);\n        let voter_1_addr = signer::address_of(&voter_1);\n        let voter_2_addr = signer::address_of(&voter_2);\n\n        create_proposal_for_test(&proposer, true);\n\n        partial_vote(&voter_1, voter_1_addr, 0, 5, true);\n        partial_vote(&voter_1, voter_1_addr, 0, 3, true);\n        partial_vote(&voter_1, voter_1_addr, 0, 2, true);\n\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 10, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);\n\n        test_resolving_proposal_generic(aptos_framework, true, execution_hash);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]\n    #[expected_failure(abort_code = 0x3, location = Self)]\n    public entry fun test_stake_pool_can_vote_with_partial_voting_power(\n        aptos_framework: signer,\n        proposer: signer,\n        voter_1: signer,\n        voter_2: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let proposer_addr = signer::address_of(&proposer);\n        let voter_1_addr = signer::address_of(&voter_1);\n        let voter_2_addr = signer::address_of(&voter_2);\n\n        create_proposal_for_test(&proposer, true);\n\n        partial_vote(&voter_1, voter_1_addr, 0, 9, true);\n\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 11, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);\n\n        // No enough Yes. The proposal cannot be resolved.\n        test_resolving_proposal_generic(aptos_framework, true, execution_hash);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]\n    public entry fun test_stake_pool_can_vote_only_with_its_own_voting_power(\n        aptos_framework: signer,\n        proposer: signer,\n        voter_1: signer,\n        voter_2: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let proposer_addr = signer::address_of(&proposer);\n        let voter_1_addr = signer::address_of(&voter_1);\n        let voter_2_addr = signer::address_of(&voter_2);\n\n        create_proposal_for_test(&proposer, true);\n\n        partial_vote(&voter_1, voter_1_addr, 0, 9, true);\n        // The total voting power of voter_1 is 20. It can only vote with 20 voting power even we pass 30 as the argument.\n        partial_vote(&voter_1, voter_1_addr, 0, 30, true);\n\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 0, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);\n\n        test_resolving_proposal_generic(aptos_framework, true, execution_hash);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]\n    public entry fun test_stake_pool_can_vote_before_and_after_partial_governance_voting_enabled(\n        aptos_framework: signer,\n        proposer: signer,\n        voter_1: signer,\n        voter_2: signer,\n    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_voting(&aptos_framework, &proposer, &voter_1, &voter_2);\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let proposer_addr = signer::address_of(&proposer);\n        let voter_1_addr = signer::address_of(&voter_1);\n        let voter_2_addr = signer::address_of(&voter_2);\n\n        create_proposal_for_test(&proposer, true);\n        vote(&voter_1, voter_1_addr, 0, true);\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 0, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);\n\n        initialize_partial_voting(&aptos_framework);\n        features::change_feature_flags_for_testing(&aptos_framework, vector[features::get_partial_governance_voting()], vector[]);\n\n        coin::register<AptosCoin>(&voter_1);\n        coin::register<AptosCoin>(&voter_2);\n        stake::add_stake(&voter_1, 20);\n        stake::add_stake(&voter_2, 5);\n\n        // voter1 has already voted before partial governance voting is enalbed. So it cannot vote even after adding stake.\n        // voter2's voting poewr increase after adding stake.\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 0, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 15, 2);\n\n        test_resolving_proposal_generic(aptos_framework, true, execution_hash);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]\n    public entry fun test_no_remaining_voting_power_about_proposal_expiration_time(\n        aptos_framework: signer,\n        proposer: signer,\n        voter_1: signer,\n        voter_2: signer,\n    ) acquires GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_voting_with_initialized_stake(&aptos_framework, &proposer, &voter_1, &voter_2);\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let proposer_addr = signer::address_of(&proposer);\n        let voter_1_addr = signer::address_of(&voter_1);\n        let voter_2_addr = signer::address_of(&voter_2);\n\n        create_proposal_for_test(&proposer, true);\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 0, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 0, 2);\n\n        // 500 seconds later, lockup period of voter_1 and voter_2 is reset.\n        timestamp::fast_forward_seconds(440);\n        stake::end_epoch();\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 20, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);\n\n        // 501 seconds later, the proposal expires.\n        timestamp::fast_forward_seconds(441);\n        stake::end_epoch();\n        assert!(get_remaining_voting_power(proposer_addr, 0) == 0, 0);\n        assert!(get_remaining_voting_power(voter_1_addr, 0) == 0, 1);\n        assert!(get_remaining_voting_power(voter_2_addr, 0) == 0, 2);\n    }\n\n    #[test_only]\n    public fun setup_voting(\n        aptos_framework: &signer,\n        proposer: &signer,\n        yes_voter: &signer,\n        no_voter: &signer,\n    ) acquires GovernanceResponsbility {\n        use std::vector;\n        use aptos_framework::account;\n        use aptos_framework::coin;\n        use aptos_framework::aptos_coin::{Self, AptosCoin};\n\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n        account::create_account_for_test(signer::address_of(aptos_framework));\n        account::create_account_for_test(signer::address_of(proposer));\n        account::create_account_for_test(signer::address_of(yes_voter));\n        account::create_account_for_test(signer::address_of(no_voter));\n\n        // Initialize the governance.\n        staking_config::initialize_for_test(aptos_framework, 0, 1000, 2000, true, 0, 1, 100);\n        initialize(aptos_framework, 10, 100, 1000);\n        store_signer_cap(\n            aptos_framework,\n            @aptos_framework,\n            account::create_test_signer_cap(@aptos_framework),\n        );\n\n        // Initialize the stake pools for proposer and voters.\n        let active_validators = vector::empty<address>();\n        vector::push_back(&mut active_validators, signer::address_of(proposer));\n        vector::push_back(&mut active_validators, signer::address_of(yes_voter));\n        vector::push_back(&mut active_validators, signer::address_of(no_voter));\n        let (_sk_1, pk_1, _pop_1) = stake::generate_identity();\n        let (_sk_2, pk_2, _pop_2) = stake::generate_identity();\n        let (_sk_3, pk_3, _pop_3) = stake::generate_identity();\n        let pks = vector[pk_1, pk_2, pk_3];\n        stake::create_validator_set(aptos_framework, active_validators, pks);\n\n        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(aptos_framework);\n        // Spread stake among active and pending_inactive because both need to be accounted for when computing voting\n        // power.\n        coin::register<AptosCoin>(proposer);\n        coin::deposit(signer::address_of(proposer), coin::mint(100, &mint_cap));\n        coin::register<AptosCoin>(yes_voter);\n        coin::deposit(signer::address_of(yes_voter), coin::mint(20, &mint_cap));\n        coin::register<AptosCoin>(no_voter);\n        coin::deposit(signer::address_of(no_voter), coin::mint(10, &mint_cap));\n        stake::create_stake_pool(proposer, coin::mint(50, &mint_cap), coin::mint(50, &mint_cap), 10000);\n        stake::create_stake_pool(yes_voter, coin::mint(10, &mint_cap), coin::mint(10, &mint_cap), 10000);\n        stake::create_stake_pool(no_voter, coin::mint(5, &mint_cap), coin::mint(5, &mint_cap), 10000);\n        coin::destroy_mint_cap<AptosCoin>(mint_cap);\n        coin::destroy_burn_cap<AptosCoin>(burn_cap);\n    }\n\n    #[test_only]\n    public fun setup_voting_with_initialized_stake(\n        aptos_framework: &signer,\n        proposer: &signer,\n        yes_voter: &signer,\n        no_voter: &signer,\n    ) acquires GovernanceResponsbility {\n        use aptos_framework::account;\n        use aptos_framework::coin;\n        use aptos_framework::aptos_coin::AptosCoin;\n\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n        account::create_account_for_test(signer::address_of(aptos_framework));\n        account::create_account_for_test(signer::address_of(proposer));\n        account::create_account_for_test(signer::address_of(yes_voter));\n        account::create_account_for_test(signer::address_of(no_voter));\n\n        // Initialize the governance.\n        stake::initialize_for_test_custom(aptos_framework, 0, 1000, 2000, true, 0, 1, 1000);\n        initialize(aptos_framework, 10, 100, 1000);\n        store_signer_cap(\n            aptos_framework,\n            @aptos_framework,\n            account::create_test_signer_cap(@aptos_framework),\n        );\n\n        // Initialize the stake pools for proposer and voters.\n        // Spread stake among active and pending_inactive because both need to be accounted for when computing voting\n        // power.\n        coin::register<AptosCoin>(proposer);\n        coin::deposit(signer::address_of(proposer), stake::mint_coins(100));\n        coin::register<AptosCoin>(yes_voter);\n        coin::deposit(signer::address_of(yes_voter), stake::mint_coins(20));\n        coin::register<AptosCoin>(no_voter);\n        coin::deposit(signer::address_of(no_voter), stake::mint_coins(10));\n\n        let (_sk_1, pk_1, pop_1) = stake::generate_identity();\n        let (_sk_2, pk_2, pop_2) = stake::generate_identity();\n        let (_sk_3, pk_3, pop_3) = stake::generate_identity();\n        stake::initialize_test_validator(&pk_2, &pop_2, yes_voter, 20, true, false);\n        stake::initialize_test_validator(&pk_3, &pop_3, no_voter, 10, true, false);\n        stake::end_epoch();\n        timestamp::fast_forward_seconds(1440);\n        stake::initialize_test_validator(&pk_1, &pop_1, proposer, 100, true, false);\n        stake::end_epoch();\n    }\n\n    #[test_only]\n    public fun setup_partial_voting(\n        aptos_framework: &signer,\n        proposer: &signer,\n        voter_1: &signer,\n        voter_2: &signer,\n    ) acquires GovernanceResponsbility {\n        initialize_partial_voting(aptos_framework);\n        features::change_feature_flags_for_testing(aptos_framework, vector[features::get_partial_governance_voting()], vector[]);\n        setup_voting(aptos_framework, proposer, voter_1, voter_2);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    public entry fun test_update_governance_config(\n        aptos_framework: signer,\n    ) acquires GovernanceConfig, GovernanceEvents {\n        account::create_account_for_test(signer::address_of(&aptos_framework));\n        initialize(&aptos_framework, 1, 2, 3);\n        update_governance_config(&aptos_framework, 10, 20, 30);\n\n        let config = borrow_global<GovernanceConfig>(@aptos_framework);\n        assert!(config.min_voting_threshold == 10, 0);\n        assert!(config.required_proposer_stake == 20, 1);\n        assert!(config.voting_duration_secs == 30, 3);\n    }\n\n    #[test(account = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    public entry fun test_update_governance_config_unauthorized_should_fail(\n        account: signer) acquires GovernanceConfig, GovernanceEvents {\n        initialize(&account, 1, 2, 3);\n        update_governance_config(&account, 10, 20, 30);\n    }\n\n    #[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]\n    public entry fun test_replace_execution_hash(\n        aptos_framework: signer,\n        proposer: signer,\n        yes_voter: signer,\n        no_voter: signer,\n    ) acquires GovernanceResponsbility, GovernanceConfig, ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {\n        setup_voting(&aptos_framework, &proposer, &yes_voter, &no_voter);\n\n        create_proposal_for_test(&proposer, true);\n        vote(&yes_voter, signer::address_of(&yes_voter), 0, true);\n        vote(&no_voter, signer::address_of(&no_voter), 0, false);\n\n        // Add approved script hash.\n        timestamp::update_global_time_for_test(100001000000);\n        add_approved_script_hash(0);\n\n        // Resolve the proposal.\n        let execution_hash = vector::empty<u8>();\n        let next_execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        vector::push_back(&mut next_execution_hash, 10);\n\n        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, 0, next_execution_hash);\n\n        if (vector::length(&next_execution_hash) == 0) {\n            remove_approved_hash(0);\n        } else {\n            add_approved_script_hash(0)\n        };\n\n        let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;\n        assert!(*simple_map::borrow(&approved_hashes, &0) == vector[10u8, ], 1);\n    }\n\n    #[test_only]\n    public fun initialize_for_test(\n        aptos_framework: &signer,\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n    ) {\n        initialize(aptos_framework, min_voting_threshold, required_proposer_stake, voting_duration_secs);\n    }\n\n    #[verify_only]\n    public fun initialize_for_verification(\n        aptos_framework: &signer,\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n    ) {\n        initialize(aptos_framework, min_voting_threshold, required_proposer_stake, voting_duration_secs);\n    }\n}\n","name":"aptos_governance.move"},{"content":"/// This module defines a struct storing the metadata of the block and new block events.\nmodule aptos_framework::block {\n    use std::error;\n    use std::features;\n    use std::vector;\n    use std::option;\n    use aptos_std::table_with_length::{Self, TableWithLength};\n    use std::option::Option;\n    use aptos_framework::randomness;\n\n    use aptos_framework::account;\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::reconfiguration;\n    use aptos_framework::reconfiguration_with_dkg;\n    use aptos_framework::stake;\n    use aptos_framework::state_storage;\n    use aptos_framework::system_addresses;\n    use aptos_framework::timestamp;\n    use aptos_framework::transaction_fee;\n\n    friend aptos_framework::genesis;\n\n    const MAX_U64: u64 = 18446744073709551615;\n\n    /// Should be in-sync with BlockResource rust struct in new_block.rs\n    struct BlockResource has key {\n        /// Height of the current block\n        height: u64,\n        /// Time period between epochs.\n        epoch_interval: u64,\n        /// Handle where events with the time of new blocks are emitted\n        new_block_events: EventHandle<NewBlockEvent>,\n        update_epoch_interval_events: EventHandle<UpdateEpochIntervalEvent>,\n    }\n\n    /// Store new block events as a move resource, internally using a circular buffer.\n    struct CommitHistory has key {\n        max_capacity: u32,\n        next_idx: u32,\n        table: TableWithLength<u32, NewBlockEvent>,\n    }\n\n    /// Should be in-sync with NewBlockEvent rust struct in new_block.rs\n    struct NewBlockEvent has copy, drop, store {\n        hash: address,\n        epoch: u64,\n        round: u64,\n        height: u64,\n        previous_block_votes_bitvec: vector<u8>,\n        proposer: address,\n        failed_proposer_indices: vector<u64>,\n        /// On-chain time during the block at the given height\n        time_microseconds: u64,\n    }\n\n    /// Event emitted when a proposal is created.\n    struct UpdateEpochIntervalEvent has drop, store {\n        old_epoch_interval: u64,\n        new_epoch_interval: u64,\n    }\n\n    #[event]\n    /// Should be in-sync with NewBlockEvent rust struct in new_block.rs\n    struct NewBlock has drop, store {\n        hash: address,\n        epoch: u64,\n        round: u64,\n        height: u64,\n        previous_block_votes_bitvec: vector<u8>,\n        proposer: address,\n        failed_proposer_indices: vector<u64>,\n        /// On-chain time during the block at the given height\n        time_microseconds: u64,\n    }\n\n    #[event]\n    /// Event emitted when a proposal is created.\n    struct UpdateEpochInterval has drop, store {\n        old_epoch_interval: u64,\n        new_epoch_interval: u64,\n    }\n\n    /// The number of new block events does not equal the current block height.\n    const ENUM_NEW_BLOCK_EVENTS_DOES_NOT_MATCH_BLOCK_HEIGHT: u64 = 1;\n    /// An invalid proposer was provided. Expected the proposer to be the VM or an active validator.\n    const EINVALID_PROPOSER: u64 = 2;\n    /// Epoch interval cannot be 0.\n    const EZERO_EPOCH_INTERVAL: u64 = 3;\n    /// The maximum capacity of the commit history cannot be 0.\n    const EZERO_MAX_CAPACITY: u64 = 3;\n\n    /// This can only be called during Genesis.\n    public(friend) fun initialize(aptos_framework: &signer, epoch_interval_microsecs: u64) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(epoch_interval_microsecs > 0, error::invalid_argument(EZERO_EPOCH_INTERVAL));\n\n        move_to<CommitHistory>(aptos_framework, CommitHistory {\n            max_capacity: 2000,\n            next_idx: 0,\n            table: table_with_length::new(),\n        });\n\n        move_to<BlockResource>(\n            aptos_framework,\n            BlockResource {\n                height: 0,\n                epoch_interval: epoch_interval_microsecs,\n                new_block_events: account::new_event_handle<NewBlockEvent>(aptos_framework),\n                update_epoch_interval_events: account::new_event_handle<UpdateEpochIntervalEvent>(aptos_framework),\n            }\n        );\n    }\n\n    /// Initialize the commit history resource if it's not in genesis.\n    public fun initialize_commit_history(fx: &signer, max_capacity: u32) {\n        assert!(max_capacity > 0, error::invalid_argument(EZERO_MAX_CAPACITY));\n        move_to<CommitHistory>(fx, CommitHistory {\n            max_capacity,\n            next_idx: 0,\n            table: table_with_length::new(),\n        });\n    }\n\n    /// Update the epoch interval.\n    /// Can only be called as part of the Aptos governance proposal process established by the AptosGovernance module.\n    public fun update_epoch_interval_microsecs(\n        aptos_framework: &signer,\n        new_epoch_interval: u64,\n    ) acquires BlockResource {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(new_epoch_interval > 0, error::invalid_argument(EZERO_EPOCH_INTERVAL));\n\n        let block_resource = borrow_global_mut<BlockResource>(@aptos_framework);\n        let old_epoch_interval = block_resource.epoch_interval;\n        block_resource.epoch_interval = new_epoch_interval;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                UpdateEpochInterval { old_epoch_interval, new_epoch_interval },\n            );\n        };\n        event::emit_event<UpdateEpochIntervalEvent>(\n            &mut block_resource.update_epoch_interval_events,\n            UpdateEpochIntervalEvent { old_epoch_interval, new_epoch_interval },\n        );\n    }\n\n    #[view]\n    /// Return epoch interval in seconds.\n    public fun get_epoch_interval_secs(): u64 acquires BlockResource {\n        borrow_global<BlockResource>(@aptos_framework).epoch_interval / 1000000\n    }\n\n\n    fun block_prologue_common(\n        vm: &signer,\n        hash: address,\n        epoch: u64,\n        round: u64,\n        proposer: address,\n        failed_proposer_indices: vector<u64>,\n        previous_block_votes_bitvec: vector<u8>,\n        timestamp: u64\n    ): u64 acquires BlockResource, CommitHistory {\n        // Operational constraint: can only be invoked by the VM.\n        system_addresses::assert_vm(vm);\n\n        // Blocks can only be produced by a valid proposer or by the VM itself for Nil blocks (no user txs).\n        assert!(\n            proposer == @vm_reserved || stake::is_current_epoch_validator(proposer),\n            error::permission_denied(EINVALID_PROPOSER),\n        );\n\n        let proposer_index = option::none();\n        if (proposer != @vm_reserved) {\n            proposer_index = option::some(stake::get_validator_index(proposer));\n        };\n\n        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);\n        block_metadata_ref.height = event::counter(&block_metadata_ref.new_block_events);\n\n        // Emit both event v1 and v2 for compatibility. Eventually only module events will be kept.\n        let new_block_event = NewBlockEvent {\n            hash,\n            epoch,\n            round,\n            height: block_metadata_ref.height,\n            previous_block_votes_bitvec,\n            proposer,\n            failed_proposer_indices,\n            time_microseconds: timestamp,\n        };\n        let new_block_event_v2 = NewBlock {\n            hash,\n            epoch,\n            round,\n            height: block_metadata_ref.height,\n            previous_block_votes_bitvec,\n            proposer,\n            failed_proposer_indices,\n            time_microseconds: timestamp,\n        };\n        emit_new_block_event(vm, &mut block_metadata_ref.new_block_events, new_block_event, new_block_event_v2);\n\n        if (features::collect_and_distribute_gas_fees()) {\n            // Assign the fees collected from the previous block to the previous block proposer.\n            // If for any reason the fees cannot be assigned, this function burns the collected coins.\n            transaction_fee::process_collected_fees();\n            // Set the proposer of this block as the receiver of the fees, so that the fees for this\n            // block are assigned to the right account.\n            transaction_fee::register_proposer_for_fee_collection(proposer);\n        };\n\n        // Performance scores have to be updated before the epoch transition as the transaction that triggers the\n        // transition is the last block in the previous epoch.\n        stake::update_performance_statistics(proposer_index, failed_proposer_indices);\n        state_storage::on_new_block(reconfiguration::current_epoch());\n\n        block_metadata_ref.epoch_interval\n    }\n\n    /// Set the metadata for the current block.\n    /// The runtime always runs this before executing the transactions in a block.\n    fun block_prologue(\n        vm: signer,\n        hash: address,\n        epoch: u64,\n        round: u64,\n        proposer: address,\n        failed_proposer_indices: vector<u64>,\n        previous_block_votes_bitvec: vector<u8>,\n        timestamp: u64\n    ) acquires BlockResource, CommitHistory {\n        let epoch_interval = block_prologue_common(&vm, hash, epoch, round, proposer, failed_proposer_indices, previous_block_votes_bitvec, timestamp);\n        randomness::on_new_block(&vm, epoch, round, option::none());\n        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {\n            reconfiguration::reconfigure();\n        };\n    }\n\n    /// `block_prologue()` but trigger reconfiguration with DKG after epoch timed out.\n    fun block_prologue_ext(\n        vm: signer,\n        hash: address,\n        epoch: u64,\n        round: u64,\n        proposer: address,\n        failed_proposer_indices: vector<u64>,\n        previous_block_votes_bitvec: vector<u8>,\n        timestamp: u64,\n        randomness_seed: Option<vector<u8>>,\n    ) acquires BlockResource, CommitHistory {\n        let epoch_interval = block_prologue_common(\n            &vm,\n            hash,\n            epoch,\n            round,\n            proposer,\n            failed_proposer_indices,\n            previous_block_votes_bitvec,\n            timestamp\n        );\n        randomness::on_new_block(&vm, epoch, round, randomness_seed);\n\n        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {\n            reconfiguration_with_dkg::try_start();\n        };\n    }\n\n    #[view]\n    /// Get the current block height\n    public fun get_current_block_height(): u64 acquires BlockResource {\n        borrow_global<BlockResource>(@aptos_framework).height\n    }\n\n    /// Emit the event and update height and global timestamp\n    fun emit_new_block_event(\n        vm: &signer,\n        event_handle: &mut EventHandle<NewBlockEvent>,\n        new_block_event: NewBlockEvent,\n        new_block_event_v2: NewBlock\n    ) acquires CommitHistory {\n        if (exists<CommitHistory>(@aptos_framework)) {\n            let commit_history_ref = borrow_global_mut<CommitHistory>(@aptos_framework);\n            let idx = commit_history_ref.next_idx;\n            if (table_with_length::contains(&commit_history_ref.table, idx)) {\n                table_with_length::remove(&mut commit_history_ref.table, idx);\n            };\n            table_with_length::add(&mut commit_history_ref.table, idx, copy new_block_event);\n            spec {\n                assume idx + 1 <= MAX_U32;\n            };\n            commit_history_ref.next_idx = (idx + 1) % commit_history_ref.max_capacity;\n        };\n        timestamp::update_global_time(vm, new_block_event.proposer, new_block_event.time_microseconds);\n        assert!(\n            event::counter(event_handle) == new_block_event.height,\n            error::invalid_argument(ENUM_NEW_BLOCK_EVENTS_DOES_NOT_MATCH_BLOCK_HEIGHT),\n        );\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(new_block_event_v2);\n        };\n        event::emit_event<NewBlockEvent>(event_handle, new_block_event);\n    }\n\n    /// Emit a `NewBlockEvent` event. This function will be invoked by genesis directly to generate the very first\n    /// reconfiguration event.\n    fun emit_genesis_block_event(vm: signer) acquires BlockResource, CommitHistory {\n        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);\n        let genesis_id = @0x0;\n        emit_new_block_event(\n            &vm,\n            &mut block_metadata_ref.new_block_events,\n            NewBlockEvent {\n                hash: genesis_id,\n                epoch: 0,\n                round: 0,\n                height: 0,\n                previous_block_votes_bitvec: vector::empty(),\n                proposer: @vm_reserved,\n                failed_proposer_indices: vector::empty(),\n                time_microseconds: 0,\n            },\n            NewBlock {\n                hash: genesis_id,\n                epoch: 0,\n                round: 0,\n                height: 0,\n                previous_block_votes_bitvec: vector::empty(),\n                proposer: @vm_reserved,\n                failed_proposer_indices: vector::empty(),\n                time_microseconds: 0,\n            }\n        );\n    }\n\n    ///  Emit a `NewBlockEvent` event. This function will be invoked by write set script directly to generate the\n    ///  new block event for WriteSetPayload.\n    public fun emit_writeset_block_event(vm_signer: &signer, fake_block_hash: address) acquires BlockResource, CommitHistory {\n        system_addresses::assert_vm(vm_signer);\n        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);\n        block_metadata_ref.height = event::counter(&block_metadata_ref.new_block_events);\n\n        emit_new_block_event(\n            vm_signer,\n            &mut block_metadata_ref.new_block_events,\n            NewBlockEvent {\n                hash: fake_block_hash,\n                epoch: reconfiguration::current_epoch(),\n                round: MAX_U64,\n                height: block_metadata_ref.height,\n                previous_block_votes_bitvec: vector::empty(),\n                proposer: @vm_reserved,\n                failed_proposer_indices: vector::empty(),\n                time_microseconds: timestamp::now_microseconds(),\n            },\n            NewBlock {\n                hash: fake_block_hash,\n                epoch: reconfiguration::current_epoch(),\n                round: MAX_U64,\n                height: block_metadata_ref.height,\n                previous_block_votes_bitvec: vector::empty(),\n                proposer: @vm_reserved,\n                failed_proposer_indices: vector::empty(),\n                time_microseconds: timestamp::now_microseconds(),\n            }\n        );\n    }\n\n    #[test_only]\n    public fun initialize_for_test(account: &signer, epoch_interval_microsecs: u64) {\n        initialize(account, epoch_interval_microsecs);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    public entry fun test_update_epoch_interval(aptos_framework: signer) acquires BlockResource {\n        account::create_account_for_test(@aptos_framework);\n        initialize(&aptos_framework, 1);\n        assert!(borrow_global<BlockResource>(@aptos_framework).epoch_interval == 1, 0);\n        update_epoch_interval_microsecs(&aptos_framework, 2);\n        assert!(borrow_global<BlockResource>(@aptos_framework).epoch_interval == 2, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, account = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    public entry fun test_update_epoch_interval_unauthorized_should_fail(\n        aptos_framework: signer,\n        account: signer,\n    ) acquires BlockResource {\n        account::create_account_for_test(@aptos_framework);\n        initialize(&aptos_framework, 1);\n        update_epoch_interval_microsecs(&account, 2);\n    }\n}\n","name":"block.move"},{"content":"/// The chain id distinguishes between different chains (e.g., testnet and the main network).\n/// One important role is to prevent transactions intended for one chain from being executed on another.\n/// This code provides a container for storing a chain id and functions to initialize and get it.\nmodule aptos_framework::chain_id {\n    use aptos_framework::system_addresses;\n\n    friend aptos_framework::genesis;\n\n    struct ChainId has key {\n        id: u8\n    }\n\n    /// Only called during genesis.\n    /// Publish the chain ID `id` of this instance under the SystemAddresses address\n    public(friend) fun initialize(aptos_framework: &signer, id: u8) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        move_to(aptos_framework, ChainId { id })\n    }\n\n    #[view]\n    /// Return the chain ID of this instance.\n    public fun get(): u8 acquires ChainId {\n        borrow_global<ChainId>(@aptos_framework).id\n    }\n\n    #[test_only]\n    use std::signer;\n\n    #[test_only]\n    public fun initialize_for_test(aptos_framework: &signer, id: u8) {\n        if (!exists<ChainId>(signer::address_of(aptos_framework))) {\n            initialize(aptos_framework, id);\n        }\n    }\n\n    #[test(aptos_framework = @0x1)]\n    fun test_get(aptos_framework: &signer) acquires ChainId {\n        initialize_for_test(aptos_framework, 1u8);\n        assert!(get() == 1u8, 1);\n    }\n}\n","name":"chain_id.move"},{"content":"/// This module code to assert that it is running in genesis (`Self::assert_genesis`) or after\n/// genesis (`Self::assert_operating`). These are essentially distinct states of the system. Specifically,\n/// if `Self::assert_operating` succeeds, assumptions about invariants over the global state can be made\n/// which reflect that the system has been successfully initialized.\nmodule aptos_framework::chain_status {\n    use aptos_framework::system_addresses;\n    use std::error;\n\n    friend aptos_framework::genesis;\n\n    /// Marker to publish at the end of genesis.\n    struct GenesisEndMarker has key {}\n\n    /// The blockchain is not in the operating status.\n    const ENOT_OPERATING: u64 = 1;\n    /// The blockchain is not in the genesis status.\n    const ENOT_GENESIS: u64 = 2;\n\n    /// Marks that genesis has finished.\n    public(friend) fun set_genesis_end(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        move_to(aptos_framework, GenesisEndMarker {});\n    }\n\n    #[view]\n    /// Helper function to determine if Aptos is in genesis state.\n    public fun is_genesis(): bool {\n        !exists<GenesisEndMarker>(@aptos_framework)\n    }\n\n    #[view]\n    /// Helper function to determine if Aptos is operating. This is\n    /// the same as `!is_genesis()` and is provided for convenience.\n    /// Testing `is_operating()` is more frequent than `is_genesis()`.\n    public fun is_operating(): bool {\n        exists<GenesisEndMarker>(@aptos_framework)\n    }\n\n    /// Helper function to assert operating (not genesis) state.\n    public fun assert_operating() {\n        assert!(is_operating(), error::invalid_state(ENOT_OPERATING));\n    }\n\n    /// Helper function to assert genesis state.\n    public fun assert_genesis() {\n        assert!(is_genesis(), error::invalid_state(ENOT_OPERATING));\n    }\n}\n","name":"chain_status.move"},{"content":"/// This module supports functionality related to code management.\nmodule aptos_framework::code {\n    use std::string::String;\n    use std::error;\n    use std::signer;\n    use std::vector;\n    use std::features;\n\n    use aptos_framework::util;\n    use aptos_framework::system_addresses;\n    use aptos_std::copyable_any::Any;\n    use std::option::Option;\n    use std::string;\n    use aptos_framework::event;\n    use aptos_framework::object::{Self, Object};\n\n    // ----------------------------------------------------------------------\n    // Code Publishing\n\n    /// The package registry at the given address.\n    struct PackageRegistry has key, store, drop {\n        /// Packages installed at this address.\n        packages: vector<PackageMetadata>,\n    }\n\n    /// Metadata for a package. All byte blobs are represented as base64-of-gzipped-bytes\n    struct PackageMetadata has store, drop {\n        /// Name of this package.\n        name: String,\n        /// The upgrade policy of this package.\n        upgrade_policy: UpgradePolicy,\n        /// The numbers of times this module has been upgraded. Also serves as the on-chain version.\n        /// This field will be automatically assigned on successful upgrade.\n        upgrade_number: u64,\n        /// The source digest of the sources in the package. This is constructed by first building the\n        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.\n        source_digest: String,\n        /// The package manifest, in the Move.toml format. Gzipped text.\n        manifest: vector<u8>,\n        /// The list of modules installed by this package.\n        modules: vector<ModuleMetadata>,\n        /// Holds PackageDeps.\n        deps: vector<PackageDep>,\n        /// For future extension\n        extension: Option<Any>\n    }\n\n    /// A dependency to a package published at address\n    struct PackageDep has store, drop, copy {\n        account: address,\n        package_name: String\n    }\n\n    /// Metadata about a module in a package.\n    struct ModuleMetadata has store, drop {\n        /// Name of the module.\n        name: String,\n        /// Source text, gzipped String. Empty if not provided.\n        source: vector<u8>,\n        /// Source map, in compressed BCS. Empty if not provided.\n        source_map: vector<u8>,\n        /// For future extensions.\n        extension: Option<Any>,\n    }\n\n    /// Describes an upgrade policy\n    struct UpgradePolicy has store, copy, drop {\n        policy: u8\n    }\n\n    #[event]\n    /// Event emitted when code is published to an address.\n    struct PublishPackage has drop, store {\n        code_address: address,\n        is_upgrade: bool,\n    }\n\n    /// Package contains duplicate module names with existing modules publised in other packages on this address\n    const EMODULE_NAME_CLASH: u64 = 0x1;\n\n    /// Cannot upgrade an immutable package\n    const EUPGRADE_IMMUTABLE: u64 = 0x2;\n\n    /// Cannot downgrade a package's upgradability policy\n    const EUPGRADE_WEAKER_POLICY: u64 = 0x3;\n\n    /// Cannot delete a module that was published in the same package\n    const EMODULE_MISSING: u64 = 0x4;\n\n    /// Dependency could not be resolved to any published package.\n    const EPACKAGE_DEP_MISSING: u64 = 0x5;\n\n    /// A dependency cannot have a weaker upgrade policy.\n    const EDEP_WEAKER_POLICY: u64 = 0x6;\n\n    /// A dependency to an `arbitrary` package must be on the same address.\n    const EDEP_ARBITRARY_NOT_SAME_ADDRESS: u64 = 0x7;\n\n    /// Creating a package with incompatible upgrade policy is disabled.\n    const EINCOMPATIBLE_POLICY_DISABLED: u64 = 0x8;\n\n    /// Not the owner of the package registry.\n    const ENOT_PACKAGE_OWNER: u64 = 0x9;\n\n    /// `code_object` does not exist.\n    const ECODE_OBJECT_DOES_NOT_EXIST: u64 = 0xA;\n\n    /// Whether unconditional code upgrade with no compatibility check is allowed. This\n    /// publication mode should only be used for modules which aren't shared with user others.\n    /// The developer is responsible for not breaking memory layout of any resources he already\n    /// stored on chain.\n    public fun upgrade_policy_arbitrary(): UpgradePolicy {\n        UpgradePolicy { policy: 0 }\n    }\n\n    /// Whether a compatibility check should be performed for upgrades. The check only passes if\n    /// a new module has (a) the same public functions (b) for existing resources, no layout change.\n    public fun upgrade_policy_compat(): UpgradePolicy {\n        UpgradePolicy { policy: 1 }\n    }\n\n    /// Whether the modules in the package are immutable and cannot be upgraded.\n    public fun upgrade_policy_immutable(): UpgradePolicy {\n        UpgradePolicy { policy: 2 }\n    }\n\n    /// Whether the upgrade policy can be changed. In general, the policy can be only\n    /// strengthened but not weakened.\n    public fun can_change_upgrade_policy_to(from: UpgradePolicy, to: UpgradePolicy): bool {\n        from.policy <= to.policy\n    }\n\n    /// Initialize package metadata for Genesis.\n    fun initialize(aptos_framework: &signer, package_owner: &signer, metadata: PackageMetadata)\n    acquires PackageRegistry {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        let addr = signer::address_of(package_owner);\n        if (!exists<PackageRegistry>(addr)) {\n            move_to(package_owner, PackageRegistry { packages: vector[metadata] })\n        } else {\n            vector::push_back(&mut borrow_global_mut<PackageRegistry>(addr).packages, metadata)\n        }\n    }\n\n    /// Publishes a package at the given signer's address. The caller must provide package metadata describing the\n    /// package.\n    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {\n        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.\n        assert!(\n            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,\n            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),\n        );\n\n        let addr = signer::address_of(owner);\n        if (!exists<PackageRegistry>(addr)) {\n            move_to(owner, PackageRegistry { packages: vector::empty() })\n        };\n\n        // Checks for valid dependencies to other packages\n        let allowed_deps = check_dependencies(addr, &pack);\n\n        // Check package against conflicts\n        // To avoid prover compiler error on spec\n        // the package need to be an immutable variable\n        let module_names = get_module_names(&pack);\n        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;\n        let len = vector::length(package_immutable);\n        let index = len;\n        let upgrade_number = 0;\n        vector::enumerate_ref(package_immutable\n        , |i, old| {\n            let old: &PackageMetadata = old;\n            if (old.name == pack.name) {\n                upgrade_number = old.upgrade_number + 1;\n                check_upgradability(old, &pack, &module_names);\n                index = i;\n            } else {\n                check_coexistence(old, &module_names)\n            };\n        });\n\n        // Assign the upgrade counter.\n        pack.upgrade_number = upgrade_number;\n\n        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;\n        // Update registry\n        let policy = pack.upgrade_policy;\n        if (index < len) {\n            *vector::borrow_mut(packages, index) = pack\n        } else {\n            vector::push_back(packages, pack)\n        };\n\n        event::emit(PublishPackage {\n            code_address: addr,\n            is_upgrade: upgrade_number > 0\n        });\n\n        // Request publish\n        if (features::code_dependency_check_enabled())\n            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)\n        else\n        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards\n        // compatible code.\n            request_publish(addr, module_names, code, policy.policy)\n    }\n\n    public fun freeze_code_object(publisher: &signer, code_object: Object<PackageRegistry>) acquires PackageRegistry {\n        let code_object_addr = object::object_address(&code_object);\n        assert!(exists<PackageRegistry>(code_object_addr), error::not_found(ECODE_OBJECT_DOES_NOT_EXIST));\n        assert!(\n            object::is_owner(code_object, signer::address_of(publisher)),\n            error::permission_denied(ENOT_PACKAGE_OWNER)\n        );\n\n        let registry = borrow_global_mut<PackageRegistry>(code_object_addr);\n        vector::for_each_mut<PackageMetadata>(&mut registry.packages, |pack| {\n            let package: &mut PackageMetadata = pack;\n            package.upgrade_policy = upgrade_policy_immutable();\n        });\n    }\n\n    /// Same as `publish_package` but as an entry function which can be called as a transaction. Because\n    /// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.\n    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)\n    acquires PackageRegistry {\n        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)\n    }\n\n    // Helpers\n    // -------\n\n    /// Checks whether the given package is upgradable, and returns true if a compatibility check is needed.\n    fun check_upgradability(\n        old_pack: &PackageMetadata, new_pack: &PackageMetadata, new_modules: &vector<String>) {\n        assert!(old_pack.upgrade_policy.policy < upgrade_policy_immutable().policy,\n            error::invalid_argument(EUPGRADE_IMMUTABLE));\n        assert!(can_change_upgrade_policy_to(old_pack.upgrade_policy, new_pack.upgrade_policy),\n            error::invalid_argument(EUPGRADE_WEAKER_POLICY));\n        let old_modules = get_module_names(old_pack);\n\n        vector::for_each_ref(&old_modules, |old_module| {\n            assert!(\n                vector::contains(new_modules, old_module),\n                EMODULE_MISSING\n            );\n        });\n    }\n\n    /// Checks whether a new package with given names can co-exist with old package.\n    fun check_coexistence(old_pack: &PackageMetadata, new_modules: &vector<String>) {\n        // The modules introduced by each package must not overlap with `names`.\n        vector::for_each_ref(&old_pack.modules, |old_mod| {\n            let old_mod: &ModuleMetadata = old_mod;\n            let j = 0;\n            while (j < vector::length(new_modules)) {\n                let name = vector::borrow(new_modules, j);\n                assert!(&old_mod.name != name, error::already_exists(EMODULE_NAME_CLASH));\n                j = j + 1;\n            };\n        });\n    }\n\n    /// Check that the upgrade policies of all packages are equal or higher quality than this package. Also\n    /// compute the list of module dependencies which are allowed by the package metadata. The later\n    /// is passed on to the native layer to verify that bytecode dependencies are actually what is pretended here.\n    fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>\n    acquires PackageRegistry {\n        let allowed_module_deps = vector::empty();\n        let deps = &pack.deps;\n        vector::for_each_ref(deps, |dep| {\n            let dep: &PackageDep = dep;\n            assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));\n            if (is_policy_exempted_address(dep.account)) {\n                // Allow all modules from this address, by using \"\" as a wildcard in the AllowedDep\n                let account: address = dep.account;\n                let module_name = string::utf8(b\"\");\n                vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });\n            } else {\n                let registry = borrow_global<PackageRegistry>(dep.account);\n                let found = vector::any(&registry.packages, |dep_pack| {\n                    let dep_pack: &PackageMetadata = dep_pack;\n                    if (dep_pack.name == dep.package_name) {\n                        // Check policy\n                        assert!(\n                            dep_pack.upgrade_policy.policy >= pack.upgrade_policy.policy,\n                            error::invalid_argument(EDEP_WEAKER_POLICY)\n                        );\n                        if (dep_pack.upgrade_policy == upgrade_policy_arbitrary()) {\n                            assert!(\n                                dep.account == publish_address,\n                                error::invalid_argument(EDEP_ARBITRARY_NOT_SAME_ADDRESS)\n                            )\n                        };\n                        // Add allowed deps\n                        let account = dep.account;\n                        let k = 0;\n                        let r = vector::length(&dep_pack.modules);\n                        while (k < r) {\n                            let module_name = vector::borrow(&dep_pack.modules, k).name;\n                            vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });\n                            k = k + 1;\n                        };\n                        true\n                    } else {\n                        false\n                    }\n                });\n                assert!(found, error::not_found(EPACKAGE_DEP_MISSING));\n            };\n        });\n        allowed_module_deps\n    }\n\n    /// Core addresses which are exempted from the check that their policy matches the referring package. Without\n    /// this exemption, it would not be possible to define an immutable package based on the core system, which\n    /// requires to be upgradable for maintenance and evolution, and is configured to be `compatible`.\n    fun is_policy_exempted_address(addr: address): bool {\n        addr == @1 || addr == @2 || addr == @3 || addr == @4 || addr == @5 ||\n            addr == @6 || addr == @7 || addr == @8 || addr == @9 || addr == @10\n    }\n\n    /// Get the names of the modules in a package.\n    fun get_module_names(pack: &PackageMetadata): vector<String> {\n        let module_names = vector::empty();\n        vector::for_each_ref(&pack.modules, |pack_module| {\n            let pack_module: &ModuleMetadata = pack_module;\n            vector::push_back(&mut module_names, pack_module.name);\n        });\n        module_names\n    }\n\n    /// Native function to initiate module loading\n    native fun request_publish(\n        owner: address,\n        expected_modules: vector<String>,\n        bundle: vector<vector<u8>>,\n        policy: u8\n    );\n\n    /// A helper type for request_publish_with_allowed_deps\n    struct AllowedDep has drop {\n        /// Address of the module.\n        account: address,\n        /// Name of the module. If this is the empty string, then this serves as a wildcard for\n        /// all modules from this address. This is used for speeding up dependency checking for packages from\n        /// well-known framework addresses, where we can assume that there are no malicious packages.\n        module_name: String\n    }\n\n    /// Native function to initiate module loading, including a list of allowed dependencies.\n    native fun request_publish_with_allowed_deps(\n        owner: address,\n        expected_modules: vector<String>,\n        allowed_deps: vector<AllowedDep>,\n        bundle: vector<vector<u8>>,\n        policy: u8\n    );\n}\n","name":"code.move"},{"content":"/// This module provides the foundation for typesafe Coins.\nmodule aptos_framework::coin {\n    use std::string;\n    use std::error;\n    use std::features;\n    use std::option::{Self, Option};\n    use std::signer;\n    use aptos_std::table::{Self, Table};\n\n    use aptos_framework::account;\n    use aptos_framework::aggregator_factory;\n    use aptos_framework::aggregator::{Self, Aggregator};\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::guid;\n    use aptos_framework::optional_aggregator::{Self, OptionalAggregator};\n    use aptos_framework::system_addresses;\n\n    use aptos_framework::fungible_asset::{Self, FungibleAsset, Metadata, MintRef, TransferRef, BurnRef};\n    use aptos_framework::object::{Self, Object, object_address};\n    use aptos_framework::primary_fungible_store;\n    use aptos_std::type_info::{Self, TypeInfo};\n    use aptos_framework::create_signer;\n    #[test_only]\n    use std::string::String;\n\n    friend aptos_framework::aptos_coin;\n    friend aptos_framework::genesis;\n    friend aptos_framework::transaction_fee;\n\n    //\n    // Errors.\n    //\n\n    /// Address of account which is used to initialize a coin `CoinType` doesn't match the deployer of module\n    const ECOIN_INFO_ADDRESS_MISMATCH: u64 = 1;\n\n    /// `CoinType` is already initialized as a coin\n    const ECOIN_INFO_ALREADY_PUBLISHED: u64 = 2;\n\n    /// `CoinType` hasn't been initialized as a coin\n    const ECOIN_INFO_NOT_PUBLISHED: u64 = 3;\n\n    /// Deprecated. Account already has `CoinStore` registered for `CoinType`\n    const ECOIN_STORE_ALREADY_PUBLISHED: u64 = 4;\n\n    /// Account hasn't registered `CoinStore` for `CoinType`\n    const ECOIN_STORE_NOT_PUBLISHED: u64 = 5;\n\n    /// Not enough coins to complete transaction\n    const EINSUFFICIENT_BALANCE: u64 = 6;\n\n    /// Cannot destroy non-zero coins\n    const EDESTRUCTION_OF_NONZERO_TOKEN: u64 = 7;\n\n    /// CoinStore is frozen. Coins cannot be deposited or withdrawn\n    const EFROZEN: u64 = 10;\n\n    /// Cannot upgrade the total supply of coins to different implementation.\n    const ECOIN_SUPPLY_UPGRADE_NOT_SUPPORTED: u64 = 11;\n\n    /// Name of the coin is too long\n    const ECOIN_NAME_TOO_LONG: u64 = 12;\n\n    /// Symbol of the coin is too long\n    const ECOIN_SYMBOL_TOO_LONG: u64 = 13;\n\n    /// The value of aggregatable coin used for transaction fees redistribution does not fit in u64.\n    const EAGGREGATABLE_COIN_VALUE_TOO_LARGE: u64 = 14;\n\n    /// Error regarding paired coin type of the fungible asset metadata.\n    const EPAIRED_COIN: u64 = 15;\n\n    /// Error regarding paired fungible asset metadata of a coin type.\n    const EPAIRED_FUNGIBLE_ASSET: u64 = 16;\n\n    /// The coin type from the map does not match the calling function type argument.\n    const ECOIN_TYPE_MISMATCH: u64 = 17;\n\n    /// The feature of migration from coin to fungible asset is not enabled.\n    const ECOIN_TO_FUNGIBLE_ASSET_FEATURE_NOT_ENABLED: u64 = 18;\n\n    /// PairedFungibleAssetRefs resource does not exist.\n    const EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND: u64 = 19;\n\n    /// The MintRefReceipt does not match the MintRef to be returned.\n    const EMINT_REF_RECEIPT_MISMATCH: u64 = 20;\n\n    /// The MintRef does not exist.\n    const EMINT_REF_NOT_FOUND: u64 = 21;\n\n    /// The TransferRefReceipt does not match the TransferRef to be returned.\n    const ETRANSFER_REF_RECEIPT_MISMATCH: u64 = 22;\n\n    /// The TransferRef does not exist.\n    const ETRANSFER_REF_NOT_FOUND: u64 = 23;\n\n    /// The BurnRefReceipt does not match the BurnRef to be returned.\n    const EBURN_REF_RECEIPT_MISMATCH: u64 = 24;\n\n    /// The BurnRef does not exist.\n    const EBURN_REF_NOT_FOUND: u64 = 25;\n\n    /// The migration process from coin to fungible asset is not enabled yet.\n    const EMIGRATION_FRAMEWORK_NOT_ENABLED: u64 = 26;\n\n    /// The coin converison map is not created yet.\n    const ECOIN_CONVERSION_MAP_NOT_FOUND: u64 = 27;\n\n    /// APT pairing is not eanbled yet.\n    const EAPT_PAIRING_IS_NOT_ENABLED: u64 = 28;\n\n    //\n    // Constants\n    //\n\n    const MAX_COIN_NAME_LENGTH: u64 = 32;\n    const MAX_COIN_SYMBOL_LENGTH: u64 = 10;\n\n    /// Core data structures\n\n    /// Main structure representing a coin/token in an account's custody.\n    struct Coin<phantom CoinType> has store {\n        /// Amount of coin this address has.\n        value: u64,\n    }\n\n    /// Represents a coin with aggregator as its value. This allows to update\n    /// the coin in every transaction avoiding read-modify-write conflicts. Only\n    /// used for gas fees distribution by Aptos Framework (0x1).\n    struct AggregatableCoin<phantom CoinType> has store {\n        /// Amount of aggregatable coin this address has.\n        value: Aggregator,\n    }\n\n    /// Maximum possible aggregatable coin value.\n    const MAX_U64: u128 = 18446744073709551615;\n\n    /// A holder of a specific coin types and associated event handles.\n    /// These are kept in a single resource to ensure locality of data.\n    struct CoinStore<phantom CoinType> has key {\n        coin: Coin<CoinType>,\n        frozen: bool,\n        deposit_events: EventHandle<DepositEvent>,\n        withdraw_events: EventHandle<WithdrawEvent>,\n    }\n\n    /// Maximum possible coin supply.\n    const MAX_U128: u128 = 340282366920938463463374607431768211455;\n\n    /// Configuration that controls the behavior of total coin supply. If the field\n    /// is set, coin creators are allowed to upgrade to parallelizable implementations.\n    struct SupplyConfig has key {\n        allow_upgrades: bool,\n    }\n\n    /// Information about a specific coin type. Stored on the creator of the coin's account.\n    struct CoinInfo<phantom CoinType> has key {\n        name: string::String,\n        /// Symbol of the coin, usually a shorter version of the name.\n        /// For example, Singapore Dollar is SGD.\n        symbol: string::String,\n        /// Number of decimals used to get its user representation.\n        /// For example, if `decimals` equals `2`, a balance of `505` coins should\n        /// be displayed to a user as `5.05` (`505 / 10 ** 2`).\n        decimals: u8,\n        /// Amount of this coin type in existence.\n        supply: Option<OptionalAggregator>,\n    }\n\n    /// Event emitted when some amount of a coin is deposited into an account.\n    struct DepositEvent has drop, store {\n        amount: u64,\n    }\n\n    #[event]\n    /// Module event emitted when some amount of a coin is deposited into an account.\n    struct Deposit<phantom CoinType> has drop, store {\n        account: address,\n        amount: u64,\n    }\n\n    /// Event emitted when some amount of a coin is withdrawn from an account.\n    struct WithdrawEvent has drop, store {\n        amount: u64,\n    }\n\n    #[event]\n    /// Module event emitted when some amount of a coin is withdrawn from an account.\n    struct Withdraw<phantom CoinType> has drop, store {\n        account: address,\n        amount: u64,\n    }\n\n    #[event]\n    /// Module event emitted when the event handles related to coin store is deleted.\n    struct CoinEventHandleDeletion has drop, store {\n        event_handle_creation_address: address,\n        deleted_deposit_event_handle_creation_number: u64,\n        deleted_withdraw_event_handle_creation_number: u64,\n    }\n\n    #[event]\n    /// Module event emitted when a new pair of coin and fungible asset is created.\n    struct PairCreation has drop, store {\n        coin_type: TypeInfo,\n        fungible_asset_metadata_address: address,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// The flag the existence of which indicates the primary fungible store is created by the migration from CoinStore.\n    struct MigrationFlag has key {}\n\n    /// Capability required to mint coins.\n    struct MintCapability<phantom CoinType> has copy, store {}\n\n    /// Capability required to freeze a coin store.\n    struct FreezeCapability<phantom CoinType> has copy, store {}\n\n    /// Capability required to burn coins.\n    struct BurnCapability<phantom CoinType> has copy, store {}\n\n    /// The mapping between coin and fungible asset.\n    struct CoinConversionMap has key {\n        coin_to_fungible_asset_map: Table<TypeInfo, Object<Metadata>>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// The paired coin type info stored in fungible asset metadata object.\n    struct PairedCoinType has key {\n        type: TypeInfo,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// The refs of the paired fungible asset.\n    struct PairedFungibleAssetRefs has key {\n        mint_ref_opt: Option<MintRef>,\n        transfer_ref_opt: Option<TransferRef>,\n        burn_ref_opt: Option<BurnRef>,\n    }\n\n    /// The hot potato receipt for flash borrowing MintRef.\n    struct MintRefReceipt {\n        metadata: Object<Metadata>,\n    }\n\n    /// The hot potato receipt for flash borrowing TransferRef.\n    struct TransferRefReceipt {\n        metadata: Object<Metadata>,\n    }\n\n    /// The hot potato receipt for flash borrowing BurnRef.\n    struct BurnRefReceipt {\n        metadata: Object<Metadata>,\n    }\n\n    #[view]\n    /// Get the paired fungible asset metadata object of a coin type. If not exist, return option::none().\n    public fun paired_metadata<CoinType>(): Option<Object<Metadata>> acquires CoinConversionMap {\n        if (exists<CoinConversionMap>(@aptos_framework) && features::coin_to_fungible_asset_migration_feature_enabled(\n        )) {\n            let map = &borrow_global<CoinConversionMap>(@aptos_framework).coin_to_fungible_asset_map;\n            let type = type_info::type_of<CoinType>();\n            if (table::contains(map, type)) {\n                return option::some(*table::borrow(map, type))\n            }\n        };\n        option::none()\n    }\n\n    public entry fun create_coin_conversion_map(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        if (!exists<CoinConversionMap>(@aptos_framework)) {\n            move_to(aptos_framework, CoinConversionMap {\n                coin_to_fungible_asset_map: table::new(),\n            })\n        };\n    }\n\n    /// Create APT pairing by passing `AptosCoin`.\n    public entry fun create_pairing<CoinType>(\n        aptos_framework: &signer\n    ) acquires CoinConversionMap, CoinInfo {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        create_and_return_paired_metadata_if_not_exist<CoinType>(true);\n    }\n\n    inline fun is_apt<CoinType>(): bool {\n        type_info::type_name<CoinType>() == string::utf8(b\"0x1::aptos_coin::AptosCoin\")\n    }\n\n    inline fun create_and_return_paired_metadata_if_not_exist<CoinType>(allow_apt_creation: bool): Object<Metadata> {\n        assert!(\n            features::coin_to_fungible_asset_migration_feature_enabled(),\n            error::invalid_state(EMIGRATION_FRAMEWORK_NOT_ENABLED)\n        );\n        assert!(exists<CoinConversionMap>(@aptos_framework), error::not_found(ECOIN_CONVERSION_MAP_NOT_FOUND));\n        let map = borrow_global_mut<CoinConversionMap>(@aptos_framework);\n        let type = type_info::type_of<CoinType>();\n        if (!table::contains(&map.coin_to_fungible_asset_map, type)) {\n            let is_apt = is_apt<CoinType>();\n            assert!(!is_apt || allow_apt_creation, error::invalid_state(EAPT_PAIRING_IS_NOT_ENABLED));\n            let metadata_object_cref =\n                if (is_apt) {\n                    object::create_sticky_object_at_address(@aptos_framework, @aptos_fungible_asset)\n                } else {\n                    object::create_named_object(\n                        &create_signer::create_signer(@aptos_fungible_asset),\n                        *string::bytes(&type_info::type_name<CoinType>())\n                    )\n                };\n            primary_fungible_store::create_primary_store_enabled_fungible_asset(\n                &metadata_object_cref,\n                option::map(coin_supply<CoinType>(), |_| MAX_U128),\n                name<CoinType>(),\n                symbol<CoinType>(),\n                decimals<CoinType>(),\n                string::utf8(b\"\"),\n                string::utf8(b\"\"),\n            );\n\n            let metadata_object_signer = &object::generate_signer(&metadata_object_cref);\n            let type = type_info::type_of<CoinType>();\n            move_to(metadata_object_signer, PairedCoinType { type });\n            let metadata_obj = object::object_from_constructor_ref(&metadata_object_cref);\n\n            table::add(&mut map.coin_to_fungible_asset_map, type, metadata_obj);\n            event::emit(PairCreation {\n                coin_type: type,\n                fungible_asset_metadata_address: object_address(&metadata_obj)\n            });\n\n            // Generates all three refs\n            let mint_ref = fungible_asset::generate_mint_ref(&metadata_object_cref);\n            let transfer_ref = fungible_asset::generate_transfer_ref(&metadata_object_cref);\n            let burn_ref = fungible_asset::generate_burn_ref(&metadata_object_cref);\n            move_to(metadata_object_signer,\n                PairedFungibleAssetRefs {\n                    mint_ref_opt: option::some(mint_ref),\n                    transfer_ref_opt: option::some(transfer_ref),\n                    burn_ref_opt: option::some(burn_ref),\n                }\n            );\n        };\n        *table::borrow(&map.coin_to_fungible_asset_map, type)\n    }\n\n    /// Get the paired fungible asset metadata object of a coin type, create if not exist.\n    public(friend) fun ensure_paired_metadata<CoinType>(): Object<Metadata> acquires CoinConversionMap, CoinInfo {\n        create_and_return_paired_metadata_if_not_exist<CoinType>(false)\n    }\n\n    #[view]\n    /// Get the paired coin type of a fungible asset metadata object.\n    public fun paired_coin(metadata: Object<Metadata>): Option<TypeInfo> acquires PairedCoinType {\n        let metadata_addr = object::object_address(&metadata);\n        if (exists<PairedCoinType>(metadata_addr)) {\n            option::some(borrow_global<PairedCoinType>(metadata_addr).type)\n        } else {\n            option::none()\n        }\n    }\n\n    /// Conversion from coin to fungible asset\n    public fun coin_to_fungible_asset<CoinType>(\n        coin: Coin<CoinType>\n    ): FungibleAsset acquires CoinConversionMap, CoinInfo {\n        let metadata = ensure_paired_metadata<CoinType>();\n        let amount = burn_internal(coin);\n        fungible_asset::mint_internal(metadata, amount)\n    }\n\n    /// Conversion from fungible asset to coin. Not public to push the migration to FA.\n    fun fungible_asset_to_coin<CoinType>(\n        fungible_asset: FungibleAsset\n    ): Coin<CoinType> acquires CoinInfo, PairedCoinType {\n        let metadata_addr = object::object_address(&fungible_asset::metadata_from_asset(&fungible_asset));\n        assert!(\n            object::object_exists<PairedCoinType>(metadata_addr),\n            error::not_found(EPAIRED_COIN)\n        );\n        let coin_type_info = borrow_global<PairedCoinType>(metadata_addr).type;\n        assert!(coin_type_info == type_info::type_of<CoinType>(), error::invalid_argument(ECOIN_TYPE_MISMATCH));\n        let amount = fungible_asset::burn_internal(fungible_asset);\n        mint_internal<CoinType>(amount)\n    }\n\n    inline fun assert_paired_metadata_exists<CoinType>(): Object<Metadata> {\n        let metadata_opt = paired_metadata<CoinType>();\n        assert!(option::is_some(&metadata_opt), error::not_found(EPAIRED_FUNGIBLE_ASSET));\n        option::destroy_some(metadata_opt)\n    }\n\n    #[view]\n    /// Check whether `MintRef` has not been taken.\n    public fun paired_mint_ref_exists<CoinType>(): bool acquires CoinConversionMap, PairedFungibleAssetRefs {\n        let metadata = assert_paired_metadata_exists<CoinType>();\n        let metadata_addr = object_address(&metadata);\n        assert!(exists<PairedFungibleAssetRefs>(metadata_addr), error::internal(EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND));\n        option::is_some(&borrow_global<PairedFungibleAssetRefs>(metadata_addr).mint_ref_opt)\n    }\n\n    /// Get the `MintRef` of paired fungible asset of a coin type from `MintCapability`.\n    public fun get_paired_mint_ref<CoinType>(\n        _: &MintCapability<CoinType>\n    ): (MintRef, MintRefReceipt) acquires CoinConversionMap, PairedFungibleAssetRefs {\n        let metadata = assert_paired_metadata_exists<CoinType>();\n        let metadata_addr = object_address(&metadata);\n        assert!(exists<PairedFungibleAssetRefs>(metadata_addr), error::internal(EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND));\n        let mint_ref_opt = &mut borrow_global_mut<PairedFungibleAssetRefs>(metadata_addr).mint_ref_opt;\n        assert!(option::is_some(mint_ref_opt), error::not_found(EMINT_REF_NOT_FOUND));\n        (option::extract(mint_ref_opt), MintRefReceipt { metadata })\n    }\n\n    /// Return the `MintRef` with the hot potato receipt.\n    public fun return_paired_mint_ref(mint_ref: MintRef, receipt: MintRefReceipt) acquires PairedFungibleAssetRefs {\n        let MintRefReceipt { metadata } = receipt;\n        assert!(\n            fungible_asset::mint_ref_metadata(&mint_ref) == metadata,\n            error::invalid_argument(EMINT_REF_RECEIPT_MISMATCH)\n        );\n        let metadata_addr = object_address(&metadata);\n        let mint_ref_opt = &mut borrow_global_mut<PairedFungibleAssetRefs>(metadata_addr).mint_ref_opt;\n        option::fill(mint_ref_opt, mint_ref);\n    }\n\n    #[view]\n    /// Check whether `TransferRef` still exists.\n    public fun paired_transfer_ref_exists<CoinType>(): bool acquires CoinConversionMap, PairedFungibleAssetRefs {\n        let metadata = assert_paired_metadata_exists<CoinType>();\n        let metadata_addr = object_address(&metadata);\n        assert!(exists<PairedFungibleAssetRefs>(metadata_addr), error::internal(EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND));\n        option::is_some(&borrow_global<PairedFungibleAssetRefs>(metadata_addr).transfer_ref_opt)\n    }\n\n    /// Get the TransferRef of paired fungible asset of a coin type from `FreezeCapability`.\n    public fun get_paired_transfer_ref<CoinType>(\n        _: &FreezeCapability<CoinType>\n    ): (TransferRef, TransferRefReceipt) acquires CoinConversionMap, PairedFungibleAssetRefs {\n        let metadata = assert_paired_metadata_exists<CoinType>();\n        let metadata_addr = object_address(&metadata);\n        assert!(exists<PairedFungibleAssetRefs>(metadata_addr), error::internal(EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND));\n        let transfer_ref_opt = &mut borrow_global_mut<PairedFungibleAssetRefs>(metadata_addr).transfer_ref_opt;\n        assert!(option::is_some(transfer_ref_opt), error::not_found(ETRANSFER_REF_NOT_FOUND));\n        (option::extract(transfer_ref_opt), TransferRefReceipt { metadata })\n    }\n\n    /// Return the `TransferRef` with the hot potato receipt.\n    public fun return_paired_transfer_ref(\n        transfer_ref: TransferRef,\n        receipt: TransferRefReceipt\n    ) acquires PairedFungibleAssetRefs {\n        let TransferRefReceipt { metadata } = receipt;\n        assert!(\n            fungible_asset::transfer_ref_metadata(&transfer_ref) == metadata,\n            error::invalid_argument(ETRANSFER_REF_RECEIPT_MISMATCH)\n        );\n        let metadata_addr = object_address(&metadata);\n        let transfer_ref_opt = &mut borrow_global_mut<PairedFungibleAssetRefs>(metadata_addr).transfer_ref_opt;\n        option::fill(transfer_ref_opt, transfer_ref);\n    }\n\n    #[view]\n    /// Check whether `BurnRef` has not been taken.\n    public fun paired_burn_ref_exists<CoinType>(): bool acquires CoinConversionMap, PairedFungibleAssetRefs {\n        let metadata = assert_paired_metadata_exists<CoinType>();\n        let metadata_addr = object_address(&metadata);\n        assert!(exists<PairedFungibleAssetRefs>(metadata_addr), error::internal(EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND));\n        option::is_some(&borrow_global<PairedFungibleAssetRefs>(metadata_addr).burn_ref_opt)\n    }\n\n    /// Get the `BurnRef` of paired fungible asset of a coin type from `BurnCapability`.\n    public fun get_paired_burn_ref<CoinType>(\n        _: &BurnCapability<CoinType>\n    ): (BurnRef, BurnRefReceipt) acquires CoinConversionMap, PairedFungibleAssetRefs {\n        let metadata = assert_paired_metadata_exists<CoinType>();\n        let metadata_addr = object_address(&metadata);\n        assert!(exists<PairedFungibleAssetRefs>(metadata_addr), error::internal(EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND));\n        let burn_ref_opt = &mut borrow_global_mut<PairedFungibleAssetRefs>(metadata_addr).burn_ref_opt;\n        assert!(option::is_some(burn_ref_opt), error::not_found(EBURN_REF_NOT_FOUND));\n        (option::extract(burn_ref_opt), BurnRefReceipt { metadata })\n    }\n\n    /// Return the `BurnRef` with the hot potato receipt.\n    public fun return_paired_burn_ref(\n        burn_ref: BurnRef,\n        receipt: BurnRefReceipt\n    ) acquires PairedFungibleAssetRefs {\n        let BurnRefReceipt { metadata } = receipt;\n        assert!(\n            fungible_asset::burn_ref_metadata(&burn_ref) == metadata,\n            error::invalid_argument(EBURN_REF_RECEIPT_MISMATCH)\n        );\n        let metadata_addr = object_address(&metadata);\n        let burn_ref_opt = &mut borrow_global_mut<PairedFungibleAssetRefs>(metadata_addr).burn_ref_opt;\n        option::fill(burn_ref_opt, burn_ref);\n    }\n\n    inline fun borrow_paired_burn_ref<CoinType>(\n        _: &BurnCapability<CoinType>\n    ): &BurnRef acquires CoinConversionMap, PairedFungibleAssetRefs {\n        let metadata = assert_paired_metadata_exists<CoinType>();\n        let metadata_addr = object_address(&metadata);\n        assert!(exists<PairedFungibleAssetRefs>(metadata_addr), error::internal(EPAIRED_FUNGIBLE_ASSET_REFS_NOT_FOUND));\n        let burn_ref_opt = &mut borrow_global_mut<PairedFungibleAssetRefs>(metadata_addr).burn_ref_opt;\n        assert!(option::is_some(burn_ref_opt), error::not_found(EBURN_REF_NOT_FOUND));\n        option::borrow(burn_ref_opt)\n    }\n\n    //\n    // Total supply config\n    //\n\n    /// Publishes supply configuration. Initially, upgrading is not allowed.\n    public(friend) fun initialize_supply_config(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        move_to(aptos_framework, SupplyConfig { allow_upgrades: false });\n    }\n\n    /// This should be called by on-chain governance to update the config and allow\n    /// or disallow upgradability of total supply.\n    public fun allow_supply_upgrades(aptos_framework: &signer, allowed: bool) acquires SupplyConfig {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        let allow_upgrades = &mut borrow_global_mut<SupplyConfig>(@aptos_framework).allow_upgrades;\n        *allow_upgrades = allowed;\n    }\n\n    //\n    //  Aggregatable coin functions\n    //\n\n    /// Creates a new aggregatable coin with value overflowing on `limit`. Note that this function can\n    /// only be called by Aptos Framework (0x1) account for now because of `create_aggregator`.\n    public(friend) fun initialize_aggregatable_coin<CoinType>(aptos_framework: &signer): AggregatableCoin<CoinType> {\n        let aggregator = aggregator_factory::create_aggregator(aptos_framework, MAX_U64);\n        AggregatableCoin<CoinType> {\n            value: aggregator,\n        }\n    }\n\n    /// Returns true if the value of aggregatable coin is zero.\n    public(friend) fun is_aggregatable_coin_zero<CoinType>(coin: &AggregatableCoin<CoinType>): bool {\n        let amount = aggregator::read(&coin.value);\n        amount == 0\n    }\n\n    /// Drains the aggregatable coin, setting it to zero and returning a standard coin.\n    public(friend) fun drain_aggregatable_coin<CoinType>(coin: &mut AggregatableCoin<CoinType>): Coin<CoinType> {\n        spec {\n            // TODO: The data invariant is not properly assumed from CollectedFeesPerBlock.\n            assume aggregator::spec_get_limit(coin.value) == MAX_U64;\n        };\n        let amount = aggregator::read(&coin.value);\n        assert!(amount <= MAX_U64, error::out_of_range(EAGGREGATABLE_COIN_VALUE_TOO_LARGE));\n        spec {\n            update aggregate_supply<CoinType> = aggregate_supply<CoinType> - amount;\n        };\n        aggregator::sub(&mut coin.value, amount);\n        spec {\n            update supply<CoinType> = supply<CoinType> + amount;\n        };\n        Coin<CoinType> {\n            value: (amount as u64),\n        }\n    }\n\n    /// Merges `coin` into aggregatable coin (`dst_coin`).\n    public(friend) fun merge_aggregatable_coin<CoinType>(\n        dst_coin: &mut AggregatableCoin<CoinType>,\n        coin: Coin<CoinType>\n    ) {\n        spec {\n            update supply<CoinType> = supply<CoinType> - coin.value;\n        };\n        let Coin { value } = coin;\n        let amount = (value as u128);\n        spec {\n            update aggregate_supply<CoinType> = aggregate_supply<CoinType> + amount;\n        };\n        aggregator::add(&mut dst_coin.value, amount);\n    }\n\n    /// Collects a specified amount of coin form an account into aggregatable coin.\n    public(friend) fun collect_into_aggregatable_coin<CoinType>(\n        account_addr: address,\n        amount: u64,\n        dst_coin: &mut AggregatableCoin<CoinType>,\n    ) acquires CoinStore, CoinConversionMap, CoinInfo, PairedCoinType {\n        // Skip collecting if amount is zero.\n        if (amount == 0) {\n            return\n        };\n\n        let (coin_amount_to_collect, fa_amount_to_collect) = calculate_amount_to_withdraw<CoinType>(\n            account_addr,\n            amount\n        );\n        let coin = if (coin_amount_to_collect > 0) {\n            let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n            extract(&mut coin_store.coin, coin_amount_to_collect)\n        } else {\n            zero()\n        };\n        if (fa_amount_to_collect > 0) {\n            let store_addr = primary_fungible_store::primary_store_address(\n                account_addr,\n                option::destroy_some(paired_metadata<CoinType>())\n            );\n            let fa = fungible_asset::withdraw_internal(store_addr, fa_amount_to_collect);\n            merge(&mut coin, fungible_asset_to_coin<CoinType>(fa));\n        };\n        merge_aggregatable_coin(dst_coin, coin);\n    }\n\n    inline fun calculate_amount_to_withdraw<CoinType>(\n        account_addr: address,\n        amount: u64\n    ): (u64, u64) {\n        let coin_balance = coin_balance<CoinType>(account_addr);\n        if (coin_balance >= amount) {\n            (amount, 0)\n        } else {\n            let metadata = paired_metadata<CoinType>();\n            if (option::is_some(&metadata) && primary_fungible_store::primary_store_exists(\n                account_addr,\n                option::destroy_some(metadata)\n            ))\n                (coin_balance, amount - coin_balance)\n            else\n                abort error::invalid_argument(EINSUFFICIENT_BALANCE)\n        }\n    }\n\n    fun maybe_convert_to_fungible_store<CoinType>(account: address) acquires CoinStore, CoinConversionMap, CoinInfo {\n        if (!features::coin_to_fungible_asset_migration_feature_enabled()) {\n            abort error::unavailable(ECOIN_TO_FUNGIBLE_ASSET_FEATURE_NOT_ENABLED)\n        };\n        assert!(is_coin_initialized<CoinType>(), error::invalid_argument(ECOIN_INFO_NOT_PUBLISHED));\n\n        let metadata = ensure_paired_metadata<CoinType>();\n        let store = primary_fungible_store::ensure_primary_store_exists(account, metadata);\n        let store_address = object::object_address(&store);\n        if (exists<CoinStore<CoinType>>(account)) {\n            let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } = move_from<CoinStore<CoinType>>(\n                account\n            );\n            event::emit(\n                CoinEventHandleDeletion {\n                    event_handle_creation_address: guid::creator_address(\n                        event::guid(&deposit_events)\n                    ),\n                    deleted_deposit_event_handle_creation_number: guid::creation_num(event::guid(&deposit_events)),\n                    deleted_withdraw_event_handle_creation_number: guid::creation_num(event::guid(&withdraw_events))\n                }\n            );\n            event::destroy_handle(deposit_events);\n            event::destroy_handle(withdraw_events);\n            if (coin.value == 0) {\n                destroy_zero(coin);\n            } else {\n                fungible_asset::deposit(store, coin_to_fungible_asset(coin));\n            };\n            // Note:\n            // It is possible the primary fungible store may already exist before this function call.\n            // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this\n            // function would convert and deposit the rest coin into the primary store and freeze it to make the\n            // `frozen` semantic as consistent as possible.\n            if (frozen != fungible_asset::is_frozen(store)) {\n                fungible_asset::set_frozen_flag_internal(store, frozen);\n            }\n        };\n        if (!exists<MigrationFlag>(store_address)) {\n            move_to(&create_signer::create_signer(store_address), MigrationFlag {});\n        }\n    }\n\n    /// Voluntarily migrate to fungible store for `CoinType` if not yet.\n    public entry fun migrate_to_fungible_store<CoinType>(\n        account: &signer\n    ) acquires CoinStore, CoinConversionMap, CoinInfo {\n        maybe_convert_to_fungible_store<CoinType>(signer::address_of(account));\n    }\n\n    //\n    // Getter functions\n    //\n\n    /// A helper function that returns the address of CoinType.\n    fun coin_address<CoinType>(): address {\n        let type_info = type_info::type_of<CoinType>();\n        type_info::account_address(&type_info)\n    }\n\n    #[view]\n    /// Returns the balance of `owner` for provided `CoinType` and its paired FA if exists.\n    public fun balance<CoinType>(owner: address): u64 acquires CoinConversionMap, CoinStore {\n        let paired_metadata = paired_metadata<CoinType>();\n        coin_balance<CoinType>(owner) + if (option::is_some(&paired_metadata)) {\n            primary_fungible_store::balance(\n                owner,\n                option::extract(&mut paired_metadata)\n            )\n        } else { 0 }\n    }\n\n    #[view]\n    /// Returns whether the balance of `owner` for provided `CoinType` and its paired FA is >= `amount`.\n    public fun is_balance_at_least<CoinType>(owner: address, amount: u64): bool acquires CoinConversionMap, CoinStore {\n        let coin_balance = coin_balance<CoinType>(owner);\n        if (coin_balance >= amount) {\n            return true\n        };\n\n        let paired_metadata = paired_metadata<CoinType>();\n        let left_amount = amount - coin_balance;\n        if (option::is_some(&paired_metadata)) {\n            primary_fungible_store::is_balance_at_least(\n                owner,\n                option::extract(&mut paired_metadata),\n                left_amount\n            )\n        } else { false }\n    }\n\n    inline fun coin_balance<CoinType>(owner: address): u64 {\n        if (exists<CoinStore<CoinType>>(owner)) {\n            borrow_global<CoinStore<CoinType>>(owner).coin.value\n        } else {\n            0\n        }\n    }\n\n    #[view]\n    /// Returns `true` if the type `CoinType` is an initialized coin.\n    public fun is_coin_initialized<CoinType>(): bool {\n        exists<CoinInfo<CoinType>>(coin_address<CoinType>())\n    }\n\n    #[view]\n    /// Returns `true` is account_addr has frozen the CoinStore or if it's not registered at all\n    public fun is_coin_store_frozen<CoinType>(\n        account_addr: address\n    ): bool acquires CoinStore, CoinConversionMap {\n        if (!is_account_registered<CoinType>(account_addr)) {\n            return true\n        };\n\n        let coin_store = borrow_global<CoinStore<CoinType>>(account_addr);\n        coin_store.frozen\n    }\n\n    #[view]\n    /// Returns `true` if `account_addr` is registered to receive `CoinType`.\n    public fun is_account_registered<CoinType>(account_addr: address): bool acquires CoinConversionMap {\n        assert!(is_coin_initialized<CoinType>(), error::invalid_argument(ECOIN_INFO_NOT_PUBLISHED));\n        if (exists<CoinStore<CoinType>>(account_addr)) {\n            true\n        } else {\n            let paired_metadata_opt = paired_metadata<CoinType>();\n            (option::is_some(\n                &paired_metadata_opt\n            ) && migrated_primary_fungible_store_exists(account_addr, option::destroy_some(paired_metadata_opt)))\n        }\n    }\n\n    #[view]\n    /// Returns the name of the coin.\n    public fun name<CoinType>(): string::String acquires CoinInfo {\n        borrow_global<CoinInfo<CoinType>>(coin_address<CoinType>()).name\n    }\n\n    #[view]\n    /// Returns the symbol of the coin, usually a shorter version of the name.\n    public fun symbol<CoinType>(): string::String acquires CoinInfo {\n        borrow_global<CoinInfo<CoinType>>(coin_address<CoinType>()).symbol\n    }\n\n    #[view]\n    /// Returns the number of decimals used to get its user representation.\n    /// For example, if `decimals` equals `2`, a balance of `505` coins should\n    /// be displayed to a user as `5.05` (`505 / 10 ** 2`).\n    public fun decimals<CoinType>(): u8 acquires CoinInfo {\n        borrow_global<CoinInfo<CoinType>>(coin_address<CoinType>()).decimals\n    }\n\n    #[view]\n    /// Returns the amount of coin in existence.\n    public fun supply<CoinType>(): Option<u128> acquires CoinInfo, CoinConversionMap {\n        let coin_supply = coin_supply<CoinType>();\n        let metadata = paired_metadata<CoinType>();\n        if (option::is_some(&metadata)) {\n            let fungible_asset_supply = fungible_asset::supply(option::extract(&mut metadata));\n            if (option::is_some(&coin_supply)) {\n                let supply = option::borrow_mut(&mut coin_supply);\n                *supply = *supply + option::destroy_some(fungible_asset_supply);\n            };\n        };\n        coin_supply\n    }\n\n    #[view]\n    /// Returns the amount of coin in existence.\n    public fun coin_supply<CoinType>(): Option<u128> acquires CoinInfo {\n        let maybe_supply = &borrow_global<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;\n        if (option::is_some(maybe_supply)) {\n            // We do track supply, in this case read from optional aggregator.\n            let supply = option::borrow(maybe_supply);\n            let value = optional_aggregator::read(supply);\n            option::some(value)\n        } else {\n            option::none()\n        }\n    }\n    //\n    // Public functions\n    //\n\n    /// Burn `coin` with capability.\n    /// The capability `_cap` should be passed as a reference to `BurnCapability<CoinType>`.\n    public fun burn<CoinType>(coin: Coin<CoinType>, _cap: &BurnCapability<CoinType>) acquires CoinInfo {\n        burn_internal(coin);\n    }\n\n    /// Burn `coin` from the specified `account` with capability.\n    /// The capability `burn_cap` should be passed as a reference to `BurnCapability<CoinType>`.\n    /// This function shouldn't fail as it's called as part of transaction fee burning.\n    ///\n    /// Note: This bypasses CoinStore::frozen -- coins within a frozen CoinStore can be burned.\n    public fun burn_from<CoinType>(\n        account_addr: address,\n        amount: u64,\n        burn_cap: &BurnCapability<CoinType>,\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedFungibleAssetRefs {\n        // Skip burning if amount is zero. This shouldn't error out as it's called as part of transaction fee burning.\n        if (amount == 0) {\n            return\n        };\n\n        let (coin_amount_to_burn, fa_amount_to_burn) = calculate_amount_to_withdraw<CoinType>(\n            account_addr,\n            amount\n        );\n        if (coin_amount_to_burn > 0) {\n            let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n            let coin_to_burn = extract(&mut coin_store.coin, coin_amount_to_burn);\n            burn(coin_to_burn, burn_cap);\n        };\n        if (fa_amount_to_burn > 0) {\n            fungible_asset::burn_from(\n                borrow_paired_burn_ref(burn_cap),\n                primary_fungible_store::primary_store(account_addr, option::destroy_some(paired_metadata<CoinType>())),\n                fa_amount_to_burn\n            );\n        };\n    }\n\n    /// Deposit the coin balance into the recipient's account and emit an event.\n    public fun deposit<CoinType>(\n        account_addr: address,\n        coin: Coin<CoinType>\n    ) acquires CoinStore, CoinConversionMap, CoinInfo {\n        if (exists<CoinStore<CoinType>>(account_addr)) {\n            let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n            assert!(\n                !coin_store.frozen,\n                error::permission_denied(EFROZEN),\n            );\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(Deposit<CoinType> { account: account_addr, amount: coin.value });\n            };\n            event::emit_event<DepositEvent>(\n                &mut coin_store.deposit_events,\n                DepositEvent { amount: coin.value },\n            );\n            merge(&mut coin_store.coin, coin);\n        } else {\n            let metadata = paired_metadata<CoinType>();\n            if (option::is_some(&metadata) && migrated_primary_fungible_store_exists(\n                account_addr,\n                option::destroy_some(metadata)\n            )) {\n                primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));\n            } else {\n                abort error::not_found(ECOIN_STORE_NOT_PUBLISHED)\n            };\n        }\n    }\n\n    inline fun migrated_primary_fungible_store_exists(\n        account_address: address,\n        metadata: Object<Metadata>\n    ): bool {\n        let primary_store_address = primary_fungible_store::primary_store_address<Metadata>(account_address, metadata);\n        fungible_asset::store_exists(primary_store_address) && exists<MigrationFlag>(primary_store_address)\n    }\n\n    /// Deposit the coin balance into the recipient's account without checking if the account is frozen.\n    /// This is for internal use only and doesn't emit an DepositEvent.\n    public(friend) fun force_deposit<CoinType>(\n        account_addr: address,\n        coin: Coin<CoinType>\n    ) acquires CoinStore, CoinConversionMap, CoinInfo {\n        if (exists<CoinStore<CoinType>>(account_addr)) {\n            let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n            merge(&mut coin_store.coin, coin);\n        } else {\n            let metadata = paired_metadata<CoinType>();\n            if (option::is_some(&metadata) && migrated_primary_fungible_store_exists(\n                account_addr,\n                option::destroy_some(metadata)\n            )) {\n                let fa = coin_to_fungible_asset(coin);\n                let metadata = fungible_asset::asset_metadata(&fa);\n                let store = primary_fungible_store::primary_store(account_addr, metadata);\n                fungible_asset::deposit_internal(store, fa);\n            } else {\n                abort error::not_found(ECOIN_STORE_NOT_PUBLISHED)\n            }\n        }\n    }\n\n    /// Destroys a zero-value coin. Calls will fail if the `value` in the passed-in `token` is non-zero\n    /// so it is impossible to \"burn\" any non-zero amount of `Coin` without having\n    /// a `BurnCapability` for the specific `CoinType`.\n    public fun destroy_zero<CoinType>(zero_coin: Coin<CoinType>) {\n        spec {\n            update supply<CoinType> = supply<CoinType> - zero_coin.value;\n        };\n        let Coin { value } = zero_coin;\n        assert!(value == 0, error::invalid_argument(EDESTRUCTION_OF_NONZERO_TOKEN))\n    }\n\n    /// Extracts `amount` from the passed-in `coin`, where the original token is modified in place.\n    public fun extract<CoinType>(coin: &mut Coin<CoinType>, amount: u64): Coin<CoinType> {\n        assert!(coin.value >= amount, error::invalid_argument(EINSUFFICIENT_BALANCE));\n        spec {\n            update supply<CoinType> = supply<CoinType> - amount;\n        };\n        coin.value = coin.value - amount;\n        spec {\n            update supply<CoinType> = supply<CoinType> + amount;\n        };\n        Coin { value: amount }\n    }\n\n    /// Extracts the entire amount from the passed-in `coin`, where the original token is modified in place.\n    public fun extract_all<CoinType>(coin: &mut Coin<CoinType>): Coin<CoinType> {\n        let total_value = coin.value;\n        spec {\n            update supply<CoinType> = supply<CoinType> - coin.value;\n        };\n        coin.value = 0;\n        spec {\n            update supply<CoinType> = supply<CoinType> + total_value;\n        };\n        Coin { value: total_value }\n    }\n\n    #[legacy_entry_fun]\n    /// Freeze a CoinStore to prevent transfers\n    public entry fun freeze_coin_store<CoinType>(\n        account_addr: address,\n        _freeze_cap: &FreezeCapability<CoinType>,\n    ) acquires CoinStore {\n        let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n        coin_store.frozen = true;\n    }\n\n    #[legacy_entry_fun]\n    /// Unfreeze a CoinStore to allow transfers\n    public entry fun unfreeze_coin_store<CoinType>(\n        account_addr: address,\n        _freeze_cap: &FreezeCapability<CoinType>,\n    ) acquires CoinStore {\n        let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n        coin_store.frozen = false;\n    }\n\n    /// Upgrade total supply to use a parallelizable implementation if it is\n    /// available.\n    public entry fun upgrade_supply<CoinType>(account: &signer) acquires CoinInfo, SupplyConfig {\n        let account_addr = signer::address_of(account);\n\n        // Only coin creators can upgrade total supply.\n        assert!(\n            coin_address<CoinType>() == account_addr,\n            error::invalid_argument(ECOIN_INFO_ADDRESS_MISMATCH),\n        );\n\n        // Can only succeed once on-chain governance agreed on the upgrade.\n        assert!(\n            borrow_global_mut<SupplyConfig>(@aptos_framework).allow_upgrades,\n            error::permission_denied(ECOIN_SUPPLY_UPGRADE_NOT_SUPPORTED)\n        );\n\n        let maybe_supply = &mut borrow_global_mut<CoinInfo<CoinType>>(account_addr).supply;\n        if (option::is_some(maybe_supply)) {\n            let supply = option::borrow_mut(maybe_supply);\n\n            // If supply is tracked and the current implementation uses an integer - upgrade.\n            if (!optional_aggregator::is_parallelizable(supply)) {\n                optional_aggregator::switch(supply);\n            }\n        }\n    }\n\n    /// Creates a new Coin with given `CoinType` and returns minting/freezing/burning capabilities.\n    /// The given signer also becomes the account hosting the information  about the coin\n    /// (name, supply, etc.). Supply is initialized as non-parallelizable integer.\n    public fun initialize<CoinType>(\n        account: &signer,\n        name: string::String,\n        symbol: string::String,\n        decimals: u8,\n        monitor_supply: bool,\n    ): (BurnCapability<CoinType>, FreezeCapability<CoinType>, MintCapability<CoinType>) {\n        initialize_internal(account, name, symbol, decimals, monitor_supply, false)\n    }\n\n    /// Same as `initialize` but supply can be initialized to parallelizable aggregator.\n    public(friend) fun initialize_with_parallelizable_supply<CoinType>(\n        account: &signer,\n        name: string::String,\n        symbol: string::String,\n        decimals: u8,\n        monitor_supply: bool,\n    ): (BurnCapability<CoinType>, FreezeCapability<CoinType>, MintCapability<CoinType>) {\n        system_addresses::assert_aptos_framework(account);\n        initialize_internal(account, name, symbol, decimals, monitor_supply, true)\n    }\n\n    fun initialize_internal<CoinType>(\n        account: &signer,\n        name: string::String,\n        symbol: string::String,\n        decimals: u8,\n        monitor_supply: bool,\n        parallelizable: bool,\n    ): (BurnCapability<CoinType>, FreezeCapability<CoinType>, MintCapability<CoinType>) {\n        let account_addr = signer::address_of(account);\n\n        assert!(\n            coin_address<CoinType>() == account_addr,\n            error::invalid_argument(ECOIN_INFO_ADDRESS_MISMATCH),\n        );\n\n        assert!(\n            !exists<CoinInfo<CoinType>>(account_addr),\n            error::already_exists(ECOIN_INFO_ALREADY_PUBLISHED),\n        );\n\n        assert!(string::length(&name) <= MAX_COIN_NAME_LENGTH, error::invalid_argument(ECOIN_NAME_TOO_LONG));\n        assert!(string::length(&symbol) <= MAX_COIN_SYMBOL_LENGTH, error::invalid_argument(ECOIN_SYMBOL_TOO_LONG));\n\n        let coin_info = CoinInfo<CoinType> {\n            name,\n            symbol,\n            decimals,\n            supply: if (monitor_supply) {\n                option::some(\n                    optional_aggregator::new(MAX_U128, parallelizable)\n                )\n            } else { option::none() },\n        };\n        move_to(account, coin_info);\n\n        (BurnCapability<CoinType> {}, FreezeCapability<CoinType> {}, MintCapability<CoinType> {})\n    }\n\n    /// \"Merges\" the two given coins.  The coin passed in as `dst_coin` will have a value equal\n    /// to the sum of the two tokens (`dst_coin` and `source_coin`).\n    public fun merge<CoinType>(dst_coin: &mut Coin<CoinType>, source_coin: Coin<CoinType>) {\n        spec {\n            assume dst_coin.value + source_coin.value <= MAX_U64;\n        };\n        spec {\n            update supply<CoinType> = supply<CoinType> - source_coin.value;\n        };\n        let Coin { value } = source_coin;\n        spec {\n            update supply<CoinType> = supply<CoinType> + value;\n        };\n        dst_coin.value = dst_coin.value + value;\n    }\n\n    /// Mint new `Coin` with capability.\n    /// The capability `_cap` should be passed as reference to `MintCapability<CoinType>`.\n    /// Returns minted `Coin`.\n    public fun mint<CoinType>(\n        amount: u64,\n        _cap: &MintCapability<CoinType>,\n    ): Coin<CoinType> acquires CoinInfo {\n        mint_internal<CoinType>(amount)\n    }\n\n    public fun register<CoinType>(account: &signer) acquires CoinConversionMap {\n        let account_addr = signer::address_of(account);\n        // Short-circuit and do nothing if account is already registered for CoinType.\n        if (is_account_registered<CoinType>(account_addr)) {\n            return\n        };\n\n        account::register_coin<CoinType>(account_addr);\n        let coin_store = CoinStore<CoinType> {\n            coin: Coin { value: 0 },\n            frozen: false,\n            deposit_events: account::new_event_handle<DepositEvent>(account),\n            withdraw_events: account::new_event_handle<WithdrawEvent>(account),\n        };\n        move_to(account, coin_store);\n    }\n\n    /// Transfers `amount` of coins `CoinType` from `from` to `to`.\n    public entry fun transfer<CoinType>(\n        from: &signer,\n        to: address,\n        amount: u64,\n    ) acquires CoinStore, CoinConversionMap, CoinInfo, PairedCoinType {\n        let coin = withdraw<CoinType>(from, amount);\n        deposit(to, coin);\n    }\n\n    /// Returns the `value` passed in `coin`.\n    public fun value<CoinType>(coin: &Coin<CoinType>): u64 {\n        coin.value\n    }\n\n    /// Withdraw specified `amount` of coin `CoinType` from the signing account.\n    public fun withdraw<CoinType>(\n        account: &signer,\n        amount: u64,\n    ): Coin<CoinType> acquires CoinStore, CoinConversionMap, CoinInfo, PairedCoinType {\n        let account_addr = signer::address_of(account);\n\n        let (coin_amount_to_withdraw, fa_amount_to_withdraw) = calculate_amount_to_withdraw<CoinType>(\n            account_addr,\n            amount\n        );\n        let withdrawn_coin = if (coin_amount_to_withdraw > 0) {\n            let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n            assert!(\n                !coin_store.frozen,\n                error::permission_denied(EFROZEN),\n            );\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(Withdraw<CoinType> { account: account_addr, amount: coin_amount_to_withdraw });\n            };\n            event::emit_event<WithdrawEvent>(\n                &mut coin_store.withdraw_events,\n                WithdrawEvent { amount: coin_amount_to_withdraw },\n            );\n            extract(&mut coin_store.coin, coin_amount_to_withdraw)\n        } else {\n            zero()\n        };\n        if (fa_amount_to_withdraw > 0) {\n            let fa = primary_fungible_store::withdraw(\n                account,\n                option::destroy_some(paired_metadata<CoinType>()),\n                fa_amount_to_withdraw\n            );\n            merge(&mut withdrawn_coin, fungible_asset_to_coin(fa));\n        };\n        withdrawn_coin\n    }\n\n    /// Create a new `Coin<CoinType>` with a value of `0`.\n    public fun zero<CoinType>(): Coin<CoinType> {\n        spec {\n            update supply<CoinType> = supply<CoinType> + 0;\n        };\n        Coin<CoinType> {\n            value: 0\n        }\n    }\n\n    /// Destroy a freeze capability. Freeze capability is dangerous and therefore should be destroyed if not used.\n    public fun destroy_freeze_cap<CoinType>(freeze_cap: FreezeCapability<CoinType>) {\n        let FreezeCapability<CoinType> {} = freeze_cap;\n    }\n\n    /// Destroy a mint capability.\n    public fun destroy_mint_cap<CoinType>(mint_cap: MintCapability<CoinType>) {\n        let MintCapability<CoinType> {} = mint_cap;\n    }\n\n    /// Destroy a burn capability.\n    public fun destroy_burn_cap<CoinType>(burn_cap: BurnCapability<CoinType>) {\n        let BurnCapability<CoinType> {} = burn_cap;\n    }\n\n    fun mint_internal<CoinType>(amount: u64): Coin<CoinType> acquires CoinInfo {\n        if (amount == 0) {\n            return Coin<CoinType> {\n                value: 0\n            }\n        };\n\n        let maybe_supply = &mut borrow_global_mut<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;\n        if (option::is_some(maybe_supply)) {\n            let supply = option::borrow_mut(maybe_supply);\n            spec {\n                use aptos_framework::optional_aggregator;\n                use aptos_framework::aggregator;\n                assume optional_aggregator::is_parallelizable(supply) ==> (aggregator::spec_aggregator_get_val(\n                    option::borrow(supply.aggregator)\n                )\n                    + amount <= aggregator::spec_get_limit(option::borrow(supply.aggregator)));\n                assume !optional_aggregator::is_parallelizable(supply) ==>\n                    (option::borrow(supply.integer).value + amount <= option::borrow(supply.integer).limit);\n            };\n            optional_aggregator::add(supply, (amount as u128));\n        };\n        spec {\n            update supply<CoinType> = supply<CoinType> + amount;\n        };\n        Coin<CoinType> { value: amount }\n    }\n\n    fun burn_internal<CoinType>(coin: Coin<CoinType>): u64 acquires CoinInfo {\n        spec {\n            update supply<CoinType> = supply<CoinType> - coin.value;\n        };\n        let Coin { value: amount } = coin;\n        if (amount != 0) {\n            let maybe_supply = &mut borrow_global_mut<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;\n            if (option::is_some(maybe_supply)) {\n                let supply = option::borrow_mut(maybe_supply);\n                optional_aggregator::sub(supply, (amount as u128));\n            };\n        };\n        amount\n    }\n\n    #[test_only]\n    struct FakeMoney {}\n\n    #[test_only]\n    struct FakeMoneyCapabilities has key {\n        burn_cap: BurnCapability<FakeMoney>,\n        freeze_cap: FreezeCapability<FakeMoney>,\n        mint_cap: MintCapability<FakeMoney>,\n    }\n\n    #[test_only]\n    struct FakeMoneyRefs has key {\n        mint_ref: MintRef,\n        transfer_ref: TransferRef,\n        burn_ref: BurnRef,\n    }\n\n    #[test_only]\n    fun create_coin_store<CoinType>(account: &signer) {\n        assert!(is_coin_initialized<CoinType>(), error::invalid_argument(ECOIN_INFO_NOT_PUBLISHED));\n        if (!exists<CoinStore<CoinType>>(signer::address_of(account))) {\n            let coin_store = CoinStore<CoinType> {\n                coin: Coin { value: 0 },\n                frozen: false,\n                deposit_events: account::new_event_handle<DepositEvent>(account),\n                withdraw_events: account::new_event_handle<WithdrawEvent>(account),\n            };\n            move_to(account, coin_store);\n        }\n    }\n\n    #[test_only]\n    fun coin_store_exists<CoinType>(account: address): bool {\n        exists<CoinStore<CoinType>>(account)\n    }\n\n    #[test_only]\n    fun initialize_fake_money(\n        account: &signer,\n        decimals: u8,\n        monitor_supply: bool,\n    ): (BurnCapability<FakeMoney>, FreezeCapability<FakeMoney>, MintCapability<FakeMoney>) {\n        aggregator_factory::initialize_aggregator_factory_for_test(account);\n        initialize<FakeMoney>(\n            account,\n            string::utf8(b\"Fake money\"),\n            string::utf8(b\"FMD\"),\n            decimals,\n            monitor_supply\n        )\n    }\n\n    #[test_only]\n    public fun initialize_and_register_fake_money(\n        account: &signer,\n        decimals: u8,\n        monitor_supply: bool,\n    ): (BurnCapability<FakeMoney>, FreezeCapability<FakeMoney>, MintCapability<FakeMoney>) {\n        let (burn_cap, freeze_cap, mint_cap) = initialize_fake_money(\n            account,\n            decimals,\n            monitor_supply\n        );\n        create_coin_store<FakeMoney>(account);\n        create_coin_conversion_map(account);\n        (burn_cap, freeze_cap, mint_cap)\n    }\n\n    #[test_only]\n    public entry fun create_fake_money(\n        source: &signer,\n        destination: &signer,\n        amount: u64\n    ) acquires CoinInfo, CoinStore, CoinConversionMap {\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(source, 18, true);\n\n        create_coin_store<FakeMoney>(destination);\n        let coins_minted = mint<FakeMoney>(amount, &mint_cap);\n        deposit(signer::address_of(source), coins_minted);\n        move_to(source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x1, destination = @0x2)]\n    public entry fun end_to_end(\n        source: signer,\n        destination: signer,\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedCoinType {\n        let source_addr = signer::address_of(&source);\n        account::create_account_for_test(source_addr);\n        let destination_addr = signer::address_of(&destination);\n        account::create_account_for_test(destination_addr);\n\n        let name = string::utf8(b\"Fake money\");\n        let symbol = string::utf8(b\"FMD\");\n\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(\n            &source,\n            18,\n            true\n        );\n        register<FakeMoney>(&source);\n        register<FakeMoney>(&destination);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 0, 0);\n\n        assert!(name<FakeMoney>() == name, 1);\n        assert!(symbol<FakeMoney>() == symbol, 2);\n        assert!(decimals<FakeMoney>() == 18, 3);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        deposit(source_addr, coins_minted);\n        maybe_convert_to_fungible_store<FakeMoney>(source_addr);\n        assert!(!coin_store_exists<FakeMoney>(source_addr), 0);\n        assert!(coin_store_exists<FakeMoney>(destination_addr), 0);\n\n        transfer<FakeMoney>(&source, destination_addr, 50);\n        maybe_convert_to_fungible_store<FakeMoney>(destination_addr);\n        assert!(!coin_store_exists<FakeMoney>(destination_addr), 0);\n\n        assert!(balance<FakeMoney>(source_addr) == 50, 4);\n        assert!(balance<FakeMoney>(destination_addr) == 50, 5);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 100, 6);\n\n        let coin = withdraw<FakeMoney>(&source, 10);\n        assert!(value(&coin) == 10, 7);\n        burn(coin, &burn_cap);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 90, 8);\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x1, destination = @0x2)]\n    public entry fun end_to_end_no_supply(\n        source: signer,\n        destination: signer,\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedCoinType {\n        let source_addr = signer::address_of(&source);\n        account::create_account_for_test(source_addr);\n        let destination_addr = signer::address_of(&destination);\n        account::create_account_for_test(destination_addr);\n\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&source, 1, false);\n\n        register<FakeMoney>(&destination);\n        assert!(option::is_none(&supply<FakeMoney>()), 0);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        deposit<FakeMoney>(source_addr, coins_minted);\n        transfer<FakeMoney>(&source, destination_addr, 50);\n\n        assert!(balance<FakeMoney>(source_addr) == 50, 1);\n        assert!(balance<FakeMoney>(destination_addr) == 50, 2);\n        assert!(option::is_none(&supply<FakeMoney>()), 3);\n\n        let coin = withdraw<FakeMoney>(&source, 10);\n        burn(coin, &burn_cap);\n        assert!(option::is_none(&supply<FakeMoney>()), 4);\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x2, framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10001, location = Self)]\n    public fun fail_initialize(source: signer, framework: signer) {\n        aggregator_factory::initialize_aggregator_factory_for_test(&framework);\n        let (burn_cap, freeze_cap, mint_cap) = initialize<FakeMoney>(\n            &source,\n            string::utf8(b\"Fake money\"),\n            string::utf8(b\"FMD\"),\n            1,\n            true,\n        );\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x1, destination = @0x2)]\n    public entry fun transfer_to_migrated_destination(\n        source: signer,\n        destination: signer,\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedCoinType {\n        let source_addr = signer::address_of(&source);\n        account::create_account_for_test(source_addr);\n        let destination_addr = signer::address_of(&destination);\n        account::create_account_for_test(destination_addr);\n\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&source, 1, true);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 0, 0);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        deposit(source_addr, coins_minted);\n        maybe_convert_to_fungible_store<FakeMoney>(source_addr);\n        assert!(!coin_store_exists<FakeMoney>(source_addr), 0);\n        maybe_convert_to_fungible_store<FakeMoney>(destination_addr);\n        transfer<FakeMoney>(&source, destination_addr, 50);\n        assert!(balance<FakeMoney>(destination_addr) == 50, 2);\n        assert!(!coin_store_exists<FakeMoney>(destination_addr), 0);\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x1)]\n    public entry fun test_burn_from_with_capability(\n        source: signer,\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedFungibleAssetRefs {\n        let source_addr = signer::address_of(&source);\n        account::create_account_for_test(source_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&source, 1, true);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        deposit(source_addr, coins_minted);\n        let fa_minted = coin_to_fungible_asset(mint<FakeMoney>(200, &mint_cap));\n        primary_fungible_store::deposit(source_addr, fa_minted);\n\n        // Burn coin only with both stores\n        burn_from<FakeMoney>(source_addr, 50, &burn_cap);\n        assert!(balance<FakeMoney>(source_addr) == 250, 0);\n        assert!(coin_balance<FakeMoney>(source_addr) == 50, 0);\n\n        // Burn coin and fa with both stores\n        burn_from<FakeMoney>(source_addr, 100, &burn_cap);\n        assert!(balance<FakeMoney>(source_addr) == 150, 0);\n        assert!(primary_fungible_store::balance(source_addr, ensure_paired_metadata<FakeMoney>()) == 150, 0);\n\n        // Burn fa only with both stores\n        burn_from<FakeMoney>(source_addr, 100, &burn_cap);\n        assert!(balance<FakeMoney>(source_addr) == 50, 0);\n        assert!(primary_fungible_store::balance(source_addr, ensure_paired_metadata<FakeMoney>()) == 50, 0);\n\n        // Burn fa only with only fungible store\n        let coins_minted = mint<FakeMoney>(50, &mint_cap);\n        deposit(source_addr, coins_minted);\n        maybe_convert_to_fungible_store<FakeMoney>(source_addr);\n        assert!(!coin_store_exists<FakeMoney>(source_addr), 0);\n        assert!(balance<FakeMoney>(source_addr) == 100, 0);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 100, 1);\n\n        burn_from<FakeMoney>(source_addr, 10, &burn_cap);\n        assert!(balance<FakeMoney>(source_addr) == 90, 2);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 90, 3);\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x1)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public fun test_destroy_non_zero(\n        source: signer,\n    ) acquires CoinInfo {\n        account::create_account_for_test(signer::address_of(&source));\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&source, 1, true);\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        destroy_zero(coins_minted);\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x1)]\n    public entry fun test_extract(\n        source: signer,\n    ) acquires CoinInfo, CoinStore, CoinConversionMap {\n        let source_addr = signer::address_of(&source);\n        account::create_account_for_test(source_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&source, 1, true);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n\n        let extracted = extract(&mut coins_minted, 25);\n        assert!(value(&coins_minted) == 75, 0);\n        assert!(value(&extracted) == 25, 1);\n\n        deposit(source_addr, coins_minted);\n        deposit(source_addr, extracted);\n\n        assert!(balance<FakeMoney>(source_addr) == 100, 2);\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(source = @0x1)]\n    public fun test_is_coin_initialized(source: signer) {\n        assert!(!is_coin_initialized<FakeMoney>(), 0);\n\n        let (burn_cap, freeze_cap, mint_cap) = initialize_fake_money(&source, 1, true);\n        assert!(is_coin_initialized<FakeMoney>(), 1);\n\n        move_to(&source, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @0x1)]\n    public fun test_is_coin_store_frozen(account: signer) acquires CoinStore, CoinConversionMap, CoinInfo {\n        let account_addr = signer::address_of(&account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&account, 18, true);\n        assert!(coin_store_exists<FakeMoney>(account_addr), 1);\n        assert!(!is_coin_store_frozen<FakeMoney>(account_addr), 1);\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        assert!(!coin_store_exists<FakeMoney>(account_addr), 1);\n\n        move_to(&account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test]\n    fun test_zero() {\n        let zero = zero<FakeMoney>();\n        assert!(value(&zero) == 0, 1);\n        destroy_zero(zero);\n    }\n\n    #[test(account = @0x1)]\n    public entry fun burn_frozen(\n        account: signer\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedFungibleAssetRefs {\n        let account_addr = signer::address_of(&account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&account, 18, true);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        deposit(account_addr, coins_minted);\n\n        freeze_coin_store(account_addr, &freeze_cap);\n        burn_from(account_addr, 90, &burn_cap);\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        assert!(primary_fungible_store::is_frozen(account_addr, ensure_paired_metadata<FakeMoney>()), 1);\n        assert!(primary_fungible_store::balance(account_addr, ensure_paired_metadata<FakeMoney>()) == 10, 1);\n\n        move_to(&account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @0x1)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::fungible_asset)]\n    public entry fun withdraw_frozen(account: signer) acquires CoinInfo, CoinStore, CoinConversionMap, PairedCoinType {\n        let account_addr = signer::address_of(&account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&account, 18, true);\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        deposit(account_addr, coins_minted);\n\n        freeze_coin_store(account_addr, &freeze_cap);\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        let coin = withdraw<FakeMoney>(&account, 90);\n        burn(coin, &burn_cap);\n\n        move_to(&account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @0x1)]\n    #[expected_failure(abort_code = 0x5000A, location = Self)]\n    public entry fun deposit_frozen(account: signer) acquires CoinInfo, CoinStore, CoinConversionMap {\n        let account_addr = signer::address_of(&account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&account, 18, true);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        freeze_coin_store(account_addr, &freeze_cap);\n        deposit(account_addr, coins_minted);\n\n        move_to(&account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @0x1)]\n    public entry fun deposit_withdraw_unfrozen(\n        account: signer\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedCoinType {\n        let account_addr = signer::address_of(&account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&account, 18, true);\n\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        freeze_coin_store(account_addr, &freeze_cap);\n        unfreeze_coin_store(account_addr, &freeze_cap);\n        deposit(account_addr, coins_minted);\n\n        freeze_coin_store(account_addr, &freeze_cap);\n        unfreeze_coin_store(account_addr, &freeze_cap);\n        let coin = withdraw<FakeMoney>(&account, 10);\n        burn(coin, &burn_cap);\n\n        move_to(&account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test_only]\n    fun initialize_with_aggregator(account: &signer) {\n        let (burn_cap, freeze_cap, mint_cap) = initialize_with_parallelizable_supply<FakeMoney>(\n            account,\n            string::utf8(b\"Fake money\"),\n            string::utf8(b\"FMD\"),\n            1,\n            true\n        );\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test_only]\n    fun initialize_with_integer(account: &signer) {\n        let (burn_cap, freeze_cap, mint_cap) = initialize<FakeMoney>(\n            account,\n            string::utf8(b\"Fake money\"),\n            string::utf8(b\"FMD\"),\n            1,\n            true\n        );\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n\n    #[test(framework = @aptos_framework, other = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    fun test_supply_initialize_fails(framework: signer, other: signer) {\n        aggregator_factory::initialize_aggregator_factory_for_test(&framework);\n        initialize_with_aggregator(&other);\n    }\n\n    #[test(other = @0x123)]\n    #[expected_failure(abort_code = 0x10003, location = Self)]\n    fun test_create_coin_store_with_non_coin_type(other: signer) acquires CoinConversionMap {\n        register<String>(&other);\n    }\n\n    #[test(other = @0x123)]\n    #[expected_failure(abort_code = 0x10003, location = Self)]\n    fun test_migration_coin_store_with_non_coin_type(other: signer) acquires CoinConversionMap, CoinStore, CoinInfo {\n        migrate_to_fungible_store<String>(&other);\n    }\n\n    #[test(framework = @aptos_framework)]\n    fun test_supply_initialize(framework: signer) acquires CoinInfo {\n        aggregator_factory::initialize_aggregator_factory_for_test(&framework);\n        initialize_with_aggregator(&framework);\n\n        let maybe_supply = &mut borrow_global_mut<CoinInfo<FakeMoney>>(coin_address<FakeMoney>()).supply;\n        let supply = option::borrow_mut(maybe_supply);\n\n        // Supply should be parallelizable.\n        assert!(optional_aggregator::is_parallelizable(supply), 0);\n\n        optional_aggregator::add(supply, 100);\n        optional_aggregator::sub(supply, 50);\n        optional_aggregator::add(supply, 950);\n        assert!(optional_aggregator::read(supply) == 1000, 0);\n    }\n\n    #[test(framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x20001, location = aptos_framework::aggregator)]\n    fun test_supply_overflow(framework: signer) acquires CoinInfo {\n        aggregator_factory::initialize_aggregator_factory_for_test(&framework);\n        initialize_with_aggregator(&framework);\n\n        let maybe_supply = &mut borrow_global_mut<CoinInfo<FakeMoney>>(coin_address<FakeMoney>()).supply;\n        let supply = option::borrow_mut(maybe_supply);\n\n        optional_aggregator::add(supply, MAX_U128);\n        optional_aggregator::add(supply, 1);\n        optional_aggregator::sub(supply, 1);\n    }\n\n    #[test(framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x5000B, location = aptos_framework::coin)]\n    fun test_supply_upgrade_fails(framework: signer) acquires CoinInfo, SupplyConfig {\n        initialize_supply_config(&framework);\n        aggregator_factory::initialize_aggregator_factory_for_test(&framework);\n        initialize_with_integer(&framework);\n\n        let maybe_supply = &mut borrow_global_mut<CoinInfo<FakeMoney>>(coin_address<FakeMoney>()).supply;\n        let supply = option::borrow_mut(maybe_supply);\n\n        // Supply should be non-parallelizable.\n        assert!(!optional_aggregator::is_parallelizable(supply), 0);\n\n        optional_aggregator::add(supply, 100);\n        optional_aggregator::sub(supply, 50);\n        optional_aggregator::add(supply, 950);\n        assert!(optional_aggregator::read(supply) == 1000, 0);\n\n        upgrade_supply<FakeMoney>(&framework);\n    }\n\n    #[test(framework = @aptos_framework)]\n    fun test_supply_upgrade(framework: signer) acquires CoinInfo, SupplyConfig {\n        initialize_supply_config(&framework);\n        aggregator_factory::initialize_aggregator_factory_for_test(&framework);\n        initialize_with_integer(&framework);\n\n        // Ensure we have a non-parellelizable non-zero supply.\n        let maybe_supply = &mut borrow_global_mut<CoinInfo<FakeMoney>>(coin_address<FakeMoney>()).supply;\n        let supply = option::borrow_mut(maybe_supply);\n        assert!(!optional_aggregator::is_parallelizable(supply), 0);\n        optional_aggregator::add(supply, 100);\n\n        // Upgrade.\n        allow_supply_upgrades(&framework, true);\n        upgrade_supply<FakeMoney>(&framework);\n\n        // Check supply again.\n        let maybe_supply = &mut borrow_global_mut<CoinInfo<FakeMoney>>(coin_address<FakeMoney>()).supply;\n        let supply = option::borrow_mut(maybe_supply);\n        assert!(optional_aggregator::is_parallelizable(supply), 0);\n        assert!(optional_aggregator::read(supply) == 100, 0);\n    }\n\n    #[test_only]\n    fun destroy_aggregatable_coin_for_test<CoinType>(aggregatable_coin: AggregatableCoin<CoinType>) {\n        let AggregatableCoin { value } = aggregatable_coin;\n        aggregator::destroy(value);\n    }\n\n    #[test(framework = @aptos_framework)]\n    public entry fun test_collect_from_and_drain(\n        framework: signer,\n    ) acquires CoinInfo, CoinStore, CoinConversionMap, PairedCoinType {\n        let framework_addr = signer::address_of(&framework);\n        account::create_account_for_test(framework_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(&framework, 1, true);\n\n        // Collect from coin store only.\n        let coins_minted = mint<FakeMoney>(100, &mint_cap);\n        deposit(framework_addr, coins_minted);\n        let aggregatable_coin = initialize_aggregatable_coin<FakeMoney>(&framework);\n        collect_into_aggregatable_coin<FakeMoney>(framework_addr, 50, &mut aggregatable_coin);\n\n        let fa_minted = coin_to_fungible_asset(mint<FakeMoney>(100, &mint_cap));\n        primary_fungible_store::deposit(framework_addr, fa_minted);\n        assert!(balance<FakeMoney>(framework_addr) == 150, 0);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 200, 0);\n\n        // Collect from coin store and fungible store.\n        collect_into_aggregatable_coin<FakeMoney>(framework_addr, 100, &mut aggregatable_coin);\n\n        assert!(balance<FakeMoney>(framework_addr) == 50, 0);\n        maybe_convert_to_fungible_store<FakeMoney>(framework_addr);\n        // Collect from fungible store only.\n        collect_into_aggregatable_coin<FakeMoney>(framework_addr, 30, &mut aggregatable_coin);\n\n        // Check that aggregatable coin has the right amount.\n        let collected_coin = drain_aggregatable_coin(&mut aggregatable_coin);\n        assert!(is_aggregatable_coin_zero(&aggregatable_coin), 0);\n        assert!(value(&collected_coin) == 180, 0);\n\n        // Supply of coins should be unchanged, but the balance on the account should decrease.\n        assert!(balance<FakeMoney>(framework_addr) == 20, 0);\n        assert!(*option::borrow(&supply<FakeMoney>()) == 200, 0);\n\n        burn(collected_coin, &burn_cap);\n        destroy_aggregatable_coin_for_test(aggregatable_coin);\n        move_to(&framework, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test_only]\n    fun deposit_to_coin_store<CoinType>(account_addr: address, coin: Coin<CoinType>) acquires CoinStore {\n        assert!(\n            coin_store_exists<CoinType>(account_addr),\n            error::not_found(ECOIN_STORE_NOT_PUBLISHED),\n        );\n\n        let coin_store = borrow_global_mut<CoinStore<CoinType>>(account_addr);\n        assert!(\n            !coin_store.frozen,\n            error::permission_denied(EFROZEN),\n        );\n\n        event::emit_event<DepositEvent>(\n            &mut coin_store.deposit_events,\n            DepositEvent { amount: coin.value },\n        );\n\n        merge(&mut coin_store.coin, coin);\n    }\n\n    #[test(account = @aptos_framework)]\n    fun test_conversion_basic(\n        account: &signer\n    ) acquires CoinConversionMap, CoinInfo, CoinStore, PairedCoinType, PairedFungibleAssetRefs {\n        let account_addr = signer::address_of(account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n\n        assert!(fungible_asset::name(ensure_paired_metadata<FakeMoney>()) == name<FakeMoney>(), 0);\n        assert!(fungible_asset::symbol(ensure_paired_metadata<FakeMoney>()) == symbol<FakeMoney>(), 0);\n        assert!(fungible_asset::decimals(ensure_paired_metadata<FakeMoney>()) == decimals<FakeMoney>(), 0);\n\n        let minted_coin = mint(100, &mint_cap);\n        let converted_fa = coin_to_fungible_asset(minted_coin);\n\n        // check and get refs\n        assert!(paired_mint_ref_exists<FakeMoney>(), 0);\n        assert!(paired_transfer_ref_exists<FakeMoney>(), 0);\n        assert!(paired_burn_ref_exists<FakeMoney>(), 0);\n        let (mint_ref, mint_ref_receipt) = get_paired_mint_ref(&mint_cap);\n        let (transfer_ref, transfer_ref_receipt) = get_paired_transfer_ref(&freeze_cap);\n        let (burn_ref, burn_ref_receipt) = get_paired_burn_ref(&burn_cap);\n        assert!(!paired_mint_ref_exists<FakeMoney>(), 0);\n        assert!(!paired_transfer_ref_exists<FakeMoney>(), 0);\n        assert!(!paired_burn_ref_exists<FakeMoney>(), 0);\n\n        let minted_fa = fungible_asset::mint(&mint_ref, 100);\n        assert!(&converted_fa == &minted_fa, 0);\n\n        let coin = fungible_asset_to_coin<FakeMoney>(converted_fa);\n        assert!(value(&coin) == 100, 0);\n\n        deposit_to_coin_store(account_addr, coin);\n        assert!(coin_store_exists<FakeMoney>(account_addr), 0);\n        primary_fungible_store::deposit(account_addr, minted_fa);\n        assert!(balance<FakeMoney>(account_addr) == 200, 0);\n\n        let withdrawn_coin = withdraw<FakeMoney>(account, 1);\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        assert!(!coin_store_exists<FakeMoney>(account_addr), 0);\n        assert!(balance<FakeMoney>(account_addr) == 199, 0);\n        assert!(primary_fungible_store::balance(account_addr, ensure_paired_metadata<FakeMoney>()) == 199, 0);\n\n        let fa = coin_to_fungible_asset(withdrawn_coin);\n        fungible_asset::burn(&burn_ref, fa);\n\n        // Return and check the refs\n        return_paired_mint_ref(mint_ref, mint_ref_receipt);\n        return_paired_transfer_ref(transfer_ref, transfer_ref_receipt);\n        return_paired_burn_ref(burn_ref, burn_ref_receipt);\n        assert!(paired_mint_ref_exists<FakeMoney>(), 0);\n        assert!(paired_transfer_ref_exists<FakeMoney>(), 0);\n        assert!(paired_burn_ref_exists<FakeMoney>(), 0);\n\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @aptos_framework, aaron = @0xcafe)]\n    fun test_balance_with_both_stores(\n        account: &signer,\n        aaron: &signer\n    ) acquires CoinConversionMap, CoinInfo, CoinStore {\n        let account_addr = signer::address_of(account);\n        let aaron_addr = signer::address_of(aaron);\n        account::create_account_for_test(account_addr);\n        account::create_account_for_test(aaron_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n        create_coin_store<FakeMoney>(aaron);\n        let coin = mint(100, &mint_cap);\n        let fa = coin_to_fungible_asset(mint(100, &mint_cap));\n        primary_fungible_store::deposit(aaron_addr, fa);\n        deposit_to_coin_store(aaron_addr, coin);\n        assert!(coin_balance<FakeMoney>(aaron_addr) == 100, 0);\n        assert!(balance<FakeMoney>(aaron_addr) == 200, 0);\n        maybe_convert_to_fungible_store<FakeMoney>(aaron_addr);\n        assert!(balance<FakeMoney>(aaron_addr) == 200, 0);\n        assert!(coin_balance<FakeMoney>(aaron_addr) == 0, 0);\n\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @aptos_framework)]\n    fun test_deposit(\n        account: &signer,\n    ) acquires CoinConversionMap, CoinInfo, CoinStore {\n        let account_addr = signer::address_of(account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n        let coin = mint<FakeMoney>(100, &mint_cap);\n        deposit(account_addr, coin);\n        assert!(coin_store_exists<FakeMoney>(account_addr), 0);\n        assert!(primary_fungible_store::balance(account_addr, ensure_paired_metadata<FakeMoney>()) == 0, 0);\n        assert!(balance<FakeMoney>(account_addr) == 100, 0);\n\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        let coin = mint<FakeMoney>(100, &mint_cap);\n        deposit(account_addr, coin);\n        assert!(!coin_store_exists<FakeMoney>(account_addr), 0);\n        assert!(balance<FakeMoney>(account_addr) == 200, 0);\n        assert!(primary_fungible_store::balance(account_addr, ensure_paired_metadata<FakeMoney>()) == 200, 0);\n\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @aptos_framework)]\n    fun test_withdraw(\n        account: &signer,\n    ) acquires CoinConversionMap, CoinInfo, CoinStore, PairedCoinType {\n        let account_addr = signer::address_of(account);\n        account::create_account_for_test(account_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n        let coin = mint<FakeMoney>(200, &mint_cap);\n        deposit_to_coin_store(account_addr, coin);\n        assert!(coin_balance<FakeMoney>(account_addr) == 200, 0);\n        assert!(balance<FakeMoney>(account_addr) == 200, 0);\n\n        // Withdraw from coin store only.\n        let coin = withdraw<FakeMoney>(account, 100);\n        assert!(coin_balance<FakeMoney>(account_addr) == 100, 0);\n        assert!(balance<FakeMoney>(account_addr) == 100, 0);\n\n        let fa = coin_to_fungible_asset(coin);\n        primary_fungible_store::deposit(account_addr, fa);\n        assert!(coin_store_exists<FakeMoney>(account_addr), 0);\n        assert!(primary_fungible_store::balance(account_addr, ensure_paired_metadata<FakeMoney>()) == 100, 0);\n        assert!(balance<FakeMoney>(account_addr) == 200, 0);\n\n        // Withdraw from both coin store and fungible store.\n        let coin = withdraw<FakeMoney>(account, 150);\n        assert!(coin_balance<FakeMoney>(account_addr) == 0, 0);\n        assert!(primary_fungible_store::balance(account_addr, ensure_paired_metadata<FakeMoney>()) == 50, 0);\n\n        deposit_to_coin_store(account_addr, coin);\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        assert!(!coin_store_exists<FakeMoney>(account_addr), 0);\n        assert!(balance<FakeMoney>(account_addr) == 200, 0);\n        assert!(primary_fungible_store::balance(account_addr, ensure_paired_metadata<FakeMoney>()) == 200, 0);\n\n        // Withdraw from fungible store only.\n        let coin = withdraw<FakeMoney>(account, 150);\n        assert!(balance<FakeMoney>(account_addr) == 50, 0);\n        burn(coin, &burn_cap);\n\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @aptos_framework)]\n    fun test_supply(\n        account: &signer,\n    ) acquires CoinConversionMap, CoinInfo, PairedCoinType, PairedFungibleAssetRefs {\n        account::create_account_for_test(signer::address_of(account));\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n        let coin = mint<FakeMoney>(100, &mint_cap);\n        ensure_paired_metadata<FakeMoney>();\n        let (mint_ref, mint_ref_receipt) = get_paired_mint_ref(&mint_cap);\n        let (burn_ref, burn_ref_receipt) = get_paired_burn_ref(&burn_cap);\n        let fungible_asset = fungible_asset::mint(&mint_ref, 50);\n        assert!(supply<FakeMoney>() == option::some(150), 0);\n        assert!(coin_supply<FakeMoney>() == option::some(100), 0);\n        assert!(fungible_asset::supply(ensure_paired_metadata<FakeMoney>()) == option::some(50), 0);\n        let fa_from_coin = coin_to_fungible_asset(coin);\n        assert!(supply<FakeMoney>() == option::some(150), 0);\n        assert!(coin_supply<FakeMoney>() == option::some(0), 0);\n        assert!(fungible_asset::supply(ensure_paired_metadata<FakeMoney>()) == option::some(150), 0);\n\n        let coin_from_fa = fungible_asset_to_coin<FakeMoney>(fungible_asset);\n        assert!(supply<FakeMoney>() == option::some(150), 0);\n        assert!(coin_supply<FakeMoney>() == option::some(50), 0);\n        assert!(fungible_asset::supply(ensure_paired_metadata<FakeMoney>()) == option::some(100), 0);\n        burn(coin_from_fa, &burn_cap);\n        fungible_asset::burn(&burn_ref, fa_from_coin);\n        assert!(supply<FakeMoney>() == option::some(0), 0);\n        return_paired_mint_ref(mint_ref, mint_ref_receipt);\n        return_paired_burn_ref(burn_ref, burn_ref_receipt);\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @aptos_framework, aaron = @0xaa10, bob = @0xb0b)]\n    #[expected_failure(abort_code = 0x60005, location = Self)]\n    fun test_force_deposit(\n        account: &signer,\n        aaron: &signer,\n        bob: &signer\n    ) acquires CoinConversionMap, CoinInfo, CoinStore {\n        let account_addr = signer::address_of(account);\n        let aaron_addr = signer::address_of(aaron);\n        let bob_addr = signer::address_of(bob);\n        account::create_account_for_test(account_addr);\n        account::create_account_for_test(aaron_addr);\n        account::create_account_for_test(bob_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n        maybe_convert_to_fungible_store<FakeMoney>(aaron_addr);\n        deposit(aaron_addr, mint<FakeMoney>(1, &mint_cap));\n\n        force_deposit(account_addr, mint<FakeMoney>(100, &mint_cap));\n        force_deposit(aaron_addr, mint<FakeMoney>(50, &mint_cap));\n        assert!(\n            primary_fungible_store::balance(aaron_addr, option::extract(&mut paired_metadata<FakeMoney>())) == 51,\n            0\n        );\n        assert!(coin_balance<FakeMoney>(account_addr) == 100, 0);\n        force_deposit(bob_addr, mint<FakeMoney>(1, &mint_cap));\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @aptos_framework, aaron = @0xaa10, bob = @0xb0b)]\n    fun test_is_account_registered(\n        account: &signer,\n        aaron: &signer,\n        bob: &signer,\n    ) acquires CoinConversionMap, CoinInfo, CoinStore {\n        let account_addr = signer::address_of(account);\n        let aaron_addr = signer::address_of(aaron);\n        let bob_addr = signer::address_of(bob);\n        account::create_account_for_test(account_addr);\n        account::create_account_for_test(aaron_addr);\n        account::create_account_for_test(bob_addr);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n\n        assert!(coin_store_exists<FakeMoney>(account_addr), 0);\n        assert!(is_account_registered<FakeMoney>(account_addr), 0);\n\n        assert!(!coin_store_exists<FakeMoney>(aaron_addr), 0);\n        assert!(!is_account_registered<FakeMoney>(aaron_addr), 0);\n\n        maybe_convert_to_fungible_store<FakeMoney>(aaron_addr);\n        let coin = mint<FakeMoney>(100, &mint_cap);\n        deposit(aaron_addr, coin);\n\n        assert!(!coin_store_exists<FakeMoney>(aaron_addr), 0);\n        assert!(is_account_registered<FakeMoney>(aaron_addr), 0);\n\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        assert!(!coin_store_exists<FakeMoney>(account_addr), 0);\n        assert!(is_account_registered<FakeMoney>(account_addr), 0);\n\n        // Deposit FA to bob to created primary fungible store without `MigrationFlag`.\n        primary_fungible_store::deposit(bob_addr, coin_to_fungible_asset(mint<FakeMoney>(100, &mint_cap)));\n        assert!(!coin_store_exists<FakeMoney>(bob_addr), 0);\n        register<FakeMoney>(bob);\n        assert!(coin_store_exists<FakeMoney>(bob_addr), 0);\n        maybe_convert_to_fungible_store<FakeMoney>(bob_addr);\n        assert!(!coin_store_exists<FakeMoney>(bob_addr), 0);\n        register<FakeMoney>(bob);\n        assert!(!coin_store_exists<FakeMoney>(bob_addr), 0);\n\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    #[test(account = @aptos_framework, aaron = @0xaa10)]\n    fun test_migration_with_existing_primary_fungible_store(\n        account: &signer,\n    ) acquires CoinConversionMap, CoinInfo, CoinStore, PairedCoinType {\n        account::create_account_for_test(signer::address_of(account));\n        let account_addr = signer::address_of(account);\n        let (burn_cap, freeze_cap, mint_cap) = initialize_and_register_fake_money(account, 1, true);\n\n        let coin = mint<FakeMoney>(100, &mint_cap);\n        primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));\n        assert!(coin_balance<FakeMoney>(account_addr) == 0, 0);\n        assert!(balance<FakeMoney>(account_addr) == 100, 0);\n        let coin = withdraw<FakeMoney>(account, 50);\n        assert!(!migrated_primary_fungible_store_exists(account_addr, ensure_paired_metadata<FakeMoney>()), 0);\n        maybe_convert_to_fungible_store<FakeMoney>(account_addr);\n        assert!(migrated_primary_fungible_store_exists(account_addr, ensure_paired_metadata<FakeMoney>()), 0);\n        deposit(account_addr, coin);\n        assert!(coin_balance<FakeMoney>(account_addr) == 0, 0);\n        assert!(balance<FakeMoney>(account_addr) == 100, 0);\n\n        move_to(account, FakeMoneyCapabilities {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n}\n","name":"coin.move"},{"content":"/// This wrapper helps store an on-chain config for the next epoch.\n///\n/// Once reconfigure with DKG is introduced, every on-chain config `C` should do the following.\n/// - Support async update when DKG is enabled. This is typically done by 3 steps below.\n///   - Implement `C::set_for_next_epoch()` using `upsert()` function in this module.\n///   - Implement `C::on_new_epoch()` using `extract()` function in this module.\n///   - Update `0x1::reconfiguration_with_dkg::finish()` to call `C::on_new_epoch()`.\n/// - Support sychronous update when DKG is disabled.\n///   This is typically done by implementing `C::set()` to update the config resource directly.\n///\n/// NOTE: on-chain config `0x1::state::ValidatorSet` implemented its own buffer.\nmodule aptos_framework::config_buffer {\n    use std::string::String;\n    use aptos_std::any;\n    use aptos_std::any::Any;\n    use aptos_std::simple_map;\n    use aptos_std::simple_map::SimpleMap;\n    use aptos_std::type_info;\n    use aptos_framework::system_addresses;\n\n    friend aptos_framework::consensus_config;\n    friend aptos_framework::execution_config;\n    friend aptos_framework::gas_schedule;\n    friend aptos_framework::jwks;\n    friend aptos_framework::jwk_consensus_config;\n    friend aptos_framework::keyless_account;\n    friend aptos_framework::randomness_api_v0_config;\n    friend aptos_framework::randomness_config;\n    friend aptos_framework::randomness_config_seqnum;\n    friend aptos_framework::version;\n\n    /// Config buffer operations failed with permission denied.\n    const ESTD_SIGNER_NEEDED: u64 = 1;\n\n    struct PendingConfigs has key {\n        configs: SimpleMap<String, Any>,\n    }\n\n    public fun initialize(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        if (!exists<PendingConfigs>(@aptos_framework)) {\n            move_to(aptos_framework, PendingConfigs {\n                configs: simple_map::new(),\n            })\n        }\n    }\n\n    /// Check whether there is a pending config payload for `T`.\n    public fun does_exist<T: store>(): bool acquires PendingConfigs {\n        if (exists<PendingConfigs>(@aptos_framework)) {\n            let config = borrow_global<PendingConfigs>(@aptos_framework);\n            simple_map::contains_key(&config.configs, &type_info::type_name<T>())\n        } else {\n            false\n        }\n    }\n\n    /// Upsert an on-chain config to the buffer for the next epoch.\n    ///\n    /// Typically used in `X::set_for_next_epoch()` where X is an on-chain config.\n    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {\n        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);\n        let key = type_info::type_name<T>();\n        let value = any::pack(config);\n        simple_map::upsert(&mut configs.configs, key, value);\n    }\n\n    /// Take the buffered config `T` out (buffer cleared). Abort if the buffer is empty.\n    /// Should only be used at the end of a reconfiguration.\n    ///\n    /// Typically used in `X::on_new_epoch()` where X is an on-chaon config.\n    public fun extract<T: store>(): T acquires PendingConfigs {\n        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);\n        let key = type_info::type_name<T>();\n        let (_, value_packed) = simple_map::remove(&mut configs.configs, &key);\n        any::unpack(value_packed)\n    }\n\n    #[test_only]\n    struct DummyConfig has drop, store {\n        data: u64,\n    }\n\n    #[test(fx = @std)]\n    fun test_config_buffer_basic(fx: &signer) acquires PendingConfigs {\n        initialize(fx);\n        // Initially nothing in the buffer.\n        assert!(!does_exist<DummyConfig>(), 1);\n\n        // Insert should work.\n        upsert(DummyConfig { data: 888 });\n        assert!(does_exist<DummyConfig>(), 1);\n\n        // Update and extract should work.\n        upsert(DummyConfig { data: 999 });\n        assert!(does_exist<DummyConfig>(), 1);\n        let config = extract<DummyConfig>();\n        assert!(config == DummyConfig { data: 999 }, 1);\n        assert!(!does_exist<DummyConfig>(), 1);\n    }\n}\n","name":"config_buffer.move"},{"content":"/// Maintains the consensus config for the blockchain. The config is stored in a\n/// Reconfiguration, and may be updated by root.\nmodule aptos_framework::consensus_config {\n    use std::error;\n    use std::vector;\n    use aptos_framework::chain_status;\n    use aptos_framework::config_buffer;\n\n    use aptos_framework::reconfiguration;\n    use aptos_framework::system_addresses;\n\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    struct ConsensusConfig has drop, key, store {\n        config: vector<u8>,\n    }\n\n    /// The provided on chain config bytes are empty or invalid\n    const EINVALID_CONFIG: u64 = 1;\n\n    /// Publishes the ConsensusConfig config.\n    public(friend) fun initialize(aptos_framework: &signer, config: vector<u8>) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));\n        move_to(aptos_framework, ConsensusConfig { config });\n    }\n\n    /// Deprecated by `set_for_next_epoch()`.\n    ///\n    /// WARNING: calling this while randomness is enabled will trigger a new epoch without randomness!\n    ///\n    /// TODO: update all the tests that reference this function, then disable this function.\n    public fun set(account: &signer, config: vector<u8>) acquires ConsensusConfig {\n        system_addresses::assert_aptos_framework(account);\n        chain_status::assert_genesis();\n        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));\n\n        let config_ref = &mut borrow_global_mut<ConsensusConfig>(@aptos_framework).config;\n        *config_ref = config;\n\n        // Need to trigger reconfiguration so validator nodes can sync on the updated configs.\n        reconfiguration::reconfigure();\n    }\n\n    /// This can be called by on-chain governance to update on-chain consensus configs for the next epoch.\n    /// Example usage:\n    /// ```\n    /// aptos_framework::consensus_config::set_for_next_epoch(&framework_signer, some_config_bytes);\n    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);\n    /// ```\n    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {\n        system_addresses::assert_aptos_framework(account);\n        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));\n        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});\n    }\n\n    /// Only used in reconfigurations to apply the pending `ConsensusConfig`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<ConsensusConfig>()) {\n            let new_config = config_buffer::extract<ConsensusConfig>();\n            if (exists<ConsensusConfig>(@aptos_framework)) {\n                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;\n            } else {\n                move_to(framework, new_config);\n            };\n        }\n    }\n\n    public fun validator_txn_enabled(): bool acquires ConsensusConfig {\n        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;\n        validator_txn_enabled_internal(config_bytes)\n    }\n\n    native fun validator_txn_enabled_internal(config_bytes: vector<u8>): bool;\n}\n","name":"consensus_config.move"},{"content":"/// Maintains the execution config for the blockchain. The config is stored in a\n/// Reconfiguration, and may be updated by root.\nmodule aptos_framework::execution_config {\n    use aptos_framework::config_buffer;\n    use std::error;\n    use std::vector;\n    use aptos_framework::chain_status;\n\n    use aptos_framework::reconfiguration;\n    use aptos_framework::system_addresses;\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    struct ExecutionConfig has drop, key, store {\n        config: vector<u8>,\n    }\n\n    /// The provided on chain config bytes are empty or invalid\n    const EINVALID_CONFIG: u64 = 1;\n\n    /// Deprecated by `set_for_next_epoch()`.\n    ///\n    /// WARNING: calling this while randomness is enabled will trigger a new epoch without randomness!\n    ///\n    /// TODO: update all the tests that reference this function, then disable this function.\n    public fun set(account: &signer, config: vector<u8>) acquires ExecutionConfig {\n        system_addresses::assert_aptos_framework(account);\n        chain_status::assert_genesis();\n\n        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));\n\n        if (exists<ExecutionConfig>(@aptos_framework)) {\n            let config_ref = &mut borrow_global_mut<ExecutionConfig>(@aptos_framework).config;\n            *config_ref = config;\n        } else {\n            move_to(account, ExecutionConfig { config });\n        };\n        // Need to trigger reconfiguration so validator nodes can sync on the updated configs.\n        reconfiguration::reconfigure();\n    }\n\n    /// This can be called by on-chain governance to update on-chain execution configs for the next epoch.\n    /// Example usage:\n    /// ```\n    /// aptos_framework::execution_config::set_for_next_epoch(&framework_signer, some_config_bytes);\n    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);\n    /// ```\n    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {\n        system_addresses::assert_aptos_framework(account);\n        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));\n        config_buffer::upsert(ExecutionConfig { config });\n    }\n\n    /// Only used in reconfigurations to apply the pending `ExecutionConfig`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires ExecutionConfig {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<ExecutionConfig>()) {\n            let config = config_buffer::extract<ExecutionConfig>();\n            if (exists<ExecutionConfig>(@aptos_framework)) {\n                *borrow_global_mut<ExecutionConfig>(@aptos_framework) = config;\n            } else {\n                move_to(framework, config);\n            };\n        }\n    }\n}\n","name":"execution_config.move"},{"content":"/// This module defines structs and methods to initialize the gas schedule, which dictates how much\n/// it costs to execute Move on the network.\nmodule aptos_framework::gas_schedule {\n    use std::error;\n    use std::string::String;\n    use std::vector;\n    use aptos_framework::chain_status;\n    use aptos_framework::config_buffer;\n\n    use aptos_framework::reconfiguration;\n    use aptos_framework::system_addresses;\n    use aptos_framework::util::from_bytes;\n    use aptos_framework::storage_gas::StorageGasConfig;\n    use aptos_framework::storage_gas;\n    #[test_only]\n    use std::bcs::to_bytes;\n\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    /// The provided gas schedule bytes are empty or invalid\n    const EINVALID_GAS_SCHEDULE: u64 = 1;\n    const EINVALID_GAS_FEATURE_VERSION: u64 = 2;\n\n    struct GasEntry has store, copy, drop {\n        key: String,\n        val: u64,\n    }\n\n    struct GasSchedule has key, copy, drop {\n        entries: vector<GasEntry>\n    }\n\n    struct GasScheduleV2 has key, copy, drop, store {\n        feature_version: u64,\n        entries: vector<GasEntry>,\n    }\n\n    /// Only called during genesis.\n    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));\n\n        // TODO(Gas): check if gas schedule is consistent\n        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);\n        move_to<GasScheduleV2>(aptos_framework, gas_schedule);\n    }\n\n    /// Deprecated by `set_for_next_epoch()`.\n    ///\n    /// WARNING: calling this while randomness is enabled will trigger a new epoch without randomness!\n    ///\n    /// TODO: update all the tests that reference this function, then disable this function.\n    public fun set_gas_schedule(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasSchedule, GasScheduleV2 {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));\n        chain_status::assert_genesis();\n\n        if (exists<GasScheduleV2>(@aptos_framework)) {\n            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);\n            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);\n            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,\n                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));\n            // TODO(Gas): check if gas schedule is consistent\n            *gas_schedule = new_gas_schedule;\n        }\n        else {\n            if (exists<GasSchedule>(@aptos_framework)) {\n                _ = move_from<GasSchedule>(@aptos_framework);\n            };\n            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);\n            // TODO(Gas): check if gas schedule is consistent\n            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);\n        };\n\n        // Need to trigger reconfiguration so validator nodes can sync on the updated gas schedule.\n        reconfiguration::reconfigure();\n    }\n\n    /// Set the gas schedule for the next epoch, typically called by on-chain governance.\n    /// Abort if the version of the given schedule is lower than the current version.\n    ///\n    /// Example usage:\n    /// ```\n    /// aptos_framework::gas_schedule::set_for_next_epoch(&framework_signer, some_gas_schedule_blob);\n    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);\n    /// ```\n    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));\n        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);\n        if (exists<GasScheduleV2>(@aptos_framework)) {\n            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);\n            assert!(\n                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,\n                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)\n            );\n        };\n        config_buffer::upsert(new_gas_schedule);\n    }\n\n    /// Only used in reconfigurations to apply the pending `GasScheduleV2`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<GasScheduleV2>()) {\n            let new_gas_schedule = config_buffer::extract<GasScheduleV2>();\n            if (exists<GasScheduleV2>(@aptos_framework)) {\n                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;\n            } else {\n                move_to(framework, new_gas_schedule);\n            }\n        }\n    }\n\n    public fun set_storage_gas_config(aptos_framework: &signer, config: StorageGasConfig) {\n        storage_gas::set_config(aptos_framework, config);\n        // Need to trigger reconfiguration so the VM is guaranteed to load the new gas fee starting from the next\n        // transaction.\n        reconfiguration::reconfigure();\n    }\n\n    public fun set_storage_gas_config_for_next_epoch(aptos_framework: &signer, config: StorageGasConfig) {\n        storage_gas::set_config(aptos_framework, config);\n    }\n\n    #[test(fx = @0x1)]\n    #[expected_failure(abort_code=0x010002, location = Self)]\n    fun set_for_next_epoch_should_abort_if_gas_version_is_too_old(fx: signer) acquires GasScheduleV2 {\n        // Setup.\n        let old_gas_schedule = GasScheduleV2 {\n            feature_version: 1000,\n            entries: vector[],\n        };\n        move_to(&fx, old_gas_schedule);\n\n        // Setting an older version should not work.\n        let new_gas_schedule = GasScheduleV2 {\n            feature_version: 999,\n            entries: vector[],\n        };\n        let new_bytes = to_bytes(&new_gas_schedule);\n        set_for_next_epoch(&fx, new_bytes);\n    }\n}\n","name":"gas_schedule.move"},{"content":"/// Structs and functions related to JWK consensus configurations.\nmodule aptos_framework::jwk_consensus_config {\n    use std::error;\n    use std::option;\n    use std::string::String;\n    use std::vector;\n    use aptos_std::copyable_any;\n    use aptos_std::copyable_any::Any;\n    use aptos_std::simple_map;\n    use aptos_framework::config_buffer;\n    use aptos_framework::system_addresses;\n    #[test_only]\n    use std::string;\n    #[test_only]\n    use std::string::utf8;\n\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    /// `ConfigV1` creation failed with duplicated providers given.\n    const EDUPLICATE_PROVIDERS: u64 = 1;\n\n    /// The configuration of the JWK consensus feature.\n    struct JWKConsensusConfig has drop, key, store {\n        /// A config variant packed as an `Any`.\n        /// Currently the variant type is one of the following.\n        /// - `ConfigOff`\n        /// - `ConfigV1`\n        variant: Any,\n    }\n\n    /// A JWK consensus config variant indicating JWK consensus should not run.\n    struct ConfigOff has copy, drop, store {}\n\n    struct OIDCProvider has copy, drop, store {\n        name: String,\n        config_url: String,\n    }\n\n    /// A JWK consensus config variant indicating JWK consensus should run to watch a given list of OIDC providers.\n    struct ConfigV1 has copy, drop, store {\n        oidc_providers: vector<OIDCProvider>,\n    }\n\n    /// Initialize the configuration. Used in genesis or governance.\n    public fun initialize(framework: &signer, config: JWKConsensusConfig) {\n        system_addresses::assert_aptos_framework(framework);\n        if (!exists<JWKConsensusConfig>(@aptos_framework)) {\n            move_to(framework, config);\n        }\n    }\n\n    /// This can be called by on-chain governance to update JWK consensus configs for the next epoch.\n    /// Example usage:\n    /// ```\n    /// use aptos_framework::jwk_consensus_config;\n    /// use aptos_framework::aptos_governance;\n    /// // ...\n    /// let config = jwk_consensus_config::new_v1(vector[]);\n    /// jwk_consensus_config::set_for_next_epoch(&framework_signer, config);\n    /// aptos_governance::reconfigure(&framework_signer);\n    /// ```\n    public fun set_for_next_epoch(framework: &signer, config: JWKConsensusConfig) {\n        system_addresses::assert_aptos_framework(framework);\n        config_buffer::upsert(config);\n    }\n\n    /// Only used in reconfigurations to apply the pending `JWKConsensusConfig`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires JWKConsensusConfig {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<JWKConsensusConfig>()) {\n            let new_config = config_buffer::extract<JWKConsensusConfig>();\n            if (exists<JWKConsensusConfig>(@aptos_framework)) {\n                *borrow_global_mut<JWKConsensusConfig>(@aptos_framework) = new_config;\n            } else {\n                move_to(framework, new_config);\n            };\n        }\n    }\n\n    /// Construct a `JWKConsensusConfig` of variant `ConfigOff`.\n    public fun new_off(): JWKConsensusConfig {\n        JWKConsensusConfig {\n            variant: copyable_any::pack( ConfigOff {} )\n        }\n    }\n\n    /// Construct a `JWKConsensusConfig` of variant `ConfigV1`.\n    ///\n    /// Abort if the given provider list contains duplicated provider names.\n    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {\n        let name_set = simple_map::new<String, u64>();\n        vector::for_each_ref(&oidc_providers, |provider| {\n            let provider: &OIDCProvider = provider;\n            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);\n            if (option::is_some(&old_value)) {\n                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))\n            }\n        });\n        JWKConsensusConfig {\n            variant: copyable_any::pack( ConfigV1 { oidc_providers } )\n        }\n    }\n\n    /// Construct an `OIDCProvider` object.\n    public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {\n        OIDCProvider { name, config_url }\n    }\n\n    #[test_only]\n    fun enabled(): bool acquires JWKConsensusConfig {\n        let variant= borrow_global<JWKConsensusConfig>(@aptos_framework).variant;\n        let variant_type_name = *string::bytes(copyable_any::type_name(&variant));\n        variant_type_name != b\"0x1::jwk_consensus_config::ConfigOff\"\n    }\n\n    #[test_only]\n    fun initialize_for_testing(framework: &signer) {\n        config_buffer::initialize(framework);\n        initialize(framework, new_off());\n    }\n\n    #[test(framework = @0x1)]\n    fun init_buffer_apply(framework: signer) acquires JWKConsensusConfig {\n        initialize_for_testing(&framework);\n        let config = new_v1(vector[\n            new_oidc_provider(utf8(b\"Bob\"), utf8(b\"https://bob.dev\")),\n            new_oidc_provider(utf8(b\"Alice\"), utf8(b\"https://alice.io\")),\n        ]);\n        set_for_next_epoch(&framework, config);\n        on_new_epoch(&framework);\n        assert!(enabled(), 1);\n\n        set_for_next_epoch(&framework, new_off());\n        on_new_epoch(&framework);\n        assert!(!enabled(), 2)\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x010001, location = Self)]\n    fun name_uniqueness_in_config_v1() {\n        new_v1(vector[\n            new_oidc_provider(utf8(b\"Alice\"), utf8(b\"https://alice.info\")),\n            new_oidc_provider(utf8(b\"Bob\"), utf8(b\"https://bob.dev\")),\n            new_oidc_provider(utf8(b\"Alice\"), utf8(b\"https://alice.io\")),\n        ]);\n\n    }\n}\n","name":"jwk_consensus_config.move"},{"content":"module aptos_framework::randomness_api_v0_config {\n    use std::option::Option;\n    use aptos_framework::chain_status;\n    use aptos_framework::config_buffer;\n    use aptos_framework::system_addresses;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    struct RequiredGasDeposit has key, drop, store {\n        gas_amount: Option<u64>,\n    }\n\n    /// If this flag is set, `max_gas` specified inside `#[randomness()]` will be used as the required deposit.\n    struct AllowCustomMaxGasFlag has key, drop, store {\n        value: bool,\n    }\n\n    /// Only used in genesis.\n    fun initialize(framework: &signer, required_amount: RequiredGasDeposit, allow_custom_max_gas_flag: AllowCustomMaxGasFlag) {\n        system_addresses::assert_aptos_framework(framework);\n        chain_status::assert_genesis();\n        move_to(framework, required_amount);\n        move_to(framework, allow_custom_max_gas_flag);\n    }\n\n    /// This can be called by on-chain governance to update `RequiredGasDeposit` for the next epoch.\n    public fun set_for_next_epoch(framework: &signer, gas_amount: Option<u64>) {\n        system_addresses::assert_aptos_framework(framework);\n        config_buffer::upsert(RequiredGasDeposit { gas_amount });\n    }\n\n    /// This can be called by on-chain governance to update `AllowCustomMaxGasFlag` for the next epoch.\n    public fun set_allow_max_gas_flag_for_next_epoch(framework: &signer, value: bool) {\n        system_addresses::assert_aptos_framework(framework);\n        config_buffer::upsert(AllowCustomMaxGasFlag { value } );\n    }\n\n    /// Only used in reconfigurations to apply the pending `RequiredGasDeposit`, if there is any.\n    public fun on_new_epoch(framework: &signer) acquires RequiredGasDeposit, AllowCustomMaxGasFlag {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<RequiredGasDeposit>()) {\n            let new_config = config_buffer::extract<RequiredGasDeposit>();\n            if (exists<RequiredGasDeposit>(@aptos_framework)) {\n                *borrow_global_mut<RequiredGasDeposit>(@aptos_framework) = new_config;\n            } else {\n                move_to(framework, new_config);\n            }\n        };\n        if (config_buffer::does_exist<AllowCustomMaxGasFlag>()) {\n            let new_config = config_buffer::extract<AllowCustomMaxGasFlag>();\n            if (exists<AllowCustomMaxGasFlag>(@aptos_framework)) {\n                *borrow_global_mut<AllowCustomMaxGasFlag>(@aptos_framework) = new_config;\n            } else {\n                move_to(framework, new_config);\n            }\n        }\n    }\n}\n","name":"randomness_api_v0_config.move"},{"content":"/// Structs and functions for on-chain randomness configurations.\nmodule aptos_framework::randomness_config {\n    use std::string;\n    use aptos_std::copyable_any;\n    use aptos_std::copyable_any::Any;\n    use aptos_std::fixed_point64::FixedPoint64;\n    use aptos_framework::config_buffer;\n    use aptos_framework::system_addresses;\n\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    const EINVALID_CONFIG_VARIANT: u64 = 1;\n\n    /// The configuration of the on-chain randomness feature.\n    struct RandomnessConfig has copy, drop, key, store {\n        /// A config variant packed as an `Any`.\n        /// Currently the variant type is one of the following.\n        /// - `ConfigOff`\n        /// - `ConfigV1`\n        variant: Any,\n    }\n\n    /// A randomness config variant indicating the feature is disabled.\n    struct ConfigOff has copy, drop, store {}\n\n    /// A randomness config variant indicating the feature is enabled.\n    struct ConfigV1 has copy, drop, store {\n        /// Any validator subset should not be able to reconstruct randomness if `subset_power / total_power <= secrecy_threshold`,\n        secrecy_threshold: FixedPoint64,\n        /// Any validator subset should be able to reconstruct randomness if `subset_power / total_power > reconstruction_threshold`.\n        reconstruction_threshold: FixedPoint64,\n    }\n\n    /// A randomness config variant indicating the feature is enabled with fast path.\n    struct ConfigV2 has copy, drop, store {\n        /// Any validator subset should not be able to reconstruct randomness if `subset_power / total_power <= secrecy_threshold`,\n        secrecy_threshold: FixedPoint64,\n        /// Any validator subset should be able to reconstruct randomness if `subset_power / total_power > reconstruction_threshold`.\n        reconstruction_threshold: FixedPoint64,\n        /// Any validator subset should not be able to reconstruct randomness via the fast path if `subset_power / total_power <= fast_path_secrecy_threshold`,\n        fast_path_secrecy_threshold: FixedPoint64,\n    }\n\n    /// Initialize the configuration. Used in genesis or governance.\n    public fun initialize(framework: &signer, config: RandomnessConfig) {\n        system_addresses::assert_aptos_framework(framework);\n        if (!exists<RandomnessConfig>(@aptos_framework)) {\n            move_to(framework, config)\n        }\n    }\n\n    /// This can be called by on-chain governance to update on-chain consensus configs for the next epoch.\n    public fun set_for_next_epoch(framework: &signer, new_config: RandomnessConfig) {\n        system_addresses::assert_aptos_framework(framework);\n        config_buffer::upsert(new_config);\n    }\n\n    /// Only used in reconfigurations to apply the pending `RandomnessConfig`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires RandomnessConfig {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<RandomnessConfig>()) {\n            let new_config = config_buffer::extract<RandomnessConfig>();\n            if (exists<RandomnessConfig>(@aptos_framework)) {\n                *borrow_global_mut<RandomnessConfig>(@aptos_framework) = new_config;\n            } else {\n                move_to(framework, new_config);\n            }\n        }\n    }\n\n    /// Check whether on-chain randomness main logic (e.g., `DKGManager`, `RandManager`, `BlockMetadataExt`) is enabled.\n    ///\n    /// NOTE: this returning true does not mean randomness will run.\n    /// The feature works if and only if `consensus_config::validator_txn_enabled() && randomness_config::enabled()`.\n    public fun enabled(): bool acquires RandomnessConfig {\n        if (exists<RandomnessConfig>(@aptos_framework)) {\n            let config = borrow_global<RandomnessConfig>(@aptos_framework);\n            let variant_type_name = *string::bytes(copyable_any::type_name(&config.variant));\n            variant_type_name != b\"0x1::randomness_config::ConfigOff\"\n        } else {\n            false\n        }\n    }\n\n    /// Create a `ConfigOff` variant.\n    public fun new_off(): RandomnessConfig {\n        RandomnessConfig {\n            variant: copyable_any::pack( ConfigOff {} )\n        }\n    }\n\n    /// Create a `ConfigV1` variant.\n    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {\n        RandomnessConfig {\n            variant: copyable_any::pack( ConfigV1 {\n                secrecy_threshold,\n                reconstruction_threshold\n            } )\n        }\n    }\n\n    /// Create a `ConfigV2` variant.\n    public fun new_v2(\n        secrecy_threshold: FixedPoint64,\n        reconstruction_threshold: FixedPoint64,\n        fast_path_secrecy_threshold: FixedPoint64,\n    ): RandomnessConfig {\n        RandomnessConfig {\n            variant: copyable_any::pack( ConfigV2 {\n                secrecy_threshold,\n                reconstruction_threshold,\n                fast_path_secrecy_threshold,\n            } )\n        }\n    }\n\n    /// Get the currently effective randomness configuration object.\n    public fun current(): RandomnessConfig acquires RandomnessConfig {\n        if (exists<RandomnessConfig>(@aptos_framework)) {\n            *borrow_global<RandomnessConfig>(@aptos_framework)\n        } else {\n            new_off()\n        }\n    }\n\n    #[test_only]\n    use aptos_std::fixed_point64;\n\n    #[test_only]\n    fun initialize_for_testing(framework: &signer) {\n        config_buffer::initialize(framework);\n        initialize(framework, new_off());\n    }\n\n    #[test(framework = @0x1)]\n    fun init_buffer_apply(framework: signer) acquires RandomnessConfig {\n        initialize_for_testing(&framework);\n\n        // Enabling.\n        let config = new_v1(\n            fixed_point64::create_from_rational(1, 2),\n            fixed_point64::create_from_rational(2, 3)\n        );\n        set_for_next_epoch(&framework, config);\n        on_new_epoch(&framework);\n        assert!(enabled(), 1);\n\n        // Disabling.\n        set_for_next_epoch(&framework, new_off());\n        on_new_epoch(&framework);\n        assert!(!enabled(), 2);\n    }\n}\n","name":"randomness_config.move"},{"content":"/// Randomness stall recovery utils.\n///\n/// When randomness generation is stuck due to a bug, the chain is also stuck. Below is the recovery procedure.\n/// 1. Ensure more than 2/3 stakes are stuck at the same version.\n/// 1. Every validator restarts with `randomness_override_seq_num` set to `X+1` in the node config file,\n///    where `X` is the current `RandomnessConfigSeqNum` on chain.\n/// 1. The chain should then be unblocked.\n/// 1. Once the bug is fixed and the binary + framework have been patched,\n///    a governance proposal is needed to set `RandomnessConfigSeqNum` to be `X+2`.\nmodule aptos_framework::randomness_config_seqnum {\n    use aptos_framework::config_buffer;\n    use aptos_framework::system_addresses;\n\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    /// If this seqnum is smaller than a validator local override, the on-chain `RandomnessConfig` will be ignored.\n    /// Useful in a chain recovery from randomness stall.\n    struct RandomnessConfigSeqNum has drop, key, store {\n        seq_num: u64,\n    }\n\n    /// Update `RandomnessConfigSeqNum`.\n    /// Used when re-enable randomness after an emergency randomness disable via local override.\n    public fun set_for_next_epoch(framework: &signer, seq_num: u64) {\n        system_addresses::assert_aptos_framework(framework);\n        config_buffer::upsert(RandomnessConfigSeqNum { seq_num });\n    }\n\n    /// Initialize the configuration. Used in genesis or governance.\n    public fun initialize(framework: &signer) {\n        system_addresses::assert_aptos_framework(framework);\n        if (!exists<RandomnessConfigSeqNum>(@aptos_framework)) {\n            move_to(framework, RandomnessConfigSeqNum { seq_num: 0 })\n        }\n    }\n\n    /// Only used in reconfigurations to apply the pending `RandomnessConfig`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires RandomnessConfigSeqNum {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<RandomnessConfigSeqNum>()) {\n            let new_config = config_buffer::extract<RandomnessConfigSeqNum>();\n            if (exists<RandomnessConfigSeqNum>(@aptos_framework)) {\n                *borrow_global_mut<RandomnessConfigSeqNum>(@aptos_framework) = new_config;\n            } else {\n                move_to(framework, new_config);\n            }\n        }\n    }\n}\n","name":"randomness_config_seqnum.move"},{"content":"/// Provides the configuration for staking and rewards\nmodule aptos_framework::staking_config {\n    use std::error;\n    use std::features;\n\n    use aptos_framework::system_addresses;\n    use aptos_framework::timestamp;\n\n    use aptos_std::fixed_point64::{Self, FixedPoint64, less_or_equal};\n    use aptos_std::math_fixed64;\n\n    friend aptos_framework::genesis;\n    friend aptos_framework::stake;\n\n    /// Stake lockup duration cannot be zero.\n    const EZERO_LOCKUP_DURATION: u64 = 1;\n    /// Reward rate denominator cannot be zero.\n    const EZERO_REWARDS_RATE_DENOMINATOR: u64 = 2;\n    /// Specified stake range is invalid. Max must be greater than min.\n    const EINVALID_STAKE_RANGE: u64 = 3;\n    /// The voting power increase limit percentage must be within (0, 50].\n    const EINVALID_VOTING_POWER_INCREASE_LIMIT: u64 = 4;\n    /// Specified rewards rate is invalid, which must be within [0, MAX_REWARDS_RATE].\n    const EINVALID_REWARDS_RATE: u64 = 5;\n    /// Specified min rewards rate is invalid, which must be within [0, rewards_rate].\n    const EINVALID_MIN_REWARDS_RATE: u64 = 6;\n    /// Specified start time of last rewards rate period is invalid, which must be not late than the current timestamp.\n    const EINVALID_LAST_REWARDS_RATE_PERIOD_START: u64 = 7;\n    /// Specified rewards rate decrease rate is invalid, which must be not greater than BPS_DENOMINATOR.\n    const EINVALID_REWARDS_RATE_DECREASE_RATE: u64 = 8;\n    /// Specified rewards rate period is invalid. It must be larger than 0 and cannot be changed if configured.\n    const EINVALID_REWARDS_RATE_PERIOD: u64 = 9;\n    /// The function has been deprecated.\n    const EDEPRECATED_FUNCTION: u64 = 10;\n    /// The function is disabled or hasn't been enabled.\n    const EDISABLED_FUNCTION: u64 = 11;\n\n    /// Limit the maximum value of `rewards_rate` in order to avoid any arithmetic overflow.\n    const MAX_REWARDS_RATE: u64 = 1000000;\n    /// Denominator of number in basis points. 1 bps(basis points) = 0.01%.\n    const BPS_DENOMINATOR: u64 = 10000;\n    /// 1 year => 365 * 24 * 60 * 60\n    const ONE_YEAR_IN_SECS: u64 = 31536000;\n\n    const MAX_U64: u128 = 18446744073709551615;\n\n\n    /// Validator set configurations that will be stored with the @aptos_framework account.\n    struct StakingConfig has copy, drop, key {\n        // A validator needs to stake at least this amount to be able to join the validator set.\n        // If after joining the validator set and at the start of any epoch, a validator's stake drops below this amount\n        // they will be removed from the set.\n        minimum_stake: u64,\n        // A validator can only stake at most this amount. Any larger stake will be rejected.\n        // If after joining the validator set and at the start of any epoch, a validator's stake exceeds this amount,\n        // their voting power and rewards would only be issued for the max stake amount.\n        maximum_stake: u64,\n        recurring_lockup_duration_secs: u64,\n        // Whether validators are allow to join/leave post genesis.\n        allow_validator_set_change: bool,\n        // DEPRECATING: staking reward configurations will be in StakingRewardsConfig once REWARD_RATE_DECREASE flag is enabled.\n        // The maximum rewards given out every epoch. This will be divided by the rewards rate denominator.\n        // For example, 0.001% (0.00001) can be represented as 10 / 1000000.\n        rewards_rate: u64,\n        // DEPRECATING: staking reward configurations will be in StakingRewardsConfig once REWARD_RATE_DECREASE flag is enabled.\n        rewards_rate_denominator: u64,\n        // Only this % of current total voting power is allowed to join the validator set in each epoch.\n        // This is necessary to prevent a massive amount of new stake from joining that can potentially take down the\n        // network if corresponding validators are not ready to participate in consensus in time.\n        // This value is within (0, 50%), not inclusive.\n        voting_power_increase_limit: u64,\n    }\n\n    /// Staking reward configurations that will be stored with the @aptos_framework account.\n    struct StakingRewardsConfig has copy, drop, key {\n        // The target rewards rate given out every epoch. This will be divided by the rewards rate denominator.\n        // For example, 0.001% (0.00001) can be represented as 10 / 1000000.\n        rewards_rate: FixedPoint64,\n        // The minimum threshold for rewards_rate. rewards_rate won't be lower than this.\n        // This will be divided by the rewards rate denominator.\n        min_rewards_rate: FixedPoint64,\n        // Reward rate decreases every rewards_rate_period_in_secs seconds.\n        // Currently it can only equal to 1 year. Keep this field as a plceholder so we can change the reward period\n        // without adding new struct.\n        rewards_rate_period_in_secs: u64,\n        // Timestamp of start of last rewards period.\n        last_rewards_rate_period_start_in_secs: u64,\n        // Rate of reward rate decrease in BPS. 1 bps(basis points) = 0.01%.\n        rewards_rate_decrease_rate: FixedPoint64,\n    }\n\n    /// Only called during genesis.\n    public(friend) fun initialize(\n        aptos_framework: &signer,\n        minimum_stake: u64,\n        maximum_stake: u64,\n        recurring_lockup_duration_secs: u64,\n        allow_validator_set_change: bool,\n        rewards_rate: u64,\n        rewards_rate_denominator: u64,\n        voting_power_increase_limit: u64,\n    ) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        // This can fail genesis but is necessary so that any misconfigurations can be corrected before genesis succeeds\n        validate_required_stake(minimum_stake, maximum_stake);\n\n        assert!(recurring_lockup_duration_secs > 0, error::invalid_argument(EZERO_LOCKUP_DURATION));\n        assert!(\n            rewards_rate_denominator > 0,\n            error::invalid_argument(EZERO_REWARDS_RATE_DENOMINATOR),\n        );\n        assert!(\n            voting_power_increase_limit > 0 && voting_power_increase_limit <= 50,\n            error::invalid_argument(EINVALID_VOTING_POWER_INCREASE_LIMIT),\n        );\n\n        // `rewards_rate` which is the numerator is limited to be `<= MAX_REWARDS_RATE` in order to avoid the arithmetic\n        // overflow in the rewards calculation. `rewards_rate_denominator` can be adjusted to get the desired rewards\n        // rate (i.e., rewards_rate / rewards_rate_denominator).\n        assert!(rewards_rate <= MAX_REWARDS_RATE, error::invalid_argument(EINVALID_REWARDS_RATE));\n\n        // We assert that (rewards_rate / rewards_rate_denominator <= 1).\n        assert!(rewards_rate <= rewards_rate_denominator, error::invalid_argument(EINVALID_REWARDS_RATE));\n\n        move_to(aptos_framework, StakingConfig {\n            minimum_stake,\n            maximum_stake,\n            recurring_lockup_duration_secs,\n            allow_validator_set_change,\n            rewards_rate,\n            rewards_rate_denominator,\n            voting_power_increase_limit,\n        });\n    }\n\n    /// Initialize rewards configurations.\n    /// Can only be called as part of the Aptos governance proposal process established by the AptosGovernance module.\n    public fun initialize_rewards(\n        aptos_framework: &signer,\n        rewards_rate: FixedPoint64,\n        min_rewards_rate: FixedPoint64,\n        rewards_rate_period_in_secs: u64,\n        last_rewards_rate_period_start_in_secs: u64,\n        rewards_rate_decrease_rate: FixedPoint64,\n    ) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        validate_rewards_config(\n            rewards_rate,\n            min_rewards_rate,\n            rewards_rate_period_in_secs,\n            rewards_rate_decrease_rate,\n        );\n        assert!(\n            timestamp::now_seconds() >= last_rewards_rate_period_start_in_secs,\n            error::invalid_argument(EINVALID_LAST_REWARDS_RATE_PERIOD_START)\n        );\n\n        move_to(aptos_framework, StakingRewardsConfig {\n            rewards_rate,\n            min_rewards_rate,\n            rewards_rate_period_in_secs,\n            last_rewards_rate_period_start_in_secs,\n            rewards_rate_decrease_rate,\n        });\n    }\n\n    public fun get(): StakingConfig acquires StakingConfig {\n        *borrow_global<StakingConfig>(@aptos_framework)\n    }\n\n    /// Return whether validator set changes are allowed\n    public fun get_allow_validator_set_change(config: &StakingConfig): bool {\n        config.allow_validator_set_change\n    }\n\n    /// Return the required min/max stake.\n    public fun get_required_stake(config: &StakingConfig): (u64, u64) {\n        (config.minimum_stake, config.maximum_stake)\n    }\n\n    /// Return the recurring lockup duration that every validator is automatically renewed for (unless they unlock and\n    /// withdraw all funds).\n    public fun get_recurring_lockup_duration(config: &StakingConfig): u64 {\n        config.recurring_lockup_duration_secs\n    }\n\n    /// Return the reward rate of this epoch.\n    public fun get_reward_rate(config: &StakingConfig): (u64, u64) acquires StakingRewardsConfig {\n        if (features::periodical_reward_rate_decrease_enabled()) {\n            let epoch_rewards_rate = borrow_global<StakingRewardsConfig>(@aptos_framework).rewards_rate;\n            if (fixed_point64::is_zero(epoch_rewards_rate)) {\n                (0u64, 1u64)\n            } else {\n                // Maximize denominator for higher precision.\n                // Restriction: nominator <= MAX_REWARDS_RATE && denominator <= MAX_U64\n                let denominator = fixed_point64::divide_u128((MAX_REWARDS_RATE as u128), epoch_rewards_rate);\n                if (denominator > MAX_U64) {\n                    denominator = MAX_U64\n                };\n                let nominator = (fixed_point64::multiply_u128(denominator, epoch_rewards_rate) as u64);\n                (nominator, (denominator as u64))\n            }\n        } else {\n            (config.rewards_rate, config.rewards_rate_denominator)\n        }\n    }\n\n    /// Return the joining limit %.\n    public fun get_voting_power_increase_limit(config: &StakingConfig): u64 {\n        config.voting_power_increase_limit\n    }\n\n    /// Calculate and save the latest rewards rate.\n    public(friend) fun calculate_and_save_latest_epoch_rewards_rate(): FixedPoint64 acquires StakingRewardsConfig {\n        assert!(features::periodical_reward_rate_decrease_enabled(), error::invalid_state(EDISABLED_FUNCTION));\n        let staking_rewards_config = calculate_and_save_latest_rewards_config();\n        staking_rewards_config.rewards_rate\n    }\n\n    /// Calculate and return the up-to-date StakingRewardsConfig.\n    fun calculate_and_save_latest_rewards_config(): StakingRewardsConfig acquires StakingRewardsConfig {\n        let staking_rewards_config = borrow_global_mut<StakingRewardsConfig>(@aptos_framework);\n        let current_time_in_secs = timestamp::now_seconds();\n        assert!(\n            current_time_in_secs >= staking_rewards_config.last_rewards_rate_period_start_in_secs,\n            error::invalid_argument(EINVALID_LAST_REWARDS_RATE_PERIOD_START)\n        );\n        if (current_time_in_secs - staking_rewards_config.last_rewards_rate_period_start_in_secs < staking_rewards_config.rewards_rate_period_in_secs) {\n            return *staking_rewards_config\n        };\n        // Rewards rate decrease rate cannot be greater than 100%. Otherwise rewards rate will be negative.\n        assert!(\n            fixed_point64::ceil(staking_rewards_config.rewards_rate_decrease_rate) <= 1,\n            error::invalid_argument(EINVALID_REWARDS_RATE_DECREASE_RATE)\n        );\n        let new_rate = math_fixed64::mul_div(\n            staking_rewards_config.rewards_rate,\n            fixed_point64::sub(\n                fixed_point64::create_from_u128(1),\n                staking_rewards_config.rewards_rate_decrease_rate,\n            ),\n            fixed_point64::create_from_u128(1),\n        );\n        new_rate = fixed_point64::max(new_rate, staking_rewards_config.min_rewards_rate);\n\n        staking_rewards_config.rewards_rate = new_rate;\n        staking_rewards_config.last_rewards_rate_period_start_in_secs =\n            staking_rewards_config.last_rewards_rate_period_start_in_secs +\n            staking_rewards_config.rewards_rate_period_in_secs;\n        return *staking_rewards_config\n    }\n\n    /// Update the min and max stake amounts.\n    /// Can only be called as part of the Aptos governance proposal process established by the AptosGovernance module.\n    public fun update_required_stake(\n        aptos_framework: &signer,\n        minimum_stake: u64,\n        maximum_stake: u64,\n    ) acquires StakingConfig {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        validate_required_stake(minimum_stake, maximum_stake);\n\n        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);\n        staking_config.minimum_stake = minimum_stake;\n        staking_config.maximum_stake = maximum_stake;\n    }\n\n    /// Update the recurring lockup duration.\n    /// Can only be called as part of the Aptos governance proposal process established by the AptosGovernance module.\n    public fun update_recurring_lockup_duration_secs(\n        aptos_framework: &signer,\n        new_recurring_lockup_duration_secs: u64,\n    ) acquires StakingConfig {\n        assert!(new_recurring_lockup_duration_secs > 0, error::invalid_argument(EZERO_LOCKUP_DURATION));\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);\n        staking_config.recurring_lockup_duration_secs = new_recurring_lockup_duration_secs;\n    }\n\n    /// DEPRECATING\n    /// Update the rewards rate.\n    /// Can only be called as part of the Aptos governance proposal process established by the AptosGovernance module.\n    public fun update_rewards_rate(\n        aptos_framework: &signer,\n        new_rewards_rate: u64,\n        new_rewards_rate_denominator: u64,\n    ) acquires StakingConfig {\n        assert!(!features::periodical_reward_rate_decrease_enabled(), error::invalid_state(EDEPRECATED_FUNCTION));\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(\n            new_rewards_rate_denominator > 0,\n            error::invalid_argument(EZERO_REWARDS_RATE_DENOMINATOR),\n        );\n        // `rewards_rate` which is the numerator is limited to be `<= MAX_REWARDS_RATE` in order to avoid the arithmetic\n        // overflow in the rewards calculation. `rewards_rate_denominator` can be adjusted to get the desired rewards\n        // rate (i.e., rewards_rate / rewards_rate_denominator).\n        assert!(new_rewards_rate <= MAX_REWARDS_RATE, error::invalid_argument(EINVALID_REWARDS_RATE));\n\n        // We assert that (rewards_rate / rewards_rate_denominator <= 1).\n        assert!(new_rewards_rate <= new_rewards_rate_denominator, error::invalid_argument(EINVALID_REWARDS_RATE));\n\n        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);\n        staking_config.rewards_rate = new_rewards_rate;\n        staking_config.rewards_rate_denominator = new_rewards_rate_denominator;\n    }\n\n    public fun update_rewards_config(\n        aptos_framework: &signer,\n        rewards_rate: FixedPoint64,\n        min_rewards_rate: FixedPoint64,\n        rewards_rate_period_in_secs: u64,\n        rewards_rate_decrease_rate: FixedPoint64,\n    ) acquires StakingRewardsConfig {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        validate_rewards_config(\n            rewards_rate,\n            min_rewards_rate,\n            rewards_rate_period_in_secs,\n            rewards_rate_decrease_rate,\n        );\n\n        let staking_rewards_config = borrow_global_mut<StakingRewardsConfig>(@aptos_framework);\n        // Currently rewards_rate_period_in_secs is not allowed to be changed because this could bring complicated\n        // logics. At the moment the argument is just a placeholder for future use.\n        assert!(\n            rewards_rate_period_in_secs == staking_rewards_config.rewards_rate_period_in_secs,\n            error::invalid_argument(EINVALID_REWARDS_RATE_PERIOD),\n        );\n        staking_rewards_config.rewards_rate = rewards_rate;\n        staking_rewards_config.min_rewards_rate = min_rewards_rate;\n        staking_rewards_config.rewards_rate_period_in_secs = rewards_rate_period_in_secs;\n        staking_rewards_config.rewards_rate_decrease_rate = rewards_rate_decrease_rate;\n    }\n\n    /// Update the joining limit %.\n    /// Can only be called as part of the Aptos governance proposal process established by the AptosGovernance module.\n    public fun update_voting_power_increase_limit(\n        aptos_framework: &signer,\n        new_voting_power_increase_limit: u64,\n    ) acquires StakingConfig {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(\n            new_voting_power_increase_limit > 0 && new_voting_power_increase_limit <= 50,\n            error::invalid_argument(EINVALID_VOTING_POWER_INCREASE_LIMIT),\n        );\n\n        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);\n        staking_config.voting_power_increase_limit = new_voting_power_increase_limit;\n    }\n\n    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {\n        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));\n    }\n\n    fun validate_rewards_config(\n        rewards_rate: FixedPoint64,\n        min_rewards_rate: FixedPoint64,\n        rewards_rate_period_in_secs: u64,\n        rewards_rate_decrease_rate: FixedPoint64,\n    ) {\n        // Bound rewards rate to avoid arithmetic overflow.\n        assert!(\n            less_or_equal(rewards_rate, fixed_point64::create_from_u128((1u128))),\n            error::invalid_argument(EINVALID_REWARDS_RATE)\n        );\n        assert!(\n            less_or_equal(min_rewards_rate, rewards_rate),\n            error::invalid_argument(EINVALID_MIN_REWARDS_RATE)\n        );\n        // Rewards rate decrease rate cannot be greater than 100%. Otherwise rewards rate will be negative.\n        assert!(\n            fixed_point64::ceil(rewards_rate_decrease_rate) <= 1,\n            error::invalid_argument(EINVALID_REWARDS_RATE_DECREASE_RATE)\n        );\n        // This field, rewards_rate_period_in_secs must be greater than 0.\n        // TODO: rewards_rate_period_in_secs should be longer than the epoch duration but reading epoch duration causes a circular dependency.\n        assert!(\n            rewards_rate_period_in_secs > 0,\n            error::invalid_argument(EINVALID_REWARDS_RATE_PERIOD),\n        );\n    }\n\n    #[test_only]\n    use aptos_std::fixed_point64::{equal, create_from_rational};\n\n    #[test(aptos_framework = @aptos_framework)]\n    public entry fun test_change_staking_configs(aptos_framework: signer) acquires StakingConfig {\n        initialize(&aptos_framework, 0, 1, 1, false, 1, 1, 1);\n\n        update_required_stake(&aptos_framework, 100, 1000);\n        update_recurring_lockup_duration_secs(&aptos_framework, 10000);\n        update_rewards_rate(&aptos_framework, 10, 100);\n        update_voting_power_increase_limit(&aptos_framework, 10);\n\n        let config = borrow_global<StakingConfig>(@aptos_framework);\n        assert!(config.minimum_stake == 100, 0);\n        assert!(config.maximum_stake == 1000, 1);\n        assert!(config.recurring_lockup_duration_secs == 10000, 3);\n        assert!(config.rewards_rate == 10, 4);\n        assert!(config.rewards_rate_denominator == 100, 4);\n        assert!(config.voting_power_increase_limit == 10, 5);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    public entry fun test_staking_rewards_rate_decrease_over_time(aptos_framework: signer) acquires StakingRewardsConfig {\n        let start_time_in_secs: u64 = 100001000000;\n        initialize_rewards_for_test(\n            &aptos_framework,\n            create_from_rational(1, 100),\n            create_from_rational(3, 1000),\n            ONE_YEAR_IN_SECS,\n            start_time_in_secs,\n            create_from_rational(50, 100)\n        );\n\n        let epoch_reward_rate = calculate_and_save_latest_epoch_rewards_rate();\n        assert!(equal(epoch_reward_rate, create_from_rational(1, 100)), 0);\n        // Rewards rate should not change until the current reward rate period ends.\n        timestamp::fast_forward_seconds(ONE_YEAR_IN_SECS / 2);\n        epoch_reward_rate = calculate_and_save_latest_epoch_rewards_rate();\n        assert!(equal(epoch_reward_rate, create_from_rational(1, 100)), 1);\n\n        // Rewards rate decreases to 1 / 100 * 5000 / 10000 = 5 / 1000.\n        timestamp::fast_forward_seconds(ONE_YEAR_IN_SECS / 2);\n        epoch_reward_rate = calculate_and_save_latest_epoch_rewards_rate();\n        assert!(equal(epoch_reward_rate, create_from_rational(5, 1000)), 2);\n\n        // Rewards rate decreases to 5 / 1000 * 5000 / 10000 = 2.5 / 1000.\n        // But rewards_rate cannot be lower than min_rewards_rate = 3 / 1000.\n        timestamp::fast_forward_seconds(ONE_YEAR_IN_SECS);\n        epoch_reward_rate = calculate_and_save_latest_epoch_rewards_rate();\n        assert!(equal(epoch_reward_rate, create_from_rational(3, 1000)), 3);\n\n        // Test when rewards_rate_decrease_rate is very small\n        update_rewards_config(\n            &aptos_framework,\n            epoch_reward_rate,\n            create_from_rational(0, 1000),\n            ONE_YEAR_IN_SECS,\n            create_from_rational(15, 1000),\n        );\n        // Rewards rate decreases to 3 / 1000 * 985 / 1000 = 2955 / 1000000.\n        timestamp::fast_forward_seconds(ONE_YEAR_IN_SECS);\n        epoch_reward_rate = calculate_and_save_latest_epoch_rewards_rate();\n        assert!(\n            fixed_point64::almost_equal(\n                epoch_reward_rate,\n                create_from_rational(2955, 1000000),\n                create_from_rational(1, 100000000)\n            ),\n            4);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    public entry fun test_change_staking_rewards_configs(aptos_framework: signer) acquires StakingRewardsConfig {\n        let start_time_in_secs: u64 = 100001000000;\n        initialize_rewards_for_test(\n            &aptos_framework,\n            create_from_rational(1, 100),\n            create_from_rational(3, 1000),\n            ONE_YEAR_IN_SECS,\n            start_time_in_secs,\n            create_from_rational(50, 100),\n        );\n\n        update_rewards_config(\n            &aptos_framework,\n            create_from_rational(2, 100),\n            create_from_rational(6, 1000),\n            ONE_YEAR_IN_SECS,\n            create_from_rational(25, 100),\n        );\n\n        let config = borrow_global<StakingRewardsConfig>(@aptos_framework);\n        assert!(equal(config.rewards_rate, create_from_rational(2, 100)), 0);\n        assert!(equal(config.min_rewards_rate, create_from_rational(6, 1000)), 1);\n        assert!(config.rewards_rate_period_in_secs == ONE_YEAR_IN_SECS, 4);\n        assert!(config.last_rewards_rate_period_start_in_secs == start_time_in_secs, 4);\n        assert!(equal(config.rewards_rate_decrease_rate, create_from_rational(25, 100)), 5);\n    }\n\n    #[test(account = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    public entry fun test_update_required_stake_unauthorized_should_fail(account: signer) acquires StakingConfig {\n        update_required_stake(&account, 1, 2);\n    }\n\n    #[test(account = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    public entry fun test_update_required_lockup_unauthorized_should_fail(account: signer) acquires StakingConfig {\n        update_recurring_lockup_duration_secs(&account, 1);\n    }\n\n    #[test(account = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    public entry fun test_update_rewards_unauthorized_should_fail(account: signer) acquires StakingConfig {\n        update_rewards_rate(&account, 1, 10);\n    }\n\n    #[test(account = @0x123)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    public entry fun test_update_voting_power_increase_limit_unauthorized_should_fail(account: signer) acquires StakingConfig {\n        update_voting_power_increase_limit(&account, 10);\n    }\n\n    #[test(account = @0x123, aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::system_addresses)]\n    public entry fun test_update_rewards_config_unauthorized_should_fail(account: signer, aptos_framework: signer) acquires StakingRewardsConfig {\n        features::change_feature_flags_for_testing(&aptos_framework, vector[features::get_periodical_reward_rate_decrease_feature()], vector[]);\n        update_rewards_config(\n            &account,\n            create_from_rational(1, 100),\n            create_from_rational(1, 100),\n            ONE_YEAR_IN_SECS,\n            create_from_rational(1, 100),\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10003, location = Self)]\n    public entry fun test_update_required_stake_invalid_range_should_fail(aptos_framework: signer) acquires StakingConfig {\n        update_required_stake(&aptos_framework, 10, 5);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10003, location = Self)]\n    public entry fun test_update_required_stake_zero_max_stake_should_fail(aptos_framework: signer) acquires StakingConfig {\n        update_required_stake(&aptos_framework, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10001, location = Self)]\n    public entry fun test_update_required_lockup_to_zero_should_fail(aptos_framework: signer) acquires StakingConfig {\n        update_recurring_lockup_duration_secs(&aptos_framework, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10002, location = Self)]\n    public entry fun test_update_rewards_invalid_denominator_should_fail(aptos_framework: signer) acquires StakingConfig {\n        update_rewards_rate(&aptos_framework, 1, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10005, location = Self)]\n    public entry fun test_update_rewards_config_rewards_rate_greater_than_1_should_fail(aptos_framework: signer) acquires StakingRewardsConfig {\n        let start_time_in_secs: u64 = 100001000000;\n        initialize_rewards_for_test(\n            &aptos_framework,\n            create_from_rational(15981, 1000000000),\n            create_from_rational(7991, 1000000000),\n            ONE_YEAR_IN_SECS,\n            start_time_in_secs,\n            create_from_rational(15, 1000),\n        );\n        update_rewards_config(\n            &aptos_framework,\n            create_from_rational(101, 100),\n            create_from_rational(1, 100),\n            ONE_YEAR_IN_SECS,\n            create_from_rational(1, 100),\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10008, location = Self)]\n    public entry fun test_update_rewards_config_invalid_rewards_rate_decrease_rate_should_fail(aptos_framework: signer) acquires StakingRewardsConfig {\n        let start_time_in_secs: u64 = 100001000000;\n        initialize_rewards_for_test(\n            &aptos_framework,\n            create_from_rational(15981, 1000000000),\n            create_from_rational(7991, 1000000000),\n            ONE_YEAR_IN_SECS,\n            start_time_in_secs,\n            create_from_rational(15, 1000),\n        );\n        update_rewards_config(\n            &aptos_framework,\n            create_from_rational(1, 100),\n            create_from_rational(1, 100),\n            ONE_YEAR_IN_SECS,\n            create_from_rational(101, 100),\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10009, location = Self)]\n    public entry fun test_update_rewards_config_cannot_change_rewards_rate_period(aptos_framework: signer) acquires StakingRewardsConfig {\n        let start_time_in_secs: u64 = 100001000000;\n        initialize_rewards_for_test(\n            &aptos_framework,\n            create_from_rational(15981, 1000000000),\n            create_from_rational(7991, 1000000000),\n            ONE_YEAR_IN_SECS,\n            start_time_in_secs,\n            create_from_rational(15, 1000),\n        );\n        update_rewards_config(\n            &aptos_framework,\n            create_from_rational(15981, 1000000000),\n            create_from_rational(7991, 1000000000),\n            ONE_YEAR_IN_SECS - 1,\n            create_from_rational(15, 1000),\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x3000B, location = Self)]\n    public entry fun test_feature_flag_disabled_get_epoch_rewards_rate_should_fail(aptos_framework: signer) acquires StakingRewardsConfig {\n        features::change_feature_flags_for_testing(&aptos_framework, vector[], vector[features::get_periodical_reward_rate_decrease_feature()]);\n        calculate_and_save_latest_epoch_rewards_rate();\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10004, location = Self)]\n    public entry fun test_update_voting_power_increase_limit_to_zero_should_fail(\n        aptos_framework: signer\n    ) acquires StakingConfig {\n        update_voting_power_increase_limit(&aptos_framework, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    #[expected_failure(abort_code = 0x10004, location = aptos_framework::staking_config)]\n    public entry fun test_update_voting_power_increase_limit_to_more_than_upper_bound_should_fail(\n        aptos_framework: signer\n    ) acquires StakingConfig {\n        update_voting_power_increase_limit(&aptos_framework, 51);\n    }\n\n    // For tests to bypass all validations.\n    #[test_only]\n    public fun initialize_for_test(\n        aptos_framework: &signer,\n        minimum_stake: u64,\n        maximum_stake: u64,\n        recurring_lockup_duration_secs: u64,\n        allow_validator_set_change: bool,\n        rewards_rate: u64,\n        rewards_rate_denominator: u64,\n        voting_power_increase_limit: u64,\n    ) {\n        if (!exists<StakingConfig>(@aptos_framework)) {\n            move_to(aptos_framework, StakingConfig {\n                minimum_stake,\n                maximum_stake,\n                recurring_lockup_duration_secs,\n                allow_validator_set_change,\n                rewards_rate,\n                rewards_rate_denominator,\n                voting_power_increase_limit,\n            });\n        };\n    }\n\n    // For tests to bypass all validations.\n    #[test_only]\n    public fun initialize_rewards_for_test(\n        aptos_framework: &signer,\n        rewards_rate: FixedPoint64,\n        min_rewards_rate: FixedPoint64,\n        rewards_rate_period_in_micros: u64,\n        last_rewards_rate_period_start_in_secs: u64,\n        rewards_rate_decrease_rate: FixedPoint64,\n    ) {\n        features::change_feature_flags_for_testing(aptos_framework, vector[features::get_periodical_reward_rate_decrease_feature()], vector[]);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n        timestamp::update_global_time_for_test_secs(last_rewards_rate_period_start_in_secs);\n        initialize_rewards(\n            aptos_framework,\n            rewards_rate,\n            min_rewards_rate,\n            rewards_rate_period_in_micros,\n            last_rewards_rate_period_start_in_secs,\n            rewards_rate_decrease_rate,\n        );\n    }\n}\n","name":"staking_config.move"},{"content":"/// Maintains the version number for the blockchain.\nmodule aptos_framework::version {\n    use std::error;\n    use std::signer;\n    use aptos_framework::chain_status;\n    use aptos_framework::config_buffer;\n\n    use aptos_framework::reconfiguration;\n    use aptos_framework::system_addresses;\n\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    struct Version has drop, key, store {\n        major: u64,\n    }\n\n    struct SetVersionCapability has key {}\n\n    /// Specified major version number must be greater than current version number.\n    const EINVALID_MAJOR_VERSION_NUMBER: u64 = 1;\n    /// Account is not authorized to make this change.\n    const ENOT_AUTHORIZED: u64 = 2;\n\n    /// Only called during genesis.\n    /// Publishes the Version config.\n    public(friend) fun initialize(aptos_framework: &signer, initial_version: u64) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        move_to(aptos_framework, Version { major: initial_version });\n        // Give aptos framework account capability to call set version. This allows on chain governance to do it through\n        // control of the aptos framework account.\n        move_to(aptos_framework, SetVersionCapability {});\n    }\n\n    /// Deprecated by `set_for_next_epoch()`.\n    ///\n    /// WARNING: calling this while randomness is enabled will trigger a new epoch without randomness!\n    ///\n    /// TODO: update all the tests that reference this function, then disable this function.\n    public entry fun set_version(account: &signer, major: u64) acquires Version {\n        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));\n        chain_status::assert_genesis();\n\n        let old_major = borrow_global<Version>(@aptos_framework).major;\n        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));\n\n        let config = borrow_global_mut<Version>(@aptos_framework);\n        config.major = major;\n\n        // Need to trigger reconfiguration so validator nodes can sync on the updated version.\n        reconfiguration::reconfigure();\n    }\n\n    /// Used in on-chain governances to update the major version for the next epoch.\n    /// Example usage:\n    /// - `aptos_framework::version::set_for_next_epoch(&framework_signer, new_version);`\n    /// - `aptos_framework::aptos_governance::reconfigure(&framework_signer);`\n    public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {\n        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));\n        let old_major = borrow_global<Version>(@aptos_framework).major;\n        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));\n        config_buffer::upsert(Version {major});\n    }\n\n    /// Only used in reconfigurations to apply the pending `Version`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires Version {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<Version>()) {\n            let new_value = config_buffer::extract<Version>();\n            if (exists<Version>(@aptos_framework)) {\n                *borrow_global_mut<Version>(@aptos_framework) = new_value;\n            } else {\n                move_to(framework, new_value);\n            }\n        }\n    }\n\n    /// Only called in tests and testnets. This allows the core resources account, which only exists in tests/testnets,\n    /// to update the version.\n    fun initialize_for_test(core_resources: &signer) {\n        system_addresses::assert_core_resource(core_resources);\n        move_to(core_resources, SetVersionCapability {});\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    public entry fun test_set_version(aptos_framework: signer) acquires Version {\n        initialize(&aptos_framework, 1);\n        assert!(borrow_global<Version>(@aptos_framework).major == 1, 0);\n        set_version(&aptos_framework, 2);\n        assert!(borrow_global<Version>(@aptos_framework).major == 2, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, core_resources = @core_resources)]\n    public entry fun test_set_version_core_resources(\n        aptos_framework: signer,\n        core_resources: signer,\n    ) acquires Version {\n        initialize(&aptos_framework, 1);\n        assert!(borrow_global<Version>(@aptos_framework).major == 1, 0);\n        initialize_for_test(&core_resources);\n        set_version(&core_resources, 2);\n        assert!(borrow_global<Version>(@aptos_framework).major == 2, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, random_account = @0x123)]\n    #[expected_failure(abort_code = 327682, location = Self)]\n    public entry fun test_set_version_unauthorized_should_fail(\n        aptos_framework: signer,\n        random_account: signer,\n    ) acquires Version {\n        initialize(&aptos_framework, 1);\n        set_version(&random_account, 2);\n    }\n}\n","name":"version.move"},{"content":"/// Provides a common place for exporting `create_signer` across the Aptos Framework.\n///\n/// To use create_signer, add the module below, such that:\n/// `friend aptos_framework::friend_wants_create_signer`\n/// where `friend_wants_create_signer` is the module that needs `create_signer`.\n///\n/// Note, that this is only available within the Aptos Framework.\n///\n/// This exists to make auditing straight forward and to limit the need to depend\n/// on account to have access to this.\nmodule aptos_framework::create_signer {\n    friend aptos_framework::account;\n    friend aptos_framework::aptos_account;\n    friend aptos_framework::coin;\n    friend aptos_framework::genesis;\n    friend aptos_framework::multisig_account;\n    friend aptos_framework::object;\n\n    public(friend) native fun create_signer(addr: address): signer;\n}\n","name":"create_signer.move"},{"content":"/**\nAllow multiple delegators to participate in the same stake pool in order to collect the minimum\nstake required to join the validator set. Delegators are rewarded out of the validator rewards\nproportionally to their stake and provided the same stake-management API as the stake pool owner.\n\nThe main accounting logic in the delegation pool contract handles the following:\n1. Tracks how much stake each delegator owns, privately deposited as well as earned.\nAccounting individual delegator stakes is achieved through the shares-based pool defined at\n<code>aptos_std::pool_u64</code>, hence delegators own shares rather than absolute stakes into the delegation pool.\n2. Tracks rewards earned by the stake pool, implicitly by the delegation one, in the meantime\nand distribute them accordingly.\n3. Tracks lockup cycles on the stake pool in order to separate inactive stake (not earning rewards)\nfrom pending_inactive stake (earning rewards) and allow its delegators to withdraw the former.\n4. Tracks how much commission fee has to be paid to the operator out of incoming rewards before\ndistributing them to the internal pool_u64 pools.\n\nIn order to distinguish between stakes in different states and route rewards accordingly,\nseparate pool_u64 pools are used for individual stake states:\n1. one of <code>active</code> + <code>pending_active</code> stake\n2. one of <code>inactive</code> stake FOR each past observed lockup cycle (OLC) on the stake pool\n3. one of <code>pending_inactive</code> stake scheduled during this ongoing OLC\n\nAs stake-state transitions and rewards are computed only at the stake pool level, the delegation pool\ngets outdated. To mitigate this, at any interaction with the delegation pool, a process of synchronization\nto the underlying stake pool is executed before the requested operation itself.\n\nAt synchronization:\n - stake deviations between the two pools are actually the rewards produced in the meantime.\n - the commission fee is extracted from the rewards, the remaining stake is distributed to the internal\npool_u64 pools and then the commission stake used to buy shares for operator.\n - if detecting that the lockup expired on the stake pool, the delegation pool will isolate its\npending_inactive stake (now inactive) and create a new pool_u64 to host future pending_inactive stake\nscheduled this newly started lockup.\nDetecting a lockup expiration on the stake pool resumes to detecting new inactive stake.\n\nAccounting main invariants:\n - each stake-management operation (add/unlock/reactivate/withdraw) and operator change triggers\nthe synchronization process before executing its own function.\n - each OLC maps to one or more real lockups on the stake pool, but not the opposite. Actually, only a real\nlockup with 'activity' (which inactivated some unlocking stake) triggers the creation of a new OLC.\n - unlocking and/or unlocked stake originating from different real lockups are never mixed together into\nthe same pool_u64. This invalidates the accounting of which rewards belong to whom.\n - no delegator can have unlocking and/or unlocked stake (pending withdrawals) in different OLCs. This ensures\ndelegators do not have to keep track of the OLCs when they unlocked. When creating a new pending withdrawal,\nthe existing one is executed (withdrawn) if is already inactive.\n - <code>add_stake</code> fees are always refunded, but only after the epoch when they have been charged ends.\n - withdrawing pending_inactive stake (when validator had gone inactive before its lockup expired)\ndoes not inactivate any stake additional to the requested one to ensure OLC would not advance indefinitely.\n - the pending withdrawal exists at an OLC iff delegator owns some shares within the shares pool of that OLC.\n\nExample flow:\n<ol>\n<li>A node operator creates a delegation pool by calling\n<code>initialize_delegation_pool</code> and sets\nits commission fee to 0% (for simplicity). A stake pool is created with no initial stake and owned by\na resource account controlled by the delegation pool.</li>\n<li>Delegator A adds 100 stake which is converted to 100 shares into the active pool_u64</li>\n<li>Operator joins the validator set as the stake pool has now the minimum stake</li>\n<li>The stake pool earned rewards and now has 200 active stake. A's active shares are worth 200 coins as\nthe commission fee is 0%.</li>\n<li></li>\n<ol>\n    <li>A requests <code>unlock</code> for 100 stake</li>\n    <li>Synchronization detects 200 - 100 active rewards which are entirely (0% commission) added to the active pool.</li>\n    <li>100 coins = (100 * 100) / 200 = 50 shares are redeemed from the active pool and exchanged for 100 shares\ninto the pending_inactive one on A's behalf</li>\n</ol>\n<li>Delegator B adds 200 stake which is converted to (200 * 50) / 100 = 100 shares into the active pool</li>\n<li>The stake pool earned rewards and now has 600 active and 200 pending_inactive stake.</li>\n<li></li>\n<ol>\n    <li>A requests <code>reactivate_stake</code> for 100 stake</li>\n    <li>\n    Synchronization detects 600 - 300 active and 200 - 100 pending_inactive rewards which are both entirely\n    distributed to their corresponding pools\n    </li>\n    <li>\n    100 coins = (100 * 100) / 200 = 50 shares are redeemed from the pending_inactive pool and exchanged for\n    (100 * 150) / 600 = 25 shares into the active one on A's behalf\n    </li>\n</ol>\n<li>The lockup expires on the stake pool, inactivating the entire pending_inactive stake</li>\n<li></li>\n<ol>\n    <li>B requests <code>unlock</code> for 100 stake</li>\n    <li>\n    Synchronization detects no active or pending_inactive rewards, but 0 -> 100 inactive stake on the stake pool,\n    so it advances the observed lockup cycle and creates a pool_u64 for the new lockup, hence allowing previous\n    pending_inactive shares to be redeemed</li>\n    <li>\n    100 coins = (100 * 175) / 700 = 25 shares are redeemed from the active pool and exchanged for 100 shares\n    into the new pending_inactive one on B's behalf\n    </li>\n</ol>\n<li>The stake pool earned rewards and now has some pending_inactive rewards.</li>\n<li></li>\n<ol>\n    <li>A requests <code>withdraw</code> for its entire inactive stake</li>\n    <li>\n    Synchronization detects no new inactive stake, but some pending_inactive rewards which are distributed\n    to the (2nd) pending_inactive pool\n    </li>\n    <li>\n    A's 50 shares = (50 * 100) / 50 = 100 coins are redeemed from the (1st) inactive pool and 100 stake is\n    transferred to A\n    </li>\n</ol>\n</ol>\n */\nmodule aptos_framework::delegation_pool {\n    use std::error;\n    use std::features;\n    use std::signer;\n    use std::vector;\n\n    use aptos_std::math64;\n    use aptos_std::pool_u64_unbound::{Self as pool_u64, total_coins};\n    use aptos_std::table::{Self, Table};\n    use aptos_std::smart_table::{Self, SmartTable};\n\n    use aptos_framework::account;\n    use aptos_framework::aptos_account;\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::aptos_governance;\n    use aptos_framework::coin;\n    use aptos_framework::event::{Self, EventHandle, emit};\n    use aptos_framework::stake;\n    use aptos_framework::stake::get_operator;\n    use aptos_framework::staking_config;\n    use aptos_framework::timestamp;\n\n    const MODULE_SALT: vector<u8> = b\"aptos_framework::delegation_pool\";\n\n    /// Delegation pool owner capability does not exist at the provided account.\n    const EOWNER_CAP_NOT_FOUND: u64 = 1;\n\n    /// Account is already owning a delegation pool.\n    const EOWNER_CAP_ALREADY_EXISTS: u64 = 2;\n\n    /// Delegation pool does not exist at the provided pool address.\n    const EDELEGATION_POOL_DOES_NOT_EXIST: u64 = 3;\n\n    /// There is a pending withdrawal to be executed before `unlock`ing any new stake.\n    const EPENDING_WITHDRAWAL_EXISTS: u64 = 4;\n\n    /// Commission percentage has to be between 0 and `MAX_FEE` - 100%.\n    const EINVALID_COMMISSION_PERCENTAGE: u64 = 5;\n\n    /// There is not enough `active` stake on the stake pool to `unlock`.\n    const ENOT_ENOUGH_ACTIVE_STAKE_TO_UNLOCK: u64 = 6;\n\n    /// Slashing (if implemented) should not be applied to already `inactive` stake.\n    /// Not only it invalidates the accounting of past observed lockup cycles (OLC),\n    /// but is also unfair to delegators whose stake has been inactive before validator started misbehaving.\n    /// Additionally, the inactive stake does not count on the voting power of validator.\n    const ESLASHED_INACTIVE_STAKE_ON_PAST_OLC: u64 = 7;\n\n    /// Delegator's active balance cannot be less than `MIN_COINS_ON_SHARES_POOL`.\n    const EDELEGATOR_ACTIVE_BALANCE_TOO_LOW: u64 = 8;\n\n    /// Delegator's pending_inactive balance cannot be less than `MIN_COINS_ON_SHARES_POOL`.\n    const EDELEGATOR_PENDING_INACTIVE_BALANCE_TOO_LOW: u64 = 9;\n\n    /// Creating delegation pools is not enabled yet.\n    const EDELEGATION_POOLS_DISABLED: u64 = 10;\n\n    /// Cannot request to withdraw zero stake.\n    const EWITHDRAW_ZERO_STAKE: u64 = 11;\n\n    /// Function is deprecated.\n    const EDEPRECATED_FUNCTION: u64 = 12;\n\n    /// The function is disabled or hasn't been enabled.\n    const EDISABLED_FUNCTION: u64 = 13;\n\n    /// Partial governance voting hasn't been enabled on this delegation pool.\n    const EPARTIAL_GOVERNANCE_VOTING_NOT_ENABLED: u64 = 14;\n\n    /// The voter does not have sufficient stake to create a proposal.\n    const EINSUFFICIENT_PROPOSER_STAKE: u64 = 15;\n\n    /// The voter does not have any voting power on this proposal.\n    const ENO_VOTING_POWER: u64 = 16;\n\n    /// The stake pool has already voted on the proposal before enabling partial governance voting on this delegation pool.\n    const EALREADY_VOTED_BEFORE_ENABLE_PARTIAL_VOTING: u64 = 17;\n\n    /// The account is not the operator of the stake pool.\n    const ENOT_OPERATOR: u64 = 18;\n\n    /// Changing beneficiaries for operators is not supported.\n    const EOPERATOR_BENEFICIARY_CHANGE_NOT_SUPPORTED: u64 = 19;\n\n    /// Commission percentage increase is too large.\n    const ETOO_LARGE_COMMISSION_INCREASE: u64 = 20;\n\n    /// Commission percentage change is too late in this lockup period, and should be done at least a quarter (1/4) of the lockup duration before the lockup cycle ends.\n    const ETOO_LATE_COMMISSION_CHANGE: u64 = 21;\n\n    /// Changing operator commission rate in delegation pool is not supported.\n    const ECOMMISSION_RATE_CHANGE_NOT_SUPPORTED: u64 = 22;\n\n    /// Delegators allowlisting is not supported.\n    const EDELEGATORS_ALLOWLISTING_NOT_SUPPORTED: u64 = 23;\n\n    /// Delegators allowlisting should be enabled to perform this operation.\n    const EDELEGATORS_ALLOWLISTING_NOT_ENABLED: u64 = 24;\n\n    /// Cannot add/reactivate stake unless being allowlisted by the pool owner.\n    const EDELEGATOR_NOT_ALLOWLISTED: u64 = 25;\n\n    /// Cannot evict an allowlisted delegator, should remove them from the allowlist first.\n    const ECANNOT_EVICT_ALLOWLISTED_DELEGATOR: u64 = 26;\n\n    /// Cannot unlock the accumulated active stake of NULL_SHAREHOLDER(0x0).\n    const ECANNOT_UNLOCK_NULL_SHAREHOLDER: u64 = 27;\n\n    const MAX_U64: u64 = 18446744073709551615;\n\n    /// Maximum operator percentage fee(of double digit precision): 22.85% is represented as 2285\n    const MAX_FEE: u64 = 10000;\n\n    const VALIDATOR_STATUS_INACTIVE: u64 = 4;\n\n    /// Special shareholder temporarily owning the `add_stake` fees charged during this epoch.\n    /// On each `add_stake` operation any resulted fee is used to buy active shares for this shareholder.\n    /// First synchronization after this epoch ends will distribute accumulated fees to the rest of the pool as refunds.\n    const NULL_SHAREHOLDER: address = @0x0;\n\n    /// Minimum coins to exist on a shares pool at all times.\n    /// Enforced per delegator for both active and pending_inactive pools.\n    /// This constraint ensures the share price cannot overly increase and lead to\n    /// substantial losses when buying shares (can lose at most 1 share which may\n    /// be worth a lot if current share price is high).\n    /// This constraint is not enforced on inactive pools as they only allow redeems\n    /// (can lose at most 1 coin regardless of current share price).\n    const MIN_COINS_ON_SHARES_POOL: u64 = 1000000000;\n\n    /// Scaling factor of shares pools used within the delegation pool\n    const SHARES_SCALING_FACTOR: u64 = 10000000000000000;\n\n    /// Maximum commission percentage increase per lockup cycle. 10% is represented as 1000.\n    const MAX_COMMISSION_INCREASE: u64 = 1000;\n\n    /// Capability that represents ownership over privileged operations on the underlying stake pool.\n    struct DelegationPoolOwnership has key, store {\n        /// equal to address of the resource account owning the stake pool\n        pool_address: address,\n    }\n\n    struct ObservedLockupCycle has copy, drop, store {\n        index: u64,\n    }\n\n    struct DelegationPool has key {\n        // Shares pool of `active` + `pending_active` stake\n        active_shares: pool_u64::Pool,\n        // Index of current observed lockup cycle on the delegation pool since its creation\n        observed_lockup_cycle: ObservedLockupCycle,\n        // Shares pools of `inactive` stake on each ended OLC and `pending_inactive` stake on the current one.\n        // Tracks shares of delegators who requested withdrawals in each OLC\n        inactive_shares: Table<ObservedLockupCycle, pool_u64::Pool>,\n        // Mapping from delegator address to the OLC of its pending withdrawal if having one\n        pending_withdrawals: Table<address, ObservedLockupCycle>,\n        // Signer capability of the resource account owning the stake pool\n        stake_pool_signer_cap: account::SignerCapability,\n        // Total (inactive) coins on the shares pools over all ended OLCs\n        total_coins_inactive: u64,\n        // Commission fee paid to the node operator out of pool rewards\n        operator_commission_percentage: u64,\n\n        // The events emitted by stake-management operations on the delegation pool\n        add_stake_events: EventHandle<AddStakeEvent>,\n        reactivate_stake_events: EventHandle<ReactivateStakeEvent>,\n        unlock_stake_events: EventHandle<UnlockStakeEvent>,\n        withdraw_stake_events: EventHandle<WithdrawStakeEvent>,\n        distribute_commission_events: EventHandle<DistributeCommissionEvent>,\n    }\n\n    struct VotingRecordKey has copy, drop, store {\n        voter: address,\n        proposal_id: u64,\n    }\n\n    /// Track delegated voter of each delegator.\n    struct VoteDelegation has copy, drop, store {\n        // The account who can vote on behalf of this delegator.\n        voter: address,\n        // The account that will become the voter in the next lockup period. Changing voter address needs 1 lockup\n        // period to take effects.\n        pending_voter: address,\n        // Tracks the last known lockup cycle end when the voter was updated. This will be used to determine when\n        // the new voter becomes effective.\n        // If <locked_until_secs of the stake pool> != last_locked_until_secs, it means that a lockup period has passed.\n        // This is slightly different from ObservedLockupCycle because ObservedLockupCycle cannot detect if a lockup\n        // period is passed when there is no unlocking during the lockup period.\n        last_locked_until_secs: u64,\n    }\n\n    /// Track total voting power of each voter.\n    struct DelegatedVotes has copy, drop, store {\n        // The total number of active shares delegated to this voter by all delegators.\n        active_shares: u128,\n        // The total number of pending inactive shares delegated to this voter by all delegators\n        pending_inactive_shares: u128,\n        // Total active shares delegated to this voter in the next lockup cycle.\n        // `active_shares_next_lockup` might be different `active_shares` when some delegators change their voter.\n        active_shares_next_lockup: u128,\n        // Tracks the last known lockup cycle end when the voter was updated. This will be used to determine when\n        // the new voter becomes effective.\n        // If <locked_until_secs of the stake pool> != last_locked_until_secs, it means that a lockup period has passed.\n        // This is slightly different from ObservedLockupCycle because ObservedLockupCycle cannot detect if a lockup\n        // period is passed when there is no unlocking during the lockup period.\n        last_locked_until_secs: u64,\n    }\n\n    /// Track governance information of a delegation(e.g. voter delegation/voting power calculation).\n    /// This struct should be stored in the delegation pool resource account.\n    struct GovernanceRecords has key {\n        // `votes` tracks voting power usage of each voter on each proposal.\n        votes: SmartTable<VotingRecordKey, u64>,\n        // `votes_per_proposal` tracks voting power usage of this stake pool on each proposal. Key is proposal_id.\n        votes_per_proposal: SmartTable<u64, u64>,\n        vote_delegation: SmartTable<address, VoteDelegation>,\n        delegated_votes: SmartTable<address, DelegatedVotes>,\n        vote_events: EventHandle<VoteEvent>,\n        create_proposal_events: EventHandle<CreateProposalEvent>,\n        // Note: a DelegateVotingPowerEvent event only means that the delegator tries to change its voter. The change\n        // won't take effect until the next lockup period.\n        delegate_voting_power_events: EventHandle<DelegateVotingPowerEvent>,\n    }\n\n    struct BeneficiaryForOperator has key {\n        beneficiary_for_operator: address,\n    }\n\n    struct NextCommissionPercentage has key {\n        commission_percentage_next_lockup_cycle: u64,\n        effective_after_secs: u64,\n    }\n\n    /// Tracks a delegation pool's allowlist of delegators.\n    /// If allowlisting is enabled, existing delegators are not implicitly allowlisted and they can be individually\n    /// evicted later by the pool owner.\n    struct DelegationPoolAllowlisting has key {\n        allowlist: SmartTable<address, bool>,\n    }\n\n    #[event]\n    struct AddStake has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_added: u64,\n        add_stake_fee: u64,\n    }\n\n    struct AddStakeEvent has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_added: u64,\n        add_stake_fee: u64,\n    }\n\n    #[event]\n    struct ReactivateStake has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_reactivated: u64,\n    }\n\n    struct ReactivateStakeEvent has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_reactivated: u64,\n    }\n\n    #[event]\n    struct UnlockStake has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_unlocked: u64,\n    }\n\n    struct UnlockStakeEvent has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_unlocked: u64,\n    }\n\n    #[event]\n    struct WithdrawStake has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_withdrawn: u64,\n    }\n\n    struct WithdrawStakeEvent has drop, store {\n        pool_address: address,\n        delegator_address: address,\n        amount_withdrawn: u64,\n    }\n\n    #[event]\n    struct DistributeCommissionEvent has drop, store {\n        pool_address: address,\n        operator: address,\n        commission_active: u64,\n        commission_pending_inactive: u64,\n    }\n\n    #[event]\n    struct DistributeCommission has drop, store {\n        pool_address: address,\n        operator: address,\n        beneficiary: address,\n        commission_active: u64,\n        commission_pending_inactive: u64,\n    }\n\n    #[event]\n    struct Vote has drop, store {\n        voter: address,\n        proposal_id: u64,\n        delegation_pool: address,\n        num_votes: u64,\n        should_pass: bool,\n    }\n\n    struct VoteEvent has drop, store {\n        voter: address,\n        proposal_id: u64,\n        delegation_pool: address,\n        num_votes: u64,\n        should_pass: bool,\n    }\n\n    #[event]\n    struct CreateProposal has drop, store {\n        proposal_id: u64,\n        voter: address,\n        delegation_pool: address,\n    }\n\n    struct CreateProposalEvent has drop, store {\n        proposal_id: u64,\n        voter: address,\n        delegation_pool: address,\n    }\n\n    #[event]\n    struct DelegateVotingPower has drop, store {\n        pool_address: address,\n        delegator: address,\n        voter: address,\n    }\n\n    struct DelegateVotingPowerEvent has drop, store {\n        pool_address: address,\n        delegator: address,\n        voter: address,\n    }\n\n    #[event]\n    struct SetBeneficiaryForOperator has drop, store {\n        operator: address,\n        old_beneficiary: address,\n        new_beneficiary: address,\n    }\n\n    #[event]\n    struct CommissionPercentageChange has drop, store {\n        pool_address: address,\n        owner: address,\n        commission_percentage_next_lockup_cycle: u64,\n    }\n\n    #[event]\n    struct EnableDelegatorsAllowlisting has drop, store {\n        pool_address: address,\n    }\n\n    #[event]\n    struct DisableDelegatorsAllowlisting has drop, store {\n        pool_address: address,\n    }\n\n    #[event]\n    struct AllowlistDelegator has drop, store {\n        pool_address: address,\n        delegator_address: address,\n    }\n\n    #[event]\n    struct RemoveDelegatorFromAllowlist has drop, store {\n        pool_address: address,\n        delegator_address: address,\n    }\n\n    #[event]\n    struct EvictDelegator has drop, store {\n        pool_address: address,\n        delegator_address: address,\n    }\n\n    #[view]\n    /// Return whether supplied address `addr` is owner of a delegation pool.\n    public fun owner_cap_exists(addr: address): bool {\n        exists<DelegationPoolOwnership>(addr)\n    }\n\n    #[view]\n    /// Return address of the delegation pool owned by `owner` or fail if there is none.\n    public fun get_owned_pool_address(owner: address): address acquires DelegationPoolOwnership {\n        assert_owner_cap_exists(owner);\n        borrow_global<DelegationPoolOwnership>(owner).pool_address\n    }\n\n    #[view]\n    /// Return whether a delegation pool exists at supplied address `addr`.\n    public fun delegation_pool_exists(addr: address): bool {\n        exists<DelegationPool>(addr)\n    }\n\n    #[view]\n    /// Return whether a delegation pool has already enabled partial governance voting.\n    public fun partial_governance_voting_enabled(pool_address: address): bool {\n        exists<GovernanceRecords>(pool_address) && stake::get_delegated_voter(pool_address) == pool_address\n    }\n\n    #[view]\n    /// Return the index of current observed lockup cycle on delegation pool `pool_address`.\n    public fun observed_lockup_cycle(pool_address: address): u64 acquires DelegationPool {\n        assert_delegation_pool_exists(pool_address);\n        borrow_global<DelegationPool>(pool_address).observed_lockup_cycle.index\n    }\n\n    #[view]\n    /// Return whether the commission percentage for the next lockup cycle is effective.\n    public fun is_next_commission_percentage_effective(pool_address: address): bool acquires NextCommissionPercentage {\n        exists<NextCommissionPercentage>(pool_address) &&\n            timestamp::now_seconds() >= borrow_global<NextCommissionPercentage>(pool_address).effective_after_secs\n    }\n\n    #[view]\n    /// Return the operator commission percentage set on the delegation pool `pool_address`.\n    public fun operator_commission_percentage(\n        pool_address: address\n    ): u64 acquires DelegationPool, NextCommissionPercentage {\n        assert_delegation_pool_exists(pool_address);\n        if (is_next_commission_percentage_effective(pool_address)) {\n            operator_commission_percentage_next_lockup_cycle(pool_address)\n        } else {\n            borrow_global<DelegationPool>(pool_address).operator_commission_percentage\n        }\n    }\n\n    #[view]\n    /// Return the operator commission percentage for the next lockup cycle.\n    public fun operator_commission_percentage_next_lockup_cycle(\n        pool_address: address\n    ): u64 acquires DelegationPool, NextCommissionPercentage {\n        assert_delegation_pool_exists(pool_address);\n        if (exists<NextCommissionPercentage>(pool_address)) {\n            borrow_global<NextCommissionPercentage>(pool_address).commission_percentage_next_lockup_cycle\n        } else {\n            borrow_global<DelegationPool>(pool_address).operator_commission_percentage\n        }\n    }\n\n    #[view]\n    /// Return the number of delegators owning active stake within `pool_address`.\n    public fun shareholders_count_active_pool(pool_address: address): u64 acquires DelegationPool {\n        assert_delegation_pool_exists(pool_address);\n        pool_u64::shareholders_count(&borrow_global<DelegationPool>(pool_address).active_shares)\n    }\n\n    #[view]\n    /// Return the stake amounts on `pool_address` in the different states:\n    /// (`active`,`inactive`,`pending_active`,`pending_inactive`)\n    public fun get_delegation_pool_stake(pool_address: address): (u64, u64, u64, u64) {\n        assert_delegation_pool_exists(pool_address);\n        stake::get_stake(pool_address)\n    }\n\n    #[view]\n    /// Return whether the given delegator has any withdrawable stake. If they recently requested to unlock\n    /// some stake and the stake pool's lockup cycle has not ended, their coins are not withdrawable yet.\n    public fun get_pending_withdrawal(\n        pool_address: address,\n        delegator_address: address\n    ): (bool, u64) acquires DelegationPool {\n        assert_delegation_pool_exists(pool_address);\n        let pool = borrow_global<DelegationPool>(pool_address);\n        let (\n            lockup_cycle_ended,\n            _,\n            pending_inactive,\n            _,\n            commission_pending_inactive\n        ) = calculate_stake_pool_drift(pool);\n\n        let (withdrawal_exists, withdrawal_olc) = pending_withdrawal_exists(pool, delegator_address);\n        if (!withdrawal_exists) {\n            // if no pending withdrawal, there is neither inactive nor pending_inactive stake\n            (false, 0)\n        } else {\n            // delegator has either inactive or pending_inactive stake due to automatic withdrawals\n            let inactive_shares = table::borrow(&pool.inactive_shares, withdrawal_olc);\n            if (withdrawal_olc.index < pool.observed_lockup_cycle.index) {\n                // if withdrawal's lockup cycle ended on delegation pool then it is inactive\n                (true, pool_u64::balance(inactive_shares, delegator_address))\n            } else {\n                pending_inactive = pool_u64::shares_to_amount_with_total_coins(\n                    inactive_shares,\n                    pool_u64::shares(inactive_shares, delegator_address),\n                    // exclude operator pending_inactive rewards not converted to shares yet\n                    pending_inactive - commission_pending_inactive\n                );\n                // if withdrawal's lockup cycle ended ONLY on stake pool then it is also inactive\n                (lockup_cycle_ended, pending_inactive)\n            }\n        }\n    }\n\n    #[view]\n    /// Return total stake owned by `delegator_address` within delegation pool `pool_address`\n    /// in each of its individual states: (`active`,`inactive`,`pending_inactive`)\n    public fun get_stake(\n        pool_address: address,\n        delegator_address: address\n    ): (u64, u64, u64) acquires DelegationPool, BeneficiaryForOperator {\n        assert_delegation_pool_exists(pool_address);\n        let pool = borrow_global<DelegationPool>(pool_address);\n        let (\n            lockup_cycle_ended,\n            active,\n            _,\n            commission_active,\n            commission_pending_inactive\n        ) = calculate_stake_pool_drift(pool);\n\n        let total_active_shares = pool_u64::total_shares(&pool.active_shares);\n        let delegator_active_shares = pool_u64::shares(&pool.active_shares, delegator_address);\n\n        let (_, _, pending_active, _) = stake::get_stake(pool_address);\n        if (pending_active == 0) {\n            // zero `pending_active` stake indicates that either there are no `add_stake` fees or\n            // previous epoch has ended and should identify shares owning these fees as released\n            total_active_shares = total_active_shares - pool_u64::shares(&pool.active_shares, NULL_SHAREHOLDER);\n            if (delegator_address == NULL_SHAREHOLDER) {\n                delegator_active_shares = 0\n            }\n        };\n        active = pool_u64::shares_to_amount_with_total_stats(\n            &pool.active_shares,\n            delegator_active_shares,\n            // exclude operator active rewards not converted to shares yet\n            active - commission_active,\n            total_active_shares\n        );\n\n        // get state and stake (0 if there is none) of the pending withdrawal\n        let (withdrawal_inactive, withdrawal_stake) = get_pending_withdrawal(pool_address, delegator_address);\n        // report non-active stakes accordingly to the state of the pending withdrawal\n        let (inactive, pending_inactive) = if (withdrawal_inactive) (withdrawal_stake, 0) else (0, withdrawal_stake);\n\n        // should also include commission rewards in case of the operator account\n        // operator rewards are actually used to buy shares which is introducing\n        // some imprecision (received stake would be slightly less)\n        // but adding rewards onto the existing stake is still a good approximation\n        if (delegator_address == beneficiary_for_operator(get_operator(pool_address))) {\n            active = active + commission_active;\n            // in-flight pending_inactive commission can coexist with already inactive withdrawal\n            if (lockup_cycle_ended) {\n                inactive = inactive + commission_pending_inactive\n            } else {\n                pending_inactive = pending_inactive + commission_pending_inactive\n            }\n        };\n\n        (active, inactive, pending_inactive)\n    }\n\n    #[view]\n    /// Return refundable stake to be extracted from added `amount` at `add_stake` operation on pool `pool_address`.\n    /// If the validator produces rewards this epoch, added stake goes directly to `pending_active` and\n    /// does not earn rewards. However, all shares within a pool appreciate uniformly and when this epoch ends:\n    /// - either added shares are still `pending_active` and steal from rewards of existing `active` stake\n    /// - or have moved to `pending_inactive` and get full rewards (they displaced `active` stake at `unlock`)\n    /// To mitigate this, some of the added stake is extracted and fed back into the pool as placeholder\n    /// for the rewards the remaining stake would have earned if active:\n    /// extracted-fee = (amount - extracted-fee) * reward-rate% * (100% - operator-commission%)\n    public fun get_add_stake_fee(\n        pool_address: address,\n        amount: u64\n    ): u64 acquires DelegationPool, NextCommissionPercentage {\n        if (stake::is_current_epoch_validator(pool_address)) {\n            let (rewards_rate, rewards_rate_denominator) = staking_config::get_reward_rate(&staking_config::get());\n            if (rewards_rate_denominator > 0) {\n                assert_delegation_pool_exists(pool_address);\n\n                rewards_rate = rewards_rate * (MAX_FEE - operator_commission_percentage(pool_address));\n                rewards_rate_denominator = rewards_rate_denominator * MAX_FEE;\n                ((((amount as u128) * (rewards_rate as u128)) / ((rewards_rate as u128) + (rewards_rate_denominator as u128))) as u64)\n            } else { 0 }\n        } else { 0 }\n    }\n\n    #[view]\n    /// Return whether `pending_inactive` stake can be directly withdrawn from\n    /// the delegation pool, implicitly its stake pool, in the special case\n    /// the validator had gone inactive before its lockup expired.\n    public fun can_withdraw_pending_inactive(pool_address: address): bool {\n        stake::get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE &&\n            timestamp::now_seconds() >= stake::get_lockup_secs(pool_address)\n    }\n\n    #[view]\n    /// Return the total voting power of a delegator in a delegation pool. This function syncs DelegationPool to the\n    /// latest state.\n    public fun calculate_and_update_voter_total_voting_power(\n        pool_address: address,\n        voter: address\n    ): u64 acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert_partial_governance_voting_enabled(pool_address);\n        // Delegation pool need to be synced to explain rewards(which could change the coin amount) and\n        // commission(which could cause share transfer).\n        synchronize_delegation_pool(pool_address);\n        let pool = borrow_global<DelegationPool>(pool_address);\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        let latest_delegated_votes = update_and_borrow_mut_delegated_votes(pool, governance_records, voter);\n        calculate_total_voting_power(pool, latest_delegated_votes)\n    }\n\n    #[view]\n    /// Return the remaining voting power of a delegator in a delegation pool on a proposal. This function syncs DelegationPool to the\n    /// latest state.\n    public fun calculate_and_update_remaining_voting_power(\n        pool_address: address,\n        voter_address: address,\n        proposal_id: u64\n    ): u64 acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert_partial_governance_voting_enabled(pool_address);\n        // If the whole stake pool has no voting power(e.g. it has already voted before partial\n        // governance voting flag is enabled), the delegator also has no voting power.\n        if (aptos_governance::get_remaining_voting_power(pool_address, proposal_id) == 0) {\n            return 0\n        };\n\n        let total_voting_power = calculate_and_update_voter_total_voting_power(pool_address, voter_address);\n        let governance_records = borrow_global<GovernanceRecords>(pool_address);\n        total_voting_power - get_used_voting_power(governance_records, voter_address, proposal_id)\n    }\n\n    #[view]\n    /// Return the latest delegated voter of a delegator in a delegation pool. This function syncs DelegationPool to the\n    /// latest state.\n    public fun calculate_and_update_delegator_voter(\n        pool_address: address,\n        delegator_address: address\n    ): address acquires DelegationPool, GovernanceRecords {\n        assert_partial_governance_voting_enabled(pool_address);\n        calculate_and_update_delegator_voter_internal(\n            borrow_global<DelegationPool>(pool_address),\n            borrow_global_mut<GovernanceRecords>(pool_address),\n            delegator_address\n        )\n    }\n\n    #[view]\n    /// Return the current state of a voting delegation of a delegator in a delegation pool.\n    public fun calculate_and_update_voting_delegation(\n        pool_address: address,\n        delegator_address: address\n    ): (address, address, u64) acquires DelegationPool, GovernanceRecords {\n        assert_partial_governance_voting_enabled(pool_address);\n        let vote_delegation = update_and_borrow_mut_delegator_vote_delegation(\n            borrow_global<DelegationPool>(pool_address),\n            borrow_global_mut<GovernanceRecords>(pool_address),\n            delegator_address\n        );\n\n        (vote_delegation.voter, vote_delegation.pending_voter, vote_delegation.last_locked_until_secs)\n    }\n\n    #[view]\n    /// Return the address of the stake pool to be created with the provided owner, and seed.\n    public fun get_expected_stake_pool_address(owner: address, delegation_pool_creation_seed: vector<u8>\n    ): address {\n        let seed = create_resource_account_seed(delegation_pool_creation_seed);\n        account::create_resource_address(&owner, seed)\n    }\n\n    #[view]\n    /// Return the minimum remaining time in seconds for commission change, which is one fourth of the lockup duration.\n    public fun min_remaining_secs_for_commission_change(): u64 {\n        let config = staking_config::get();\n        staking_config::get_recurring_lockup_duration(&config) / 4\n    }\n\n    #[view]\n    /// Return whether allowlisting is enabled for the provided delegation pool.\n    public fun allowlisting_enabled(pool_address: address): bool {\n        assert_delegation_pool_exists(pool_address);\n        exists<DelegationPoolAllowlisting>(pool_address)\n    }\n\n    #[view]\n    /// Return whether the provided delegator is allowlisted.\n    /// A delegator is allowlisted if:\n    /// - allowlisting is disabled on the pool\n    /// - delegator is part of the allowlist\n    public fun delegator_allowlisted(\n        pool_address: address,\n        delegator_address: address,\n    ): bool acquires DelegationPoolAllowlisting {\n        if (!allowlisting_enabled(pool_address)) { return true };\n        smart_table::contains(freeze(borrow_mut_delegators_allowlist(pool_address)), delegator_address)\n    }\n\n    #[view]\n    /// Return allowlist or revert if allowlisting is not enabled for the provided delegation pool.\n    public fun get_delegators_allowlist(\n        pool_address: address,\n    ): vector<address> acquires DelegationPoolAllowlisting {\n        assert_allowlisting_enabled(pool_address);\n\n        let allowlist = vector[];\n        smart_table::for_each_ref(freeze(borrow_mut_delegators_allowlist(pool_address)), |delegator, _v| {\n            vector::push_back(&mut allowlist, *delegator);\n        });\n        allowlist\n    }\n\n    /// Initialize a delegation pool of custom fixed `operator_commission_percentage`.\n    /// A resource account is created from `owner` signer and its supplied `delegation_pool_creation_seed`\n    /// to host the delegation pool resource and own the underlying stake pool.\n    /// Ownership over setting the operator/voter is granted to `owner` who has both roles initially.\n    public entry fun initialize_delegation_pool(\n        owner: &signer,\n        operator_commission_percentage: u64,\n        delegation_pool_creation_seed: vector<u8>,\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert!(features::delegation_pools_enabled(), error::invalid_state(EDELEGATION_POOLS_DISABLED));\n        let owner_address = signer::address_of(owner);\n        assert!(!owner_cap_exists(owner_address), error::already_exists(EOWNER_CAP_ALREADY_EXISTS));\n        assert!(operator_commission_percentage <= MAX_FEE, error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE));\n\n        // generate a seed to be used to create the resource account hosting the delegation pool\n        let seed = create_resource_account_seed(delegation_pool_creation_seed);\n\n        let (stake_pool_signer, stake_pool_signer_cap) = account::create_resource_account(owner, seed);\n        coin::register<AptosCoin>(&stake_pool_signer);\n\n        // stake_pool_signer will be owner of the stake pool and have its `stake::OwnerCapability`\n        let pool_address = signer::address_of(&stake_pool_signer);\n        stake::initialize_stake_owner(&stake_pool_signer, 0, owner_address, owner_address);\n\n        let inactive_shares = table::new<ObservedLockupCycle, pool_u64::Pool>();\n        table::add(\n            &mut inactive_shares,\n            olc_with_index(0),\n            pool_u64::create_with_scaling_factor(SHARES_SCALING_FACTOR)\n        );\n\n        move_to(&stake_pool_signer, DelegationPool {\n            active_shares: pool_u64::create_with_scaling_factor(SHARES_SCALING_FACTOR),\n            observed_lockup_cycle: olc_with_index(0),\n            inactive_shares,\n            pending_withdrawals: table::new<address, ObservedLockupCycle>(),\n            stake_pool_signer_cap,\n            total_coins_inactive: 0,\n            operator_commission_percentage,\n            add_stake_events: account::new_event_handle<AddStakeEvent>(&stake_pool_signer),\n            reactivate_stake_events: account::new_event_handle<ReactivateStakeEvent>(&stake_pool_signer),\n            unlock_stake_events: account::new_event_handle<UnlockStakeEvent>(&stake_pool_signer),\n            withdraw_stake_events: account::new_event_handle<WithdrawStakeEvent>(&stake_pool_signer),\n            distribute_commission_events: account::new_event_handle<DistributeCommissionEvent>(&stake_pool_signer),\n        });\n\n        // save delegation pool ownership and resource account address (inner stake pool address) on `owner`\n        move_to(owner, DelegationPoolOwnership { pool_address });\n\n        // All delegation pool enable partial governance voting by default once the feature flag is enabled.\n        if (features::partial_governance_voting_enabled(\n        ) && features::delegation_pool_partial_governance_voting_enabled()) {\n            enable_partial_governance_voting(pool_address);\n        }\n    }\n\n    #[view]\n    /// Return the beneficiary address of the operator.\n    public fun beneficiary_for_operator(operator: address): address acquires BeneficiaryForOperator {\n        if (exists<BeneficiaryForOperator>(operator)) {\n            return borrow_global<BeneficiaryForOperator>(operator).beneficiary_for_operator\n        } else {\n            operator\n        }\n    }\n\n    /// Enable partial governance voting on a stake pool. The voter of this stake pool will be managed by this module.\n    /// The existing voter will be replaced. The function is permissionless.\n    public entry fun enable_partial_governance_voting(\n        pool_address: address,\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert!(features::partial_governance_voting_enabled(), error::invalid_state(EDISABLED_FUNCTION));\n        assert!(\n            features::delegation_pool_partial_governance_voting_enabled(),\n            error::invalid_state(EDISABLED_FUNCTION)\n        );\n        assert_delegation_pool_exists(pool_address);\n        // synchronize delegation and stake pools before any user operation.\n        synchronize_delegation_pool(pool_address);\n\n        let delegation_pool = borrow_global<DelegationPool>(pool_address);\n        let stake_pool_signer = retrieve_stake_pool_owner(delegation_pool);\n        // delegated_voter is managed by the stake pool itself, which signer capability is managed by DelegationPool.\n        // So voting power of this stake pool can only be used through this module.\n        stake::set_delegated_voter(&stake_pool_signer, signer::address_of(&stake_pool_signer));\n\n        move_to(&stake_pool_signer, GovernanceRecords {\n            votes: smart_table::new(),\n            votes_per_proposal: smart_table::new(),\n            vote_delegation: smart_table::new(),\n            delegated_votes: smart_table::new(),\n            vote_events: account::new_event_handle<VoteEvent>(&stake_pool_signer),\n            create_proposal_events: account::new_event_handle<CreateProposalEvent>(&stake_pool_signer),\n            delegate_voting_power_events: account::new_event_handle<DelegateVotingPowerEvent>(&stake_pool_signer),\n        });\n    }\n\n    /// Vote on a proposal with a voter's voting power. To successfully vote, the following conditions must be met:\n    /// 1. The voting period of the proposal hasn't ended.\n    /// 2. The delegation pool's lockup period ends after the voting period of the proposal.\n    /// 3. The voter still has spare voting power on this proposal.\n    /// 4. The delegation pool never votes on the proposal before enabling partial governance voting.\n    public entry fun vote(\n        voter: &signer,\n        pool_address: address,\n        proposal_id: u64,\n        voting_power: u64,\n        should_pass: bool\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert_partial_governance_voting_enabled(pool_address);\n        // synchronize delegation and stake pools before any user operation.\n        synchronize_delegation_pool(pool_address);\n\n        let voter_address = signer::address_of(voter);\n        let remaining_voting_power = calculate_and_update_remaining_voting_power(\n            pool_address,\n            voter_address,\n            proposal_id\n        );\n        if (voting_power > remaining_voting_power) {\n            voting_power = remaining_voting_power;\n        };\n        assert!(voting_power > 0, error::invalid_argument(ENO_VOTING_POWER));\n\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        // Check a edge case during the transient period of enabling partial governance voting.\n        assert_and_update_proposal_used_voting_power(governance_records, pool_address, proposal_id, voting_power);\n        let used_voting_power = borrow_mut_used_voting_power(governance_records, voter_address, proposal_id);\n        *used_voting_power = *used_voting_power + voting_power;\n\n        let pool_signer = retrieve_stake_pool_owner(borrow_global<DelegationPool>(pool_address));\n        aptos_governance::partial_vote(&pool_signer, pool_address, proposal_id, voting_power, should_pass);\n\n        if (features::module_event_migration_enabled()) {\n            event::emit(\n                Vote {\n                    voter: voter_address,\n                    proposal_id,\n                    delegation_pool: pool_address,\n                    num_votes: voting_power,\n                    should_pass,\n                }\n            );\n        };\n\n        event::emit_event(\n            &mut governance_records.vote_events,\n            VoteEvent {\n                voter: voter_address,\n                proposal_id,\n                delegation_pool: pool_address,\n                num_votes: voting_power,\n                should_pass,\n            }\n        );\n    }\n\n    /// A voter could create a governance proposal by this function. To successfully create a proposal, the voter's\n    /// voting power in THIS delegation pool must be not less than the minimum required voting power specified in\n    /// `aptos_governance.move`.\n    public entry fun create_proposal(\n        voter: &signer,\n        pool_address: address,\n        execution_hash: vector<u8>,\n        metadata_location: vector<u8>,\n        metadata_hash: vector<u8>,\n        is_multi_step_proposal: bool,\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert_partial_governance_voting_enabled(pool_address);\n\n        // synchronize delegation and stake pools before any user operation\n        synchronize_delegation_pool(pool_address);\n\n        let voter_addr = signer::address_of(voter);\n        let pool = borrow_global<DelegationPool>(pool_address);\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        let total_voting_power = calculate_and_update_delegated_votes(pool, governance_records, voter_addr);\n        assert!(\n            total_voting_power >= aptos_governance::get_required_proposer_stake(),\n            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE));\n        let pool_signer = retrieve_stake_pool_owner(borrow_global<DelegationPool>(pool_address));\n        let proposal_id = aptos_governance::create_proposal_v2_impl(\n            &pool_signer,\n            pool_address,\n            execution_hash,\n            metadata_location,\n            metadata_hash,\n            is_multi_step_proposal,\n        );\n\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n\n        if (features::module_event_migration_enabled()) {\n            event::emit(\n                CreateProposal {\n                    proposal_id,\n                    voter: voter_addr,\n                    delegation_pool: pool_address,\n                }\n            );\n        };\n\n        event::emit_event(\n            &mut governance_records.create_proposal_events,\n            CreateProposalEvent {\n                proposal_id,\n                voter: voter_addr,\n                delegation_pool: pool_address,\n            }\n        );\n    }\n\n    fun assert_owner_cap_exists(owner: address) {\n        assert!(owner_cap_exists(owner), error::not_found(EOWNER_CAP_NOT_FOUND));\n    }\n\n    fun assert_delegation_pool_exists(pool_address: address) {\n        assert!(delegation_pool_exists(pool_address), error::invalid_argument(EDELEGATION_POOL_DOES_NOT_EXIST));\n    }\n\n    fun assert_min_active_balance(pool: &DelegationPool, delegator_address: address) {\n        let balance = pool_u64::balance(&pool.active_shares, delegator_address);\n        assert!(balance >= MIN_COINS_ON_SHARES_POOL, error::invalid_argument(EDELEGATOR_ACTIVE_BALANCE_TOO_LOW));\n    }\n\n    fun assert_min_pending_inactive_balance(pool: &DelegationPool, delegator_address: address) {\n        let balance = pool_u64::balance(pending_inactive_shares_pool(pool), delegator_address);\n        assert!(\n            balance >= MIN_COINS_ON_SHARES_POOL,\n            error::invalid_argument(EDELEGATOR_PENDING_INACTIVE_BALANCE_TOO_LOW)\n        );\n    }\n\n    fun assert_partial_governance_voting_enabled(pool_address: address) {\n        assert_delegation_pool_exists(pool_address);\n        assert!(\n            partial_governance_voting_enabled(pool_address),\n            error::invalid_state(EPARTIAL_GOVERNANCE_VOTING_NOT_ENABLED)\n        );\n    }\n\n    fun assert_allowlisting_enabled(pool_address: address) {\n        assert!(allowlisting_enabled(pool_address), error::invalid_state(EDELEGATORS_ALLOWLISTING_NOT_ENABLED));\n    }\n\n    fun assert_delegator_allowlisted(\n        pool_address: address,\n        delegator_address: address,\n    ) acquires DelegationPoolAllowlisting {\n        assert!(\n            delegator_allowlisted(pool_address, delegator_address),\n            error::permission_denied(EDELEGATOR_NOT_ALLOWLISTED)\n        );\n    }\n\n    fun coins_to_redeem_to_ensure_min_stake(\n        src_shares_pool: &pool_u64::Pool,\n        shareholder: address,\n        amount: u64,\n    ): u64 {\n        // find how many coins would be redeemed if supplying `amount`\n        let redeemed_coins = pool_u64::shares_to_amount(\n            src_shares_pool,\n            amount_to_shares_to_redeem(src_shares_pool, shareholder, amount)\n        );\n        // if balance drops under threshold then redeem it entirely\n        let src_balance = pool_u64::balance(src_shares_pool, shareholder);\n        if (src_balance - redeemed_coins < MIN_COINS_ON_SHARES_POOL) {\n            amount = src_balance;\n        };\n        amount\n    }\n\n    fun coins_to_transfer_to_ensure_min_stake(\n        src_shares_pool: &pool_u64::Pool,\n        dst_shares_pool: &pool_u64::Pool,\n        shareholder: address,\n        amount: u64,\n    ): u64 {\n        // find how many coins would be redeemed from source if supplying `amount`\n        let redeemed_coins = pool_u64::shares_to_amount(\n            src_shares_pool,\n            amount_to_shares_to_redeem(src_shares_pool, shareholder, amount)\n        );\n        // if balance on destination would be less than threshold then redeem difference to threshold\n        let dst_balance = pool_u64::balance(dst_shares_pool, shareholder);\n        if (dst_balance + redeemed_coins < MIN_COINS_ON_SHARES_POOL) {\n            // `redeemed_coins` >= `amount` - 1 as redeem can lose at most 1 coin\n            amount = MIN_COINS_ON_SHARES_POOL - dst_balance + 1;\n        };\n        // check if new `amount` drops balance on source under threshold and adjust\n        coins_to_redeem_to_ensure_min_stake(src_shares_pool, shareholder, amount)\n    }\n\n    /// Retrieves the shared resource account owning the stake pool in order\n    /// to forward a stake-management operation to this underlying pool.\n    fun retrieve_stake_pool_owner(pool: &DelegationPool): signer {\n        account::create_signer_with_capability(&pool.stake_pool_signer_cap)\n    }\n\n    /// Get the address of delegation pool reference `pool`.\n    fun get_pool_address(pool: &DelegationPool): address {\n        account::get_signer_capability_address(&pool.stake_pool_signer_cap)\n    }\n\n    /// Get the active share amount of the delegator.\n    fun get_delegator_active_shares(pool: &DelegationPool, delegator: address): u128 {\n        pool_u64::shares(&pool.active_shares, delegator)\n    }\n\n    /// Get the pending inactive share amount of the delegator.\n    fun get_delegator_pending_inactive_shares(pool: &DelegationPool, delegator: address): u128 {\n        pool_u64::shares(pending_inactive_shares_pool(pool), delegator)\n    }\n\n    /// Get the used voting power of a voter on a proposal.\n    fun get_used_voting_power(governance_records: &GovernanceRecords, voter: address, proposal_id: u64): u64 {\n        let votes = &governance_records.votes;\n        let key = VotingRecordKey {\n            voter,\n            proposal_id,\n        };\n        *smart_table::borrow_with_default(votes, key, &0)\n    }\n\n    /// Create the seed to derive the resource account address.\n    fun create_resource_account_seed(\n        delegation_pool_creation_seed: vector<u8>,\n    ): vector<u8> {\n        let seed = vector::empty<u8>();\n        // include module salt (before any subseeds) to avoid conflicts with other modules creating resource accounts\n        vector::append(&mut seed, MODULE_SALT);\n        // include an additional salt in case the same resource account has already been created\n        vector::append(&mut seed, delegation_pool_creation_seed);\n        seed\n    }\n\n    /// Borrow the mutable used voting power of a voter on a proposal.\n    inline fun borrow_mut_used_voting_power(\n        governance_records: &mut GovernanceRecords,\n        voter: address,\n        proposal_id: u64\n    ): &mut u64 {\n        let votes = &mut governance_records.votes;\n        let key = VotingRecordKey {\n            proposal_id,\n            voter,\n        };\n        smart_table::borrow_mut_with_default(votes, key, 0)\n    }\n\n    /// Update VoteDelegation of a delegator to up-to-date then borrow_mut it.\n    fun update_and_borrow_mut_delegator_vote_delegation(\n        pool: &DelegationPool,\n        governance_records: &mut GovernanceRecords,\n        delegator: address\n    ): &mut VoteDelegation {\n        let pool_address = get_pool_address(pool);\n        let locked_until_secs = stake::get_lockup_secs(pool_address);\n\n        let vote_delegation_table = &mut governance_records.vote_delegation;\n        // By default, a delegator's delegated voter is itself.\n        // TODO: recycle storage when VoteDelegation equals to default value.\n        if (!smart_table::contains(vote_delegation_table, delegator)) {\n            return smart_table::borrow_mut_with_default(vote_delegation_table, delegator, VoteDelegation {\n                voter: delegator,\n                last_locked_until_secs: locked_until_secs,\n                pending_voter: delegator,\n            })\n        };\n\n        let vote_delegation = smart_table::borrow_mut(vote_delegation_table, delegator);\n        // A lockup period has passed since last time `vote_delegation` was updated. Pending voter takes effect.\n        if (vote_delegation.last_locked_until_secs < locked_until_secs) {\n            vote_delegation.voter = vote_delegation.pending_voter;\n            vote_delegation.last_locked_until_secs = locked_until_secs;\n        };\n        vote_delegation\n    }\n\n    /// Update DelegatedVotes of a voter to up-to-date then borrow_mut it.\n    fun update_and_borrow_mut_delegated_votes(\n        pool: &DelegationPool,\n        governance_records: &mut GovernanceRecords,\n        voter: address\n    ): &mut DelegatedVotes {\n        let pool_address = get_pool_address(pool);\n        let locked_until_secs = stake::get_lockup_secs(pool_address);\n\n        let delegated_votes_per_voter = &mut governance_records.delegated_votes;\n        // By default, a delegator's voter is itself.\n        // TODO: recycle storage when DelegatedVotes equals to default value.\n        if (!smart_table::contains(delegated_votes_per_voter, voter)) {\n            let active_shares = get_delegator_active_shares(pool, voter);\n            let inactive_shares = get_delegator_pending_inactive_shares(pool, voter);\n            return smart_table::borrow_mut_with_default(delegated_votes_per_voter, voter, DelegatedVotes {\n                active_shares,\n                pending_inactive_shares: inactive_shares,\n                active_shares_next_lockup: active_shares,\n                last_locked_until_secs: locked_until_secs,\n            })\n        };\n\n        let delegated_votes = smart_table::borrow_mut(delegated_votes_per_voter, voter);\n        // A lockup period has passed since last time `delegated_votes` was updated. Pending voter takes effect.\n        if (delegated_votes.last_locked_until_secs < locked_until_secs) {\n            delegated_votes.active_shares = delegated_votes.active_shares_next_lockup;\n            delegated_votes.pending_inactive_shares = 0;\n            delegated_votes.last_locked_until_secs = locked_until_secs;\n        };\n        delegated_votes\n    }\n\n    fun olc_with_index(index: u64): ObservedLockupCycle {\n        ObservedLockupCycle { index }\n    }\n\n    /// Given the amounts of shares in `active_shares` pool and `inactive_shares` pool, calculate the total voting\n    /// power, which equals to the sum of the coin amounts.\n    fun calculate_total_voting_power(delegation_pool: &DelegationPool, latest_delegated_votes: &DelegatedVotes): u64 {\n        let active_amount = pool_u64::shares_to_amount(\n            &delegation_pool.active_shares,\n            latest_delegated_votes.active_shares);\n        let pending_inactive_amount = pool_u64::shares_to_amount(\n            pending_inactive_shares_pool(delegation_pool),\n            latest_delegated_votes.pending_inactive_shares);\n        active_amount + pending_inactive_amount\n    }\n\n    /// Update VoteDelegation of a delegator to up-to-date then return the latest voter.\n    fun calculate_and_update_delegator_voter_internal(\n        pool: &DelegationPool,\n        governance_records: &mut GovernanceRecords,\n        delegator: address\n    ): address {\n        let vote_delegation = update_and_borrow_mut_delegator_vote_delegation(pool, governance_records, delegator);\n        vote_delegation.voter\n    }\n\n    /// Update DelegatedVotes of a voter to up-to-date then return the total voting power of this voter.\n    fun calculate_and_update_delegated_votes(\n        pool: &DelegationPool,\n        governance_records: &mut GovernanceRecords,\n        voter: address\n    ): u64 {\n        let delegated_votes = update_and_borrow_mut_delegated_votes(pool, governance_records, voter);\n        calculate_total_voting_power(pool, delegated_votes)\n    }\n\n    inline fun borrow_mut_delegators_allowlist(\n        pool_address: address\n    ): &mut SmartTable<address, bool> acquires DelegationPoolAllowlisting {\n        &mut borrow_global_mut<DelegationPoolAllowlisting>(pool_address).allowlist\n    }\n\n    /// Allows an owner to change the operator of the underlying stake pool.\n    public entry fun set_operator(\n        owner: &signer,\n        new_operator: address\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        let pool_address = get_owned_pool_address(signer::address_of(owner));\n        // synchronize delegation and stake pools before any user operation\n        // ensure the old operator is paid its uncommitted commission rewards\n        synchronize_delegation_pool(pool_address);\n        stake::set_operator(&retrieve_stake_pool_owner(borrow_global<DelegationPool>(pool_address)), new_operator);\n    }\n\n    /// Allows an operator to change its beneficiary. Any existing unpaid commission rewards will be paid to the new\n    /// beneficiary. To ensure payment to the current beneficiary, one should first call `synchronize_delegation_pool`\n    /// before switching the beneficiary. An operator can set one beneficiary for delegation pools, not a separate\n    /// one for each pool.\n    public entry fun set_beneficiary_for_operator(\n        operator: &signer,\n        new_beneficiary: address\n    ) acquires BeneficiaryForOperator {\n        assert!(features::operator_beneficiary_change_enabled(), std::error::invalid_state(\n            EOPERATOR_BENEFICIARY_CHANGE_NOT_SUPPORTED\n        ));\n        // The beneficiay address of an operator is stored under the operator's address.\n        // So, the operator does not need to be validated with respect to a staking pool.\n        let operator_addr = signer::address_of(operator);\n        let old_beneficiary = beneficiary_for_operator(operator_addr);\n        if (exists<BeneficiaryForOperator>(operator_addr)) {\n            borrow_global_mut<BeneficiaryForOperator>(operator_addr).beneficiary_for_operator = new_beneficiary;\n        } else {\n            move_to(operator, BeneficiaryForOperator { beneficiary_for_operator: new_beneficiary });\n        };\n\n        emit(SetBeneficiaryForOperator {\n            operator: operator_addr,\n            old_beneficiary,\n            new_beneficiary,\n        });\n    }\n\n    /// Allows an owner to update the commission percentage for the operator of the underlying stake pool.\n    public entry fun update_commission_percentage(\n        owner: &signer,\n        new_commission_percentage: u64\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert!(features::commission_change_delegation_pool_enabled(), error::invalid_state(\n            ECOMMISSION_RATE_CHANGE_NOT_SUPPORTED\n        ));\n        assert!(new_commission_percentage <= MAX_FEE, error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE));\n        let owner_address = signer::address_of(owner);\n        let pool_address = get_owned_pool_address(owner_address);\n        assert!(\n            operator_commission_percentage(pool_address) + MAX_COMMISSION_INCREASE >= new_commission_percentage,\n            error::invalid_argument(ETOO_LARGE_COMMISSION_INCREASE)\n        );\n        assert!(\n            stake::get_remaining_lockup_secs(pool_address) >= min_remaining_secs_for_commission_change(),\n            error::invalid_state(ETOO_LATE_COMMISSION_CHANGE)\n        );\n\n        // synchronize delegation and stake pools before any user operation. this ensures:\n        // (1) the operator is paid its uncommitted commission rewards with the old commission percentage, and\n        // (2) any pending commission percentage change is applied before the new commission percentage is set.\n        synchronize_delegation_pool(pool_address);\n\n        if (exists<NextCommissionPercentage>(pool_address)) {\n            let commission_percentage = borrow_global_mut<NextCommissionPercentage>(pool_address);\n            commission_percentage.commission_percentage_next_lockup_cycle = new_commission_percentage;\n            commission_percentage.effective_after_secs = stake::get_lockup_secs(pool_address);\n        } else {\n            let delegation_pool = borrow_global<DelegationPool>(pool_address);\n            let pool_signer = account::create_signer_with_capability(&delegation_pool.stake_pool_signer_cap);\n            move_to(&pool_signer, NextCommissionPercentage {\n                commission_percentage_next_lockup_cycle: new_commission_percentage,\n                effective_after_secs: stake::get_lockup_secs(pool_address),\n            });\n        };\n\n        event::emit(CommissionPercentageChange {\n            pool_address,\n            owner: owner_address,\n            commission_percentage_next_lockup_cycle: new_commission_percentage,\n        });\n    }\n\n    /// Allows an owner to change the delegated voter of the underlying stake pool.\n    public entry fun set_delegated_voter(\n        owner: &signer,\n        new_voter: address\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        // No one can change delegated_voter once the partial governance voting feature is enabled.\n        assert!(\n            !features::delegation_pool_partial_governance_voting_enabled(),\n            error::invalid_state(EDEPRECATED_FUNCTION)\n        );\n        let pool_address = get_owned_pool_address(signer::address_of(owner));\n        // synchronize delegation and stake pools before any user operation\n        synchronize_delegation_pool(pool_address);\n        stake::set_delegated_voter(&retrieve_stake_pool_owner(borrow_global<DelegationPool>(pool_address)), new_voter);\n    }\n\n    /// Allows a delegator to delegate its voting power to a voter. If this delegator already has a delegated voter,\n    /// this change won't take effects until the next lockup period.\n    public entry fun delegate_voting_power(\n        delegator: &signer,\n        pool_address: address,\n        new_voter: address\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert_partial_governance_voting_enabled(pool_address);\n\n        // synchronize delegation and stake pools before any user operation\n        synchronize_delegation_pool(pool_address);\n\n        let delegator_address = signer::address_of(delegator);\n        let delegation_pool = borrow_global<DelegationPool>(pool_address);\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        let delegator_vote_delegation = update_and_borrow_mut_delegator_vote_delegation(\n            delegation_pool,\n            governance_records,\n            delegator_address\n        );\n        let pending_voter: address = delegator_vote_delegation.pending_voter;\n\n        // No need to update if the voter doesn't really change.\n        if (pending_voter != new_voter) {\n            delegator_vote_delegation.pending_voter = new_voter;\n            let active_shares = get_delegator_active_shares(delegation_pool, delegator_address);\n            // <active shares> of <pending voter of shareholder> -= <active_shares>\n            // <active shares> of <new voter of shareholder> += <active_shares>\n            let pending_delegated_votes = update_and_borrow_mut_delegated_votes(\n                delegation_pool,\n                governance_records,\n                pending_voter\n            );\n            pending_delegated_votes.active_shares_next_lockup =\n                pending_delegated_votes.active_shares_next_lockup - active_shares;\n\n            let new_delegated_votes = update_and_borrow_mut_delegated_votes(\n                delegation_pool,\n                governance_records,\n                new_voter\n            );\n            new_delegated_votes.active_shares_next_lockup =\n                new_delegated_votes.active_shares_next_lockup + active_shares;\n        };\n\n        if (features::module_event_migration_enabled()) {\n            event::emit(DelegateVotingPower {\n                pool_address,\n                delegator: delegator_address,\n                voter: new_voter,\n            })\n        };\n\n        event::emit_event(&mut governance_records.delegate_voting_power_events, DelegateVotingPowerEvent {\n            pool_address,\n            delegator: delegator_address,\n            voter: new_voter,\n        });\n    }\n\n    /// Enable delegators allowlisting as the pool owner.\n    public entry fun enable_delegators_allowlisting(\n        owner: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool {\n        assert!(\n            features::delegation_pool_allowlisting_enabled(),\n            error::invalid_state(EDELEGATORS_ALLOWLISTING_NOT_SUPPORTED)\n        );\n\n        let pool_address = get_owned_pool_address(signer::address_of(owner));\n        if (allowlisting_enabled(pool_address)) { return };\n\n        let pool_signer = retrieve_stake_pool_owner(borrow_global<DelegationPool>(pool_address));\n        move_to(&pool_signer, DelegationPoolAllowlisting { allowlist: smart_table::new<address, bool>() });\n\n        event::emit(EnableDelegatorsAllowlisting { pool_address });\n    }\n\n    /// Disable delegators allowlisting as the pool owner. The existing allowlist will be emptied.\n    public entry fun disable_delegators_allowlisting(\n        owner: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPoolAllowlisting {\n        let pool_address = get_owned_pool_address(signer::address_of(owner));\n        assert_allowlisting_enabled(pool_address);\n\n        let DelegationPoolAllowlisting { allowlist } = move_from<DelegationPoolAllowlisting>(pool_address);\n        // if the allowlist becomes too large, the owner can always remove some delegators\n        smart_table::destroy(allowlist);\n\n        event::emit(DisableDelegatorsAllowlisting { pool_address });\n    }\n\n    /// Allowlist a delegator as the pool owner.\n    public entry fun allowlist_delegator(\n        owner: &signer,\n        delegator_address: address,\n    ) acquires DelegationPoolOwnership, DelegationPoolAllowlisting {\n        let pool_address = get_owned_pool_address(signer::address_of(owner));\n        assert_allowlisting_enabled(pool_address);\n\n        if (delegator_allowlisted(pool_address, delegator_address)) { return };\n\n        smart_table::add(borrow_mut_delegators_allowlist(pool_address), delegator_address, true);\n\n        event::emit(AllowlistDelegator { pool_address, delegator_address });\n    }\n\n    /// Remove a delegator from the allowlist as the pool owner, but do not unlock their stake.\n    public entry fun remove_delegator_from_allowlist(\n        owner: &signer,\n        delegator_address: address,\n    ) acquires DelegationPoolOwnership, DelegationPoolAllowlisting {\n        let pool_address = get_owned_pool_address(signer::address_of(owner));\n        assert_allowlisting_enabled(pool_address);\n\n        if (!delegator_allowlisted(pool_address, delegator_address)) { return };\n\n        smart_table::remove(borrow_mut_delegators_allowlist(pool_address), delegator_address);\n\n        event::emit(RemoveDelegatorFromAllowlist { pool_address, delegator_address });\n    }\n\n    /// Evict a delegator that is not allowlisted by unlocking their entire stake.\n    public entry fun evict_delegator(\n        owner: &signer,\n        delegator_address: address,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        let pool_address = get_owned_pool_address(signer::address_of(owner));\n        assert_allowlisting_enabled(pool_address);\n        assert!(\n            !delegator_allowlisted(pool_address, delegator_address),\n            error::invalid_state(ECANNOT_EVICT_ALLOWLISTED_DELEGATOR)\n        );\n\n        // synchronize pool in order to query latest balance of delegator\n        synchronize_delegation_pool(pool_address);\n\n        let pool = borrow_global<DelegationPool>(pool_address);\n        if (get_delegator_active_shares(pool, delegator_address) == 0) { return };\n\n        unlock_internal(delegator_address, pool_address, pool_u64::balance(&pool.active_shares, delegator_address));\n\n        event::emit(EvictDelegator { pool_address, delegator_address });\n    }\n\n    /// Add `amount` of coins to the delegation pool `pool_address`.\n    public entry fun add_stake(\n        delegator: &signer,\n        pool_address: address,\n        amount: u64\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        // short-circuit if amount to add is 0 so no event is emitted\n        if (amount == 0) { return };\n\n        let delegator_address = signer::address_of(delegator);\n        assert_delegator_allowlisted(pool_address, delegator_address);\n\n        // synchronize delegation and stake pools before any user operation\n        synchronize_delegation_pool(pool_address);\n\n        // fee to be charged for adding `amount` stake on this delegation pool at this epoch\n        let add_stake_fee = get_add_stake_fee(pool_address, amount);\n\n        let pool = borrow_global_mut<DelegationPool>(pool_address);\n\n        // stake the entire amount to the stake pool\n        aptos_account::transfer(delegator, pool_address, amount);\n        stake::add_stake(&retrieve_stake_pool_owner(pool), amount);\n\n        // but buy shares for delegator just for the remaining amount after fee\n        buy_in_active_shares(pool, delegator_address, amount - add_stake_fee);\n        assert_min_active_balance(pool, delegator_address);\n\n        // grant temporary ownership over `add_stake` fees to a separate shareholder in order to:\n        // - not mistake them for rewards to pay the operator from\n        // - distribute them together with the `active` rewards when this epoch ends\n        // in order to appreciate all shares on the active pool atomically\n        buy_in_active_shares(pool, NULL_SHAREHOLDER, add_stake_fee);\n\n        if (features::module_event_migration_enabled()) {\n            event::emit(\n                AddStake {\n                    pool_address,\n                    delegator_address,\n                    amount_added: amount,\n                    add_stake_fee,\n                },\n            );\n        };\n\n        event::emit_event(\n            &mut pool.add_stake_events,\n            AddStakeEvent {\n                pool_address,\n                delegator_address,\n                amount_added: amount,\n                add_stake_fee,\n            },\n        );\n    }\n\n    /// Unlock `amount` from the active + pending_active stake of `delegator` or\n    /// at most how much active stake there is on the stake pool.\n    public entry fun unlock(\n        delegator: &signer,\n        pool_address: address,\n        amount: u64\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        // short-circuit if amount to unlock is 0 so no event is emitted\n        if (amount == 0) { return };\n\n        // synchronize delegation and stake pools before any user operation\n        synchronize_delegation_pool(pool_address);\n\n        let delegator_address = signer::address_of(delegator);\n        unlock_internal(delegator_address, pool_address, amount);\n    }\n\n    fun unlock_internal(\n        delegator_address: address,\n        pool_address: address,\n        amount: u64\n    ) acquires DelegationPool, GovernanceRecords {\n        assert!(delegator_address != NULL_SHAREHOLDER, error::invalid_argument(ECANNOT_UNLOCK_NULL_SHAREHOLDER));\n\n        // fail unlock of more stake than `active` on the stake pool\n        let (active, _, _, _) = stake::get_stake(pool_address);\n        assert!(amount <= active, error::invalid_argument(ENOT_ENOUGH_ACTIVE_STAKE_TO_UNLOCK));\n\n        let pool = borrow_global_mut<DelegationPool>(pool_address);\n        amount = coins_to_transfer_to_ensure_min_stake(\n            &pool.active_shares,\n            pending_inactive_shares_pool(pool),\n            delegator_address,\n            amount,\n        );\n        amount = redeem_active_shares(pool, delegator_address, amount);\n\n        stake::unlock(&retrieve_stake_pool_owner(pool), amount);\n\n        buy_in_pending_inactive_shares(pool, delegator_address, amount);\n        assert_min_pending_inactive_balance(pool, delegator_address);\n\n        if (features::module_event_migration_enabled()) {\n            event::emit(\n                UnlockStake {\n                    pool_address,\n                    delegator_address,\n                    amount_unlocked: amount,\n                },\n            );\n        };\n\n        event::emit_event(\n            &mut pool.unlock_stake_events,\n            UnlockStakeEvent {\n                pool_address,\n                delegator_address,\n                amount_unlocked: amount,\n            },\n        );\n    }\n\n    /// Move `amount` of coins from pending_inactive to active.\n    public entry fun reactivate_stake(\n        delegator: &signer,\n        pool_address: address,\n        amount: u64\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        // short-circuit if amount to reactivate is 0 so no event is emitted\n        if (amount == 0) { return };\n\n        let delegator_address = signer::address_of(delegator);\n        assert_delegator_allowlisted(pool_address, delegator_address);\n\n        // synchronize delegation and stake pools before any user operation\n        synchronize_delegation_pool(pool_address);\n\n        let pool = borrow_global_mut<DelegationPool>(pool_address);\n        amount = coins_to_transfer_to_ensure_min_stake(\n            pending_inactive_shares_pool(pool),\n            &pool.active_shares,\n            delegator_address,\n            amount,\n        );\n        let observed_lockup_cycle = pool.observed_lockup_cycle;\n        amount = redeem_inactive_shares(pool, delegator_address, amount, observed_lockup_cycle);\n\n        stake::reactivate_stake(&retrieve_stake_pool_owner(pool), amount);\n\n        buy_in_active_shares(pool, delegator_address, amount);\n        assert_min_active_balance(pool, delegator_address);\n\n        if (features::module_event_migration_enabled()) {\n            event::emit(\n                ReactivateStake {\n                    pool_address,\n                    delegator_address,\n                    amount_reactivated: amount,\n                },\n            );\n        };\n\n        event::emit_event(\n            &mut pool.reactivate_stake_events,\n            ReactivateStakeEvent {\n                pool_address,\n                delegator_address,\n                amount_reactivated: amount,\n            },\n        );\n    }\n\n    /// Withdraw `amount` of owned inactive stake from the delegation pool at `pool_address`.\n    public entry fun withdraw(\n        delegator: &signer,\n        pool_address: address,\n        amount: u64\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert!(amount > 0, error::invalid_argument(EWITHDRAW_ZERO_STAKE));\n        // synchronize delegation and stake pools before any user operation\n        synchronize_delegation_pool(pool_address);\n        withdraw_internal(borrow_global_mut<DelegationPool>(pool_address), signer::address_of(delegator), amount);\n    }\n\n    fun withdraw_internal(\n        pool: &mut DelegationPool,\n        delegator_address: address,\n        amount: u64\n    ) acquires GovernanceRecords {\n        // TODO: recycle storage when a delegator fully exits the delegation pool.\n        // short-circuit if amount to withdraw is 0 so no event is emitted\n        if (amount == 0) { return };\n\n        let pool_address = get_pool_address(pool);\n        let (withdrawal_exists, withdrawal_olc) = pending_withdrawal_exists(pool, delegator_address);\n        // exit if no withdrawal or (it is pending and cannot withdraw pending_inactive stake from stake pool)\n        if (!(\n            withdrawal_exists &&\n                (withdrawal_olc.index < pool.observed_lockup_cycle.index || can_withdraw_pending_inactive(pool_address))\n        )) { return };\n\n        if (withdrawal_olc.index == pool.observed_lockup_cycle.index) {\n            amount = coins_to_redeem_to_ensure_min_stake(\n                pending_inactive_shares_pool(pool),\n                delegator_address,\n                amount,\n            )\n        };\n        amount = redeem_inactive_shares(pool, delegator_address, amount, withdrawal_olc);\n\n        let stake_pool_owner = &retrieve_stake_pool_owner(pool);\n        // stake pool will inactivate entire pending_inactive stake at `stake::withdraw` to make it withdrawable\n        // however, bypassing the inactivation of excess stake (inactivated but not withdrawn) ensures\n        // the OLC is not advanced indefinitely on `unlock`-`withdraw` paired calls\n        if (can_withdraw_pending_inactive(pool_address)) {\n            // get excess stake before being entirely inactivated\n            let (_, _, _, pending_inactive) = stake::get_stake(pool_address);\n            if (withdrawal_olc.index == pool.observed_lockup_cycle.index) {\n                // `amount` less excess if withdrawing pending_inactive stake\n                pending_inactive = pending_inactive - amount\n            };\n            // escape excess stake from inactivation\n            stake::reactivate_stake(stake_pool_owner, pending_inactive);\n            stake::withdraw(stake_pool_owner, amount);\n            // restore excess stake to the pending_inactive state\n            stake::unlock(stake_pool_owner, pending_inactive);\n        } else {\n            // no excess stake if `stake::withdraw` does not inactivate at all\n            stake::withdraw(stake_pool_owner, amount);\n        };\n        aptos_account::transfer(stake_pool_owner, delegator_address, amount);\n\n        // commit withdrawal of possibly inactive stake to the `total_coins_inactive`\n        // known by the delegation pool in order to not mistake it for slashing at next synchronization\n        let (_, inactive, _, _) = stake::get_stake(pool_address);\n        pool.total_coins_inactive = inactive;\n\n        if (features::module_event_migration_enabled()) {\n            event::emit(\n                WithdrawStake {\n                    pool_address,\n                    delegator_address,\n                    amount_withdrawn: amount,\n                },\n            );\n        };\n\n        event::emit_event(\n            &mut pool.withdraw_stake_events,\n            WithdrawStakeEvent {\n                pool_address,\n                delegator_address,\n                amount_withdrawn: amount,\n            },\n        );\n    }\n\n    /// Return the unique observed lockup cycle where delegator `delegator_address` may have\n    /// unlocking (or already unlocked) stake to be withdrawn from delegation pool `pool`.\n    /// A bool is returned to signal if a pending withdrawal exists at all.\n    fun pending_withdrawal_exists(pool: &DelegationPool, delegator_address: address): (bool, ObservedLockupCycle) {\n        if (table::contains(&pool.pending_withdrawals, delegator_address)) {\n            (true, *table::borrow(&pool.pending_withdrawals, delegator_address))\n        } else {\n            (false, olc_with_index(0))\n        }\n    }\n\n    /// Return a mutable reference to the shares pool of `pending_inactive` stake on the\n    /// delegation pool, always the last item in `inactive_shares`.\n    fun pending_inactive_shares_pool_mut(pool: &mut DelegationPool): &mut pool_u64::Pool {\n        let observed_lockup_cycle = pool.observed_lockup_cycle;\n        table::borrow_mut(&mut pool.inactive_shares, observed_lockup_cycle)\n    }\n\n    fun pending_inactive_shares_pool(pool: &DelegationPool): &pool_u64::Pool {\n        table::borrow(&pool.inactive_shares, pool.observed_lockup_cycle)\n    }\n\n    /// Execute the pending withdrawal of `delegator_address` on delegation pool `pool`\n    /// if existing and already inactive to allow the creation of a new one.\n    /// `pending_inactive` stake would be left untouched even if withdrawable and should\n    /// be explicitly withdrawn by delegator\n    fun execute_pending_withdrawal(pool: &mut DelegationPool, delegator_address: address) acquires GovernanceRecords {\n        let (withdrawal_exists, withdrawal_olc) = pending_withdrawal_exists(pool, delegator_address);\n        if (withdrawal_exists && withdrawal_olc.index < pool.observed_lockup_cycle.index) {\n            withdraw_internal(pool, delegator_address, MAX_U64);\n        }\n    }\n\n    /// Buy shares into the active pool on behalf of delegator `shareholder` who\n    /// deposited `coins_amount`. This function doesn't make any coin transfer.\n    fun buy_in_active_shares(\n        pool: &mut DelegationPool,\n        shareholder: address,\n        coins_amount: u64,\n    ): u128 acquires GovernanceRecords {\n        let new_shares = pool_u64::amount_to_shares(&pool.active_shares, coins_amount);\n        // No need to buy 0 shares.\n        if (new_shares == 0) { return 0 };\n\n        // Always update governance records before any change to the shares pool.\n        let pool_address = get_pool_address(pool);\n        if (partial_governance_voting_enabled(pool_address)) {\n            update_governance_records_for_buy_in_active_shares(pool, pool_address, new_shares, shareholder);\n        };\n\n        pool_u64::buy_in(&mut pool.active_shares, shareholder, coins_amount);\n        new_shares\n    }\n\n    /// Buy shares into the pending_inactive pool on behalf of delegator `shareholder` who\n    /// redeemed `coins_amount` from the active pool to schedule it for unlocking.\n    /// If delegator's pending withdrawal exists and has been inactivated, execute it firstly\n    /// to ensure there is always only one withdrawal request.\n    fun buy_in_pending_inactive_shares(\n        pool: &mut DelegationPool,\n        shareholder: address,\n        coins_amount: u64,\n    ): u128 acquires GovernanceRecords {\n        let new_shares = pool_u64::amount_to_shares(pending_inactive_shares_pool(pool), coins_amount);\n        // never create a new pending withdrawal unless delegator owns some pending_inactive shares\n        if (new_shares == 0) { return 0 };\n\n        // Always update governance records before any change to the shares pool.\n        let pool_address = get_pool_address(pool);\n        if (partial_governance_voting_enabled(pool_address)) {\n            update_governance_records_for_buy_in_pending_inactive_shares(pool, pool_address, new_shares, shareholder);\n        };\n\n        // cannot buy inactive shares, only pending_inactive at current lockup cycle\n        pool_u64::buy_in(pending_inactive_shares_pool_mut(pool), shareholder, coins_amount);\n\n        // execute the pending withdrawal if exists and is inactive before creating a new one\n        execute_pending_withdrawal(pool, shareholder);\n\n        // save observed lockup cycle for the new pending withdrawal\n        let observed_lockup_cycle = pool.observed_lockup_cycle;\n        assert!(*table::borrow_mut_with_default(\n            &mut pool.pending_withdrawals,\n            shareholder,\n            observed_lockup_cycle\n        ) == observed_lockup_cycle,\n            error::invalid_state(EPENDING_WITHDRAWAL_EXISTS)\n        );\n\n        new_shares\n    }\n\n    /// Convert `coins_amount` of coins to be redeemed from shares pool `shares_pool`\n    /// to the exact number of shares to redeem in order to achieve this.\n    fun amount_to_shares_to_redeem(\n        shares_pool: &pool_u64::Pool,\n        shareholder: address,\n        coins_amount: u64,\n    ): u128 {\n        if (coins_amount >= pool_u64::balance(shares_pool, shareholder)) {\n            // cap result at total shares of shareholder to pass `EINSUFFICIENT_SHARES` on subsequent redeem\n            pool_u64::shares(shares_pool, shareholder)\n        } else {\n            pool_u64::amount_to_shares(shares_pool, coins_amount)\n        }\n    }\n\n    /// Redeem shares from the active pool on behalf of delegator `shareholder` who\n    /// wants to unlock `coins_amount` of its active stake.\n    /// Extracted coins will be used to buy shares into the pending_inactive pool and\n    /// be available for withdrawal when current OLC ends.\n    fun redeem_active_shares(\n        pool: &mut DelegationPool,\n        shareholder: address,\n        coins_amount: u64,\n    ): u64 acquires GovernanceRecords {\n        let shares_to_redeem = amount_to_shares_to_redeem(&pool.active_shares, shareholder, coins_amount);\n        // silently exit if not a shareholder otherwise redeem would fail with `ESHAREHOLDER_NOT_FOUND`\n        if (shares_to_redeem == 0) return 0;\n\n        // Always update governance records before any change to the shares pool.\n        let pool_address = get_pool_address(pool);\n        if (partial_governance_voting_enabled(pool_address)) {\n            update_governanace_records_for_redeem_active_shares(pool, pool_address, shares_to_redeem, shareholder);\n        };\n\n        pool_u64::redeem_shares(&mut pool.active_shares, shareholder, shares_to_redeem)\n    }\n\n    /// Redeem shares from the inactive pool at `lockup_cycle` < current OLC on behalf of\n    /// delegator `shareholder` who wants to withdraw `coins_amount` of its unlocked stake.\n    /// Redeem shares from the pending_inactive pool at `lockup_cycle` == current OLC on behalf of\n    /// delegator `shareholder` who wants to reactivate `coins_amount` of its unlocking stake.\n    /// For latter case, extracted coins will be used to buy shares into the active pool and\n    /// escape inactivation when current lockup ends.\n    fun redeem_inactive_shares(\n        pool: &mut DelegationPool,\n        shareholder: address,\n        coins_amount: u64,\n        lockup_cycle: ObservedLockupCycle,\n    ): u64 acquires GovernanceRecords {\n        let shares_to_redeem = amount_to_shares_to_redeem(\n            table::borrow(&pool.inactive_shares, lockup_cycle),\n            shareholder,\n            coins_amount);\n        // silently exit if not a shareholder otherwise redeem would fail with `ESHAREHOLDER_NOT_FOUND`\n        if (shares_to_redeem == 0) return 0;\n\n        // Always update governance records before any change to the shares pool.\n        let pool_address = get_pool_address(pool);\n        // Only redeem shares from the pending_inactive pool at `lockup_cycle` == current OLC.\n        if (partial_governance_voting_enabled(pool_address) && lockup_cycle.index == pool.observed_lockup_cycle.index) {\n            update_governanace_records_for_redeem_pending_inactive_shares(\n                pool,\n                pool_address,\n                shares_to_redeem,\n                shareholder\n            );\n        };\n\n        let inactive_shares = table::borrow_mut(&mut pool.inactive_shares, lockup_cycle);\n        // 1. reaching here means delegator owns inactive/pending_inactive shares at OLC `lockup_cycle`\n        let redeemed_coins = pool_u64::redeem_shares(inactive_shares, shareholder, shares_to_redeem);\n\n        // if entirely reactivated pending_inactive stake or withdrawn inactive one,\n        // re-enable unlocking for delegator by deleting this pending withdrawal\n        if (pool_u64::shares(inactive_shares, shareholder) == 0) {\n            // 2. a delegator owns inactive/pending_inactive shares only at the OLC of its pending withdrawal\n            // 1 & 2: the pending withdrawal itself has been emptied of shares and can be safely deleted\n            table::remove(&mut pool.pending_withdrawals, shareholder);\n        };\n        // destroy inactive shares pool of past OLC if all its stake has been withdrawn\n        if (lockup_cycle.index < pool.observed_lockup_cycle.index && total_coins(inactive_shares) == 0) {\n            pool_u64::destroy_empty(table::remove(&mut pool.inactive_shares, lockup_cycle));\n        };\n\n        redeemed_coins\n    }\n\n    /// Calculate stake deviations between the delegation and stake pools in order to\n    /// capture the rewards earned in the meantime, resulted operator commission and\n    /// whether the lockup expired on the stake pool.\n    fun calculate_stake_pool_drift(pool: &DelegationPool): (bool, u64, u64, u64, u64) {\n        let (active, inactive, pending_active, pending_inactive) = stake::get_stake(get_pool_address(pool));\n        assert!(\n            inactive >= pool.total_coins_inactive,\n            error::invalid_state(ESLASHED_INACTIVE_STAKE_ON_PAST_OLC)\n        );\n        // determine whether a new lockup cycle has been ended on the stake pool and\n        // inactivated SOME `pending_inactive` stake which should stop earning rewards now,\n        // thus requiring separation of the `pending_inactive` stake on current observed lockup\n        // and the future one on the newly started lockup\n        let lockup_cycle_ended = inactive > pool.total_coins_inactive;\n\n        // actual coins on stake pool belonging to the active shares pool\n        active = active + pending_active;\n        // actual coins on stake pool belonging to the shares pool hosting `pending_inactive` stake\n        // at current observed lockup cycle, either pending: `pending_inactive` or already inactivated:\n        if (lockup_cycle_ended) {\n            // `inactive` on stake pool = any previous `inactive` stake +\n            // any previous `pending_inactive` stake and its rewards (both inactivated)\n            pending_inactive = inactive - pool.total_coins_inactive\n        };\n\n        // on stake-management operations, total coins on the internal shares pools and individual\n        // stakes on the stake pool are updated simultaneously, thus the only stakes becoming\n        // unsynced are rewards and slashes routed exclusively to/out the stake pool\n\n        // operator `active` rewards not persisted yet to the active shares pool\n        let pool_active = total_coins(&pool.active_shares);\n        let commission_active = if (active > pool_active) {\n            math64::mul_div(active - pool_active, pool.operator_commission_percentage, MAX_FEE)\n        } else {\n            // handle any slashing applied to `active` stake\n            0\n        };\n        // operator `pending_inactive` rewards not persisted yet to the pending_inactive shares pool\n        let pool_pending_inactive = total_coins(pending_inactive_shares_pool(pool));\n        let commission_pending_inactive = if (pending_inactive > pool_pending_inactive) {\n            math64::mul_div(\n                pending_inactive - pool_pending_inactive,\n                pool.operator_commission_percentage,\n                MAX_FEE\n            )\n        } else {\n            // handle any slashing applied to `pending_inactive` stake\n            0\n        };\n\n        (lockup_cycle_ended, active, pending_inactive, commission_active, commission_pending_inactive)\n    }\n\n    /// Synchronize delegation and stake pools: distribute yet-undetected rewards to the corresponding internal\n    /// shares pools, assign commission to operator and eventually prepare delegation pool for a new lockup cycle.\n    public entry fun synchronize_delegation_pool(\n        pool_address: address\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        assert_delegation_pool_exists(pool_address);\n        let pool = borrow_global_mut<DelegationPool>(pool_address);\n        let (\n            lockup_cycle_ended,\n            active,\n            pending_inactive,\n            commission_active,\n            commission_pending_inactive\n        ) = calculate_stake_pool_drift(pool);\n\n        // zero `pending_active` stake indicates that either there are no `add_stake` fees or\n        // previous epoch has ended and should release the shares owning the existing fees\n        let (_, _, pending_active, _) = stake::get_stake(pool_address);\n        if (pending_active == 0) {\n            // renounce ownership over the `add_stake` fees by redeeming all shares of\n            // the special shareholder, implicitly their equivalent coins, out of the active shares pool\n            redeem_active_shares(pool, NULL_SHAREHOLDER, MAX_U64);\n        };\n\n        // distribute rewards remaining after commission, to delegators (to already existing shares)\n        // before buying shares for the operator for its entire commission fee\n        // otherwise, operator's new shares would additionally appreciate from rewards it does not own\n\n        // update total coins accumulated by `active` + `pending_active` shares\n        // redeemed `add_stake` fees are restored and distributed to the rest of the pool as rewards\n        pool_u64::update_total_coins(&mut pool.active_shares, active - commission_active);\n        // update total coins accumulated by `pending_inactive` shares at current observed lockup cycle\n        pool_u64::update_total_coins(\n            pending_inactive_shares_pool_mut(pool),\n            pending_inactive - commission_pending_inactive\n        );\n\n        // reward operator its commission out of uncommitted active rewards (`add_stake` fees already excluded)\n        buy_in_active_shares(pool, beneficiary_for_operator(stake::get_operator(pool_address)), commission_active);\n        // reward operator its commission out of uncommitted pending_inactive rewards\n        buy_in_pending_inactive_shares(\n            pool,\n            beneficiary_for_operator(stake::get_operator(pool_address)),\n            commission_pending_inactive\n        );\n\n        event::emit_event(\n            &mut pool.distribute_commission_events,\n            DistributeCommissionEvent {\n                pool_address,\n                operator: stake::get_operator(pool_address),\n                commission_active,\n                commission_pending_inactive,\n            },\n        );\n\n        if (features::operator_beneficiary_change_enabled()) {\n            emit(DistributeCommission {\n                pool_address,\n                operator: stake::get_operator(pool_address),\n                beneficiary: beneficiary_for_operator(stake::get_operator(pool_address)),\n                commission_active,\n                commission_pending_inactive,\n            })\n        };\n\n        // advance lockup cycle on delegation pool if already ended on stake pool (AND stake explicitly inactivated)\n        if (lockup_cycle_ended) {\n            // capture inactive coins over all ended lockup cycles (including this ending one)\n            let (_, inactive, _, _) = stake::get_stake(pool_address);\n            pool.total_coins_inactive = inactive;\n\n            // advance lockup cycle on the delegation pool\n            pool.observed_lockup_cycle.index = pool.observed_lockup_cycle.index + 1;\n            // start new lockup cycle with a fresh shares pool for `pending_inactive` stake\n            table::add(\n                &mut pool.inactive_shares,\n                pool.observed_lockup_cycle,\n                pool_u64::create_with_scaling_factor(SHARES_SCALING_FACTOR)\n            );\n        };\n\n        if (is_next_commission_percentage_effective(pool_address)) {\n            pool.operator_commission_percentage = borrow_global<NextCommissionPercentage>(\n                pool_address\n            ).commission_percentage_next_lockup_cycle;\n        }\n    }\n\n    inline fun assert_and_update_proposal_used_voting_power(\n        governance_records: &mut GovernanceRecords, pool_address: address, proposal_id: u64, voting_power: u64\n    ) {\n        let stake_pool_remaining_voting_power = aptos_governance::get_remaining_voting_power(pool_address, proposal_id);\n        let stake_pool_used_voting_power = aptos_governance::get_voting_power(\n            pool_address\n        ) - stake_pool_remaining_voting_power;\n        let proposal_used_voting_power = smart_table::borrow_mut_with_default(\n            &mut governance_records.votes_per_proposal,\n            proposal_id,\n            0\n        );\n        // A edge case: Before enabling partial governance voting on a delegation pool, the delegation pool has\n        // a voter which can vote with all voting power of this delegation pool. If the voter votes on a proposal after\n        // partial governance voting flag is enabled, the delegation pool doesn't have enough voting power on this\n        // proposal for all the delegators. To be fair, no one can vote on this proposal through this delegation pool.\n        // To detect this case, check if the stake pool had used voting power not through delegation_pool module.\n        assert!(\n            stake_pool_used_voting_power == *proposal_used_voting_power,\n            error::invalid_argument(EALREADY_VOTED_BEFORE_ENABLE_PARTIAL_VOTING)\n        );\n        *proposal_used_voting_power = *proposal_used_voting_power + voting_power;\n    }\n\n    fun update_governance_records_for_buy_in_active_shares(\n        pool: &DelegationPool, pool_address: address, new_shares: u128, shareholder: address\n    ) acquires GovernanceRecords {\n        // <active shares> of <shareholder> += <new_shares> ---->\n        // <active shares> of <current voter of shareholder> += <new_shares>\n        // <active shares> of <next voter of shareholder> += <new_shares>\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        let vote_delegation = update_and_borrow_mut_delegator_vote_delegation(pool, governance_records, shareholder);\n        let current_voter = vote_delegation.voter;\n        let pending_voter = vote_delegation.pending_voter;\n        let current_delegated_votes =\n            update_and_borrow_mut_delegated_votes(pool, governance_records, current_voter);\n        current_delegated_votes.active_shares = current_delegated_votes.active_shares + new_shares;\n        if (pending_voter == current_voter) {\n            current_delegated_votes.active_shares_next_lockup =\n                current_delegated_votes.active_shares_next_lockup + new_shares;\n        } else {\n            let pending_delegated_votes =\n                update_and_borrow_mut_delegated_votes(pool, governance_records, pending_voter);\n            pending_delegated_votes.active_shares_next_lockup =\n                pending_delegated_votes.active_shares_next_lockup + new_shares;\n        };\n    }\n\n    fun update_governance_records_for_buy_in_pending_inactive_shares(\n        pool: &DelegationPool, pool_address: address, new_shares: u128, shareholder: address\n    ) acquires GovernanceRecords {\n        // <pending inactive shares> of <shareholder> += <new_shares>   ---->\n        // <pending inactive shares> of <current voter of shareholder> += <new_shares>\n        // no impact on <pending inactive shares> of <next voter of shareholder>\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        let current_voter = calculate_and_update_delegator_voter_internal(pool, governance_records, shareholder);\n        let current_delegated_votes = update_and_borrow_mut_delegated_votes(pool, governance_records, current_voter);\n        current_delegated_votes.pending_inactive_shares = current_delegated_votes.pending_inactive_shares + new_shares;\n    }\n\n    fun update_governanace_records_for_redeem_active_shares(\n        pool: &DelegationPool, pool_address: address, shares_to_redeem: u128, shareholder: address\n    ) acquires GovernanceRecords {\n        // <active shares> of <shareholder> -= <shares_to_redeem> ---->\n        // <active shares> of <current voter of shareholder> -= <shares_to_redeem>\n        // <active shares> of <next voter of shareholder> -= <shares_to_redeem>\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        let vote_delegation = update_and_borrow_mut_delegator_vote_delegation(\n            pool,\n            governance_records,\n            shareholder\n        );\n        let current_voter = vote_delegation.voter;\n        let pending_voter = vote_delegation.pending_voter;\n        let current_delegated_votes = update_and_borrow_mut_delegated_votes(pool, governance_records, current_voter);\n        current_delegated_votes.active_shares = current_delegated_votes.active_shares - shares_to_redeem;\n        if (current_voter == pending_voter) {\n            current_delegated_votes.active_shares_next_lockup =\n                current_delegated_votes.active_shares_next_lockup - shares_to_redeem;\n        } else {\n            let pending_delegated_votes =\n                update_and_borrow_mut_delegated_votes(pool, governance_records, pending_voter);\n            pending_delegated_votes.active_shares_next_lockup =\n                pending_delegated_votes.active_shares_next_lockup - shares_to_redeem;\n        };\n    }\n\n    fun update_governanace_records_for_redeem_pending_inactive_shares(\n        pool: &DelegationPool, pool_address: address, shares_to_redeem: u128, shareholder: address\n    ) acquires GovernanceRecords {\n        // <pending inactive shares> of <shareholder> -= <shares_to_redeem>  ---->\n        // <pending inactive shares> of <current voter of shareholder> -= <shares_to_redeem>\n        // no impact on <pending inactive shares> of <next voter of shareholder>\n        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);\n        let current_voter = calculate_and_update_delegator_voter_internal(pool, governance_records, shareholder);\n        let current_delegated_votes = update_and_borrow_mut_delegated_votes(pool, governance_records, current_voter);\n        current_delegated_votes.pending_inactive_shares = current_delegated_votes.pending_inactive_shares - shares_to_redeem;\n    }\n\n    #[deprecated]\n    /// Deprecated, prefer math64::mul_div\n    public fun multiply_then_divide(x: u64, y: u64, z: u64): u64 {\n        math64::mul_div(x, y, z)\n    }\n\n    #[test_only]\n    use aptos_framework::reconfiguration;\n    #[test_only]\n    use aptos_std::fixed_point64;\n    #[test_only]\n    use aptos_framework::stake::fast_forward_to_unlock;\n    #[test_only]\n    use aptos_framework::timestamp::fast_forward_seconds;\n\n    #[test_only]\n    const CONSENSUS_KEY_1: vector<u8> = x\"8a54b92288d4ba5073d3a52e80cc00ae9fbbc1cc5b433b46089b7804c38a76f00fc64746c7685ee628fc2d0b929c2294\";\n    #[test_only]\n    const CONSENSUS_POP_1: vector<u8> = x\"a9d6c1f1270f2d1454c89a83a4099f813a56dc7db55591d46aa4e6ccae7898b234029ba7052f18755e6fa5e6b73e235f14efc4e2eb402ca2b8f56bad69f965fc11b7b25eb1c95a06f83ddfd023eac4559b6582696cfea97b227f4ce5bdfdfed0\";\n\n    #[test_only]\n    const EPOCH_DURATION: u64 = 60;\n    #[test_only]\n    const LOCKUP_CYCLE_SECONDS: u64 = 2592000;\n\n    #[test_only]\n    const ONE_APT: u64 = 100000000;\n\n    #[test_only]\n    const VALIDATOR_STATUS_PENDING_ACTIVE: u64 = 1;\n    #[test_only]\n    const VALIDATOR_STATUS_ACTIVE: u64 = 2;\n    #[test_only]\n    const VALIDATOR_STATUS_PENDING_INACTIVE: u64 = 3;\n\n    #[test_only]\n    const DELEGATION_POOLS: u64 = 11;\n\n    #[test_only]\n    const MODULE_EVENT: u64 = 26;\n\n    #[test_only]\n    const OPERATOR_BENEFICIARY_CHANGE: u64 = 39;\n\n    #[test_only]\n    const COMMISSION_CHANGE_DELEGATION_POOL: u64 = 42;\n\n    #[test_only]\n    public fun end_aptos_epoch() {\n        stake::end_epoch(); // additionally forwards EPOCH_DURATION seconds\n        reconfiguration::reconfigure_for_test_custom();\n    }\n\n    #[test_only]\n    public fun initialize_for_test(aptos_framework: &signer) {\n        initialize_for_test_custom(\n            aptos_framework,\n            100 * ONE_APT,\n            10000000 * ONE_APT,\n            LOCKUP_CYCLE_SECONDS,\n            true,\n            1,\n            100,\n            1000000\n        );\n    }\n\n    #[test_only]\n    public fun initialize_for_test_no_reward(aptos_framework: &signer) {\n        initialize_for_test_custom(\n            aptos_framework,\n            100 * ONE_APT,\n            10000000 * ONE_APT,\n            LOCKUP_CYCLE_SECONDS,\n            true,\n            0,\n            100,\n            1000000\n        );\n    }\n\n    #[test_only]\n    public fun initialize_for_test_custom(\n        aptos_framework: &signer,\n        minimum_stake: u64,\n        maximum_stake: u64,\n        recurring_lockup_secs: u64,\n        allow_validator_set_change: bool,\n        rewards_rate_numerator: u64,\n        rewards_rate_denominator: u64,\n        voting_power_increase_limit: u64,\n    ) {\n        account::create_account_for_test(signer::address_of(aptos_framework));\n        stake::initialize_for_test_custom(\n            aptos_framework,\n            minimum_stake,\n            maximum_stake,\n            recurring_lockup_secs,\n            allow_validator_set_change,\n            rewards_rate_numerator,\n            rewards_rate_denominator,\n            voting_power_increase_limit,\n        );\n        reconfiguration::initialize_for_test(aptos_framework);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[DELEGATION_POOLS, MODULE_EVENT, OPERATOR_BENEFICIARY_CHANGE, COMMISSION_CHANGE_DELEGATION_POOL],\n            vector[]\n        );\n    }\n\n    #[test_only]\n    public fun initialize_test_validator(\n        validator: &signer,\n        amount: u64,\n        should_join_validator_set: bool,\n        should_end_epoch: bool,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_test_validator_custom(validator, amount, should_join_validator_set, should_end_epoch, 0);\n    }\n\n    #[test_only]\n    public fun initialize_test_validator_custom(\n        validator: &signer,\n        amount: u64,\n        should_join_validator_set: bool,\n        should_end_epoch: bool,\n        commission_percentage: u64,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        let validator_address = signer::address_of(validator);\n        if (!account::exists_at(validator_address)) {\n            account::create_account_for_test(validator_address);\n        };\n\n        initialize_delegation_pool(validator, commission_percentage, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(validator_address);\n\n        stake::rotate_consensus_key(validator, pool_address, CONSENSUS_KEY_1, CONSENSUS_POP_1);\n\n        if (amount > 0) {\n            stake::mint(validator, amount);\n            add_stake(validator, pool_address, amount);\n        };\n\n        if (should_join_validator_set) {\n            stake::join_validator_set(validator, pool_address);\n        };\n\n        if (should_end_epoch) {\n            end_aptos_epoch();\n        };\n    }\n\n    #[test_only]\n    fun unlock_with_min_stake_disabled(\n        delegator: &signer,\n        pool_address: address,\n        amount: u64\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        synchronize_delegation_pool(pool_address);\n\n        let pool = borrow_global_mut<DelegationPool>(pool_address);\n        let delegator_address = signer::address_of(delegator);\n\n        amount = redeem_active_shares(pool, delegator_address, amount);\n        stake::unlock(&retrieve_stake_pool_owner(pool), amount);\n        buy_in_pending_inactive_shares(pool, delegator_address, amount);\n    }\n\n    #[test_only]\n    public fun enable_delegation_pool_allowlisting_feature(aptos_framework: &signer) {\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_delegation_pool_allowlisting_feature()],\n            vector[]\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x3000A, location = Self)]\n    public entry fun test_delegation_pools_disabled(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        initialize_for_test(aptos_framework);\n        features::change_feature_flags_for_testing(aptos_framework, vector[], vector[DELEGATION_POOLS]);\n\n        initialize_delegation_pool(validator, 0, vector::empty<u8>());\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_set_operator_and_delegated_voter(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        initialize_for_test(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        initialize_delegation_pool(validator, 0, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(validator_address);\n\n        assert!(stake::get_operator(pool_address) == @0x123, 1);\n        assert!(stake::get_delegated_voter(pool_address) == @0x123, 1);\n\n        set_operator(validator, @0x111);\n        assert!(stake::get_operator(pool_address) == @0x111, 2);\n\n        set_delegated_voter(validator, @0x112);\n        assert!(stake::get_delegated_voter(pool_address) == @0x112, 2);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x60001, location = Self)]\n    public entry fun test_cannot_set_operator(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        initialize_for_test(aptos_framework);\n        // account does not own any delegation pool\n        set_operator(validator, @0x111);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x60001, location = Self)]\n    public entry fun test_cannot_set_delegated_voter(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        initialize_for_test(aptos_framework);\n        // account does not own any delegation pool\n        set_delegated_voter(validator, @0x112);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x80002, location = Self)]\n    public entry fun test_already_owns_delegation_pool(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        initialize_for_test(aptos_framework);\n        initialize_delegation_pool(validator, 0, x\"00\");\n        initialize_delegation_pool(validator, 0, x\"01\");\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x1000B, location = Self)]\n    public entry fun test_cannot_withdraw_zero_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        initialize_for_test(aptos_framework);\n        initialize_delegation_pool(validator, 0, x\"00\");\n        withdraw(validator, get_owned_pool_address(signer::address_of(validator)), 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_initialize_delegation_pool(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {\n        initialize_for_test(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        initialize_delegation_pool(validator, 1234, vector::empty<u8>());\n\n        assert_owner_cap_exists(validator_address);\n        let pool_address = get_owned_pool_address(validator_address);\n        assert_delegation_pool_exists(pool_address);\n\n        assert!(stake::stake_pool_exists(pool_address), 0);\n        assert!(stake::get_operator(pool_address) == validator_address, 0);\n        assert!(stake::get_delegated_voter(pool_address) == validator_address, 0);\n\n        assert!(observed_lockup_cycle(pool_address) == 0, 0);\n        assert!(total_coins_inactive(pool_address) == 0, 0);\n        assert!(operator_commission_percentage(pool_address) == 1234, 0);\n        assert_inactive_shares_pool(pool_address, 0, true, 0);\n        stake::assert_stake_pool(pool_address, 0, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, delegator2 = @0x020)]\n    public entry fun test_add_stake_fee(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test_custom(\n            aptos_framework,\n            100 * ONE_APT,\n            10000000 * ONE_APT,\n            LOCKUP_CYCLE_SECONDS,\n            true,\n            1,\n            100,\n            1000000\n        );\n\n        let validator_address = signer::address_of(validator);\n        account::create_account_for_test(validator_address);\n\n        // create delegation pool with 37.35% operator commission\n        initialize_delegation_pool(validator, 3735, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(validator_address);\n\n        stake::rotate_consensus_key(validator, pool_address, CONSENSUS_KEY_1, CONSENSUS_POP_1);\n\n        // zero `add_stake` fee as validator is not producing rewards this epoch\n        assert!(get_add_stake_fee(pool_address, 1000000 * ONE_APT) == 0, 0);\n\n        // add 1M APT, join the validator set and activate this stake\n        stake::mint(validator, 1000000 * ONE_APT);\n        add_stake(validator, pool_address, 1000000 * ONE_APT);\n\n        stake::join_validator_set(validator, pool_address);\n        end_aptos_epoch();\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n\n        // `add_stake` fee for 100000 coins: 100000 * 0.006265 / (1 + 0.006265)\n        assert!(get_add_stake_fee(pool_address, 100000 * ONE_APT) == 62259941466, 0);\n\n        // add pending_active stake from multiple delegators\n        stake::mint(delegator1, 100000 * ONE_APT);\n        add_stake(delegator1, pool_address, 100000 * ONE_APT);\n        stake::mint(delegator2, 10000 * ONE_APT);\n        add_stake(delegator2, pool_address, 10000 * ONE_APT);\n\n        end_aptos_epoch();\n        // delegators should own the same amount as initially deposited\n        assert_delegation(delegator1_address, pool_address, 10000000000000, 0, 0);\n        assert_delegation(delegator2_address, pool_address, 1000000000000, 0, 0);\n\n        // add more stake from delegator 1\n        stake::mint(delegator1, 10000 * ONE_APT);\n        let (delegator1_active, _, _) = get_stake(pool_address, delegator1_address);\n        add_stake(delegator1, pool_address, 10000 * ONE_APT);\n\n        let fee = get_add_stake_fee(pool_address, 10000 * ONE_APT);\n        assert_delegation(delegator1_address, pool_address, delegator1_active + 10000 * ONE_APT - fee, 0, 0);\n\n        // delegator 2 should not benefit in any way from this new stake\n        assert_delegation(delegator2_address, pool_address, 1000000000000, 0, 0);\n\n        // add more stake from delegator 2\n        stake::mint(delegator2, 100000 * ONE_APT);\n        add_stake(delegator2, pool_address, 100000 * ONE_APT);\n\n        end_aptos_epoch();\n        // delegators should own the same amount as initially deposited + any rewards produced\n        // 10000000000000 * 1% * (100 - 37.35)%\n        assert_delegation(delegator1_address, pool_address, 11062650000001, 0, 0);\n        // 1000000000000 * 1% * (100 - 37.35)%\n        assert_delegation(delegator2_address, pool_address, 11006265000001, 0, 0);\n\n        // in-flight operator commission rewards do not automatically restake/compound\n        synchronize_delegation_pool(pool_address);\n\n        // stakes should remain the same - `Self::get_stake` correctly calculates them\n        assert_delegation(delegator1_address, pool_address, 11062650000001, 0, 0);\n        assert_delegation(delegator2_address, pool_address, 11006265000001, 0, 0);\n\n        end_aptos_epoch();\n        // delegators should own previous stake * 1.006265\n        assert_delegation(delegator1_address, pool_address, 11131957502251, 0, 0);\n        assert_delegation(delegator2_address, pool_address, 11075219250226, 0, 0);\n\n        // add more stake from delegator 1\n        stake::mint(delegator1, 20000 * ONE_APT);\n        (delegator1_active, _, _) = get_stake(pool_address, delegator1_address);\n        add_stake(delegator1, pool_address, 20000 * ONE_APT);\n\n        fee = get_add_stake_fee(pool_address, 20000 * ONE_APT);\n        assert_delegation(delegator1_address, pool_address, delegator1_active + 20000 * ONE_APT - fee, 0, 0);\n\n        // delegator 1 unlocks his entire newly added stake\n        unlock(delegator1, pool_address, 20000 * ONE_APT - fee);\n        end_aptos_epoch();\n        // delegator 1 should own previous 11131957502250 active * 1.006265 and 20000 coins pending_inactive\n        assert_delegation(delegator1_address, pool_address, 11201699216002, 0, 2000000000000);\n\n        // stakes should remain the same - `Self::get_stake` correctly calculates them\n        synchronize_delegation_pool(pool_address);\n        assert_delegation(delegator1_address, pool_address, 11201699216002, 0, 2000000000000);\n\n        let reward_period_start_time_in_sec = timestamp::now_seconds();\n        // Enable rewards rate decrease. Initially rewards rate is still 1% every epoch. Rewards rate halves every year.\n        let one_year_in_secs: u64 = 31536000;\n        staking_config::initialize_rewards(\n            aptos_framework,\n            fixed_point64::create_from_rational(2, 100),\n            fixed_point64::create_from_rational(6, 1000),\n            one_year_in_secs,\n            reward_period_start_time_in_sec,\n            fixed_point64::create_from_rational(50, 100),\n        );\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_periodical_reward_rate_decrease_feature()],\n            vector[]\n        );\n\n        // add more stake from delegator 1\n        stake::mint(delegator1, 20000 * ONE_APT);\n        let delegator1_pending_inactive: u64;\n        (delegator1_active, _, delegator1_pending_inactive) = get_stake(pool_address, delegator1_address);\n        fee = get_add_stake_fee(pool_address, 20000 * ONE_APT);\n        add_stake(delegator1, pool_address, 20000 * ONE_APT);\n\n        assert_delegation(\n            delegator1_address,\n            pool_address,\n            delegator1_active + 20000 * ONE_APT - fee,\n            0,\n            delegator1_pending_inactive\n        );\n\n        // delegator 1 unlocks his entire newly added stake\n        unlock(delegator1, pool_address, 20000 * ONE_APT - fee);\n        end_aptos_epoch();\n        // delegator 1 should own previous 11201699216002 active * ~1.01253 and 20000 * ~1.01253 + 20000 coins pending_inactive\n        assert_delegation(delegator1_address, pool_address, 11342056366822, 0, 4025059974939);\n\n        // stakes should remain the same - `Self::get_stake` correctly calculates them\n        synchronize_delegation_pool(pool_address);\n        assert_delegation(delegator1_address, pool_address, 11342056366822, 0, 4025059974939);\n\n        fast_forward_seconds(one_year_in_secs);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator = @0x010)]\n    public entry fun test_never_create_pending_withdrawal_if_no_shares_bought(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1000 * ONE_APT, true, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        // add stake without fees as validator is not active yet\n        stake::mint(delegator, 10 * ONE_APT);\n        add_stake(delegator, pool_address, 10 * ONE_APT);\n        end_aptos_epoch();\n\n        unlock(validator, pool_address, 100 * ONE_APT);\n\n        stake::assert_stake_pool(pool_address, 91000000000, 0, 0, 10000000000);\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 91910000000, 0, 0, 10100000000);\n\n        unlock_with_min_stake_disabled(delegator, pool_address, 1);\n        // request 1 coins * 910 / 919.1 = 0.99 shares to redeem * 1.01 price -> 0 coins out\n        // 1 coins lost at redeem due to 0.99 shares being burned\n        assert_delegation(delegator_address, pool_address, 1009999999, 0, 0);\n        assert_pending_withdrawal(delegator_address, pool_address, false, 0, false, 0);\n\n        unlock_with_min_stake_disabled(delegator, pool_address, 2);\n        // request 2 coins * 909.99 / 919.1 = 1.98 shares to redeem * 1.01 price -> 1 coins out\n        // with 1 coins buy 1 * 100 / 101 = 0.99 shares in pending_inactive pool * 1.01 -> 0 coins in\n        // 1 coins lost at redeem due to 1.98 - 1.01 shares being burned + 1 coins extracted\n        synchronize_delegation_pool(pool_address);\n        assert_delegation(delegator_address, pool_address, 1009999997, 0, 0);\n        // the pending withdrawal has been created as > 0 pending_inactive shares have been bought\n        assert_pending_withdrawal(delegator_address, pool_address, true, 0, false, 0);\n\n        // successfully delete the pending withdrawal (redeem all owned shares even worth 0 coins)\n        reactivate_stake(delegator, pool_address, 1);\n        assert_delegation(delegator_address, pool_address, 1009999997, 0, 0);\n        assert_pending_withdrawal(delegator_address, pool_address, false, 0, false, 0);\n\n        // unlock min coins to own some pending_inactive balance (have to disable min-balance checks)\n        unlock_with_min_stake_disabled(delegator, pool_address, 3);\n        // request 3 coins * 909.99 / 919.09 = 2.97 shares to redeem * 1.01 price -> 2 coins out\n        // with 2 coins buy 2 * 100 / 101 = 1.98 shares in pending_inactive pool * 1.01 -> 1 coins in\n        // 1 coins lost at redeem due to 2.97 - 2 * 1.01 shares being burned + 2 coins extracted\n        synchronize_delegation_pool(pool_address);\n        assert_delegation(delegator_address, pool_address, 1009999994, 0, 1);\n        // the pending withdrawal has been created as > 0 pending_inactive shares have been bought\n        assert_pending_withdrawal(delegator_address, pool_address, true, 0, false, 1);\n\n        reactivate_stake(delegator, pool_address, 1);\n        // redeem 1 coins >= delegator balance -> all shares are redeemed and pending withdrawal is deleted\n        assert_delegation(delegator_address, pool_address, 1009999995, 0, 0);\n        // the pending withdrawal has been deleted as delegator has 0 pending_inactive shares now\n        assert_pending_withdrawal(delegator_address, pool_address, false, 0, false, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x10008, location = Self)]\n    public entry fun test_add_stake_min_amount(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, MIN_COINS_ON_SHARES_POOL - 1, false, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_add_stake_single(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1000 * ONE_APT, false, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        // validator is inactive => added stake is `active` by default\n        stake::assert_stake_pool(pool_address, 1000 * ONE_APT, 0, 0, 0);\n        assert_delegation(validator_address, pool_address, 1000 * ONE_APT, 0, 0);\n\n        // zero `add_stake` fee as validator is not producing rewards this epoch\n        assert!(get_add_stake_fee(pool_address, 250 * ONE_APT) == 0, 0);\n\n        // check `add_stake` increases `active` stakes of delegator and stake pool\n        stake::mint(validator, 300 * ONE_APT);\n        let balance = coin::balance<AptosCoin>(validator_address);\n        add_stake(validator, pool_address, 250 * ONE_APT);\n\n        // check added stake have been transferred out of delegator account\n        assert!(coin::balance<AptosCoin>(validator_address) == balance - 250 * ONE_APT, 0);\n        // zero `add_stake` fee charged from added stake\n        assert_delegation(validator_address, pool_address, 1250 * ONE_APT, 0, 0);\n        // zero `add_stake` fee transferred to null shareholder\n        assert_delegation(NULL_SHAREHOLDER, pool_address, 0, 0, 0);\n        // added stake is automatically `active` on inactive validator\n        stake::assert_stake_pool(pool_address, 1250 * ONE_APT, 0, 0, 0);\n\n        // activate validator\n        stake::join_validator_set(validator, pool_address);\n        end_aptos_epoch();\n\n        // add 250 coins being pending_active until next epoch\n        stake::mint(validator, 250 * ONE_APT);\n        add_stake(validator, pool_address, 250 * ONE_APT);\n\n        let fee1 = get_add_stake_fee(pool_address, 250 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 1500 * ONE_APT - fee1, 0, 0);\n        // check `add_stake` fee has been transferred to the null shareholder\n        assert_delegation(NULL_SHAREHOLDER, pool_address, fee1, 0, 0);\n        stake::assert_stake_pool(pool_address, 1250 * ONE_APT, 0, 250 * ONE_APT, 0);\n\n        // add 100 additional coins being pending_active until next epoch\n        stake::mint(validator, 100 * ONE_APT);\n        add_stake(validator, pool_address, 100 * ONE_APT);\n\n        let fee2 = get_add_stake_fee(pool_address, 100 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 1600 * ONE_APT - fee1 - fee2, 0, 0);\n        // check `add_stake` fee has been transferred to the null shareholder\n        assert_delegation(NULL_SHAREHOLDER, pool_address, fee1 + fee2, 0, 0);\n        stake::assert_stake_pool(pool_address, 1250 * ONE_APT, 0, 350 * ONE_APT, 0);\n\n        end_aptos_epoch();\n        // delegator got its `add_stake` fees back + 1250 * 1% * (100% - 0%) active rewards\n        assert_delegation(validator_address, pool_address, 161250000000, 0, 0);\n        stake::assert_stake_pool(pool_address, 161250000000, 0, 0, 0);\n\n        // check that shares of null shareholder have been released\n        assert_delegation(NULL_SHAREHOLDER, pool_address, 0, 0, 0);\n        synchronize_delegation_pool(pool_address);\n        assert!(pool_u64::shares(&borrow_global<DelegationPool>(pool_address).active_shares, NULL_SHAREHOLDER) == 0, 0);\n        assert_delegation(NULL_SHAREHOLDER, pool_address, 0, 0, 0);\n\n        // add 200 coins being pending_active until next epoch\n        stake::mint(validator, 200 * ONE_APT);\n        add_stake(validator, pool_address, 200 * ONE_APT);\n\n        fee1 = get_add_stake_fee(pool_address, 200 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 181250000000 - fee1, 0, 0);\n        // check `add_stake` fee has been transferred to the null shareholder\n        assert_delegation(NULL_SHAREHOLDER, pool_address, fee1 - 1, 0, 0);\n        stake::assert_stake_pool(pool_address, 161250000000, 0, 20000000000, 0);\n\n        end_aptos_epoch();\n        // delegator got its `add_stake` fee back + 161250000000 * 1% active rewards\n        assert_delegation(validator_address, pool_address, 182862500000, 0, 0);\n        stake::assert_stake_pool(pool_address, 182862500000, 0, 0, 0);\n\n        // check that shares of null shareholder have been released\n        assert_delegation(NULL_SHAREHOLDER, pool_address, 0, 0, 0);\n        synchronize_delegation_pool(pool_address);\n        assert!(pool_u64::shares(&borrow_global<DelegationPool>(pool_address).active_shares, NULL_SHAREHOLDER) == 0, 0);\n        assert_delegation(NULL_SHAREHOLDER, pool_address, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator = @0x010)]\n    public entry fun test_add_stake_many(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1000 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        stake::assert_stake_pool(pool_address, 1000 * ONE_APT, 0, 0, 0);\n        assert_delegation(validator_address, pool_address, 1000 * ONE_APT, 0, 0);\n\n        // add 250 coins from second account\n        stake::mint(delegator, 250 * ONE_APT);\n        add_stake(delegator, pool_address, 250 * ONE_APT);\n\n        let fee1 = get_add_stake_fee(pool_address, 250 * ONE_APT);\n        assert_delegation(delegator_address, pool_address, 250 * ONE_APT - fee1, 0, 0);\n        assert_delegation(validator_address, pool_address, 1000 * ONE_APT, 0, 0);\n        stake::assert_stake_pool(pool_address, 1000 * ONE_APT, 0, 250 * ONE_APT, 0);\n\n        end_aptos_epoch();\n        // 1000 * 1.01 active stake + 250 pending_active stake\n        stake::assert_stake_pool(pool_address, 1260 * ONE_APT, 0, 0, 0);\n        // delegator got its `add_stake` fee back\n        assert_delegation(delegator_address, pool_address, 250 * ONE_APT, 0, 0);\n        // actual active rewards have been distributed to their earner(s)\n        assert_delegation(validator_address, pool_address, 100999999999, 0, 0);\n\n        // add another 250 coins from first account\n        stake::mint(validator, 250 * ONE_APT);\n        add_stake(validator, pool_address, 250 * ONE_APT);\n\n        fee1 = get_add_stake_fee(pool_address, 250 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 125999999999 - fee1, 0, 0);\n        assert_delegation(delegator_address, pool_address, 250 * ONE_APT, 0, 0);\n        stake::assert_stake_pool(pool_address, 1260 * ONE_APT, 0, 250 * ONE_APT, 0);\n\n        // add another 100 coins from second account\n        stake::mint(delegator, 100 * ONE_APT);\n        add_stake(delegator, pool_address, 100 * ONE_APT);\n\n        let fee2 = get_add_stake_fee(pool_address, 100 * ONE_APT);\n        assert_delegation(delegator_address, pool_address, 350 * ONE_APT - fee2, 0, 0);\n        assert_delegation(validator_address, pool_address, 125999999999 - fee1, 0, 0);\n        stake::assert_stake_pool(pool_address, 1260 * ONE_APT, 0, 350 * ONE_APT, 0);\n\n        end_aptos_epoch();\n        // both delegators got their `add_stake` fees back\n        // 250 * 1.01 active stake + 100 pending_active stake\n        assert_delegation(delegator_address, pool_address, 35250000001, 0, 0);\n        // 1010 * 1.01 active stake + 250 pending_active stake\n        assert_delegation(validator_address, pool_address, 127009999998, 0, 0);\n        stake::assert_stake_pool(pool_address, 162260000000, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator = @0x010)]\n    public entry fun test_unlock_single(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        // add 200 coins pending_active until next epoch\n        stake::mint(validator, 200 * ONE_APT);\n        add_stake(validator, pool_address, 200 * ONE_APT);\n\n        let fee = get_add_stake_fee(pool_address, 200 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 300 * ONE_APT - fee, 0, 0);\n        stake::assert_stake_pool(pool_address, 100 * ONE_APT, 0, 200 * ONE_APT, 0);\n\n        // cannot unlock pending_active stake (only 100/300 stake can be displaced)\n        unlock(validator, pool_address, 100 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 200 * ONE_APT - fee, 0, 100 * ONE_APT);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, false, 100 * ONE_APT);\n        stake::assert_stake_pool(pool_address, 0, 0, 200 * ONE_APT, 100 * ONE_APT);\n        assert_inactive_shares_pool(pool_address, 0, true, 100 * ONE_APT);\n\n        // reactivate entire pending_inactive stake progressively\n        reactivate_stake(validator, pool_address, 50 * ONE_APT);\n\n        assert_delegation(validator_address, pool_address, 250 * ONE_APT - fee, 0, 50 * ONE_APT);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, false, 50 * ONE_APT);\n        stake::assert_stake_pool(pool_address, 50 * ONE_APT, 0, 200 * ONE_APT, 50 * ONE_APT);\n\n        reactivate_stake(validator, pool_address, 50 * ONE_APT);\n\n        assert_delegation(validator_address, pool_address, 300 * ONE_APT - fee, 0, 0);\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n        stake::assert_stake_pool(pool_address, 100 * ONE_APT, 0, 200 * ONE_APT, 0);\n        // pending_inactive shares pool has not been deleted (as can still `unlock` this OLC)\n        assert_inactive_shares_pool(pool_address, 0, true, 0);\n\n        end_aptos_epoch();\n        // 10000000000 * 1.01 active stake + 20000000000 pending_active stake\n        assert_delegation(validator_address, pool_address, 301 * ONE_APT, 0, 0);\n        stake::assert_stake_pool(pool_address, 301 * ONE_APT, 0, 0, 0);\n\n        // can unlock more than at previous epoch as the pending_active stake became active\n        unlock(validator, pool_address, 150 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 15100000001, 0, 14999999999);\n        stake::assert_stake_pool(pool_address, 15100000001, 0, 0, 14999999999);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, false, 14999999999);\n\n        assert!(stake::get_remaining_lockup_secs(pool_address) == LOCKUP_CYCLE_SECONDS - EPOCH_DURATION, 0);\n        end_aptos_epoch(); // additionally forwards EPOCH_DURATION seconds\n\n        // pending_inactive stake should have not been inactivated\n        // 15100000001 * 1.01 active stake + 14999999999 pending_inactive * 1.01 stake\n        assert_delegation(validator_address, pool_address, 15251000001, 0, 15149999998);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, false, 15149999998);\n        stake::assert_stake_pool(pool_address, 15251000001, 0, 0, 15149999998);\n\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS - 3 * EPOCH_DURATION);\n        end_aptos_epoch(); // additionally forwards EPOCH_DURATION seconds and expires lockup cycle\n\n        // 15251000001 * 1.01 active stake + 15149999998 * 1.01 pending_inactive(now inactive) stake\n        assert_delegation(validator_address, pool_address, 15403510001, 15301499997, 0);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, true, 15301499997);\n        stake::assert_stake_pool(pool_address, 15403510001, 15301499997, 0, 0);\n\n        // add 50 coins from another account\n        stake::mint(delegator, 50 * ONE_APT);\n        add_stake(delegator, pool_address, 50 * ONE_APT);\n\n        // observed lockup cycle should have advanced at `add_stake`(on synchronization)\n        assert!(observed_lockup_cycle(pool_address) == 1, 0);\n\n        fee = get_add_stake_fee(pool_address, 50 * ONE_APT);\n        assert_delegation(delegator_address, pool_address, 4999999999 - fee, 0, 0);\n        assert_delegation(validator_address, pool_address, 15403510001, 15301499997, 0);\n        stake::assert_stake_pool(pool_address, 15403510001, 15301499997, 50 * ONE_APT, 0);\n\n        // cannot withdraw stake unlocked by others\n        withdraw(delegator, pool_address, 50 * ONE_APT);\n        assert!(coin::balance<AptosCoin>(delegator_address) == 0, 0);\n\n        // withdraw own unlocked stake\n        withdraw(validator, pool_address, 15301499997);\n        assert!(coin::balance<AptosCoin>(validator_address) == 15301499997, 0);\n        assert_delegation(validator_address, pool_address, 15403510001, 0, 0);\n        // pending withdrawal has been executed and deleted\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n        // inactive shares pool on OLC 0 has been deleted because its stake has been withdrawn\n        assert_inactive_shares_pool(pool_address, 0, false, 0);\n\n        // new pending withdrawal can be created on lockup cycle 1\n        unlock(validator, pool_address, 5403510001);\n        assert_delegation(validator_address, pool_address, 10000000000, 0, 5403510000);\n        assert_pending_withdrawal(validator_address, pool_address, true, 1, false, 5403510000);\n\n        // end lockup cycle 1\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        // 10000000000 * 1.01 active stake + 5403510000 * 1.01 pending_inactive(now inactive) stake\n        assert_delegation(validator_address, pool_address, 10100000000, 5457545100, 0);\n        assert_pending_withdrawal(validator_address, pool_address, true, 1, true, 5457545100);\n\n        // unlock when the pending withdrawal exists and gets automatically executed\n        let balance = coin::balance<AptosCoin>(validator_address);\n        unlock(validator, pool_address, 10100000000);\n        assert!(coin::balance<AptosCoin>(validator_address) == balance + 5457545100, 0);\n        assert_delegation(validator_address, pool_address, 0, 0, 10100000000);\n        // this is the new pending withdrawal replacing the executed one\n        assert_pending_withdrawal(validator_address, pool_address, true, 2, false, 10100000000);\n\n        // create dummy validator to ensure the existing validator can leave the set\n        initialize_test_validator(delegator, 100 * ONE_APT, true, true);\n        // inactivate validator\n        stake::leave_validator_set(validator, pool_address);\n        end_aptos_epoch();\n\n        // expire lockup cycle on the stake pool\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        let observed_lockup_cycle = observed_lockup_cycle(pool_address);\n        end_aptos_epoch();\n\n        // observed lockup cycle should be unchanged as no stake has been inactivated\n        synchronize_delegation_pool(pool_address);\n        assert!(observed_lockup_cycle(pool_address) == observed_lockup_cycle, 0);\n\n        // stake is pending_inactive as it has not been inactivated\n        stake::assert_stake_pool(pool_address, 5100500001, 0, 0, 10303010000);\n        // 10100000000 * 1.01 * 1.01 pending_inactive stake\n        assert_delegation(validator_address, pool_address, 0, 0, 10303010000);\n        // the pending withdrawal should be reported as still pending\n        assert_pending_withdrawal(validator_address, pool_address, true, 2, false, 10303010000);\n\n        // validator is inactive and lockup expired => pending_inactive stake is withdrawable\n        balance = coin::balance<AptosCoin>(validator_address);\n        withdraw(validator, pool_address, 10303010000);\n\n        assert!(coin::balance<AptosCoin>(validator_address) == balance + 10303010000, 0);\n        assert_delegation(validator_address, pool_address, 0, 0, 0);\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n        stake::assert_stake_pool(pool_address, 5100500001, 0, 0, 0);\n        // pending_inactive shares pool has not been deleted (as can still `unlock` this OLC)\n        assert_inactive_shares_pool(pool_address, observed_lockup_cycle(pool_address), true, 0);\n\n        stake::mint(validator, 30 * ONE_APT);\n        add_stake(validator, pool_address, 30 * ONE_APT);\n        unlock(validator, pool_address, 10 * ONE_APT);\n\n        assert_delegation(validator_address, pool_address, 1999999999, 0, 1000000000);\n        // the pending withdrawal should be reported as still pending\n        assert_pending_withdrawal(validator_address, pool_address, true, 2, false, 1000000000);\n\n        balance = coin::balance<AptosCoin>(validator_address);\n        // pending_inactive balance would be under threshold => redeem entire balance\n        withdraw(validator, pool_address, 1);\n        // pending_inactive balance has been withdrawn and the pending withdrawal executed\n        assert_delegation(validator_address, pool_address, 1999999999, 0, 0);\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n        assert!(coin::balance<AptosCoin>(validator_address) == balance + 1000000000, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, delegator2 = @0x020)]\n    public entry fun test_total_coins_inactive(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 200 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n\n        stake::mint(delegator1, 100 * ONE_APT);\n        stake::mint(delegator2, 200 * ONE_APT);\n        add_stake(delegator1, pool_address, 100 * ONE_APT);\n        add_stake(delegator2, pool_address, 200 * ONE_APT);\n        end_aptos_epoch();\n\n        assert_delegation(delegator1_address, pool_address, 100 * ONE_APT, 0, 0);\n        assert_delegation(delegator2_address, pool_address, 200 * ONE_APT, 0, 0);\n\n        // unlock some stake from delegator 1\n        unlock(delegator1, pool_address, 50 * ONE_APT);\n        assert_delegation(delegator1_address, pool_address, 5000000000, 0, 4999999999);\n\n        // move to lockup cycle 1\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        // delegator 1 pending_inactive stake has been inactivated\n        assert_delegation(delegator1_address, pool_address, 5050000000, 5049999998, 0);\n        assert_delegation(delegator2_address, pool_address, 202 * ONE_APT, 0, 0);\n\n        synchronize_delegation_pool(pool_address);\n        assert!(total_coins_inactive(pool_address) == 5049999998, 0);\n\n        // unlock some stake from delegator 2\n        unlock(delegator2, pool_address, 50 * ONE_APT);\n        assert_delegation(delegator2_address, pool_address, 15200000001, 0, 4999999999);\n\n        // withdraw some of inactive stake of delegator 1\n        withdraw(delegator1, pool_address, 2049999998);\n        assert_delegation(delegator1_address, pool_address, 5050000000, 3000000001, 0);\n        assert!(total_coins_inactive(pool_address) == 3000000001, 0);\n\n        // move to lockup cycle 2\n        let (_, inactive, _, pending_inactive) = stake::get_stake(pool_address);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        // delegator 2 pending_inactive stake has been inactivated\n        assert_delegation(delegator1_address, pool_address, 5100500000, 3000000001, 0);\n        assert_delegation(delegator2_address, pool_address, 15352000001, 5049999998, 0);\n\n        // total_coins_inactive remains unchanged in the absence of user operations\n        assert!(total_coins_inactive(pool_address) == inactive, 0);\n        synchronize_delegation_pool(pool_address);\n        // total_coins_inactive == previous inactive stake + previous pending_inactive stake and its rewards\n        assert!(total_coins_inactive(pool_address) == inactive + pending_inactive + pending_inactive / 100, 0);\n\n        // withdraw some of inactive stake of delegator 2\n        let total_coins_inactive = total_coins_inactive(pool_address);\n        withdraw(delegator2, pool_address, 3049999998);\n        assert!(total_coins_inactive(pool_address) == total_coins_inactive - 3049999997, 0);\n\n        // unlock some stake from delegator `validator`\n        unlock(validator, pool_address, 50 * ONE_APT);\n\n        // create dummy validator to ensure the existing validator can leave the set\n        initialize_test_validator(delegator1, 100 * ONE_APT, true, true);\n        // inactivate validator\n        stake::leave_validator_set(validator, pool_address);\n        end_aptos_epoch();\n\n        // move to lockup cycle 3\n        (_, inactive, _, pending_inactive) = stake::get_stake(pool_address);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        // pending_inactive stake has not been inactivated as validator is inactive\n        let (_, inactive_now, _, pending_inactive_now) = stake::get_stake(pool_address);\n        assert!(inactive_now == inactive, inactive_now);\n        assert!(pending_inactive_now == pending_inactive, pending_inactive_now);\n\n        // total_coins_inactive remains unchanged in the absence of a new OLC\n        synchronize_delegation_pool(pool_address);\n        assert!(total_coins_inactive(pool_address) == inactive, 0);\n\n        // withdraw entire pending_inactive stake\n        withdraw(validator, pool_address, MAX_U64);\n        assert!(total_coins_inactive(pool_address) == inactive, 0);\n        (_, _, _, pending_inactive) = stake::get_stake(pool_address);\n        assert!(pending_inactive == 0, pending_inactive);\n\n        // withdraw entire inactive stake\n        withdraw(delegator1, pool_address, MAX_U64);\n        withdraw(delegator2, pool_address, MAX_U64);\n        assert!(total_coins_inactive(pool_address) == 0, 0);\n        (_, inactive, _, _) = stake::get_stake(pool_address);\n        assert!(inactive == 0, inactive);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_reactivate_stake_single(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 200 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        // unlock some stake from the active one\n        unlock(validator, pool_address, 100 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 100 * ONE_APT, 0, 100 * ONE_APT);\n        stake::assert_stake_pool(pool_address, 100 * ONE_APT, 0, 0, 100 * ONE_APT);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, false, 100 * ONE_APT);\n\n        // add some stake to pending_active state\n        stake::mint(validator, 150 * ONE_APT);\n        add_stake(validator, pool_address, 150 * ONE_APT);\n\n        let fee = get_add_stake_fee(pool_address, 150 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 250 * ONE_APT - fee, 0, 100 * ONE_APT);\n        stake::assert_stake_pool(pool_address, 100 * ONE_APT, 0, 150 * ONE_APT, 100 * ONE_APT);\n\n        // can reactivate only pending_inactive stake\n        reactivate_stake(validator, pool_address, 150 * ONE_APT);\n\n        assert_delegation(validator_address, pool_address, 350 * ONE_APT - fee, 0, 0);\n        stake::assert_stake_pool(pool_address, 200 * ONE_APT, 0, 150 * ONE_APT, 0);\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n\n        end_aptos_epoch();\n        // 20000000000 active stake * 1.01 + 15000000000 pending_active stake\n        assert_delegation(validator_address, pool_address, 35200000000, 0, 0);\n\n        // unlock stake added at previous epoch (expect some imprecision when moving shares)\n        unlock(validator, pool_address, 150 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 20200000001, 0, 14999999999);\n        stake::assert_stake_pool(pool_address, 20200000001, 0, 0, 14999999999);\n\n        // inactivate pending_inactive stake\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        // 20200000001 active stake * 1.01 + 14999999999 pending_inactive stake * 1.01\n        assert_delegation(validator_address, pool_address, 20402000001, 15149999998, 0);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, true, 15149999998);\n\n        // cannot reactivate inactive stake\n        reactivate_stake(validator, pool_address, 15149999998);\n        assert_delegation(validator_address, pool_address, 20402000001, 15149999998, 0);\n\n        // unlock stake in the new lockup cycle (the pending withdrawal is executed)\n        unlock(validator, pool_address, 100 * ONE_APT);\n        assert!(coin::balance<AptosCoin>(validator_address) == 15149999998, 0);\n        assert_delegation(validator_address, pool_address, 10402000002, 0, 9999999999);\n        assert_pending_withdrawal(validator_address, pool_address, true, 1, false, 9999999999);\n\n        // reactivate the new pending withdrawal almost entirely\n        reactivate_stake(validator, pool_address, 8999999999);\n        assert_pending_withdrawal(validator_address, pool_address, true, 1, false, 1000000000);\n        // reactivate remaining stake of the new pending withdrawal\n        reactivate_stake(validator, pool_address, 1000000000);\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator = @0x010)]\n    public entry fun test_withdraw_many(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1000 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        stake::mint(delegator, 200 * ONE_APT);\n        add_stake(delegator, pool_address, 200 * ONE_APT);\n\n        unlock(validator, pool_address, 100 * ONE_APT);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, false, 100 * ONE_APT);\n\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        assert_delegation(delegator_address, pool_address, 200 * ONE_APT, 0, 0);\n        assert_delegation(validator_address, pool_address, 90899999999, 10100000000, 0);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, true, 10100000000);\n        assert_inactive_shares_pool(pool_address, 0, true, 100 * ONE_APT);\n\n        // check cannot withdraw inactive stake unlocked by others\n        withdraw(delegator, pool_address, MAX_U64);\n        assert_delegation(delegator_address, pool_address, 200 * ONE_APT, 0, 0);\n        assert_delegation(validator_address, pool_address, 90899999999, 10100000000, 0);\n\n        unlock(delegator, pool_address, 100 * ONE_APT);\n        assert_delegation(delegator_address, pool_address, 10000000000, 0, 9999999999);\n        assert_delegation(validator_address, pool_address, 90900000000, 10100000000, 0);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, false, 9999999999);\n\n        // check cannot withdraw inactive stake unlocked by others even if owning pending_inactive\n        withdraw(delegator, pool_address, MAX_U64);\n        assert_delegation(delegator_address, pool_address, 10000000000, 0, 9999999999);\n        assert_delegation(validator_address, pool_address, 90900000000, 10100000000, 0);\n\n        // withdraw entire owned inactive stake\n        let balance = coin::balance<AptosCoin>(validator_address);\n        withdraw(validator, pool_address, MAX_U64);\n        assert!(coin::balance<AptosCoin>(validator_address) == balance + 10100000000, 0);\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n        assert_inactive_shares_pool(pool_address, 0, false, 0);\n\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        assert_delegation(delegator_address, pool_address, 10100000000, 10099999998, 0);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, true, 10099999998);\n        assert_inactive_shares_pool(pool_address, 1, true, 9999999999);\n\n        // use too small of an unlock amount to actually transfer shares to the pending_inactive pool\n        // check that no leftovers have been produced on the stake or delegation pools\n        stake::assert_stake_pool(pool_address, 101909000001, 10099999998, 0, 0);\n        unlock_with_min_stake_disabled(delegator, pool_address, 1);\n        stake::assert_stake_pool(pool_address, 101909000001, 10099999998, 0, 0);\n        assert_delegation(delegator_address, pool_address, 10100000000, 10099999998, 0);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, true, 10099999998);\n\n        // implicitly execute the pending withdrawal by unlocking min stake to buy 1 share\n        unlock_with_min_stake_disabled(delegator, pool_address, 2);\n        stake::assert_stake_pool(pool_address, 101909000000, 0, 0, 1);\n        assert_delegation(delegator_address, pool_address, 10099999998, 0, 1);\n        // old pending withdrawal has been replaced\n        assert_pending_withdrawal(delegator_address, pool_address, true, 2, false, 1);\n        assert_inactive_shares_pool(pool_address, 1, false, 0);\n        assert_inactive_shares_pool(pool_address, 2, true, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator = @0x010)]\n    public entry fun test_inactivate_no_excess_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1200 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        stake::mint(delegator, 200 * ONE_APT);\n        add_stake(delegator, pool_address, 200 * ONE_APT);\n\n        // create inactive and pending_inactive stakes on the stake pool\n        unlock(validator, pool_address, 200 * ONE_APT);\n\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        unlock(delegator, pool_address, 100 * ONE_APT);\n\n        // check no excess pending_inactive is inactivated in the special case\n        // the validator had gone inactive before its lockup expired\n\n        let observed_lockup_cycle = observed_lockup_cycle(pool_address);\n\n        // create dummy validator to ensure the existing validator can leave the set\n        initialize_test_validator(delegator, 100 * ONE_APT, true, true);\n        // inactivate validator\n        stake::leave_validator_set(validator, pool_address);\n        end_aptos_epoch();\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE, 0);\n\n        // expire lockup afterwards\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        synchronize_delegation_pool(pool_address);\n        // no new inactive stake detected => OLC does not advance\n        assert!(observed_lockup_cycle(pool_address) == observed_lockup_cycle, 0);\n\n        // pending_inactive stake has not been inactivated\n        stake::assert_stake_pool(pool_address, 113231100001, 20200000000, 0, 10200999997);\n        assert_delegation(delegator_address, pool_address, 10201000000, 0, 10200999997);\n        assert_delegation(validator_address, pool_address, 103030100000, 20200000000, 0);\n\n        // withdraw some inactive stake (remaining pending_inactive is not inactivated)\n        withdraw(validator, pool_address, 200000000);\n        stake::assert_stake_pool(pool_address, 113231100001, 20000000001, 0, 10200999997);\n        assert_delegation(delegator_address, pool_address, 10201000000, 0, 10200999997);\n        assert_delegation(validator_address, pool_address, 103030100000, 20000000001, 0);\n\n        // withdraw some pending_inactive stake (remaining pending_inactive is not inactivated)\n        withdraw(delegator, pool_address, 200999997);\n        stake::assert_stake_pool(pool_address, 113231100001, 20000000001, 0, 10000000001);\n        assert_delegation(delegator_address, pool_address, 10201000000, 0, 10000000001);\n        assert_delegation(validator_address, pool_address, 103030100000, 20000000001, 0);\n\n        // no new inactive stake detected => OLC does not advance\n        assert!(observed_lockup_cycle(pool_address) == observed_lockup_cycle, 0);\n\n        unlock(delegator, pool_address, 10201000000);\n        withdraw(delegator, pool_address, 10201000000);\n        assert!(observed_lockup_cycle(pool_address) == observed_lockup_cycle, 0);\n\n        assert_delegation(delegator_address, pool_address, 0, 0, 10000000002);\n        assert_delegation(validator_address, pool_address, 103030100001, 20000000001, 0);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, true, 20000000001);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, false, 10000000002);\n        stake::assert_stake_pool(pool_address, 103030100001, 20000000001, 0, 10000000002);\n\n        // reactivate validator\n        stake::join_validator_set(validator, pool_address);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 0);\n        end_aptos_epoch();\n\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 0);\n        // no rewards have been produced yet and no stake inactivated as lockup has been refreshed\n        stake::assert_stake_pool(pool_address, 103030100001, 20000000001, 0, 10000000002);\n\n        synchronize_delegation_pool(pool_address);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, true, 20000000001);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, false, 10000000002);\n        assert!(observed_lockup_cycle(pool_address) == observed_lockup_cycle, 0);\n\n        // cannot withdraw pending_inactive stake anymore\n        withdraw(delegator, pool_address, 10000000002);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, false, 10000000002);\n\n        // earning rewards is resumed from this epoch on\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 104060401001, 20000000001, 0, 10100000002);\n\n        // new pending_inactive stake earns rewards but so does the old one\n        unlock(validator, pool_address, 104060401001);\n        assert_pending_withdrawal(validator_address, pool_address, true, 1, false, 104060401000);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, false, 10100000002);\n        end_aptos_epoch();\n        assert_pending_withdrawal(validator_address, pool_address, true, 1, false, 105101005010);\n        assert_pending_withdrawal(delegator_address, pool_address, true, 1, false, 10201000002);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_stake_rewards(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1000 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        end_aptos_epoch();\n        // 100000000000 active stake * 1.01\n        assert_delegation(validator_address, pool_address, 1010 * ONE_APT, 0, 0);\n\n        // add stake in pending_active state\n        stake::mint(validator, 200 * ONE_APT);\n        add_stake(validator, pool_address, 200 * ONE_APT);\n\n        let fee = get_add_stake_fee(pool_address, 200 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 1210 * ONE_APT - fee, 0, 0);\n\n        end_aptos_epoch();\n        // 101000000000 active stake * 1.01 + 20000000000 pending_active stake with no rewards\n        assert_delegation(validator_address, pool_address, 122010000000, 0, 0);\n\n        end_aptos_epoch();\n        // 122010000000 active stake * 1.01\n        assert_delegation(validator_address, pool_address, 123230100000, 0, 0);\n\n        // 123230100000 active stake * 1.01\n        end_aptos_epoch();\n        // 124462401000 active stake * 1.01\n        end_aptos_epoch();\n        // 125707025010 active stake * 1.01\n        end_aptos_epoch();\n        // 126964095260 active stake * 1.01\n        end_aptos_epoch();\n        // 128233736212 active stake * 1.01\n        end_aptos_epoch();\n        assert_delegation(validator_address, pool_address, 129516073574, 0, 0);\n\n        // unlock 200 coins from delegator `validator`\n        unlock(validator, pool_address, 200 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 109516073575, 0, 19999999999);\n\n        // end this lockup cycle\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        // 109516073575 active stake * 1.01 + 19999999999 pending_inactive stake * 1.01\n        assert_delegation(validator_address, pool_address, 110611234310, 20199999998, 0);\n\n        end_aptos_epoch();\n        // 110611234310 active stake * 1.01 + 20199999998 inactive stake\n        assert_delegation(validator_address, pool_address, 111717346653, 20199999998, 0);\n\n        // add stake in pending_active state\n        stake::mint(validator, 1000 * ONE_APT);\n        add_stake(validator, pool_address, 1000 * ONE_APT);\n\n        fee = get_add_stake_fee(pool_address, 1000 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 211717346653 - fee, 20199999998, 0);\n\n        end_aptos_epoch();\n        // 111717346653 active stake * 1.01 + 100000000000 pending_active stake + 20199999998 inactive stake\n        assert_delegation(validator_address, pool_address, 212834520119, 20199999998, 0);\n\n        end_aptos_epoch();\n        // 212834520119 active stake * 1.01 + 20199999998 inactive stake\n        assert_delegation(validator_address, pool_address, 214962865320, 20199999998, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator = @0x010)]\n    public entry fun test_active_stake_rewards_multiple(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 200 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        // add stake in pending_active state\n        stake::mint(delegator, 300 * ONE_APT);\n        add_stake(delegator, pool_address, 300 * ONE_APT);\n\n        let fee = get_add_stake_fee(pool_address, 300 * ONE_APT);\n        assert_delegation(delegator_address, pool_address, 300 * ONE_APT - fee, 0, 0);\n        assert_delegation(validator_address, pool_address, 200 * ONE_APT, 0, 0);\n        stake::assert_stake_pool(pool_address, 200 * ONE_APT, 0, 300 * ONE_APT, 0);\n\n        end_aptos_epoch();\n        // `delegator` got its `add_stake` fee back and `validator` its active stake rewards\n        assert_delegation(delegator_address, pool_address, 300 * ONE_APT, 0, 0);\n        assert_delegation(validator_address, pool_address, 20199999999, 0, 0);\n        stake::assert_stake_pool(pool_address, 502 * ONE_APT, 0, 0, 0);\n\n        // delegators earn their own rewards from now on\n        end_aptos_epoch();\n        assert_delegation(delegator_address, pool_address, 303 * ONE_APT, 0, 0);\n        assert_delegation(validator_address, pool_address, 20401999999, 0, 0);\n        stake::assert_stake_pool(pool_address, 50702000000, 0, 0, 0);\n\n        end_aptos_epoch();\n        assert_delegation(delegator_address, pool_address, 30603000000, 0, 0);\n        assert_delegation(validator_address, pool_address, 20606019999, 0, 0);\n        stake::assert_stake_pool(pool_address, 51209020000, 0, 0, 0);\n\n        end_aptos_epoch();\n        assert_delegation(delegator_address, pool_address, 30909030000, 0, 0);\n        assert_delegation(validator_address, pool_address, 20812080199, 0, 0);\n        stake::assert_stake_pool(pool_address, 51721110200, 0, 0, 0);\n\n        // add more stake in pending_active state than currently active\n        stake::mint(delegator, 1000 * ONE_APT);\n        add_stake(delegator, pool_address, 1000 * ONE_APT);\n\n        fee = get_add_stake_fee(pool_address, 1000 * ONE_APT);\n        assert_delegation(delegator_address, pool_address, 130909030000 - fee, 0, 0);\n        assert_delegation(validator_address, pool_address, 20812080199, 0, 0);\n\n        end_aptos_epoch();\n        // `delegator` got its `add_stake` fee back and `validator` its active stake rewards\n        assert_delegation(delegator_address, pool_address, 131218120300, 0, 0);\n        assert_delegation(validator_address, pool_address, 21020201001, 0, 0);\n        stake::assert_stake_pool(pool_address, 152238321302, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_pending_inactive_stake_rewards(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1000 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        end_aptos_epoch();\n        assert_delegation(validator_address, pool_address, 1010 * ONE_APT, 0, 0);\n\n        // unlock 200 coins from delegator `validator`\n        unlock(validator, pool_address, 200 * ONE_APT);\n        assert_delegation(validator_address, pool_address, 81000000001, 0, 19999999999);\n\n        end_aptos_epoch(); // 81000000001 active stake * 1.01 + 19999999999 pending_inactive stake * 1.01\n        end_aptos_epoch(); // 81810000001 active stake * 1.01 + 20199999998 pending_inactive stake * 1.01\n\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch(); // 82628100001 active stake * 1.01 + 20401999997 pending_inactive stake * 1.01\n        end_aptos_epoch(); // 83454381001 active stake * 1.01 + 20606019996 pending_inactive stake(now inactive)\n        assert_delegation(validator_address, pool_address, 84288924811, 20606019996, 0);\n\n        // unlock 200 coins from delegator `validator` which implicitly executes its pending withdrawal\n        unlock(validator, pool_address, 200 * ONE_APT);\n        assert!(coin::balance<AptosCoin>(validator_address) == 20606019996, 0);\n        assert_delegation(validator_address, pool_address, 64288924812, 0, 19999999999);\n\n        // lockup cycle is not ended, pending_inactive stake is still earning\n        end_aptos_epoch(); // 64288924812 active stake * 1.01 + 19999999999 pending_inactive stake * 1.01\n        end_aptos_epoch(); // 64931814060 active stake * 1.01 + 20199999998 pending_inactive stake * 1.01\n        end_aptos_epoch(); // 65581132200 active stake * 1.01 + 20401999997 pending_inactive stake * 1.01\n        end_aptos_epoch(); // 66236943522 active stake * 1.01 + 20606019996 pending_inactive stake * 1.01\n        assert_delegation(validator_address, pool_address, 66899312957, 0, 20812080195);\n\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch(); // 66899312957 active stake * 1.01 + 20812080195 pending_inactive stake * 1.01\n        end_aptos_epoch(); // 67568306086 active stake * 1.01 + 21020200996 pending_inactive stake(now inactive)\n        end_aptos_epoch(); // 68243989147 active stake * 1.01 + 21020200996 inactive stake\n        assert_delegation(validator_address, pool_address, 68926429037, 21020200996, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, delegator2 = @0x020)]\n    public entry fun test_out_of_order_redeem(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 1000 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n\n        stake::mint(delegator1, 300 * ONE_APT);\n        add_stake(delegator1, pool_address, 300 * ONE_APT);\n\n        stake::mint(delegator2, 300 * ONE_APT);\n        add_stake(delegator2, pool_address, 300 * ONE_APT);\n\n        end_aptos_epoch();\n\n        // create the pending withdrawal of delegator 1 in lockup cycle 0\n        unlock(delegator1, pool_address, 150 * ONE_APT);\n        assert_pending_withdrawal(delegator1_address, pool_address, true, 0, false, 14999999999);\n\n        // move to lockup cycle 1\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        // create the pending withdrawal of delegator 2 in lockup cycle 1\n        unlock(delegator2, pool_address, 150 * ONE_APT);\n        assert_pending_withdrawal(delegator2_address, pool_address, true, 1, false, 14999999999);\n        // 14999999999 pending_inactive stake * 1.01\n        assert_pending_withdrawal(delegator1_address, pool_address, true, 0, true, 15149999998);\n\n        // move to lockup cycle 2\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        assert_pending_withdrawal(delegator2_address, pool_address, true, 1, true, 15149999998);\n        assert_pending_withdrawal(delegator1_address, pool_address, true, 0, true, 15149999998);\n\n        // both delegators who unlocked at different lockup cycles should be able to withdraw their stakes\n        withdraw(delegator1, pool_address, 15149999998);\n        withdraw(delegator2, pool_address, 5149999998);\n\n        assert_pending_withdrawal(delegator2_address, pool_address, true, 1, true, 10000000001);\n        assert_pending_withdrawal(delegator1_address, pool_address, false, 0, false, 0);\n        assert!(coin::balance<AptosCoin>(delegator1_address) == 15149999998, 0);\n        assert!(coin::balance<AptosCoin>(delegator2_address) == 5149999997, 0);\n\n        // recreate the pending withdrawal of delegator 1 in lockup cycle 2\n        unlock(delegator1, pool_address, 100 * ONE_APT);\n\n        // move to lockup cycle 3\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        assert_pending_withdrawal(delegator2_address, pool_address, true, 1, true, 10000000001);\n        // 9999999999 pending_inactive stake * 1.01\n        assert_pending_withdrawal(delegator1_address, pool_address, true, 2, true, 10099999998);\n\n        // withdraw inactive stake of delegator 2 left from lockup cycle 1 in cycle 3\n        withdraw(delegator2, pool_address, 10000000001);\n        assert!(coin::balance<AptosCoin>(delegator2_address) == 15149999998, 0);\n        assert_pending_withdrawal(delegator2_address, pool_address, false, 0, false, 0);\n\n        // withdraw inactive stake of delegator 1 left from previous lockup cycle\n        withdraw(delegator1, pool_address, 10099999998);\n        assert!(coin::balance<AptosCoin>(delegator1_address) == 15149999998 + 10099999998, 0);\n        assert_pending_withdrawal(delegator1_address, pool_address, false, 0, false, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, delegator2 = @0x020)]\n    public entry fun test_operator_fee(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        account::create_account_for_test(validator_address);\n\n        // create delegation pool of commission fee 12.65%\n        initialize_delegation_pool(validator, 1265, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(validator_address);\n        assert!(stake::get_operator(pool_address) == validator_address, 0);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n\n        stake::mint(delegator1, 100 * ONE_APT);\n        add_stake(delegator1, pool_address, 100 * ONE_APT);\n\n        stake::mint(delegator2, 200 * ONE_APT);\n        add_stake(delegator2, pool_address, 200 * ONE_APT);\n\n        // validator is inactive and added stake is instantly `active`\n        stake::assert_stake_pool(pool_address, 300 * ONE_APT, 0, 0, 0);\n\n        // validator does not produce rewards yet\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 300 * ONE_APT, 0, 0, 0);\n\n        // therefore, there are no operator commission rewards yet\n        assert_delegation(validator_address, pool_address, 0, 0, 0);\n\n        // activate validator\n        stake::rotate_consensus_key(validator, pool_address, CONSENSUS_KEY_1, CONSENSUS_POP_1);\n        stake::join_validator_set(validator, pool_address);\n        end_aptos_epoch();\n\n        // produce active rewards\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 30300000000, 0, 0, 0);\n\n        // 300000000 active rewards * 0.1265\n        assert_delegation(validator_address, pool_address, 37950000, 0, 0);\n        // 10000000000 active stake * (1 + 1% reward-rate * 0.8735)\n        assert_delegation(delegator1_address, pool_address, 10087350000, 0, 0);\n        // 20000000000 active stake * 1.008735\n        assert_delegation(delegator2_address, pool_address, 20174700000, 0, 0);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 30603000000, 0, 0, 0);\n\n        // 603000000 active rewards * 0.1265 instead of\n        // 303000000 active rewards * 0.1265 + 37950000 active stake * 1.008735\n        // because operator commission rewards are not automatically restaked compared to already owned stake\n        assert_delegation(validator_address, pool_address, 76279500, 0, 0);\n        // 10087350000 active stake * 1.008735 + some of the rewards of previous commission if restaked\n        assert_delegation(delegator1_address, pool_address, 10175573500, 0, 0);\n        // 20174700000 active stake * 1.008735 + some of the rewards of previous commission if restaked\n        assert_delegation(delegator2_address, pool_address, 20351147000, 0, 0);\n\n        // restake operator commission rewards\n        synchronize_delegation_pool(pool_address);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 30909030000, 0, 0, 0);\n\n        // 306030000 active rewards * 0.1265 + 76279500 active stake * 1.008735\n        assert_delegation(validator_address, pool_address, 115658596, 0, 0);\n        // 10175573500 active stake * 1.008735\n        assert_delegation(delegator1_address, pool_address, 10264457134, 0, 0);\n        // 20351147000 active stake * 1.008735\n        assert_delegation(delegator2_address, pool_address, 20528914269, 0, 0);\n\n        // check operator is rewarded by pending_inactive stake too\n        unlock(delegator2, pool_address, 100 * ONE_APT);\n        stake::assert_stake_pool(pool_address, 20909030001, 0, 0, 9999999999);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 21118120301, 0, 0, 10099999998);\n\n        assert_pending_withdrawal(validator_address, pool_address, false, 0, false, 0);\n        // distribute operator pending_inactive commission rewards\n        synchronize_delegation_pool(pool_address);\n        // 99999999 pending_inactive rewards * 0.1265\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, false, 12649998);\n\n        // 209090300 active rewards * 0.1265 + 115658596 active stake * 1.008735\n        // 99999999 pending_inactive rewards * 0.1265\n        assert_delegation(validator_address, pool_address, 143118796, 0, 12649998);\n        // 10264457134 active stake * 1.008735\n        assert_delegation(delegator1_address, pool_address, 10354117168, 0, 0);\n        // 10528914270 active stake * 1.008735\n        // 9999999999 pending_inactive stake * 1.008735\n        assert_delegation(delegator2_address, pool_address, 10620884336, 0, 10087349999);\n\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 21329301504, 10200999997, 0, 0);\n\n        // operator pending_inactive rewards on previous epoch have been inactivated\n        // 211181203 active rewards * 0.1265 + 143118796 active stake * 1.008735\n        // 100999999 pending_inactive rewards * 0.1265 + 12649998 pending_inactive stake * 1.008735\n        assert_delegation(validator_address, pool_address, 171083360, 25536995, 0);\n        // distribute operator pending_inactive commission rewards\n        synchronize_delegation_pool(pool_address);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, true, 25536995);\n\n        // check operator is not rewarded by `add_stake` fees\n        stake::mint(delegator1, 100 * ONE_APT);\n        assert!(get_add_stake_fee(pool_address, 100 * ONE_APT) > 0, 0);\n        add_stake(delegator1, pool_address, 100 * ONE_APT);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 31542594519, 10200999997, 0, 0);\n\n        // 213293015 active rewards * 0.1265 + 171083360 active stake * 1.008735\n        assert_delegation(validator_address, pool_address, 199559340, 25536995, 0);\n\n        // unlock some more stake to produce pending_inactive commission\n        // 10620884336 active stake * (1.008735 ^ 2 epochs)\n        // 10087349999 pending_inactive stake * 1.008735\n        assert_delegation(delegator2_address, pool_address, 10807241561, 10175463001, 0);\n        unlock(delegator2, pool_address, 100 * ONE_APT);\n        // 10807241561 - 100 APT < `MIN_COINS_ON_SHARES_POOL` thus active stake is entirely unlocked\n        assert_delegation(delegator2_address, pool_address, 0, 0, 10807241561);\n        end_aptos_epoch();\n\n        // in-flight pending_inactive commission can coexist with previous inactive commission\n        assert_delegation(validator_address, pool_address, 227532711, 25536996, 13671160);\n        assert_pending_withdrawal(validator_address, pool_address, true, 0, true, 25536996);\n\n        // distribute in-flight pending_inactive commission, implicitly executing the inactive withdrawal of operator\n        coin::register<AptosCoin>(validator);\n        synchronize_delegation_pool(pool_address);\n        assert!(coin::balance<AptosCoin>(validator_address) == 25536996, 0);\n\n        // in-flight commission has been synced, implicitly used to buy shares for operator\n        // expect operator stake to be slightly less than previously reported by `Self::get_stake`\n        assert_delegation(validator_address, pool_address, 227532711, 0, 13671159);\n        assert_pending_withdrawal(validator_address, pool_address, true, 1, false, 13671159);\n    }\n\n    #[test(aptos_framework = @aptos_framework, old_operator = @0x123, delegator = @0x010, new_operator = @0x020)]\n    public entry fun test_change_operator(\n        aptos_framework: &signer,\n        old_operator: &signer,\n        delegator: &signer,\n        new_operator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n\n        let old_operator_address = signer::address_of(old_operator);\n        account::create_account_for_test(old_operator_address);\n\n        let new_operator_address = signer::address_of(new_operator);\n        account::create_account_for_test(new_operator_address);\n\n        // create delegation pool of commission fee 12.65%\n        initialize_delegation_pool(old_operator, 1265, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(old_operator_address);\n        assert!(stake::get_operator(pool_address) == old_operator_address, 0);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        stake::mint(delegator, 200 * ONE_APT);\n        add_stake(delegator, pool_address, 200 * ONE_APT);\n        unlock(delegator, pool_address, 100 * ONE_APT);\n\n        // activate validator\n        stake::rotate_consensus_key(old_operator, pool_address, CONSENSUS_KEY_1, CONSENSUS_POP_1);\n        stake::join_validator_set(old_operator, pool_address);\n        end_aptos_epoch();\n\n        // produce active and pending_inactive rewards\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10100000000, 0, 0, 10100000000);\n        assert_delegation(old_operator_address, pool_address, 12650000, 0, 12650000);\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10201000000, 0, 0, 10201000000);\n        assert_delegation(old_operator_address, pool_address, 25426500, 0, 25426500);\n\n        // change operator\n        set_operator(old_operator, new_operator_address);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10303010000, 0, 0, 10303010000);\n        // 25426500 active stake * 1.008735 and 25426500 pending_inactive stake * 1.008735\n        assert_delegation(old_operator_address, pool_address, 25648600, 0, 25648600);\n        // 102010000 active rewards * 0.1265 and 102010000 pending_inactive rewards * 0.1265\n        assert_delegation(new_operator_address, pool_address, 12904265, 0, 12904265);\n\n        // restake `new_operator` commission rewards\n        synchronize_delegation_pool(pool_address);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10406040100, 0, 0, 10406040100);\n        // 25648600 active stake * 1.008735 and 25648600 pending_inactive stake * 1.008735\n        assert_delegation(old_operator_address, pool_address, 25872641, 0, 25872641);\n        // 103030100 active rewards * 0.1265 and 12904265 active stake * 1.008735\n        // 103030100 pending_inactive rewards * 0.1265 and 12904265 pending_inactive stake * 1.008735\n        assert_delegation(new_operator_address, pool_address, 26050290, 0, 26050290);\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        operator1 = @0x123,\n        delegator = @0x010,\n        beneficiary = @0x020,\n        operator2 = @0x030\n    )]\n    public entry fun test_set_beneficiary_for_operator(\n        aptos_framework: &signer,\n        operator1: &signer,\n        delegator: &signer,\n        beneficiary: &signer,\n        operator2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n\n        let operator1_address = signer::address_of(operator1);\n        aptos_account::create_account(operator1_address);\n\n        let operator2_address = signer::address_of(operator2);\n        aptos_account::create_account(operator2_address);\n\n        let beneficiary_address = signer::address_of(beneficiary);\n        aptos_account::create_account(beneficiary_address);\n\n        // create delegation pool of commission fee 12.65%\n        initialize_delegation_pool(operator1, 1265, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(operator1_address);\n        assert!(stake::get_operator(pool_address) == operator1_address, 0);\n        assert!(beneficiary_for_operator(operator1_address) == operator1_address, 0);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        stake::mint(delegator, 2000000 * ONE_APT);\n        add_stake(delegator, pool_address, 2000000 * ONE_APT);\n        unlock(delegator, pool_address, 1000000 * ONE_APT);\n\n        // activate validator\n        stake::rotate_consensus_key(operator1, pool_address, CONSENSUS_KEY_1, CONSENSUS_POP_1);\n        stake::join_validator_set(operator1, pool_address);\n        end_aptos_epoch();\n\n        // produce active and pending_inactive rewards\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 101000000000000, 0, 0, 101000000000000);\n        assert_delegation(operator1_address, pool_address, 126500000000, 0, 126500000000);\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 102010000000000, 0, 0, 102010000000000);\n        assert_delegation(operator1_address, pool_address, 254265000000, 0, 254265000000);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        withdraw(operator1, pool_address, ONE_APT);\n        assert!(coin::balance<AptosCoin>(operator1_address) == ONE_APT - 1, 0);\n\n        set_beneficiary_for_operator(operator1, beneficiary_address);\n        assert!(beneficiary_for_operator(operator1_address) == beneficiary_address, 0);\n        end_aptos_epoch();\n\n        unlock(beneficiary, pool_address, ONE_APT);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        withdraw(beneficiary, pool_address, ONE_APT);\n        assert!(coin::balance<AptosCoin>(beneficiary_address) == ONE_APT - 1, 0);\n        assert!(coin::balance<AptosCoin>(operator1_address) == ONE_APT - 1, 0);\n\n        // switch operator to operator2. The rewards should go to operator2 not to the beneficiay of operator1.\n        set_operator(operator1, operator2_address);\n        end_aptos_epoch();\n        unlock(operator2, pool_address, ONE_APT);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n\n        withdraw(operator2, pool_address, ONE_APT);\n        assert!(coin::balance<AptosCoin>(beneficiary_address) == ONE_APT - 1, 0);\n        assert!(coin::balance<AptosCoin>(operator2_address) == ONE_APT - 1, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, operator = @0x123, delegator = @0x010)]\n    public entry fun test_update_commission_percentage(\n        aptos_framework: &signer,\n        operator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n\n        let operator_address = signer::address_of(operator);\n        account::create_account_for_test(operator_address);\n\n        // create delegation pool of commission fee 12.65%\n        initialize_delegation_pool(operator, 1265, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(operator_address);\n        assert!(stake::get_operator(pool_address) == operator_address, 0);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        stake::mint(delegator, 200 * ONE_APT);\n        add_stake(delegator, pool_address, 200 * ONE_APT);\n        unlock(delegator, pool_address, 100 * ONE_APT);\n\n        // activate validator\n        stake::rotate_consensus_key(operator, pool_address, CONSENSUS_KEY_1, CONSENSUS_POP_1);\n        stake::join_validator_set(operator, pool_address);\n        end_aptos_epoch();\n\n        // produce active and pending_inactive rewards\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10100000000, 0, 0, 10100000000);\n        assert_delegation(operator_address, pool_address, 12650000, 0, 12650000);\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10201000000, 0, 0, 10201000000);\n        assert_delegation(operator_address, pool_address, 25426500, 0, 25426500);\n\n        // change the commission percentage\n        update_commission_percentage(operator, 2265);\n        // the new commission percentage does not take effect until the next lockup cycle.\n        assert!(operator_commission_percentage(pool_address) == 1265, 0);\n\n        // end the lockup cycle\n        fast_forward_to_unlock(pool_address);\n\n        // Test that the `get_add_stake_fee` correctly uses the new commission percentage, and returns the correct\n        // fee amount 76756290 in the following case, not 86593604 (calculated with the old commission rate).\n        assert!(get_add_stake_fee(pool_address, 100 * ONE_APT) == 76756290, 0);\n\n        synchronize_delegation_pool(pool_address);\n        // the commission percentage is updated to the new one.\n        assert!(operator_commission_percentage(pool_address) == 2265, 0);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10406040100, 10303010000, 0, 0);\n        assert_delegation(operator_address, pool_address, 62187388, 38552865, 0);\n\n        end_aptos_epoch();\n        stake::assert_stake_pool(pool_address, 10510100501, 10303010000, 0, 0);\n        assert_delegation(operator_address, pool_address, 86058258, 38552865, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, operator = @0x123, delegator = @0x010)]\n    #[expected_failure(abort_code = 196629, location = Self)]\n    public entry fun test_last_minute_commission_rate_change_failed(\n        aptos_framework: &signer,\n        operator: &signer,\n        delegator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n\n        let operator_address = signer::address_of(operator);\n        account::create_account_for_test(operator_address);\n\n        // create delegation pool of commission fee 12.65%\n        initialize_delegation_pool(operator, 1265, vector::empty<u8>());\n        let pool_address = get_owned_pool_address(operator_address);\n        assert!(stake::get_operator(pool_address) == operator_address, 0);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n\n        stake::mint(delegator, 200 * ONE_APT);\n        add_stake(delegator, pool_address, 200 * ONE_APT);\n        unlock(delegator, pool_address, 100 * ONE_APT);\n\n        // activate validator\n        stake::rotate_consensus_key(operator, pool_address, CONSENSUS_KEY_1, CONSENSUS_POP_1);\n        stake::join_validator_set(operator, pool_address);\n        end_aptos_epoch();\n\n        // 30 days are remaining in the lockup period.\n        update_commission_percentage(operator, 2215);\n        timestamp::fast_forward_seconds(7 * 24 * 60 * 60);\n        end_aptos_epoch();\n\n        // 23 days are remaining in the lockup period.\n        update_commission_percentage(operator, 2225);\n        timestamp::fast_forward_seconds(7 * 24 * 60 * 60);\n        end_aptos_epoch();\n\n        // 16 days are remaining in the lockup period.\n        update_commission_percentage(operator, 2235);\n        timestamp::fast_forward_seconds(7 * 24 * 60 * 60);\n        end_aptos_epoch();\n\n        // 9 days are remaining in the lockup period.\n        update_commission_percentage(operator, 2245);\n        timestamp::fast_forward_seconds(7 * 24 * 60 * 60);\n        end_aptos_epoch();\n\n        // 2 days are remaining in the lockup period. So, the following line is expected to fail.\n        update_commission_percentage(operator, 2255);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, delegator2 = @0x020)]\n    public entry fun test_min_stake_is_preserved(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n\n        // add stake without fees as validator is not active yet\n        stake::mint(delegator1, 50 * ONE_APT);\n        add_stake(delegator1, pool_address, 50 * ONE_APT);\n        stake::mint(delegator2, 16 * ONE_APT);\n        add_stake(delegator2, pool_address, 16 * ONE_APT);\n\n        // validator becomes active and share price is 1\n        end_aptos_epoch();\n\n        assert_delegation(delegator1_address, pool_address, 5000000000, 0, 0);\n        // pending_inactive balance would be under threshold => move MIN_COINS_ON_SHARES_POOL coins\n        unlock(delegator1, pool_address, MIN_COINS_ON_SHARES_POOL - 1);\n        assert_delegation(delegator1_address, pool_address, 3999999999, 0, 1000000001);\n\n        // pending_inactive balance is over threshold\n        reactivate_stake(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 4000000000, 0, 1000000000);\n\n        // pending_inactive balance would be under threshold => move entire balance\n        reactivate_stake(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 5000000000, 0, 0);\n\n        // active balance would be under threshold => move entire balance\n        unlock(delegator1, pool_address, 5000000000 - (MIN_COINS_ON_SHARES_POOL - 1));\n        assert_delegation(delegator1_address, pool_address, 0, 0, 5000000000);\n\n        // active balance would be under threshold => move MIN_COINS_ON_SHARES_POOL coins\n        reactivate_stake(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 1000000001, 0, 3999999999);\n\n        // active balance is over threshold\n        unlock(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 1000000000, 0, 4000000000);\n\n        // pending_inactive balance would be under threshold => move entire balance\n        reactivate_stake(delegator1, pool_address, 4000000000 - (MIN_COINS_ON_SHARES_POOL - 1));\n        assert_delegation(delegator1_address, pool_address, 5000000000, 0, 0);\n\n        // active + pending_inactive balance < 2 * MIN_COINS_ON_SHARES_POOL\n        // stake can live on only one of the shares pools\n        assert_delegation(delegator2_address, pool_address, 16 * ONE_APT, 0, 0);\n        unlock(delegator2, pool_address, 1);\n        assert_delegation(delegator2_address, pool_address, 0, 0, 16 * ONE_APT);\n        reactivate_stake(delegator2, pool_address, 1);\n        assert_delegation(delegator2_address, pool_address, 16 * ONE_APT, 0, 0);\n\n        unlock(delegator2, pool_address, ONE_APT);\n        assert_delegation(delegator2_address, pool_address, 0, 0, 16 * ONE_APT);\n        reactivate_stake(delegator2, pool_address, 2 * ONE_APT);\n        assert_delegation(delegator2_address, pool_address, 16 * ONE_APT, 0, 0);\n\n        // share price becomes 1.01 on both pools\n        unlock(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 3999999999, 0, 1000000001);\n        end_aptos_epoch();\n        assert_delegation(delegator1_address, pool_address, 4039999998, 0, 1010000001);\n\n        // pending_inactive balance is over threshold\n        reactivate_stake(delegator1, pool_address, 10000001);\n        assert_delegation(delegator1_address, pool_address, 4049999998, 0, 1000000001);\n\n        // 1 coin < 1.01 so no shares are redeemed\n        reactivate_stake(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 4049999998, 0, 1000000001);\n\n        // pending_inactive balance is over threshold\n        // requesting 2 coins actually redeems 1 coin from pending_inactive pool\n        reactivate_stake(delegator1, pool_address, 2);\n        assert_delegation(delegator1_address, pool_address, 4049999999, 0, 1000000000);\n\n        // 1 coin < 1.01 so no shares are redeemed\n        reactivate_stake(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 4049999999, 0, 1000000000);\n\n        // pending_inactive balance would be under threshold => move entire balance\n        reactivate_stake(delegator1, pool_address, 2);\n        assert_delegation(delegator1_address, pool_address, 5049999999, 0, 0);\n\n        // pending_inactive balance would be under threshold => move MIN_COINS_ON_SHARES_POOL coins\n        unlock(delegator1, pool_address, MIN_COINS_ON_SHARES_POOL - 1);\n        assert_delegation(delegator1_address, pool_address, 4049999998, 0, 1000000000);\n\n        // pending_inactive balance would be under threshold => move entire balance\n        reactivate_stake(delegator1, pool_address, 1);\n        assert_delegation(delegator1_address, pool_address, 5049999998, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010)]\n    #[expected_failure(abort_code = 0x1000f, location = Self)]\n    public entry fun test_create_proposal_abort_if_inefficient_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        // delegator2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        aptos_governance::initialize_for_test(\n            aptos_framework,\n            (10 * ONE_APT as u128),\n            100 * ONE_APT,\n            1000,\n        );\n        aptos_governance::initialize_partial_voting(aptos_framework);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]);\n        initialize_test_validator(validator, 100 * ONE_APT, true, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        // Delegation pool is created after partial governance voting feature flag is enabled. So this delegation\n        // pool is created with partial governance voting enabled.\n        assert!(stake::get_delegated_voter(pool_address) == pool_address, 1);\n        assert!(partial_governance_voting_enabled(pool_address), 2);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        stake::mint(delegator1, 100 * ONE_APT);\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n        end_aptos_epoch();\n\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        create_proposal(\n            delegator1,\n            pool_address,\n            execution_hash,\n            b\"\",\n            b\"\",\n            true,\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010)]\n    public entry fun test_create_proposal_with_sufficient_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        aptos_governance::initialize_for_test(\n            aptos_framework,\n            (10 * ONE_APT as u128),\n            100 * ONE_APT,\n            1000,\n        );\n        aptos_governance::initialize_partial_voting(aptos_framework);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]);\n        initialize_test_validator(validator, 100 * ONE_APT, true, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        // Delegation pool is created after partial governance voting feature flag is enabled. So this delegation\n        // pool is created with partial governance voting enabled.\n        assert!(stake::get_delegated_voter(pool_address) == pool_address, 1);\n        assert!(partial_governance_voting_enabled(pool_address), 2);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        stake::mint(delegator1, 100 * ONE_APT);\n        add_stake(delegator1, pool_address, 100 * ONE_APT);\n        end_aptos_epoch();\n\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        create_proposal(\n            delegator1,\n            pool_address,\n            execution_hash,\n            b\"\",\n            b\"\",\n            true,\n        );\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        validator = @0x123,\n        delegator1 = @0x010,\n        delegator2 = @0x020,\n        voter1 = @0x030,\n        voter2 = @0x040\n    )]\n    public entry fun test_voting_power_change(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n        voter1: &signer,\n        voter2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test_no_reward(aptos_framework);\n        aptos_governance::initialize_for_test(\n            aptos_framework,\n            (10 * ONE_APT as u128),\n            100 * ONE_APT,\n            1000,\n        );\n        aptos_governance::initialize_partial_voting(aptos_framework);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]\n        );\n\n        initialize_test_validator(validator, 100 * ONE_APT, true, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        // Delegation pool is created after partial governance voting feature flag is enabled. So this delegation\n        // pool is created with partial governance voting enabled.\n        assert!(stake::get_delegated_voter(pool_address) == pool_address, 1);\n        assert!(partial_governance_voting_enabled(pool_address), 1);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n        let voter1_address = signer::address_of(voter1);\n        account::create_account_for_test(voter1_address);\n        let voter2_address = signer::address_of(voter2);\n        account::create_account_for_test(voter2_address);\n\n        stake::mint(delegator1, 110 * ONE_APT);\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n        stake::mint(delegator2, 110 * ONE_APT);\n        add_stake(delegator2, pool_address, 90 * ONE_APT);\n        // By default, the voter of a delegator is itself.\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        end_aptos_epoch();\n        // Reward rate is 0. No reward so no voting power change.\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        // Delegator1 delegates its voting power to voter1 but it takes 1 lockup cycle to take effects. So no voting power\n        // change now.\n        delegate_voting_power(delegator1, pool_address, voter1_address);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        // 1 epoch passed but the lockup cycle hasn't ended. No voting power change.\n        end_aptos_epoch();\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        // One cycle passed. The voter change takes effects.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        // Delegator2 delegates its voting power to voter1 but it takes 1 lockup cycle to take effects. So no voting power\n        // change now.\n        delegate_voting_power(delegator2, pool_address, voter1_address);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        // One cycle passed. The voter change takes effects.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        assert!(calculate_and_update_delegator_voter(pool_address, delegator2_address) == voter1_address, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n\n        // delegator1 changes to voter2 then change back. delegator2 changes to voter1.\n        // No voting power change in this lockup cycle.\n        delegate_voting_power(delegator1, pool_address, voter2_address);\n        delegate_voting_power(delegator2, pool_address, voter2_address);\n        delegate_voting_power(delegator1, pool_address, voter1_address);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n\n        // One cycle passed. The voter change takes effects.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        assert!(calculate_and_update_delegator_voter(pool_address, delegator1_address) == voter1_address, 1);\n        assert!(calculate_and_update_delegator_voter(pool_address, delegator2_address) == voter2_address, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 90 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n\n        // delegator1 adds stake to the pool. Voting power changes immediately.\n        add_stake(delegator1, pool_address, 90 * ONE_APT);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 90 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n\n        // delegator1 unlocks stake and changes its voter. No voting power change until next lockup cycle.\n        unlock(delegator1, pool_address, 90 * ONE_APT);\n        delegate_voting_power(delegator1, pool_address, voter2_address);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 90 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n\n        // One cycle passed. The voter change takes effects.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        // Withdrawl inactive shares will not change voting power.\n        withdraw(delegator1, pool_address, 45 * ONE_APT);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n\n        // voter2 adds stake for itself. Voting power changes immediately.\n        stake::mint(voter2, 110 * ONE_APT);\n        add_stake(voter2, pool_address, 10 * ONE_APT);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 110 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, voter1 = @0x030)]\n    public entry fun test_voting_power_change_for_existing_delegation_pool(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        voter1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test_no_reward(aptos_framework);\n        aptos_governance::initialize_for_test(\n            aptos_framework,\n            (10 * ONE_APT as u128),\n            100 * ONE_APT,\n            1000,\n        );\n        aptos_governance::initialize_partial_voting(aptos_framework);\n\n        initialize_test_validator(validator, 100 * ONE_APT, true, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        // Delegation pool is created before partial governance voting feature flag is enabled. So this delegation\n        // pool's voter is its owner.\n        assert!(stake::get_delegated_voter(pool_address) == validator_address, 1);\n        assert!(!partial_governance_voting_enabled(pool_address), 1);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        let voter1_address = signer::address_of(voter1);\n        account::create_account_for_test(voter1_address);\n\n        stake::mint(delegator1, 110 * ONE_APT);\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n\n        // Enable partial governance voting feature flag.\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]\n        );\n        // Voter doens't change until enabling partial governance voting on this delegation pool.\n        assert!(stake::get_delegated_voter(pool_address) == validator_address, 1);\n        // Enable partial governance voting on this delegation pool.\n        enable_partial_governance_voting(pool_address);\n        assert!(stake::get_delegated_voter(pool_address) == pool_address, 1);\n        assert!(partial_governance_voting_enabled(pool_address), 1);\n\n        // By default, the voter of a delegator is itself.\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n\n        // Delegator1 delegates its voting power to voter1.\n        // It takes 1 cycle to take effect. No immediate change.\n        delegate_voting_power(delegator1, pool_address, voter1_address);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n\n        // One cycle passed. The voter change takes effects.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        validator = @0x123,\n        delegator1 = @0x010,\n        delegator2 = @0x020,\n        voter1 = @0x030,\n        voter2 = @0x040\n    )]\n    public entry fun test_voting_power_change_for_rewards(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n        voter1: &signer,\n        voter2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test_custom(\n            aptos_framework,\n            100 * ONE_APT,\n            10000 * ONE_APT,\n            LOCKUP_CYCLE_SECONDS,\n            true,\n            100,\n            100,\n            1000000\n        );\n        aptos_governance::initialize_for_test(\n            aptos_framework,\n            (10 * ONE_APT as u128),\n            100 * ONE_APT,\n            1000,\n        );\n        aptos_governance::initialize_partial_voting(aptos_framework);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]\n        );\n\n        // 50% commission rate\n        initialize_test_validator_custom(validator, 100 * ONE_APT, true, false, 5000);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        // Delegation pool is created after partial governance voting feature flag is enabled. So this delegation\n        // pool is created with partial governance voting enabled.\n        assert!(stake::get_delegated_voter(pool_address) == pool_address, 1);\n        assert!(partial_governance_voting_enabled(pool_address), 1);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n        let voter1_address = signer::address_of(voter1);\n        account::create_account_for_test(voter1_address);\n        let voter2_address = signer::address_of(voter2);\n        account::create_account_for_test(voter2_address);\n\n        stake::mint(delegator1, 110 * ONE_APT);\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n        stake::mint(delegator2, 110 * ONE_APT);\n        add_stake(delegator2, pool_address, 90 * ONE_APT);\n        // By default, the voter of a delegator is itself.\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, validator_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        // One epoch is passed. Delegators earn no reward because their stake was inactive.\n        end_aptos_epoch();\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, validator_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n\n        // 2 epoches are passed. Delegators earn reward and voting power increases. Operator earns reward and\n        // commission. Because there is no operation during these 2 epoches. Operator's commission is not compounded.\n        end_aptos_epoch();\n        end_aptos_epoch();\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, validator_address) == 550 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 25 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 225 * ONE_APT, 1);\n\n        // Another epoch is passed. Voting power chage due to reward is correct even if delegator1 and delegator2 change its voter.\n        delegate_voting_power(delegator1, pool_address, voter1_address);\n        delegate_voting_power(delegator2, pool_address, voter1_address);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_aptos_epoch();\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, validator_address) == 122499999999, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 375 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 0, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 0, 1);\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        validator = @0x123,\n        delegator1 = @0x010,\n        delegator2 = @0x020,\n        voter1 = @0x030,\n        voter2 = @0x040\n    )]\n    public entry fun test_voting_power_change_already_voted_before_partial(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        delegator2: &signer,\n        voter1: &signer,\n        voter2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        // partial voing hasn't been enabled yet. A proposal has been created by the validator.\n        let proposal1_id = setup_vote(aptos_framework, validator, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        let delegator2_address = signer::address_of(delegator2);\n        account::create_account_for_test(delegator2_address);\n        let voter1_address = signer::address_of(voter1);\n        account::create_account_for_test(voter1_address);\n        let voter2_address = signer::address_of(voter2);\n        account::create_account_for_test(voter2_address);\n\n        stake::mint(delegator1, 110 * ONE_APT);\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n        stake::mint(delegator2, 110 * ONE_APT);\n        add_stake(delegator2, pool_address, 90 * ONE_APT);\n\n        // Create 2 proposals and vote for proposal1.\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let proposal2_id = aptos_governance::create_proposal_v2_impl(\n            validator,\n            pool_address,\n            execution_hash,\n            b\"\",\n            b\"\",\n            true,\n        );\n        aptos_governance::vote(validator, pool_address, proposal1_id, true);\n\n        // Enable partial governance voting feature flag.\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]\n        );\n        // Voter doens't change until enabling partial governance voting on this delegation pool.\n        assert!(stake::get_delegated_voter(pool_address) == validator_address, 1);\n        // Enable partial governance voting on this delegation pool.\n        enable_partial_governance_voting(pool_address);\n        assert!(stake::get_delegated_voter(pool_address) == pool_address, 1);\n        assert!(partial_governance_voting_enabled(pool_address), 1);\n\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, validator_address) == 100 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 10 * ONE_APT, 1);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator2_address) == 90 * ONE_APT, 1);\n        // No one can vote for proposal1 because it's already voted before enabling partial governance voting.\n        assert!(calculate_and_update_remaining_voting_power(pool_address, validator_address, proposal1_id) == 0, 1);\n        assert!(calculate_and_update_remaining_voting_power(pool_address, delegator1_address, proposal1_id) == 0, 1);\n        assert!(calculate_and_update_remaining_voting_power(pool_address, delegator2_address, proposal1_id) == 0, 1);\n        assert!(\n            calculate_and_update_remaining_voting_power(pool_address, validator_address, proposal2_id) == 100 * ONE_APT,\n            1\n        );\n        assert!(\n            calculate_and_update_remaining_voting_power(pool_address, delegator1_address, proposal2_id) == 10 * ONE_APT,\n            1\n        );\n        assert!(\n            calculate_and_update_remaining_voting_power(pool_address, delegator2_address, proposal2_id) == 90 * ONE_APT,\n            1\n        );\n\n        // Delegator1 tries to use 50 APT to vote on proposal2, but it only has 10 APT. So only 10 APT voting power is used.\n        vote(delegator1, pool_address, proposal2_id, 50 * ONE_APT, true);\n        assert!(calculate_and_update_remaining_voting_power(pool_address, delegator1_address, proposal2_id) == 0, 1);\n\n        add_stake(delegator1, pool_address, 60 * ONE_APT);\n        assert!(calculate_and_update_voter_total_voting_power(pool_address, delegator1_address) == 70 * ONE_APT, 1);\n        vote(delegator1, pool_address, proposal2_id, 25 * ONE_APT, true);\n        assert!(\n            calculate_and_update_remaining_voting_power(pool_address, delegator1_address, proposal2_id) == 35 * ONE_APT,\n            1\n        );\n        vote(delegator1, pool_address, proposal2_id, 30 * ONE_APT, false);\n        assert!(\n            calculate_and_update_remaining_voting_power(pool_address, delegator1_address, proposal2_id) == 5 * ONE_APT,\n            1\n        );\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, voter1 = @0x030)]\n    #[expected_failure(abort_code = 0x10010, location = Self)]\n    public entry fun test_vote_should_failed_if_already_voted_before_enable_partial_voting_flag(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        voter1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        // partial voing hasn't been enabled yet. A proposal has been created by the validator.\n        let proposal1_id = setup_vote(aptos_framework, validator, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        let voter1_address = signer::address_of(voter1);\n        account::create_account_for_test(voter1_address);\n\n        stake::mint(delegator1, 110 * ONE_APT);\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n        end_aptos_epoch();\n\n        aptos_governance::vote(validator, pool_address, proposal1_id, true);\n\n        // Enable partial governance voting feature flag.\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]\n        );\n        // Enable partial governance voting on this delegation pool.\n        enable_partial_governance_voting(pool_address);\n\n        vote(delegator1, pool_address, proposal1_id, 10 * ONE_APT, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, voter1 = @0x030)]\n    #[expected_failure(abort_code = 0x10011, location = Self)]\n    public entry fun test_vote_should_failed_if_already_voted_before_enable_partial_voting_on_pool(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        voter1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        // partial voing hasn't been enabled yet. A proposal has been created by the validator.\n        let proposal1_id = setup_vote(aptos_framework, validator, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n        let voter1_address = signer::address_of(voter1);\n        account::create_account_for_test(voter1_address);\n\n        stake::mint(delegator1, 110 * ONE_APT);\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n        end_aptos_epoch();\n\n        // Enable partial governance voting feature flag.\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[features::get_partial_governance_voting(), features::get_delegation_pool_partial_governance_voting(\n            )],\n            vector[]\n        );\n\n        // The operator voter votes on the proposal after partial governace voting flag is enabled but before partial voting is enabled on the pool.\n        aptos_governance::vote(validator, pool_address, proposal1_id, true);\n\n        // Enable partial governance voting on this delegation pool.\n        enable_partial_governance_voting(pool_address);\n\n        add_stake(delegator1, pool_address, 10 * ONE_APT);\n        vote(delegator1, pool_address, proposal1_id, 10 * ONE_APT, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010)]\n    #[expected_failure(abort_code = 0x10010, location = Self)]\n    public entry fun test_vote_should_failed_if_no_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        // partial voing hasn't been enabled yet. A proposal has been created by the validator.\n        let proposal1_id = setup_vote(aptos_framework, validator, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n\n        // Delegator1 has no stake. Abort.\n        vote(delegator1, pool_address, proposal1_id, 10 * ONE_APT, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator1 = @0x010, voter1 = @0x030)]\n    public entry fun test_delegate_voting_power_should_pass_even_if_no_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator1: &signer,\n        voter1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        // partial voing hasn't been enabled yet. A proposal has been created by the validator.\n        setup_vote(aptos_framework, validator, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        let delegator1_address = signer::address_of(delegator1);\n        account::create_account_for_test(delegator1_address);\n\n        // Delegator1 has no stake. Abort.\n        delegate_voting_power(delegator1, pool_address, signer::address_of(voter1));\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        validator = @0x123,\n        delegator = @0x010,\n        voter1 = @0x020,\n        voter2 = @0x030\n    )]\n    public entry fun test_delegate_voting_power_applies_next_lockup(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator: &signer,\n        voter1: &signer,\n        voter2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        aptos_governance::initialize_partial_voting(aptos_framework);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[\n                features::get_partial_governance_voting(),\n                features::get_delegation_pool_partial_governance_voting()\n            ],\n            vector[]\n        );\n\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n        let voter1_address = signer::address_of(voter1);\n        let voter2_address = signer::address_of(voter2);\n\n        stake::mint(delegator, 100 * ONE_APT);\n        add_stake(delegator, pool_address, 20 * ONE_APT);\n\n        let first_lockup_end = stake::get_lockup_secs(pool_address);\n        // default voter is the delegator\n        let (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == delegator_address, 0);\n        assert!(pending_voter == delegator_address, 0);\n        assert!(last_locked_until_secs == first_lockup_end, 0);\n\n        // delegate to voter 1 which takes effect next lockup\n        delegate_voting_power(delegator, pool_address, voter1_address);\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == delegator_address, 0);\n        assert!(pending_voter == voter1_address, 0);\n        assert!(last_locked_until_secs == first_lockup_end, 0);\n        assert!(\n            calculate_and_update_voter_total_voting_power(\n                pool_address,\n                delegator_address\n            ) == 20 * ONE_APT - get_add_stake_fee(pool_address, 20 * ONE_APT),\n            0\n        );\n\n        // end this lockup cycle\n        fast_forward_to_unlock(pool_address);\n        let second_lockup_end = stake::get_lockup_secs(pool_address);\n        assert!(second_lockup_end > first_lockup_end, 0);\n\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        // voter 1 becomes current voter and owns all voting power of delegator\n        assert!(voter == voter1_address, 0);\n        assert!(pending_voter == voter1_address, 0);\n        assert!(last_locked_until_secs == second_lockup_end, 0);\n        assert!(\n            calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 20 * ONE_APT,\n            0\n        );\n\n        // delegate to voter 2, current voter should still be voter 1\n        delegate_voting_power(delegator, pool_address, voter2_address);\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == voter1_address, 0);\n        assert!(pending_voter == voter2_address, 0);\n        assert!(last_locked_until_secs == second_lockup_end, 0);\n        assert!(\n            calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 20 * ONE_APT,\n            0\n        );\n\n        // stake added by delegator counts as voting power for the current voter\n        add_stake(delegator, pool_address, 30 * ONE_APT);\n        assert!(\n            calculate_and_update_voter_total_voting_power(\n                pool_address,\n                voter1_address\n            ) == 20 * ONE_APT + 30 * ONE_APT - get_add_stake_fee(pool_address, 30 * ONE_APT),\n            0\n        );\n\n        // refunded `add_stake` fee is counted as voting power too\n        end_aptos_epoch();\n        assert!(\n            calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 5020000000,\n            0\n        );\n\n        // delegator can unlock their entire stake (all voting shares are owned by voter 1)\n        unlock(delegator, pool_address, 5020000000);\n        assert!(\n            calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 5020000000,\n            0\n        );\n\n        // delegator can reactivate their entire stake (all voting shares are owned by voter 1)\n        reactivate_stake(delegator, pool_address, 5020000000);\n        assert!(\n            calculate_and_update_voter_total_voting_power(pool_address, voter1_address) == 5019999999,\n            0\n        );\n\n        // end this lockup cycle\n        fast_forward_to_unlock(pool_address);\n        let third_lockup_end = stake::get_lockup_secs(pool_address);\n        assert!(third_lockup_end > second_lockup_end, 0);\n\n        // voter 2 becomes current voter and owns all voting power of delegator\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == voter2_address, 0);\n        assert!(pending_voter == voter2_address, 0);\n        assert!(last_locked_until_secs == third_lockup_end, 0);\n        assert!(\n            calculate_and_update_voter_total_voting_power(pool_address, voter2_address) == 5070199999,\n            0\n        );\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        validator = @0x123,\n        validator_min_consensus = @0x234,\n        delegator = @0x010,\n        voter1 = @0x020,\n        voter2 = @0x030\n    )]\n    public entry fun test_delegate_voting_power_from_inactive_validator(\n        aptos_framework: &signer,\n        validator: &signer,\n        validator_min_consensus: &signer,\n        delegator: &signer,\n        voter1: &signer,\n        voter2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        aptos_governance::initialize_partial_voting(aptos_framework);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[\n                features::get_partial_governance_voting(),\n                features::get_delegation_pool_partial_governance_voting()\n            ],\n            vector[]\n        );\n\n        // activate more validators in order to inactivate one later\n        initialize_test_validator(validator, 100 * ONE_APT, true, false);\n        initialize_test_validator(validator_min_consensus, 100 * ONE_APT, true, true);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_address = signer::address_of(delegator);\n        account::create_account_for_test(delegator_address);\n        let voter1_address = signer::address_of(voter1);\n        let voter2_address = signer::address_of(voter2);\n\n        let first_lockup_end = stake::get_lockup_secs(pool_address);\n        let (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == delegator_address, 0);\n        assert!(pending_voter == delegator_address, 0);\n        assert!(last_locked_until_secs == first_lockup_end, 0);\n\n        delegate_voting_power(delegator, pool_address, voter1_address);\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == delegator_address, 0);\n        assert!(pending_voter == voter1_address, 0);\n        assert!(last_locked_until_secs == first_lockup_end, 0);\n\n        // end this lockup cycle\n        fast_forward_to_unlock(pool_address);\n        let second_lockup_end = stake::get_lockup_secs(pool_address);\n        assert!(second_lockup_end > first_lockup_end, 0);\n\n        // voter 1 becomes current voter\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == voter1_address, 0);\n        assert!(pending_voter == voter1_address, 0);\n        assert!(last_locked_until_secs == second_lockup_end, 0);\n\n        // delegate to voter 2 which should apply next lockup\n        delegate_voting_power(delegator, pool_address, voter2_address);\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == voter1_address, 0);\n        assert!(pending_voter == voter2_address, 0);\n        assert!(last_locked_until_secs == second_lockup_end, 0);\n\n        // lockup cycle won't be refreshed on the pool anymore\n        stake::leave_validator_set(validator, pool_address);\n        end_aptos_epoch();\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE, 0);\n\n        // lockup cycle passes, but validator has no lockup refresh because it is inactive\n        fast_forward_to_unlock(pool_address);\n        assert!(second_lockup_end == stake::get_lockup_secs(pool_address), 0);\n        assert!(second_lockup_end <= reconfiguration::last_reconfiguration_time(), 0);\n\n        // pending voter 2 is not applied\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == voter1_address, 0);\n        assert!(pending_voter == voter2_address, 0);\n        assert!(last_locked_until_secs == second_lockup_end, 0);\n\n        // reactivate validator\n        stake::join_validator_set(validator, pool_address);\n        end_aptos_epoch();\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 0);\n\n        // lockup cycle of pool has been refreshed again\n        let third_lockup_end = stake::get_lockup_secs(pool_address);\n        assert!(third_lockup_end > second_lockup_end, 0);\n\n        // voter 2 finally becomes current voter\n        (voter, pending_voter, last_locked_until_secs) = calculate_and_update_voting_delegation(\n            pool_address,\n            delegator_address\n        );\n        assert!(voter == voter2_address, 0);\n        assert!(pending_voter == voter2_address, 0);\n        assert!(last_locked_until_secs == third_lockup_end, 0);\n    }\n\n    #[test(staker = @0xe256f4f4e2986cada739e339895cf5585082ff247464cab8ec56eea726bd2263)]\n    public entry fun test_get_expected_stake_pool_address(staker: address) {\n        let pool_address = get_expected_stake_pool_address(staker, vector[0x42, 0x42]);\n        assert!(pool_address == @0xe9fc2fbb82b7e1cb7af3daef8c7a24e66780f9122d15e4f1d486ee7c7c36c48d, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x30017, location = Self)]\n    public entry fun test_delegators_allowlisting_not_supported(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        features::change_feature_flags_for_testing(\n            aptos_framework,\n            vector[],\n            vector[features::get_delegation_pool_allowlisting_feature()],\n        );\n\n        enable_delegators_allowlisting(validator);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x30018, location = Self)]\n    public entry fun test_cannot_disable_allowlisting_if_already_off(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n\n        let pool_address = get_owned_pool_address(signer::address_of(validator));\n        assert!(!allowlisting_enabled(pool_address), 0);\n\n        disable_delegators_allowlisting(validator);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010)]\n    #[expected_failure(abort_code = 0x30018, location = Self)]\n    public entry fun test_cannot_allowlist_delegator_if_allowlisting_disabled(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n\n        let pool_address = get_owned_pool_address(signer::address_of(validator));\n        assert!(!allowlisting_enabled(pool_address), 0);\n\n        allowlist_delegator(validator, signer::address_of(delegator_1));\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010)]\n    #[expected_failure(abort_code = 0x30018, location = Self)]\n    public entry fun test_cannot_remove_delegator_from_allowlist_if_allowlisting_disabled(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n\n        let pool_address = get_owned_pool_address(signer::address_of(validator));\n        assert!(!allowlisting_enabled(pool_address), 0);\n\n        remove_delegator_from_allowlist(validator, signer::address_of(delegator_1));\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010)]\n    #[expected_failure(abort_code = 0x30018, location = Self)]\n    public entry fun test_cannot_evict_delegator_if_allowlisting_disabled(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n\n        let pool_address = get_owned_pool_address(signer::address_of(validator));\n        assert!(!allowlisting_enabled(pool_address), 0);\n\n        evict_delegator(validator, signer::address_of(delegator_1));\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010, delegator_2 = @0x020)]\n    public entry fun test_allowlist_operations_only_e2e(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n        delegator_2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        enable_delegation_pool_allowlisting_feature(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        let delegator_1_address = signer::address_of(delegator_1);\n        let delegator_2_address = signer::address_of(delegator_2);\n\n        // any address is allowlisted if allowlist is not created\n        assert!(!allowlisting_enabled(pool_address), 0);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(delegator_allowlisted(pool_address, delegator_2_address), 0);\n\n        // no address is allowlisted when allowlist is empty\n        enable_delegators_allowlisting(validator);\n        assert!(!delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_2_address), 0);\n        let allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 0, 0);\n\n        allowlist_delegator(validator, delegator_1_address);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_2_address), 0);\n        allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 1 && vector::contains(allowlist, &delegator_1_address), 0);\n\n        allowlist_delegator(validator, delegator_2_address);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(delegator_allowlisted(pool_address, delegator_2_address), 0);\n        allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 2 &&\n            vector::contains(allowlist, &delegator_1_address) &&\n            vector::contains(allowlist, &delegator_2_address),\n            0\n        );\n\n        remove_delegator_from_allowlist(validator, delegator_2_address);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_2_address), 0);\n        allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 1 && vector::contains(allowlist, &delegator_1_address), 0);\n\n        // destroy the allowlist constructed so far\n        disable_delegators_allowlisting(validator);\n        assert!(!allowlisting_enabled(pool_address), 0);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(delegator_allowlisted(pool_address, delegator_2_address), 0);\n\n        enable_delegators_allowlisting(validator);\n        assert!(!delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_2_address), 0);\n\n        allowlist_delegator(validator, delegator_2_address);\n        assert!(!delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(delegator_allowlisted(pool_address, delegator_2_address), 0);\n        allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 1 && vector::contains(allowlist, &delegator_2_address), 0);\n\n        // allowlist does not ever have duplicates\n        allowlist_delegator(validator, delegator_2_address);\n        allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 1 && vector::contains(allowlist, &delegator_2_address), 0);\n\n        // no override of existing allowlist when enabling allowlisting again\n        enable_delegators_allowlisting(validator);\n        allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 1 && vector::contains(allowlist, &delegator_2_address), 0);\n\n        // nothing changes when trying to remove an inexistent delegator\n        remove_delegator_from_allowlist(validator, delegator_1_address);\n        allowlist = &get_delegators_allowlist(pool_address);\n        assert!(vector::length(allowlist) == 1 && vector::contains(allowlist, &delegator_2_address), 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010)]\n    #[expected_failure(abort_code = 0x3001a, location = Self)]\n    public entry fun test_cannot_evict_explicitly_allowlisted_delegator(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        enable_delegation_pool_allowlisting_feature(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        enable_delegators_allowlisting(validator);\n        assert!(allowlisting_enabled(pool_address), 0);\n\n        let delegator_1_address = signer::address_of(delegator_1);\n        allowlist_delegator(validator, delegator_1_address);\n\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n        evict_delegator(validator, delegator_1_address);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010)]\n    #[expected_failure(abort_code = 0x1001b, location = Self)]\n    public entry fun test_cannot_evict_null_address(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        enable_delegation_pool_allowlisting_feature(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_1_address = signer::address_of(delegator_1);\n        account::create_account_for_test(delegator_1_address);\n\n        // add some active shares to NULL_SHAREHOLDER from `add_stake` fee\n        stake::mint(delegator_1, 50 * ONE_APT);\n        add_stake(delegator_1, pool_address, 50 * ONE_APT);\n        assert!(get_delegator_active_shares(borrow_global<DelegationPool>(pool_address), NULL_SHAREHOLDER) != 0, 0);\n\n        enable_delegators_allowlisting(validator);\n        evict_delegator(validator, NULL_SHAREHOLDER);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010)]\n    #[expected_failure(abort_code = 0x50019, location = Self)]\n    public entry fun test_cannot_add_stake_if_not_allowlisted(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        enable_delegation_pool_allowlisting_feature(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_1_address = signer::address_of(delegator_1);\n        account::create_account_for_test(delegator_1_address);\n\n        // allowlisting not enabled yet\n        assert!(!allowlisting_enabled(pool_address), 0);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n\n        stake::mint(delegator_1, 30 * ONE_APT);\n        add_stake(delegator_1, pool_address, 20 * ONE_APT);\n\n        end_aptos_epoch();\n        assert_delegation(delegator_1_address, pool_address, 20 * ONE_APT, 0, 0);\n\n        // allowlist is created but has no address added\n        enable_delegators_allowlisting(validator);\n        assert!(allowlisting_enabled(pool_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_1_address), 0);\n\n        add_stake(delegator_1, pool_address, 10 * ONE_APT);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010)]\n    #[expected_failure(abort_code = 0x50019, location = Self)]\n    public entry fun test_cannot_reactivate_stake_if_not_allowlisted(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        enable_delegation_pool_allowlisting_feature(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_1_address = signer::address_of(delegator_1);\n        account::create_account_for_test(delegator_1_address);\n\n        // allowlist is created but has no address added\n        enable_delegators_allowlisting(validator);\n        // allowlist delegator\n        allowlist_delegator(validator, delegator_1_address);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n\n        // delegator is allowed to add stake\n        stake::mint(delegator_1, 50 * ONE_APT);\n        add_stake(delegator_1, pool_address, 50 * ONE_APT);\n\n        // restore `add_stake` fee back to delegator\n        end_aptos_epoch();\n        assert_delegation(delegator_1_address, pool_address, 50 * ONE_APT, 0, 0);\n\n        // some of the stake is unlocked by the delegator\n        unlock(delegator_1, pool_address, 30 * ONE_APT);\n        assert_delegation(delegator_1_address, pool_address, 20 * ONE_APT, 0, 2999999999);\n\n        // remove delegator from allowlist\n        remove_delegator_from_allowlist(validator, delegator_1_address);\n        assert!(!delegator_allowlisted(pool_address, delegator_1_address), 0);\n\n        // remaining stake is unlocked by the pool owner by evicting the delegator\n        evict_delegator(validator, delegator_1_address);\n        assert_delegation(delegator_1_address, pool_address, 0, 0, 4999999999);\n\n        // delegator cannot reactivate stake\n        reactivate_stake(delegator_1, pool_address, 50 * ONE_APT);\n        assert_delegation(delegator_1_address, pool_address, 0, 0, 4999999999);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, delegator_1 = @0x010, delegator_2 = @0x020)]\n    public entry fun test_delegation_pool_allowlisting_e2e(\n        aptos_framework: &signer,\n        validator: &signer,\n        delegator_1: &signer,\n        delegator_2: &signer,\n    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test(aptos_framework);\n        initialize_test_validator(validator, 100 * ONE_APT, true, true);\n        enable_delegation_pool_allowlisting_feature(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n\n        let delegator_1_address = signer::address_of(delegator_1);\n        account::create_account_for_test(delegator_1_address);\n        let delegator_2_address = signer::address_of(delegator_2);\n        account::create_account_for_test(delegator_2_address);\n\n        // add stake while allowlisting is disabled\n        assert!(!allowlisting_enabled(pool_address), 0);\n        stake::mint(delegator_1, 100 * ONE_APT);\n        stake::mint(delegator_2, 100 * ONE_APT);\n        add_stake(delegator_1, pool_address, 50 * ONE_APT);\n        add_stake(delegator_2, pool_address, 30 * ONE_APT);\n\n        end_aptos_epoch();\n        assert_delegation(delegator_1_address, pool_address, 50 * ONE_APT, 0, 0);\n        assert_delegation(delegator_2_address, pool_address, 30 * ONE_APT, 0, 0);\n\n        // create allowlist\n        enable_delegators_allowlisting(validator);\n        assert!(allowlisting_enabled(pool_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_2_address), 0);\n\n        allowlist_delegator(validator, delegator_1_address);\n        assert!(delegator_allowlisted(pool_address, delegator_1_address), 0);\n        assert!(!delegator_allowlisted(pool_address, delegator_2_address), 0);\n\n        // evict delegator 2 which unlocks their entire active stake\n        evict_delegator(validator, delegator_2_address);\n        assert_delegation(delegator_2_address, pool_address, 0, 0, 30 * ONE_APT);\n\n        end_aptos_epoch();\n        // 5000000000 * 1.01 active\n        assert_delegation(delegator_1_address, pool_address, 5050000000, 0, 0);\n        // 3000000000 * 1.01 pending-inactive\n        assert_delegation(delegator_2_address, pool_address, 0, 0, 3030000000);\n\n        // can add stake when allowlisted\n        add_stake(delegator_1, pool_address, 10 * ONE_APT);\n        end_aptos_epoch();\n        // 5050000000 * 1.01 + 1000000000 active\n        assert_delegation(delegator_1_address, pool_address, 6100500000, 0, 0);\n        // 3030000000 * 1.01 pending-inactive\n        assert_delegation(delegator_2_address, pool_address, 0, 0, 3060300000);\n\n        end_aptos_epoch();\n        // 6100500000 * 1.01 active\n        assert_delegation(delegator_1_address, pool_address, 6161505000, 0, 0);\n        // 3060300000 * 1.01 pending-inactive\n        assert_delegation(delegator_2_address, pool_address, 0, 0, 3090903000);\n\n        remove_delegator_from_allowlist(validator, delegator_1_address);\n        assert!(!delegator_allowlisted(pool_address, delegator_1_address), 0);\n\n        // check that in-flight active rewards are evicted too, which validates that `synchronize_delegation_pool` was called\n        let active = pool_u64::balance(\n            &borrow_global<DelegationPool>(pool_address).active_shares,\n            delegator_1_address\n        ) + get_add_stake_fee(pool_address, 10 * ONE_APT);\n        // 5050000000 + 1000000000 active at last `synchronize_delegation_pool`\n        assert!(active == 6050000000, active);\n\n        evict_delegator(validator, delegator_1_address);\n        assert_delegation(delegator_1_address, pool_address, 0, 0, 6161504999);\n        let pending_inactive = pool_u64::balance(\n            pending_inactive_shares_pool(borrow_global<DelegationPool>(pool_address)),\n            delegator_1_address\n        );\n        assert!(pending_inactive == 6161504999, pending_inactive);\n\n        // allowlist delegator 1 back and check that they can add stake\n        allowlist_delegator(validator, delegator_1_address);\n        add_stake(delegator_1, pool_address, 20 * ONE_APT);\n        end_aptos_epoch();\n        // 2000000000 active and 6161505000 * 1.01 pending-inactive\n        assert_delegation(delegator_1_address, pool_address, 20 * ONE_APT, 0, 6223120049);\n\n        // can reactivate stake when allowlisted\n        reactivate_stake(delegator_1, pool_address, 5223120050);\n        assert_delegation(delegator_1_address, pool_address, 20 * ONE_APT + 5223120049, 0, 10 * ONE_APT);\n\n        // evict delegator 1 after they reactivated\n        remove_delegator_from_allowlist(validator, delegator_1_address);\n        evict_delegator(validator, delegator_1_address);\n        // 2000000000 + 5223120050 + 1000000000 pending-inactive\n        assert_delegation(delegator_1_address, pool_address, 0, 0, 8223120049);\n\n        end_aptos_epoch();\n        // (2000000000 + 5223120050 + 1000000000) * 1.01 pending-inactive\n        assert_delegation(delegator_1_address, pool_address, 0, 0, 8305351249);\n    }\n\n    #[test_only]\n    public fun assert_delegation(\n        delegator_address: address,\n        pool_address: address,\n        active_stake: u64,\n        inactive_stake: u64,\n        pending_inactive_stake: u64,\n    ) acquires DelegationPool, BeneficiaryForOperator {\n        let (actual_active, actual_inactive, actual_pending_inactive) = get_stake(pool_address, delegator_address);\n        assert!(actual_active == active_stake, actual_active);\n        assert!(actual_inactive == inactive_stake, actual_inactive);\n        assert!(actual_pending_inactive == pending_inactive_stake, actual_pending_inactive);\n    }\n\n    #[test_only]\n    public fun assert_pending_withdrawal(\n        delegator_address: address,\n        pool_address: address,\n        exists: bool,\n        olc: u64,\n        inactive: bool,\n        stake: u64,\n    ) acquires DelegationPool {\n        assert_delegation_pool_exists(pool_address);\n        let pool = borrow_global<DelegationPool>(pool_address);\n        let (withdrawal_exists, withdrawal_olc) = pending_withdrawal_exists(pool, delegator_address);\n        assert!(withdrawal_exists == exists, 0);\n        assert!(withdrawal_olc.index == olc, withdrawal_olc.index);\n        let (withdrawal_inactive, withdrawal_stake) = get_pending_withdrawal(pool_address, delegator_address);\n        assert!(withdrawal_inactive == inactive, 0);\n        assert!(withdrawal_stake == stake, withdrawal_stake);\n    }\n\n    #[test_only]\n    public fun assert_inactive_shares_pool(\n        pool_address: address,\n        olc: u64,\n        exists: bool,\n        stake: u64,\n    ) acquires DelegationPool {\n        assert_delegation_pool_exists(pool_address);\n        let pool = borrow_global<DelegationPool>(pool_address);\n        assert!(table::contains(&pool.inactive_shares, olc_with_index(olc)) == exists, 0);\n        if (exists) {\n            let actual_stake = total_coins(table::borrow(&pool.inactive_shares, olc_with_index(olc)));\n            assert!(actual_stake == stake, actual_stake);\n        } else {\n            assert!(0 == stake, 0);\n        }\n    }\n\n    #[test_only]\n    public fun setup_vote(\n        aptos_framework: &signer,\n        validator: &signer,\n        enable_partial_voting: bool,\n    ): u64 acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {\n        initialize_for_test_no_reward(aptos_framework);\n        aptos_governance::initialize_for_test(\n            aptos_framework,\n            (10 * ONE_APT as u128),\n            100 * ONE_APT,\n            1000,\n        );\n        aptos_governance::initialize_partial_voting(aptos_framework);\n\n        initialize_test_validator(validator, 100 * ONE_APT, true, false);\n\n        let validator_address = signer::address_of(validator);\n        let pool_address = get_owned_pool_address(validator_address);\n        // Delegation pool is created before partial governance voting feature flag is enabled. So this delegation\n        // pool's voter is its owner.\n        assert!(stake::get_delegated_voter(pool_address) == validator_address, 1);\n        assert!(!partial_governance_voting_enabled(pool_address), 1);\n        end_aptos_epoch();\n\n        // Create 1 proposals and vote for proposal1.\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let proposal_id = aptos_governance::create_proposal_v2_impl(\n            validator,\n            pool_address,\n            execution_hash,\n            b\"\",\n            b\"\",\n            true,\n        );\n        if (enable_partial_voting) {\n            features::change_feature_flags_for_testing(\n                aptos_framework,\n                vector[features::get_partial_governance_voting(\n                ), features::get_delegation_pool_partial_governance_voting()],\n                vector[]);\n            enable_partial_governance_voting(pool_address);\n        };\n        proposal_id\n    }\n\n    #[test_only]\n    public fun total_coins_inactive(pool_address: address): u64 acquires DelegationPool {\n        borrow_global<DelegationPool>(pool_address).total_coins_inactive\n    }\n}\n","name":"delegation_pool.move"},{"content":"/// This defines the fungible asset module that can issue fungible asset of any `Metadata` object. The\n/// metadata object can be any object that equipped with `Metadata` resource.\n///\n/// The dispatchable_fungible_asset wraps the existing fungible_asset module and adds the ability for token issuer\n/// to customize the logic for withdraw and deposit operations. For example:\n///\n/// - Deflation token: a fixed percentage of token will be destructed upon transfer.\n/// - Transfer allowlist: token can only be transfered to addresses in the allow list.\n/// - Predicated transfer: transfer can only happen when some certain predicate has been met.\n/// - Loyalty token: a fixed loyalty will be paid to a designated address when a fungible asset transfer happens\n///\n/// The api listed here intended to be an in-place replacement for defi applications that uses fungible_asset api directly\n/// and is safe for non-dispatchable (aka vanilla) fungible assets as well.\n///\n/// See AIP-73 for further discussion\n///\nmodule aptos_framework::dispatchable_fungible_asset {\n    use aptos_framework::fungible_asset::{Self, FungibleAsset, TransferRef};\n    use aptos_framework::function_info::{Self, FunctionInfo};\n    use aptos_framework::object::{Self, ConstructorRef, Object};\n\n    use std::error;\n    use std::features;\n    use std::option::{Self, Option};\n\n    /// TransferRefStore doesn't exist on the fungible asset type.\n    const ESTORE_NOT_FOUND: u64 = 1;\n    /// Recipient is not getting the guaranteed value;\n    const EAMOUNT_MISMATCH: u64 = 2;\n    /// Feature is not activated yet on the network.\n    const ENOT_ACTIVATED: u64 = 3;\n    /// Dispatch target is not loaded.\n    const ENOT_LOADED: u64 = 4;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct TransferRefStore has key {\n        transfer_ref: TransferRef\n    }\n\n    public fun register_dispatch_functions(\n        constructor_ref: &ConstructorRef,\n        withdraw_function: Option<FunctionInfo>,\n        deposit_function: Option<FunctionInfo>,\n        derived_balance_function: Option<FunctionInfo>,\n    ) {\n        fungible_asset::register_dispatch_functions(\n            constructor_ref,\n            withdraw_function,\n            deposit_function,\n            derived_balance_function,\n        );\n        let store_obj = &object::generate_signer(constructor_ref);\n        move_to<TransferRefStore>(\n            store_obj,\n            TransferRefStore {\n                transfer_ref: fungible_asset::generate_transfer_ref(constructor_ref),\n            }\n        );\n    }\n\n    /// Withdraw `amount` of the fungible asset from `store` by the owner.\n    ///\n    /// The semantics of deposit will be governed by the function specified in DispatchFunctionStore.\n    public fun withdraw<T: key>(\n        owner: &signer,\n        store: Object<T>,\n        amount: u64,\n    ): FungibleAsset acquires TransferRefStore {\n        fungible_asset::withdraw_sanity_check(owner, store, false);\n        let func_opt = fungible_asset::withdraw_dispatch_function(store);\n        if (option::is_some(&func_opt)) {\n            assert!(\n                features::dispatchable_fungible_asset_enabled(),\n                error::aborted(ENOT_ACTIVATED)\n            );\n            let start_balance = fungible_asset::balance(store);\n            let func = option::borrow(&func_opt);\n            function_info::load_module_from_function(func);\n            let fa = dispatchable_withdraw(\n                store,\n                amount,\n                borrow_transfer_ref(store),\n                func,\n            );\n            let end_balance = fungible_asset::balance(store);\n            assert!(amount <= start_balance - end_balance, error::aborted(EAMOUNT_MISMATCH));\n            fa\n        } else {\n            fungible_asset::withdraw_internal(object::object_address(&store), amount)\n        }\n    }\n\n    /// Deposit `amount` of the fungible asset to `store`.\n    ///\n    /// The semantics of deposit will be governed by the function specified in DispatchFunctionStore.\n    public fun deposit<T: key>(store: Object<T>, fa: FungibleAsset) acquires TransferRefStore {\n        fungible_asset::deposit_sanity_check(store, false);\n        let func_opt = fungible_asset::deposit_dispatch_function(store);\n        if (option::is_some(&func_opt)) {\n            assert!(\n                features::dispatchable_fungible_asset_enabled(),\n                error::aborted(ENOT_ACTIVATED)\n            );\n            let func = option::borrow(&func_opt);\n            function_info::load_module_from_function(func);\n            dispatchable_deposit(\n                store,\n                fa,\n                borrow_transfer_ref(store),\n                func\n            )\n        } else {\n            fungible_asset::deposit_internal(store, fa)\n        }\n    }\n\n    /// Transfer an `amount` of fungible asset from `from_store`, which should be owned by `sender`, to `receiver`.\n    /// Note: it does not move the underlying object.\n    public entry fun transfer<T: key>(\n        sender: &signer,\n        from: Object<T>,\n        to: Object<T>,\n        amount: u64,\n    ) acquires TransferRefStore {\n        let fa = withdraw(sender, from, amount);\n        deposit(to, fa);\n    }\n\n    /// Transfer an `amount` of fungible asset from `from_store`, which should be owned by `sender`, to `receiver`.\n    /// The recipient is guranteed to receive asset greater than the expected amount.\n    /// Note: it does not move the underlying object.\n    public entry fun transfer_assert_minimum_deposit<T: key>(\n        sender: &signer,\n        from: Object<T>,\n        to: Object<T>,\n        amount: u64,\n        expected: u64\n    ) acquires TransferRefStore {\n        let start = fungible_asset::balance(to);\n        let fa = withdraw(sender, from, amount);\n        deposit(to, fa);\n        let end = fungible_asset::balance(to);\n        assert!(end - start >= expected, error::aborted(EAMOUNT_MISMATCH));\n    }\n\n    #[view]\n    /// Get the derived value of store using the overloaded hook.\n    ///\n    /// The semantics of value will be governed by the function specified in DispatchFunctionStore.\n    public fun derived_balance<T: key>(store: Object<T>): u64 {\n        let func_opt = fungible_asset::derived_balance_dispatch_function(store);\n        if (option::is_some(&func_opt)) {\n            assert!(\n                features::dispatchable_fungible_asset_enabled(),\n                error::aborted(ENOT_ACTIVATED)\n            );\n            let func = option::borrow(&func_opt);\n            function_info::load_module_from_function(func);\n            dispatchable_derived_balance(store, func)\n        } else {\n            fungible_asset::balance(store)\n        }\n    }\n\n    inline fun borrow_transfer_ref<T: key>(metadata: Object<T>): &TransferRef acquires TransferRefStore {\n        let metadata_addr = object::object_address(\n            &fungible_asset::store_metadata(metadata)\n        );\n        assert!(\n            exists<TransferRefStore>(metadata_addr),\n            error::not_found(ESTORE_NOT_FOUND)\n        );\n        &borrow_global<TransferRefStore>(metadata_addr).transfer_ref\n    }\n\n    native fun dispatchable_withdraw<T: key>(\n        store: Object<T>,\n        amount: u64,\n        transfer_ref: &TransferRef,\n        function: &FunctionInfo,\n    ): FungibleAsset;\n\n    native fun dispatchable_deposit<T: key>(\n        store: Object<T>,\n        fa: FungibleAsset,\n        transfer_ref: &TransferRef,\n        function: &FunctionInfo,\n    );\n\n    native fun dispatchable_derived_balance<T: key>(\n        store: Object<T>,\n        function: &FunctionInfo,\n    ): u64;\n}\n","name":"dispatchable_fungible_asset.move"},{"content":"/// DKG on-chain states and helper functions.\nmodule aptos_framework::dkg {\n    use std::error;\n    use std::option;\n    use std::option::Option;\n    use aptos_framework::event::emit;\n    use aptos_framework::randomness_config::RandomnessConfig;\n    use aptos_framework::system_addresses;\n    use aptos_framework::timestamp;\n    use aptos_framework::validator_consensus_info::ValidatorConsensusInfo;\n    friend aptos_framework::block;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    const EDKG_IN_PROGRESS: u64 = 1;\n    const EDKG_NOT_IN_PROGRESS: u64 = 2;\n\n    /// This can be considered as the public input of DKG.\n    struct DKGSessionMetadata has copy, drop, store {\n        dealer_epoch: u64,\n        randomness_config: RandomnessConfig,\n        dealer_validator_set: vector<ValidatorConsensusInfo>,\n        target_validator_set: vector<ValidatorConsensusInfo>,\n    }\n\n    #[event]\n    struct DKGStartEvent has drop, store {\n        session_metadata: DKGSessionMetadata,\n        start_time_us: u64,\n    }\n\n    /// The input and output of a DKG session.\n    /// The validator set of epoch `x` works together for an DKG output for the target validator set of epoch `x+1`.\n    struct DKGSessionState has copy, store, drop {\n        metadata: DKGSessionMetadata,\n        start_time_us: u64,\n        transcript: vector<u8>,\n    }\n\n    /// The completed and in-progress DKG sessions.\n    struct DKGState has key {\n        last_completed: Option<DKGSessionState>,\n        in_progress: Option<DKGSessionState>,\n    }\n\n    /// Called in genesis to initialize on-chain states.\n    public fun initialize(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        if (!exists<DKGState>(@aptos_framework)) {\n            move_to<DKGState>(\n                aptos_framework,\n                DKGState {\n                    last_completed: std::option::none(),\n                    in_progress: std::option::none(),\n                }\n            );\n        }\n    }\n\n    /// Mark on-chain DKG state as in-progress. Notify validators to start DKG.\n    /// Abort if a DKG is already in progress.\n    public(friend) fun start(\n        dealer_epoch: u64,\n        randomness_config: RandomnessConfig,\n        dealer_validator_set: vector<ValidatorConsensusInfo>,\n        target_validator_set: vector<ValidatorConsensusInfo>,\n    ) acquires DKGState {\n        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);\n        let new_session_metadata = DKGSessionMetadata {\n            dealer_epoch,\n            randomness_config,\n            dealer_validator_set,\n            target_validator_set,\n        };\n        let start_time_us = timestamp::now_microseconds();\n        dkg_state.in_progress = std::option::some(DKGSessionState {\n            metadata: new_session_metadata,\n            start_time_us,\n            transcript: vector[],\n        });\n\n        emit(DKGStartEvent {\n            start_time_us,\n            session_metadata: new_session_metadata,\n        });\n    }\n\n    /// Put a transcript into the currently incomplete DKG session, then mark it completed.\n    ///\n    /// Abort if DKG is not in progress.\n    public(friend) fun finish(transcript: vector<u8>) acquires DKGState {\n        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);\n        assert!(option::is_some(&dkg_state.in_progress), error::invalid_state(EDKG_NOT_IN_PROGRESS));\n        let session = option::extract(&mut dkg_state.in_progress);\n        session.transcript = transcript;\n        dkg_state.last_completed = option::some(session);\n        dkg_state.in_progress = option::none();\n    }\n\n    /// Delete the currently incomplete session, if it exists.\n    public fun try_clear_incomplete_session(fx: &signer) acquires DKGState {\n        system_addresses::assert_aptos_framework(fx);\n        if (exists<DKGState>(@aptos_framework)) {\n            let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);\n            dkg_state.in_progress = option::none();\n        }\n    }\n\n    /// Return the incomplete DKG session state, if it exists.\n    public fun incomplete_session(): Option<DKGSessionState> acquires DKGState {\n        if (exists<DKGState>(@aptos_framework)) {\n            borrow_global<DKGState>(@aptos_framework).in_progress\n        } else {\n            option::none()\n        }\n    }\n\n    /// Return the dealer epoch of a `DKGSessionState`.\n    public fun session_dealer_epoch(session: &DKGSessionState): u64 {\n        session.metadata.dealer_epoch\n    }\n}\n","name":"dkg.move"},{"content":"/// The Event module defines an `EventHandleGenerator` that is used to create\n/// `EventHandle`s with unique GUIDs. It contains a counter for the number\n/// of `EventHandle`s it generates. An `EventHandle` is used to count the number of\n/// events emitted to a handle and emit events to the event store.\nmodule aptos_framework::event {\n    use std::bcs;\n\n    use aptos_framework::guid::GUID;\n\n    friend aptos_framework::account;\n    friend aptos_framework::object;\n\n    /// Emit a module event with payload `msg`.\n    public fun emit<T: store + drop>(msg: T) {\n        write_module_event_to_store<T>(msg);\n    }\n\n    /// Log `msg` with the event stream identified by `T`\n    native fun write_module_event_to_store<T: drop + store>(msg: T);\n\n    #[test_only]\n    public native fun emitted_events<T: drop + store>(): vector<T>;\n\n    #[test_only]\n    public fun was_event_emitted<T: drop + store>(msg: &T): bool {\n        use std::vector;\n        vector::contains(&emitted_events<T>(), msg)\n    }\n\n    #[deprecated]\n    /// A handle for an event such that:\n    /// 1. Other modules can emit events to this handle.\n    /// 2. Storage can use this handle to prove the total number of events that happened in the past.\n    struct EventHandle<phantom T: drop + store> has store {\n        /// Total number of events emitted to this event stream.\n        counter: u64,\n        /// A globally unique ID for this event stream.\n        guid: GUID,\n    }\n\n    #[deprecated]\n    /// Use EventHandleGenerator to generate a unique event handle for `sig`\n    public(friend) fun new_event_handle<T: drop + store>(guid: GUID): EventHandle<T> {\n        EventHandle<T> {\n            counter: 0,\n            guid,\n        }\n    }\n\n    #[deprecated]\n    /// Emit an event with payload `msg` by using `handle_ref`'s key and counter.\n    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {\n        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);\n        spec {\n            assume handle_ref.counter + 1 <= MAX_U64;\n        };\n        handle_ref.counter = handle_ref.counter + 1;\n    }\n\n    #[deprecated]\n    /// Return the GUID associated with this EventHandle\n    public fun guid<T: drop + store>(handle_ref: &EventHandle<T>): &GUID {\n        &handle_ref.guid\n    }\n\n    #[deprecated]\n    /// Return the current counter associated with this EventHandle\n    public fun counter<T: drop + store>(handle_ref: &EventHandle<T>): u64 {\n        handle_ref.counter\n    }\n\n    #[deprecated]\n    /// Log `msg` as the `count`th event associated with the event stream identified by `guid`\n    native fun write_to_event_store<T: drop + store>(guid: vector<u8>, count: u64, msg: T);\n\n    #[deprecated]\n    /// Destroy a unique handle.\n    public fun destroy_handle<T: drop + store>(handle: EventHandle<T>) {\n        EventHandle<T> { counter: _, guid: _ } = handle;\n    }\n\n    #[deprecated]\n    #[test_only]\n    public native fun emitted_events_by_handle<T: drop + store>(handle: &EventHandle<T>): vector<T>;\n\n    #[deprecated]\n    #[test_only]\n    public fun was_event_emitted_by_handle<T: drop + store>(handle: &EventHandle<T>, msg: &T): bool {\n        use std::vector;\n        vector::contains(&emitted_events_by_handle(handle), msg)\n    }\n}\n","name":"event.move"},{"content":"/// The `function_info` module defines the `FunctionInfo` type which simulates a function pointer.\nmodule aptos_framework::function_info {\n    use std::error;\n    use std::features;\n    use std::signer;\n    use std::string::{Self, String};\n\n    friend aptos_framework::fungible_asset;\n    friend aptos_framework::dispatchable_fungible_asset;\n\n    /// String is not a valid Move identifier\n    const EINVALID_IDENTIFIER: u64 = 1;\n    /// Function specified in the FunctionInfo doesn't exist on chain.\n    const EINVALID_FUNCTION: u64 = 2;\n    /// Feature hasn't been activated yet.\n    const ENOT_ACTIVATED: u64 = 3;\n\n    /// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.\n    struct FunctionInfo has copy, drop, store {\n        module_address: address,\n        module_name: String,\n        function_name: String,\n    }\n\n    /// Creates a new function info from names.\n    public fun new_function_info(\n        module_signer: &signer,\n        module_name: String,\n        function_name: String,\n    ): FunctionInfo {\n        new_function_info_from_address(\n            signer::address_of(module_signer),\n            module_name,\n            function_name,\n        )\n    }\n\n    public(friend) fun new_function_info_from_address(\n        module_address: address,\n        module_name: String,\n        function_name: String,\n    ): FunctionInfo {\n        assert!(\n            is_identifier(string::bytes(&module_name)),\n            EINVALID_IDENTIFIER\n        );\n        assert!(\n            is_identifier(string::bytes(&function_name)),\n            EINVALID_IDENTIFIER\n        );\n        FunctionInfo {\n            module_address,\n            module_name,\n            function_name,\n        }\n    }\n\n    /// Check if the dispatch target function meets the type requirements of the disptach entry point.\n    ///\n    /// framework_function is the dispatch native function defined in the aptos_framework.\n    /// dispatch_target is the function passed in by the user.\n    ///\n    /// dispatch_target should have the same signature (same argument type, same generics constraint) except\n    /// that the framework_function will have a `&FunctionInfo` in the last argument that will instruct the VM which\n    /// function to jump to.\n    ///\n    /// dispatch_target also needs to be public so the type signature will remain unchanged.\n    public(friend) fun check_dispatch_type_compatibility(\n        framework_function: &FunctionInfo,\n        dispatch_target: &FunctionInfo,\n    ): bool {\n        assert!(\n            features::dispatchable_fungible_asset_enabled(),\n            error::aborted(ENOT_ACTIVATED)\n        );\n        load_function_impl(dispatch_target);\n        check_dispatch_type_compatibility_impl(framework_function, dispatch_target)\n    }\n\n    /// Load up a function into VM's loader and charge for its dependencies\n    ///\n    /// It is **critical** to make sure that this function is invoked before `check_dispatch_type_compatibility`\n    /// or performing any other dispatching logic to ensure:\n    /// 1. We properly charge gas for the function to dispatch.\n    /// 2. The function is loaded in the cache so that we can perform further type checking/dispatching logic.\n    ///\n    /// Calling `check_dispatch_type_compatibility_impl` or dispatch without loading up the module would yield an error\n    /// if such module isn't accessed previously in the transaction.\n    public(friend) fun load_module_from_function(f: &FunctionInfo) {\n        load_function_impl(f)\n    }\n\n    native fun check_dispatch_type_compatibility_impl(lhs: &FunctionInfo, r: &FunctionInfo): bool;\n    native fun is_identifier(s: &vector<u8>): bool;\n    native fun load_function_impl(f: &FunctionInfo);\n\n    // Test only dependencies so we can invoke those friend functions.\n    #[test_only]\n    friend aptos_framework::function_info_tests;\n}\n","name":"function_info.move"},{"content":"/// This defines the fungible asset module that can issue fungible asset of any `Metadata` object. The\n/// metadata object can be any object that equipped with `Metadata` resource.\nmodule aptos_framework::fungible_asset {\n    use aptos_framework::aggregator_v2::{Self, Aggregator};\n    use aptos_framework::event;\n    use aptos_framework::function_info::{Self, FunctionInfo};\n    use aptos_framework::object::{Self, Object, ConstructorRef, DeleteRef, ExtendRef};\n    use std::string;\n    use std::features;\n\n    use std::error;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::string::String;\n\n    friend aptos_framework::coin;\n    friend aptos_framework::primary_fungible_store;\n\n    friend aptos_framework::dispatchable_fungible_asset;\n\n    /// Amount cannot be zero.\n    const EAMOUNT_CANNOT_BE_ZERO: u64 = 1;\n    /// The transfer ref and the fungible asset do not match.\n    const ETRANSFER_REF_AND_FUNGIBLE_ASSET_MISMATCH: u64 = 2;\n    /// Store is disabled from sending and receiving this fungible asset.\n    const ESTORE_IS_FROZEN: u64 = 3;\n    /// Insufficient balance to withdraw or transfer.\n    const EINSUFFICIENT_BALANCE: u64 = 4;\n    /// The fungible asset's supply has exceeded maximum.\n    const EMAX_SUPPLY_EXCEEDED: u64 = 5;\n    /// Fungible asset do not match when merging.\n    const EFUNGIBLE_ASSET_MISMATCH: u64 = 6;\n    /// The mint ref and the store do not match.\n    const EMINT_REF_AND_STORE_MISMATCH: u64 = 7;\n    /// Account is not the store's owner.\n    const ENOT_STORE_OWNER: u64 = 8;\n    /// Transfer ref and store do not match.\n    const ETRANSFER_REF_AND_STORE_MISMATCH: u64 = 9;\n    /// Burn ref and store do not match.\n    const EBURN_REF_AND_STORE_MISMATCH: u64 = 10;\n    /// Fungible asset and store do not match.\n    const EFUNGIBLE_ASSET_AND_STORE_MISMATCH: u64 = 11;\n    /// Cannot destroy non-empty fungible assets.\n    const EAMOUNT_IS_NOT_ZERO: u64 = 12;\n    /// Burn ref and fungible asset do not match.\n    const EBURN_REF_AND_FUNGIBLE_ASSET_MISMATCH: u64 = 13;\n    /// Cannot destroy fungible stores with a non-zero balance.\n    const EBALANCE_IS_NOT_ZERO: u64 = 14;\n    /// Name of the fungible asset metadata is too long\n    const ENAME_TOO_LONG: u64 = 15;\n    /// Symbol of the fungible asset metadata is too long\n    const ESYMBOL_TOO_LONG: u64 = 16;\n    /// Decimals is over the maximum of 32\n    const EDECIMALS_TOO_LARGE: u64 = 17;\n    /// Fungibility is only available for non-deletable objects.\n    const EOBJECT_IS_DELETABLE: u64 = 18;\n    /// URI for the icon of the fungible asset metadata is too long\n    const EURI_TOO_LONG: u64 = 19;\n    /// The fungible asset's supply will be negative which should be impossible.\n    const ESUPPLY_UNDERFLOW: u64 = 20;\n    /// Supply resource is not found for a metadata object.\n    const ESUPPLY_NOT_FOUND: u64 = 21;\n    /// Flag for Concurrent Supply not enabled\n    const ECONCURRENT_SUPPLY_NOT_ENABLED: u64 = 22;\n    /// Flag for the existence of fungible store.\n    const EFUNGIBLE_STORE_EXISTENCE: u64 = 23;\n    /// Account is not the owner of metadata object.\n    const ENOT_METADATA_OWNER: u64 = 24;\n    /// Provided withdraw function type doesn't meet the signature requirement.\n    const EWITHDRAW_FUNCTION_SIGNATURE_MISMATCH: u64 = 25;\n    /// Provided deposit function type doesn't meet the signature requirement.\n    const EDEPOSIT_FUNCTION_SIGNATURE_MISMATCH: u64 = 26;\n    /// Provided derived_balance function type doesn't meet the signature requirement.\n    const EDERIVED_BALANCE_FUNCTION_SIGNATURE_MISMATCH: u64 = 27;\n    /// Invalid withdraw/deposit on dispatchable token. The specified token has a dispatchable function hook.\n    /// Need to invoke dispatchable_fungible_asset::withdraw/deposit to perform transfer.\n    const EINVALID_DISPATCHABLE_OPERATIONS: u64 = 28;\n    /// Trying to re-register dispatch hook on a fungible asset.\n    const EALREADY_REGISTERED: u64 = 29;\n    /// Fungible metadata does not exist on this account.\n    const EFUNGIBLE_METADATA_EXISTENCE: u64 = 30;\n    /// Cannot register dispatch hook for APT.\n    const EAPT_NOT_DISPATCHABLE: u64 = 31;\n\n    //\n    // Constants\n    //\n\n    const MAX_NAME_LENGTH: u64 = 32;\n    const MAX_SYMBOL_LENGTH: u64 = 10;\n    const MAX_DECIMALS: u8 = 32;\n    const MAX_URI_LENGTH: u64 = 512;\n\n    /// Maximum possible coin supply.\n    const MAX_U128: u128 = 340282366920938463463374607431768211455;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct Supply has key {\n        current: u128,\n        // option::none() means unlimited supply.\n        maximum: Option<u128>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct ConcurrentSupply has key {\n        current: Aggregator<u128>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Metadata of a Fungible asset\n    struct Metadata has key {\n        /// Name of the fungible metadata, i.e., \"USDT\".\n        name: String,\n        /// Symbol of the fungible metadata, usually a shorter version of the name.\n        /// For example, Singapore Dollar is SGD.\n        symbol: String,\n        /// Number of decimals used for display purposes.\n        /// For example, if `decimals` equals `2`, a balance of `505` coins should\n        /// be displayed to a user as `5.05` (`505 / 10 ** 2`).\n        decimals: u8,\n        /// The Uniform Resource Identifier (uri) pointing to an image that can be used as the icon for this fungible\n        /// asset.\n        icon_uri: String,\n        /// The Uniform Resource Identifier (uri) pointing to the website for the fungible asset.\n        project_uri: String,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Defines a `FungibleAsset`, such that all `FungibleStore`s stores are untransferable at\n    /// the object layer.\n    struct Untransferable has key {}\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// The store object that holds fungible assets of a specific type associated with an account.\n    struct FungibleStore has key {\n        /// The address of the base metadata object.\n        metadata: Object<Metadata>,\n        /// The balance of the fungible metadata.\n        balance: u64,\n        /// If true, owner transfer is disabled that only `TransferRef` can move in/out from this store.\n        frozen: bool,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct DispatchFunctionStore has key {\n\t\twithdraw_function: Option<FunctionInfo>,\n\t\tdeposit_function: Option<FunctionInfo>,\n        derived_balance_function: Option<FunctionInfo>,\n    }\n\n    /// FungibleAsset can be passed into function for type safety and to guarantee a specific amount.\n    /// FungibleAsset is ephemeral and cannot be stored directly. It must be deposited back into a store.\n    struct FungibleAsset {\n        metadata: Object<Metadata>,\n        amount: u64,\n    }\n\n    /// MintRef can be used to mint the fungible asset into an account's store.\n    struct MintRef has drop, store {\n        metadata: Object<Metadata>\n    }\n\n    /// TransferRef can be used to allow or disallow the owner of fungible assets from transferring the asset\n    /// and allow the holder of TransferRef to transfer fungible assets from any account.\n    struct TransferRef has drop, store {\n        metadata: Object<Metadata>\n    }\n\n    /// BurnRef can be used to burn fungible assets from a given holder account.\n    struct BurnRef has drop, store {\n        metadata: Object<Metadata>\n    }\n\n    #[event]\n    /// Emitted when fungible assets are deposited into a store.\n    struct Deposit has drop, store {\n        store: address,\n        amount: u64,\n    }\n\n    #[event]\n    /// Emitted when fungible assets are withdrawn from a store.\n    struct Withdraw has drop, store {\n        store: address,\n        amount: u64,\n    }\n\n    #[event]\n    /// Emitted when a store's frozen status is updated.\n    struct Frozen has drop, store {\n        store: address,\n        frozen: bool,\n    }\n\n    /// Make an existing object fungible by adding the Metadata resource.\n    /// This returns the capabilities to mint, burn, and transfer.\n    /// maximum_supply defines the behavior of maximum supply when monitoring:\n    ///   - option::none(): Monitoring unlimited supply\n    ///     (width of the field - MAX_U128 is the implicit maximum supply)\n    ///     if option::some(MAX_U128) is used, it is treated as unlimited supply.\n    ///   - option::some(max): Monitoring fixed supply with `max` as the maximum supply.\n    public fun add_fungibility(\n        constructor_ref: &ConstructorRef,\n        maximum_supply: Option<u128>,\n        name: String,\n        symbol: String,\n        decimals: u8,\n        icon_uri: String,\n        project_uri: String,\n    ): Object<Metadata> {\n        assert!(!object::can_generate_delete_ref(constructor_ref), error::invalid_argument(EOBJECT_IS_DELETABLE));\n        let metadata_object_signer = &object::generate_signer(constructor_ref);\n        assert!(string::length(&name) <= MAX_NAME_LENGTH, error::out_of_range(ENAME_TOO_LONG));\n        assert!(string::length(&symbol) <= MAX_SYMBOL_LENGTH, error::out_of_range(ESYMBOL_TOO_LONG));\n        assert!(decimals <= MAX_DECIMALS, error::out_of_range(EDECIMALS_TOO_LARGE));\n        assert!(string::length(&icon_uri) <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));\n        assert!(string::length(&project_uri) <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));\n        move_to(metadata_object_signer,\n            Metadata {\n                name,\n                symbol,\n                decimals,\n                icon_uri,\n                project_uri,\n            }\n        );\n\n        if (features::concurrent_fungible_assets_enabled()) {\n            let unlimited = option::is_none(&maximum_supply);\n            move_to(metadata_object_signer, ConcurrentSupply {\n                current: if (unlimited) {\n                    aggregator_v2::create_unbounded_aggregator()\n                } else {\n                    aggregator_v2::create_aggregator(option::extract(&mut maximum_supply))\n                },\n            });\n        } else {\n            move_to(metadata_object_signer, Supply {\n                current: 0,\n                maximum: maximum_supply\n            });\n        };\n\n        object::object_from_constructor_ref<Metadata>(constructor_ref)\n    }\n\n    /// Set that only untransferable stores can be created for this fungible asset.\n    public fun set_untransferable(constructor_ref: &ConstructorRef) {\n        let metadata_addr = object::address_from_constructor_ref(constructor_ref);\n        assert!(exists<Metadata>(metadata_addr), error::not_found(EFUNGIBLE_METADATA_EXISTENCE));\n        let metadata_signer = &object::generate_signer(constructor_ref);\n        move_to(metadata_signer, Untransferable {});\n    }\n\n\n    #[view]\n    /// Returns true if the FA is untransferable.\n    public fun is_untransferable<T: key>(metadata: Object<T>): bool {\n        exists<Untransferable>(object::object_address(&metadata))\n    }\n\n    /// Create a fungible asset store whose transfer rule would be overloaded by the provided function.\n    public(friend) fun register_dispatch_functions(\n        constructor_ref: &ConstructorRef,\n        withdraw_function: Option<FunctionInfo>,\n        deposit_function: Option<FunctionInfo>,\n        derived_balance_function: Option<FunctionInfo>,\n    ) {\n        // Verify that caller type matches callee type so wrongly typed function cannot be registered.\n        option::for_each_ref(&withdraw_function, |withdraw_function| {\n            let dispatcher_withdraw_function_info = function_info::new_function_info_from_address(\n                @aptos_framework,\n                string::utf8(b\"dispatchable_fungible_asset\"),\n                string::utf8(b\"dispatchable_withdraw\"),\n            );\n\n            assert!(\n                function_info::check_dispatch_type_compatibility(\n                    &dispatcher_withdraw_function_info,\n                    withdraw_function\n                ),\n                error::invalid_argument(\n                    EWITHDRAW_FUNCTION_SIGNATURE_MISMATCH\n                )\n            );\n        });\n\n        option::for_each_ref(&deposit_function, |deposit_function| {\n            let dispatcher_deposit_function_info = function_info::new_function_info_from_address(\n                @aptos_framework,\n                string::utf8(b\"dispatchable_fungible_asset\"),\n                string::utf8(b\"dispatchable_deposit\"),\n            );\n            // Verify that caller type matches callee type so wrongly typed function cannot be registered.\n            assert!(\n                function_info::check_dispatch_type_compatibility(\n                    &dispatcher_deposit_function_info,\n                    deposit_function\n                ),\n                error::invalid_argument(\n                    EDEPOSIT_FUNCTION_SIGNATURE_MISMATCH\n                )\n            );\n        });\n\n        option::for_each_ref(&derived_balance_function, |balance_function| {\n            let dispatcher_derived_balance_function_info = function_info::new_function_info_from_address(\n                @aptos_framework,\n                string::utf8(b\"dispatchable_fungible_asset\"),\n                string::utf8(b\"dispatchable_derived_balance\"),\n            );\n            // Verify that caller type matches callee type so wrongly typed function cannot be registered.\n            assert!(\n                function_info::check_dispatch_type_compatibility(\n                    &dispatcher_derived_balance_function_info,\n                    balance_function\n                ),\n                error::invalid_argument(\n                    EDERIVED_BALANCE_FUNCTION_SIGNATURE_MISMATCH\n                )\n            );\n        });\n\n        // Cannot register hook for APT.\n        assert!(\n            object::address_from_constructor_ref(constructor_ref) != @aptos_fungible_asset,\n            error::permission_denied(EAPT_NOT_DISPATCHABLE)\n        );\n        assert!(\n            !object::can_generate_delete_ref(constructor_ref),\n            error::invalid_argument(EOBJECT_IS_DELETABLE)\n        );\n        assert!(\n            !exists<DispatchFunctionStore>(\n                object::address_from_constructor_ref(constructor_ref)\n            ),\n            error::already_exists(EALREADY_REGISTERED)\n        );\n        assert!(\n            exists<Metadata>(\n                object::address_from_constructor_ref(constructor_ref)\n            ),\n            error::not_found(EFUNGIBLE_METADATA_EXISTENCE),\n        );\n\n        let store_obj = &object::generate_signer(constructor_ref);\n\n        // Store the overload function hook.\n        move_to<DispatchFunctionStore>(\n            store_obj,\n            DispatchFunctionStore {\n                withdraw_function,\n                deposit_function,\n                derived_balance_function,\n            }\n        );\n    }\n\n    /// Creates a mint ref that can be used to mint fungible assets from the given fungible object's constructor ref.\n    /// This can only be called at object creation time as constructor_ref is only available then.\n    public fun generate_mint_ref(constructor_ref: &ConstructorRef): MintRef {\n        let metadata = object::object_from_constructor_ref<Metadata>(constructor_ref);\n        MintRef { metadata }\n    }\n\n    /// Creates a burn ref that can be used to burn fungible assets from the given fungible object's constructor ref.\n    /// This can only be called at object creation time as constructor_ref is only available then.\n    public fun generate_burn_ref(constructor_ref: &ConstructorRef): BurnRef {\n        let metadata = object::object_from_constructor_ref<Metadata>(constructor_ref);\n        BurnRef { metadata }\n    }\n\n    /// Creates a transfer ref that can be used to freeze/unfreeze/transfer fungible assets from the given fungible\n    /// object's constructor ref.\n    /// This can only be called at object creation time as constructor_ref is only available then.\n    public fun generate_transfer_ref(constructor_ref: &ConstructorRef): TransferRef {\n        let metadata = object::object_from_constructor_ref<Metadata>(constructor_ref);\n        TransferRef { metadata }\n    }\n\n    #[view]\n    /// Get the current supply from the `metadata` object.\n    public fun supply<T: key>(metadata: Object<T>): Option<u128> acquires Supply, ConcurrentSupply {\n        let metadata_address = object::object_address(&metadata);\n        if (exists<ConcurrentSupply>(metadata_address)) {\n            let supply = borrow_global<ConcurrentSupply>(metadata_address);\n            option::some(aggregator_v2::read(&supply.current))\n        } else if (exists<Supply>(metadata_address)) {\n            let supply = borrow_global<Supply>(metadata_address);\n            option::some(supply.current)\n        } else {\n            option::none()\n        }\n    }\n\n    #[view]\n    /// Get the maximum supply from the `metadata` object.\n    /// If supply is unlimited (or set explicitly to MAX_U128), none is returned\n    public fun maximum<T: key>(metadata: Object<T>): Option<u128> acquires Supply, ConcurrentSupply {\n        let metadata_address = object::object_address(&metadata);\n        if (exists<ConcurrentSupply>(metadata_address)) {\n            let supply = borrow_global<ConcurrentSupply>(metadata_address);\n            let max_value = aggregator_v2::max_value(&supply.current);\n            if (max_value == MAX_U128) {\n                option::none()\n            } else {\n                option::some(max_value)\n            }\n        } else if (exists<Supply>(metadata_address)) {\n            let supply = borrow_global<Supply>(metadata_address);\n            supply.maximum\n        } else {\n            option::none()\n        }\n    }\n\n    #[view]\n    /// Get the name of the fungible asset from the `metadata` object.\n    public fun name<T: key>(metadata: Object<T>): String acquires Metadata {\n        borrow_fungible_metadata(&metadata).name\n    }\n\n    #[view]\n    /// Get the symbol of the fungible asset from the `metadata` object.\n    public fun symbol<T: key>(metadata: Object<T>): String acquires Metadata {\n        borrow_fungible_metadata(&metadata).symbol\n    }\n\n    #[view]\n    /// Get the decimals from the `metadata` object.\n    public fun decimals<T: key>(metadata: Object<T>): u8 acquires Metadata {\n        borrow_fungible_metadata(&metadata).decimals\n    }\n\n    #[view]\n    /// Return whether the provided address has a store initialized.\n    public fun store_exists(store: address): bool {\n        exists<FungibleStore>(store)\n    }\n\n    /// Return the underlying metadata object\n    public fun metadata_from_asset(fa: &FungibleAsset): Object<Metadata> {\n        fa.metadata\n    }\n\n    #[view]\n    /// Return the underlying metadata object.\n    public fun store_metadata<T: key>(store: Object<T>): Object<Metadata> acquires FungibleStore {\n        borrow_store_resource(&store).metadata\n    }\n\n    /// Return the `amount` of a given fungible asset.\n    public fun amount(fa: &FungibleAsset): u64 {\n        fa.amount\n    }\n\n    #[view]\n    /// Get the balance of a given store.\n    public fun balance<T: key>(store: Object<T>): u64 acquires FungibleStore {\n        if (store_exists(object::object_address(&store))) {\n            borrow_store_resource(&store).balance\n        } else {\n            0\n        }\n    }\n\n    #[view]\n    /// Check whether the balance of a given store is >= `amount`.\n    public fun is_balance_at_least<T: key>(store: Object<T>, amount: u64): bool acquires FungibleStore {\n        let store_addr = object::object_address(&store);\n        if (store_exists(store_addr)) {\n            borrow_store_resource(&store).balance >= amount\n        } else {\n            amount == 0\n        }\n    }\n\n    #[view]\n    /// Return whether a store is frozen.\n    ///\n    /// If the store has not been created, we default to returning false so deposits can be sent to it.\n    public fun is_frozen<T: key>(store: Object<T>): bool acquires FungibleStore {\n        store_exists(object::object_address(&store)) && borrow_store_resource(&store).frozen\n    }\n\n    #[view]\n    /// Return whether a fungible asset type is dispatchable.\n    public fun is_store_dispatchable<T: key>(store: Object<T>): bool acquires FungibleStore {\n        let fa_store = borrow_store_resource(&store);\n        let metadata_addr = object::object_address(&fa_store.metadata);\n        exists<DispatchFunctionStore>(metadata_addr)\n    }\n\n    public fun deposit_dispatch_function<T: key>(store: Object<T>): Option<FunctionInfo> acquires FungibleStore, DispatchFunctionStore {\n        let fa_store = borrow_store_resource(&store);\n        let metadata_addr = object::object_address(&fa_store.metadata);\n        if(exists<DispatchFunctionStore>(metadata_addr)) {\n            borrow_global<DispatchFunctionStore>(metadata_addr).deposit_function\n        } else {\n            option::none()\n        }\n    }\n\n    fun has_deposit_dispatch_function(metadata: Object<Metadata>): bool acquires DispatchFunctionStore {\n        let metadata_addr = object::object_address(&metadata);\n        // Short circuit on APT for better perf\n        if(metadata_addr != @aptos_fungible_asset && exists<DispatchFunctionStore>(metadata_addr)) {\n            option::is_some(&borrow_global<DispatchFunctionStore>(metadata_addr).deposit_function)\n        } else {\n            false\n        }\n    }\n\n    public fun withdraw_dispatch_function<T: key>(store: Object<T>): Option<FunctionInfo> acquires FungibleStore, DispatchFunctionStore {\n        let fa_store = borrow_store_resource(&store);\n        let metadata_addr = object::object_address(&fa_store.metadata);\n        if(exists<DispatchFunctionStore>(metadata_addr)) {\n            borrow_global<DispatchFunctionStore>(metadata_addr).withdraw_function\n        } else {\n            option::none()\n        }\n    }\n\n    fun has_withdraw_dispatch_function(metadata: Object<Metadata>): bool acquires DispatchFunctionStore {\n        let metadata_addr = object::object_address(&metadata);\n        // Short circuit on APT for better perf\n        if (metadata_addr != @aptos_fungible_asset && exists<DispatchFunctionStore>(metadata_addr)) {\n            option::is_some(&borrow_global<DispatchFunctionStore>(metadata_addr).withdraw_function)\n        } else {\n            false\n        }\n    }\n\n    public(friend) fun derived_balance_dispatch_function<T: key>(store: Object<T>): Option<FunctionInfo> acquires FungibleStore, DispatchFunctionStore {\n        let fa_store = borrow_store_resource(&store);\n        let metadata_addr = object::object_address(&fa_store.metadata);\n        if (exists<DispatchFunctionStore>(metadata_addr)) {\n            borrow_global<DispatchFunctionStore>(metadata_addr).derived_balance_function\n        } else {\n            option::none()\n        }\n    }\n\n    public fun asset_metadata(fa: &FungibleAsset): Object<Metadata> {\n        fa.metadata\n    }\n\n    /// Get the underlying metadata object from the `MintRef`.\n    public fun mint_ref_metadata(ref: &MintRef): Object<Metadata> {\n        ref.metadata\n    }\n\n    /// Get the underlying metadata object from the `TransferRef`.\n    public fun transfer_ref_metadata(ref: &TransferRef): Object<Metadata> {\n        ref.metadata\n    }\n\n    /// Get the underlying metadata object from the `BurnRef`.\n    public fun burn_ref_metadata(ref: &BurnRef): Object<Metadata> {\n        ref.metadata\n    }\n\n    /// Transfer an `amount` of fungible asset from `from_store`, which should be owned by `sender`, to `receiver`.\n    /// Note: it does not move the underlying object.\n    public entry fun transfer<T: key>(\n        sender: &signer,\n        from: Object<T>,\n        to: Object<T>,\n        amount: u64,\n    ) acquires FungibleStore, DispatchFunctionStore {\n        let fa = withdraw(sender, from, amount);\n        deposit(to, fa);\n    }\n\n    /// Allow an object to hold a store for fungible assets.\n    /// Applications can use this to create multiple stores for isolating fungible assets for different purposes.\n    public fun create_store<T: key>(\n        constructor_ref: &ConstructorRef,\n        metadata: Object<T>,\n    ): Object<FungibleStore> {\n        let store_obj = &object::generate_signer(constructor_ref);\n        move_to(store_obj, FungibleStore {\n            metadata: object::convert(metadata),\n            balance: 0,\n            frozen: false,\n        });\n        if (is_untransferable(metadata)) {\n            object::set_untransferable(constructor_ref);\n        };\n        object::object_from_constructor_ref<FungibleStore>(constructor_ref)\n    }\n\n    /// Used to delete a store.  Requires the store to be completely empty prior to removing it\n    public fun remove_store(delete_ref: &DeleteRef) acquires FungibleStore, FungibleAssetEvents {\n        let store = &object::object_from_delete_ref<FungibleStore>(delete_ref);\n        let addr = object::object_address(store);\n        let FungibleStore { metadata: _, balance, frozen: _ }\n            = move_from<FungibleStore>(addr);\n        assert!(balance == 0, error::permission_denied(EBALANCE_IS_NOT_ZERO));\n        // Cleanup deprecated event handles if exist.\n        if (exists<FungibleAssetEvents>(addr)) {\n            let FungibleAssetEvents {\n                deposit_events,\n                withdraw_events,\n                frozen_events,\n            } = move_from<FungibleAssetEvents>(addr);\n            event::destroy_handle(deposit_events);\n            event::destroy_handle(withdraw_events);\n            event::destroy_handle(frozen_events);\n        }\n    }\n\n    /// Withdraw `amount` of the fungible asset from `store` by the owner.\n    public fun withdraw<T: key>(\n        owner: &signer,\n        store: Object<T>,\n        amount: u64,\n    ): FungibleAsset acquires FungibleStore, DispatchFunctionStore {\n        withdraw_sanity_check(owner, store, true);\n        withdraw_internal(object::object_address(&store), amount)\n    }\n\n    /// Check the permission for withdraw operation.\n    public(friend) fun withdraw_sanity_check<T: key>(\n        owner: &signer,\n        store: Object<T>,\n        abort_on_dispatch: bool,\n    ) acquires FungibleStore, DispatchFunctionStore {\n        assert!(object::owns(store, signer::address_of(owner)), error::permission_denied(ENOT_STORE_OWNER));\n        let fa_store = borrow_store_resource(&store);\n        assert!(\n            !abort_on_dispatch || !has_withdraw_dispatch_function(fa_store.metadata),\n            error::invalid_argument(EINVALID_DISPATCHABLE_OPERATIONS)\n        );\n        assert!(!fa_store.frozen, error::permission_denied(ESTORE_IS_FROZEN));\n    }\n\n    /// Deposit `amount` of the fungible asset to `store`.\n    public fun deposit_sanity_check<T: key>(\n        store: Object<T>,\n        abort_on_dispatch: bool\n    ) acquires FungibleStore, DispatchFunctionStore {\n        let fa_store = borrow_store_resource(&store);\n        assert!(\n            !abort_on_dispatch || !has_deposit_dispatch_function(fa_store.metadata),\n            error::invalid_argument(EINVALID_DISPATCHABLE_OPERATIONS)\n        );\n        assert!(!fa_store.frozen, error::permission_denied(ESTORE_IS_FROZEN));\n    }\n\n    /// Deposit `amount` of the fungible asset to `store`.\n    public fun deposit<T: key>(store: Object<T>, fa: FungibleAsset) acquires FungibleStore, DispatchFunctionStore {\n        deposit_sanity_check(store, true);\n        deposit_internal(store, fa);\n    }\n\n    /// Mint the specified `amount` of the fungible asset.\n    public fun mint(ref: &MintRef, amount: u64): FungibleAsset acquires Supply, ConcurrentSupply {\n        let metadata = ref.metadata;\n        mint_internal(metadata, amount)\n    }\n\n    /// CAN ONLY BE CALLED BY coin.move for migration.\n    public(friend) fun mint_internal(\n        metadata: Object<Metadata>,\n        amount: u64\n    ): FungibleAsset acquires Supply, ConcurrentSupply {\n        increase_supply(&metadata, amount);\n        FungibleAsset {\n            metadata,\n            amount\n        }\n    }\n\n    /// Mint the specified `amount` of the fungible asset to a destination store.\n    public fun mint_to<T: key>(ref: &MintRef, store: Object<T>, amount: u64)\n    acquires FungibleStore, Supply, ConcurrentSupply, DispatchFunctionStore {\n        deposit_sanity_check(store, false);\n        deposit_internal(store, mint(ref, amount));\n    }\n\n    /// Enable/disable a store's ability to do direct transfers of the fungible asset.\n    public fun set_frozen_flag<T: key>(\n        ref: &TransferRef,\n        store: Object<T>,\n        frozen: bool,\n    ) acquires FungibleStore {\n        assert!(\n            ref.metadata == store_metadata(store),\n            error::invalid_argument(ETRANSFER_REF_AND_STORE_MISMATCH),\n        );\n        set_frozen_flag_internal(store, frozen)\n    }\n\n    public(friend) fun set_frozen_flag_internal<T: key>(\n        store: Object<T>,\n        frozen: bool\n    ) acquires FungibleStore {\n        let store_addr = object::object_address(&store);\n        borrow_global_mut<FungibleStore>(store_addr).frozen = frozen;\n\n        event::emit(Frozen { store: store_addr, frozen });\n    }\n\n    /// Burns a fungible asset\n    public fun burn(ref: &BurnRef, fa: FungibleAsset) acquires Supply, ConcurrentSupply {\n        assert!(\n            ref.metadata == metadata_from_asset(&fa),\n            error::invalid_argument(EBURN_REF_AND_FUNGIBLE_ASSET_MISMATCH)\n        );\n        burn_internal(fa);\n    }\n\n    /// CAN ONLY BE CALLED BY coin.move for migration.\n    public(friend) fun burn_internal(\n        fa: FungibleAsset\n    ): u64 acquires Supply, ConcurrentSupply {\n        let FungibleAsset {\n            metadata,\n            amount\n        } = fa;\n        decrease_supply(&metadata, amount);\n        amount\n    }\n\n    /// Burn the `amount` of the fungible asset from the given store.\n    public fun burn_from<T: key>(\n        ref: &BurnRef,\n        store: Object<T>,\n        amount: u64\n    ) acquires FungibleStore, Supply, ConcurrentSupply {\n        let metadata = ref.metadata;\n        assert!(metadata == store_metadata(store), error::invalid_argument(EBURN_REF_AND_STORE_MISMATCH));\n        let store_addr = object::object_address(&store);\n        burn(ref, withdraw_internal(store_addr, amount));\n    }\n\n    /// Withdraw `amount` of the fungible asset from the `store` ignoring `frozen`.\n    public fun withdraw_with_ref<T: key>(\n        ref: &TransferRef,\n        store: Object<T>,\n        amount: u64\n    ): FungibleAsset acquires FungibleStore {\n        assert!(\n            ref.metadata == store_metadata(store),\n            error::invalid_argument(ETRANSFER_REF_AND_STORE_MISMATCH),\n        );\n        withdraw_internal(object::object_address(&store), amount)\n    }\n\n    /// Deposit the fungible asset into the `store` ignoring `frozen`.\n    public fun deposit_with_ref<T: key>(\n        ref: &TransferRef,\n        store: Object<T>,\n        fa: FungibleAsset\n    ) acquires FungibleStore {\n        assert!(\n            ref.metadata == fa.metadata,\n            error::invalid_argument(ETRANSFER_REF_AND_FUNGIBLE_ASSET_MISMATCH)\n        );\n        deposit_internal(store, fa);\n    }\n\n    /// Transfer `amount` of the fungible asset with `TransferRef` even it is frozen.\n    public fun transfer_with_ref<T: key>(\n        transfer_ref: &TransferRef,\n        from: Object<T>,\n        to: Object<T>,\n        amount: u64,\n    ) acquires FungibleStore {\n        let fa = withdraw_with_ref(transfer_ref, from, amount);\n        deposit_with_ref(transfer_ref, to, fa);\n    }\n\n    /// Create a fungible asset with zero amount.\n    /// This can be useful when starting a series of computations where the initial value is 0.\n    public fun zero<T: key>(metadata: Object<T>): FungibleAsset {\n        FungibleAsset {\n            metadata: object::convert(metadata),\n            amount: 0,\n        }\n    }\n\n    /// Extract a given amount from the given fungible asset and return a new one.\n    public fun extract(fungible_asset: &mut FungibleAsset, amount: u64): FungibleAsset {\n        assert!(fungible_asset.amount >= amount, error::invalid_argument(EINSUFFICIENT_BALANCE));\n        fungible_asset.amount = fungible_asset.amount - amount;\n        FungibleAsset {\n            metadata: fungible_asset.metadata,\n            amount,\n        }\n    }\n\n    /// \"Merges\" the two given fungible assets. The fungible asset passed in as `dst_fungible_asset` will have a value\n    /// equal to the sum of the two (`dst_fungible_asset` and `src_fungible_asset`).\n    public fun merge(dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset) {\n        let FungibleAsset { metadata, amount } = src_fungible_asset;\n        assert!(metadata == dst_fungible_asset.metadata, error::invalid_argument(EFUNGIBLE_ASSET_MISMATCH));\n        dst_fungible_asset.amount = dst_fungible_asset.amount + amount;\n    }\n\n    /// Destroy an empty fungible asset.\n    public fun destroy_zero(fungible_asset: FungibleAsset) {\n        let FungibleAsset { amount, metadata: _ } = fungible_asset;\n        assert!(amount == 0, error::invalid_argument(EAMOUNT_IS_NOT_ZERO));\n    }\n\n    public(friend) fun deposit_internal<T: key>(store: Object<T>, fa: FungibleAsset) acquires FungibleStore {\n        let FungibleAsset { metadata, amount } = fa;\n        if (amount == 0) return;\n\n        let store_metadata = store_metadata(store);\n        assert!(metadata == store_metadata, error::invalid_argument(EFUNGIBLE_ASSET_AND_STORE_MISMATCH));\n        let store_addr = object::object_address(&store);\n        let store = borrow_global_mut<FungibleStore>(store_addr);\n        store.balance = store.balance + amount;\n\n        event::emit(Deposit { store: store_addr, amount });\n    }\n\n    /// Extract `amount` of the fungible asset from `store`.\n    public(friend) fun withdraw_internal(\n        store_addr: address,\n        amount: u64,\n    ): FungibleAsset acquires FungibleStore {\n        assert!(exists<FungibleStore>(store_addr), error::not_found(EFUNGIBLE_STORE_EXISTENCE));\n        let store = borrow_global_mut<FungibleStore>(store_addr);\n        let metadata = store.metadata;\n        if (amount != 0) {\n            assert!(store.balance >= amount, error::invalid_argument(EINSUFFICIENT_BALANCE));\n            store.balance = store.balance - amount;\n            event::emit<Withdraw>(Withdraw { store: store_addr, amount });\n        };\n        FungibleAsset { metadata, amount }\n    }\n\n    /// Increase the supply of a fungible asset by minting.\n    fun increase_supply<T: key>(metadata: &Object<T>, amount: u64) acquires Supply, ConcurrentSupply {\n        if (amount == 0) {\n            return\n        };\n        let metadata_address = object::object_address(metadata);\n\n        if (exists<ConcurrentSupply>(metadata_address)) {\n            let supply = borrow_global_mut<ConcurrentSupply>(metadata_address);\n            assert!(\n                aggregator_v2::try_add(&mut supply.current, (amount as u128)),\n                error::out_of_range(EMAX_SUPPLY_EXCEEDED)\n            );\n        } else if (exists<Supply>(metadata_address)) {\n            let supply = borrow_global_mut<Supply>(metadata_address);\n            if (option::is_some(&supply.maximum)) {\n                let max = *option::borrow_mut(&mut supply.maximum);\n                assert!(\n                    max - supply.current >= (amount as u128),\n                    error::out_of_range(EMAX_SUPPLY_EXCEEDED)\n                )\n            };\n            supply.current = supply.current + (amount as u128);\n        } else {\n            abort error::not_found(ESUPPLY_NOT_FOUND)\n        }\n    }\n\n    /// Decrease the supply of a fungible asset by burning.\n    fun decrease_supply<T: key>(metadata: &Object<T>, amount: u64) acquires Supply, ConcurrentSupply {\n        if (amount == 0) {\n            return\n        };\n        let metadata_address = object::object_address(metadata);\n\n        if (exists<ConcurrentSupply>(metadata_address)) {\n            let supply = borrow_global_mut<ConcurrentSupply>(metadata_address);\n\n            assert!(\n                aggregator_v2::try_sub(&mut supply.current, (amount as u128)),\n                error::out_of_range(ESUPPLY_UNDERFLOW)\n            );\n        } else if (exists<Supply>(metadata_address)) {\n            assert!(exists<Supply>(metadata_address), error::not_found(ESUPPLY_NOT_FOUND));\n            let supply = borrow_global_mut<Supply>(metadata_address);\n            assert!(\n                supply.current >= (amount as u128),\n                error::invalid_state(ESUPPLY_UNDERFLOW)\n            );\n            supply.current = supply.current - (amount as u128);\n        } else {\n            assert!(false, error::not_found(ESUPPLY_NOT_FOUND));\n        }\n    }\n\n    inline fun borrow_fungible_metadata<T: key>(\n        metadata: &Object<T>\n    ): &Metadata acquires Metadata {\n        let addr = object::object_address(metadata);\n        borrow_global<Metadata>(addr)\n    }\n\n    inline fun borrow_fungible_metadata_mut<T: key>(\n        metadata: &Object<T>\n    ): &mut Metadata acquires Metadata {\n        let addr = object::object_address(metadata);\n        borrow_global_mut<Metadata>(addr)\n    }\n\n    inline fun borrow_store_resource<T: key>(store: &Object<T>): &FungibleStore acquires FungibleStore {\n        let store_addr = object::object_address(store);\n        assert!(exists<FungibleStore>(store_addr), error::not_found(EFUNGIBLE_STORE_EXISTENCE));\n        borrow_global<FungibleStore>(store_addr)\n    }\n\n    public fun upgrade_to_concurrent(\n        ref: &ExtendRef,\n    ) acquires Supply {\n        let metadata_object_address = object::address_from_extend_ref(ref);\n        let metadata_object_signer = object::generate_signer_for_extending(ref);\n        assert!(\n            features::concurrent_fungible_assets_enabled(),\n            error::invalid_argument(ECONCURRENT_SUPPLY_NOT_ENABLED)\n        );\n        assert!(exists<Supply>(metadata_object_address), error::not_found(ESUPPLY_NOT_FOUND));\n        let Supply {\n            current,\n            maximum,\n        } = move_from<Supply>(metadata_object_address);\n\n        let unlimited = option::is_none(&maximum);\n        let supply = ConcurrentSupply {\n            current: if (unlimited) {\n                aggregator_v2::create_unbounded_aggregator()\n            }\n            else {\n                aggregator_v2::create_aggregator(option::extract(&mut maximum))\n            },\n        };\n        // update current state:\n        aggregator_v2::add(&mut supply.current, current);\n        move_to(&metadata_object_signer, supply);\n    }\n\n    #[test_only]\n    use aptos_framework::account;\n\n    #[test_only]\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n\n    struct TestToken has key {}\n\n    #[test_only]\n    public fun create_test_token(creator: &signer): (ConstructorRef, Object<TestToken>) {\n        account::create_account_for_test(signer::address_of(creator));\n        let creator_ref = object::create_named_object(creator, b\"TEST\");\n        let object_signer = object::generate_signer(&creator_ref);\n        move_to(&object_signer, TestToken {});\n\n        let token = object::object_from_constructor_ref<TestToken>(&creator_ref);\n        (creator_ref, token)\n    }\n\n    #[test_only]\n    public fun init_test_metadata(constructor_ref: &ConstructorRef): (MintRef, TransferRef, BurnRef) {\n        add_fungibility(\n            constructor_ref,\n            option::some(100) /* max supply */,\n            string::utf8(b\"TEST\"),\n            string::utf8(b\"@@\"),\n            0,\n            string::utf8(b\"http://www.example.com/favicon.ico\"),\n            string::utf8(b\"http://www.example.com\"),\n        );\n        let mint_ref = generate_mint_ref(constructor_ref);\n        let burn_ref = generate_burn_ref(constructor_ref);\n        let transfer_ref = generate_transfer_ref(constructor_ref);\n        (mint_ref, transfer_ref, burn_ref)\n    }\n\n    #[test_only]\n    public fun create_fungible_asset(\n        creator: &signer\n    ): (MintRef, TransferRef, BurnRef, Object<Metadata>) {\n        let (creator_ref, token_object) = create_test_token(creator);\n        let (mint, transfer, burn) = init_test_metadata(&creator_ref);\n        (mint, transfer, burn, object::convert(token_object))\n    }\n\n    #[test_only]\n    public fun create_test_store<T: key>(owner: &signer, metadata: Object<T>): Object<FungibleStore> {\n        let owner_addr = signer::address_of(owner);\n        if (!account::exists_at(owner_addr)) {\n            account::create_account_for_test(owner_addr);\n        };\n        create_store(&object::create_object_from_account(owner), metadata)\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_metadata_basic_flow(creator: &signer) acquires Metadata, Supply, ConcurrentSupply {\n        let (creator_ref, metadata) = create_test_token(creator);\n        init_test_metadata(&creator_ref);\n        assert!(supply(metadata) == option::some(0), 1);\n        assert!(maximum(metadata) == option::some(100), 2);\n        assert!(name(metadata) == string::utf8(b\"TEST\"), 3);\n        assert!(symbol(metadata) == string::utf8(b\"@@\"), 4);\n        assert!(decimals(metadata) == 0, 5);\n\n        increase_supply(&metadata, 50);\n        assert!(supply(metadata) == option::some(50), 6);\n        decrease_supply(&metadata, 30);\n        assert!(supply(metadata) == option::some(20), 7);\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 0x20005, location = Self)]\n    fun test_supply_overflow(creator: &signer) acquires Supply, ConcurrentSupply {\n        let (creator_ref, metadata) = create_test_token(creator);\n        init_test_metadata(&creator_ref);\n        increase_supply(&metadata, 101);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_create_and_remove_store(creator: &signer) acquires FungibleStore, FungibleAssetEvents {\n        let (_, _, _, metadata) = create_fungible_asset(creator);\n        let creator_ref = object::create_object_from_account(creator);\n        create_store(&creator_ref, metadata);\n        let delete_ref = object::generate_delete_ref(&creator_ref);\n        remove_store(&delete_ref);\n    }\n\n    #[test(creator = @0xcafe, aaron = @0xface)]\n    fun test_e2e_basic_flow(\n        creator: &signer,\n        aaron: &signer,\n    ) acquires FungibleStore, Supply, ConcurrentSupply, DispatchFunctionStore {\n        let (mint_ref, transfer_ref, burn_ref, test_token) = create_fungible_asset(creator);\n        let metadata = mint_ref.metadata;\n        let creator_store = create_test_store(creator, metadata);\n        let aaron_store = create_test_store(aaron, metadata);\n\n        assert!(supply(test_token) == option::some(0), 1);\n        // Mint\n        let fa = mint(&mint_ref, 100);\n        assert!(supply(test_token) == option::some(100), 2);\n        // Deposit\n        deposit(creator_store, fa);\n        // Withdraw\n        let fa = withdraw(creator, creator_store, 80);\n        assert!(supply(test_token) == option::some(100), 3);\n        deposit(aaron_store, fa);\n        // Burn\n        burn_from(&burn_ref, aaron_store, 30);\n        assert!(supply(test_token) == option::some(70), 4);\n        // Transfer\n        transfer(creator, creator_store, aaron_store, 10);\n        assert!(balance(creator_store) == 10, 5);\n        assert!(balance(aaron_store) == 60, 6);\n\n        set_frozen_flag(&transfer_ref, aaron_store, true);\n        assert!(is_frozen(aaron_store), 7);\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_frozen(\n        creator: &signer\n    ) acquires FungibleStore, Supply, ConcurrentSupply, DispatchFunctionStore {\n        let (mint_ref, transfer_ref, _burn_ref, _) = create_fungible_asset(creator);\n\n        let creator_store = create_test_store(creator, mint_ref.metadata);\n        let fa = mint(&mint_ref, 100);\n        set_frozen_flag(&transfer_ref, creator_store, true);\n        deposit(creator_store, fa);\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 0x50003, location = Self)]\n    fun test_mint_to_frozen(\n        creator: &signer\n    ) acquires FungibleStore, Supply, ConcurrentSupply, DispatchFunctionStore {\n        let (mint_ref, transfer_ref, _burn_ref, _) = create_fungible_asset(creator);\n\n        let creator_store = create_test_store(creator, mint_ref.metadata);\n        set_frozen_flag(&transfer_ref, creator_store, true);\n        mint_to(&mint_ref, creator_store, 100);\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 0x50003, location = aptos_framework::object)]\n    fun test_untransferable(\n        creator: &signer\n    ) {\n        let (creator_ref, _) = create_test_token(creator);\n        let (mint_ref, _, _) = init_test_metadata(&creator_ref);\n        set_untransferable(&creator_ref);\n\n        let creator_store = create_test_store(creator, mint_ref.metadata);\n        object::transfer(creator, creator_store, @0x456);\n    }\n\n    #[test(creator = @0xcafe, aaron = @0xface)]\n    fun test_transfer_with_ref(\n        creator: &signer,\n        aaron: &signer,\n    ) acquires FungibleStore, Supply, ConcurrentSupply {\n        let (mint_ref, transfer_ref, _burn_ref, _) = create_fungible_asset(creator);\n        let metadata = mint_ref.metadata;\n        let creator_store = create_test_store(creator, metadata);\n        let aaron_store = create_test_store(aaron, metadata);\n\n        let fa = mint(&mint_ref, 100);\n        set_frozen_flag(&transfer_ref, creator_store, true);\n        set_frozen_flag(&transfer_ref, aaron_store, true);\n        deposit_with_ref(&transfer_ref, creator_store, fa);\n        transfer_with_ref(&transfer_ref, creator_store, aaron_store, 80);\n        assert!(balance(creator_store) == 20, 1);\n        assert!(balance(aaron_store) == 80, 2);\n        assert!(!!is_frozen(creator_store), 3);\n        assert!(!!is_frozen(aaron_store), 4);\n    }\n\n    #[test(creator = @0xcafe)]\n    fun test_merge_and_exact(creator: &signer) acquires Supply, ConcurrentSupply {\n        let (mint_ref, _transfer_ref, burn_ref, _) = create_fungible_asset(creator);\n        let fa = mint(&mint_ref, 100);\n        let cash = extract(&mut fa, 80);\n        assert!(fa.amount == 20, 1);\n        assert!(cash.amount == 80, 2);\n        let more_cash = extract(&mut fa, 20);\n        destroy_zero(fa);\n        merge(&mut cash, more_cash);\n        assert!(cash.amount == 100, 3);\n        burn(&burn_ref, cash);\n    }\n\n    #[test(creator = @0xcafe)]\n    #[expected_failure(abort_code = 0x10012, location = Self)]\n    fun test_add_fungibility_to_deletable_object(creator: &signer) {\n        account::create_account_for_test(signer::address_of(creator));\n        let creator_ref = &object::create_object_from_account(creator);\n        init_test_metadata(creator_ref);\n    }\n\n    #[test(creator = @0xcafe, aaron = @0xface)]\n    #[expected_failure(abort_code = 0x10006, location = Self)]\n    fun test_fungible_asset_mismatch_when_merge(creator: &signer, aaron: &signer) {\n        let (_, _, _, metadata1) = create_fungible_asset(creator);\n        let (_, _, _, metadata2) = create_fungible_asset(aaron);\n        let base = FungibleAsset {\n            metadata: metadata1,\n            amount: 1,\n        };\n        let addon = FungibleAsset {\n            metadata: metadata2,\n            amount: 1\n        };\n        merge(&mut base, addon);\n        let FungibleAsset {\n            metadata: _,\n            amount: _\n        } = base;\n    }\n\n    #[test(fx = @aptos_framework, creator = @0xcafe)]\n    fun test_fungible_asset_upgrade(\n        fx: &signer,\n        creator: &signer\n    ) acquires Supply, ConcurrentSupply, FungibleStore {\n        let feature = features::get_concurrent_fungible_assets_feature();\n        let agg_feature = features::get_aggregator_v2_api_feature();\n        features::change_feature_flags_for_testing(fx, vector[], vector[feature, agg_feature]);\n\n        let (creator_ref, token_object) = create_test_token(creator);\n        let (mint_ref, transfer_ref, _burn) = init_test_metadata(&creator_ref);\n        let test_token = object::convert<TestToken, Metadata>(token_object);\n        let creator_store = create_test_store(creator, test_token);\n\n        let fa = mint(&mint_ref, 30);\n        assert!(supply(test_token) == option::some(30), 2);\n\n        deposit_with_ref(&transfer_ref, creator_store, fa);\n\n        features::change_feature_flags_for_testing(fx, vector[feature, agg_feature], vector[]);\n\n        let extend_ref = object::generate_extend_ref(&creator_ref);\n        upgrade_to_concurrent(&extend_ref);\n\n        let fb = mint(&mint_ref, 20);\n        assert!(supply(test_token) == option::some(50), 3);\n\n        deposit_with_ref(&transfer_ref, creator_store, fb);\n    }\n\n    #[deprecated]\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct FungibleAssetEvents has key {\n        deposit_events: event::EventHandle<DepositEvent>,\n        withdraw_events: event::EventHandle<WithdrawEvent>,\n        frozen_events: event::EventHandle<FrozenEvent>,\n    }\n\n    #[deprecated]\n    struct DepositEvent has drop, store {\n        amount: u64,\n    }\n\n    #[deprecated]\n    struct WithdrawEvent has drop, store {\n        amount: u64,\n    }\n\n    #[deprecated]\n    struct FrozenEvent has drop, store {\n        frozen: bool,\n    }\n}\n","name":"fungible_asset.move"},{"content":"module aptos_framework::genesis {\n    use std::error;\n    use std::fixed_point32;\n    use std::vector;\n\n    use aptos_std::simple_map;\n\n    use aptos_framework::account;\n    use aptos_framework::aggregator_factory;\n    use aptos_framework::aptos_coin::{Self, AptosCoin};\n    use aptos_framework::aptos_governance;\n    use aptos_framework::block;\n    use aptos_framework::chain_id;\n    use aptos_framework::chain_status;\n    use aptos_framework::coin;\n    use aptos_framework::consensus_config;\n    use aptos_framework::execution_config;\n    use aptos_framework::create_signer::create_signer;\n    use aptos_framework::gas_schedule;\n    use aptos_framework::reconfiguration;\n    use aptos_framework::stake;\n    use aptos_framework::staking_contract;\n    use aptos_framework::staking_config;\n    use aptos_framework::state_storage;\n    use aptos_framework::storage_gas;\n    use aptos_framework::timestamp;\n    use aptos_framework::transaction_fee;\n    use aptos_framework::transaction_validation;\n    use aptos_framework::version;\n    use aptos_framework::vesting;\n\n    const EDUPLICATE_ACCOUNT: u64 = 1;\n    const EACCOUNT_DOES_NOT_EXIST: u64 = 2;\n\n    struct AccountMap has drop {\n        account_address: address,\n        balance: u64,\n    }\n\n    struct EmployeeAccountMap has copy, drop {\n        accounts: vector<address>,\n        validator: ValidatorConfigurationWithCommission,\n        vesting_schedule_numerator: vector<u64>,\n        vesting_schedule_denominator: u64,\n        beneficiary_resetter: address,\n    }\n\n    struct ValidatorConfiguration has copy, drop {\n        owner_address: address,\n        operator_address: address,\n        voter_address: address,\n        stake_amount: u64,\n        consensus_pubkey: vector<u8>,\n        proof_of_possession: vector<u8>,\n        network_addresses: vector<u8>,\n        full_node_network_addresses: vector<u8>,\n    }\n\n    struct ValidatorConfigurationWithCommission has copy, drop {\n        validator_config: ValidatorConfiguration,\n        commission_percentage: u64,\n        join_during_genesis: bool,\n    }\n\n    /// Genesis step 1: Initialize aptos framework account and core modules on chain.\n    fun initialize(\n        gas_schedule: vector<u8>,\n        chain_id: u8,\n        initial_version: u64,\n        consensus_config: vector<u8>,\n        execution_config: vector<u8>,\n        epoch_interval_microsecs: u64,\n        minimum_stake: u64,\n        maximum_stake: u64,\n        recurring_lockup_duration_secs: u64,\n        allow_validator_set_change: bool,\n        rewards_rate: u64,\n        rewards_rate_denominator: u64,\n        voting_power_increase_limit: u64,\n    ) {\n        // Initialize the aptos framework account. This is the account where system resources and modules will be\n        // deployed to. This will be entirely managed by on-chain governance and no entities have the key or privileges\n        // to use this account.\n        let (aptos_framework_account, aptos_framework_signer_cap) = account::create_framework_reserved_account(@aptos_framework);\n        // Initialize account configs on aptos framework account.\n        account::initialize(&aptos_framework_account);\n\n        transaction_validation::initialize(\n            &aptos_framework_account,\n            b\"script_prologue\",\n            b\"module_prologue\",\n            b\"multi_agent_script_prologue\",\n            b\"epilogue\",\n        );\n\n        // Give the decentralized on-chain governance control over the core framework account.\n        aptos_governance::store_signer_cap(&aptos_framework_account, @aptos_framework, aptos_framework_signer_cap);\n\n        // put reserved framework reserved accounts under aptos governance\n        let framework_reserved_addresses = vector<address>[@0x2, @0x3, @0x4, @0x5, @0x6, @0x7, @0x8, @0x9, @0xa];\n        while (!vector::is_empty(&framework_reserved_addresses)) {\n            let address = vector::pop_back<address>(&mut framework_reserved_addresses);\n            let (_, framework_signer_cap) = account::create_framework_reserved_account(address);\n            aptos_governance::store_signer_cap(&aptos_framework_account, address, framework_signer_cap);\n        };\n\n        consensus_config::initialize(&aptos_framework_account, consensus_config);\n        execution_config::set(&aptos_framework_account, execution_config);\n        version::initialize(&aptos_framework_account, initial_version);\n        stake::initialize(&aptos_framework_account);\n        staking_config::initialize(\n            &aptos_framework_account,\n            minimum_stake,\n            maximum_stake,\n            recurring_lockup_duration_secs,\n            allow_validator_set_change,\n            rewards_rate,\n            rewards_rate_denominator,\n            voting_power_increase_limit,\n        );\n        storage_gas::initialize(&aptos_framework_account);\n        gas_schedule::initialize(&aptos_framework_account, gas_schedule);\n\n        // Ensure we can create aggregators for supply, but not enable it for common use just yet.\n        aggregator_factory::initialize_aggregator_factory(&aptos_framework_account);\n        coin::initialize_supply_config(&aptos_framework_account);\n\n        chain_id::initialize(&aptos_framework_account, chain_id);\n        reconfiguration::initialize(&aptos_framework_account);\n        block::initialize(&aptos_framework_account, epoch_interval_microsecs);\n        state_storage::initialize(&aptos_framework_account);\n        timestamp::set_time_has_started(&aptos_framework_account);\n    }\n\n    /// Genesis step 2: Initialize Aptos coin.\n    fun initialize_aptos_coin(aptos_framework: &signer) {\n        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);\n\n        coin::create_coin_conversion_map(aptos_framework);\n        coin::create_pairing<AptosCoin>(aptos_framework);\n\n        // Give stake module MintCapability<AptosCoin> so it can mint rewards.\n        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);\n        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.\n        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);\n        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.\n        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);\n    }\n\n    /// Only called for testnets and e2e tests.\n    fun initialize_core_resources_and_aptos_coin(\n        aptos_framework: &signer,\n        core_resources_auth_key: vector<u8>,\n    ) {\n        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);\n\n        coin::create_coin_conversion_map(aptos_framework);\n        coin::create_pairing<AptosCoin>(aptos_framework);\n\n        // Give stake module MintCapability<AptosCoin> so it can mint rewards.\n        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);\n        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.\n        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);\n        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.\n        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);\n\n        let core_resources = account::create_account(@core_resources);\n        account::rotate_authentication_key_internal(&core_resources, core_resources_auth_key);\n        aptos_coin::configure_accounts_for_test(aptos_framework, &core_resources, mint_cap);\n    }\n\n    fun create_accounts(aptos_framework: &signer, accounts: vector<AccountMap>) {\n        let unique_accounts = vector::empty();\n        vector::for_each_ref(&accounts, |account_map| {\n            let account_map: &AccountMap = account_map;\n            assert!(\n                !vector::contains(&unique_accounts, &account_map.account_address),\n                error::already_exists(EDUPLICATE_ACCOUNT),\n            );\n            vector::push_back(&mut unique_accounts, account_map.account_address);\n\n            create_account(\n                aptos_framework,\n                account_map.account_address,\n                account_map.balance,\n            );\n        });\n    }\n\n    /// This creates an funds an account if it doesn't exist.\n    /// If it exists, it just returns the signer.\n    fun create_account(aptos_framework: &signer, account_address: address, balance: u64): signer {\n        if (account::exists_at(account_address)) {\n            create_signer(account_address)\n        } else {\n            let account = account::create_account(account_address);\n            coin::register<AptosCoin>(&account);\n            aptos_coin::mint(aptos_framework, account_address, balance);\n            account\n        }\n    }\n\n    fun create_employee_validators(\n        employee_vesting_start: u64,\n        employee_vesting_period_duration: u64,\n        employees: vector<EmployeeAccountMap>,\n    ) {\n        let unique_accounts = vector::empty();\n\n        vector::for_each_ref(&employees, |employee_group| {\n            let j = 0;\n            let employee_group: &EmployeeAccountMap = employee_group;\n            let num_employees_in_group = vector::length(&employee_group.accounts);\n\n            let buy_ins = simple_map::create();\n\n            while (j < num_employees_in_group) {\n                let account = vector::borrow(&employee_group.accounts, j);\n                assert!(\n                    !vector::contains(&unique_accounts, account),\n                    error::already_exists(EDUPLICATE_ACCOUNT),\n                );\n                vector::push_back(&mut unique_accounts, *account);\n\n                let employee = create_signer(*account);\n                let total = coin::balance<AptosCoin>(*account);\n                let coins = coin::withdraw<AptosCoin>(&employee, total);\n                simple_map::add(&mut buy_ins, *account, coins);\n\n                j = j + 1;\n            };\n\n            let j = 0;\n            let num_vesting_events = vector::length(&employee_group.vesting_schedule_numerator);\n            let schedule = vector::empty();\n\n            while (j < num_vesting_events) {\n                let numerator = vector::borrow(&employee_group.vesting_schedule_numerator, j);\n                let event = fixed_point32::create_from_rational(*numerator, employee_group.vesting_schedule_denominator);\n                vector::push_back(&mut schedule, event);\n\n                j = j + 1;\n            };\n\n            let vesting_schedule = vesting::create_vesting_schedule(\n                schedule,\n                employee_vesting_start,\n                employee_vesting_period_duration,\n            );\n\n            let admin = employee_group.validator.validator_config.owner_address;\n            let admin_signer = &create_signer(admin);\n            let contract_address = vesting::create_vesting_contract(\n                admin_signer,\n                &employee_group.accounts,\n                buy_ins,\n                vesting_schedule,\n                admin,\n                employee_group.validator.validator_config.operator_address,\n                employee_group.validator.validator_config.voter_address,\n                employee_group.validator.commission_percentage,\n                x\"\",\n            );\n            let pool_address = vesting::stake_pool_address(contract_address);\n\n            if (employee_group.beneficiary_resetter != @0x0) {\n                vesting::set_beneficiary_resetter(admin_signer, contract_address, employee_group.beneficiary_resetter);\n            };\n\n            let validator = &employee_group.validator.validator_config;\n            assert!(\n                account::exists_at(validator.owner_address),\n                error::not_found(EACCOUNT_DOES_NOT_EXIST),\n            );\n            assert!(\n                account::exists_at(validator.operator_address),\n                error::not_found(EACCOUNT_DOES_NOT_EXIST),\n            );\n            assert!(\n                account::exists_at(validator.voter_address),\n                error::not_found(EACCOUNT_DOES_NOT_EXIST),\n            );\n            if (employee_group.validator.join_during_genesis) {\n                initialize_validator(pool_address, validator);\n            };\n        });\n    }\n\n    fun create_initialize_validators_with_commission(\n        aptos_framework: &signer,\n        use_staking_contract: bool,\n        validators: vector<ValidatorConfigurationWithCommission>,\n    ) {\n        vector::for_each_ref(&validators, |validator| {\n            let validator: &ValidatorConfigurationWithCommission = validator;\n            create_initialize_validator(aptos_framework, validator, use_staking_contract);\n        });\n\n        // Destroy the aptos framework account's ability to mint coins now that we're done with setting up the initial\n        // validators.\n        aptos_coin::destroy_mint_cap(aptos_framework);\n\n        stake::on_new_epoch();\n    }\n\n    /// Sets up the initial validator set for the network.\n    /// The validator \"owner\" accounts, and their authentication\n    /// Addresses (and keys) are encoded in the `owners`\n    /// Each validator signs consensus messages with the private key corresponding to the Ed25519\n    /// public key in `consensus_pubkeys`.\n    /// Finally, each validator must specify the network address\n    /// (see types/src/network_address/mod.rs) for itself and its full nodes.\n    ///\n    /// Network address fields are a vector per account, where each entry is a vector of addresses\n    /// encoded in a single BCS byte array.\n    fun create_initialize_validators(aptos_framework: &signer, validators: vector<ValidatorConfiguration>) {\n        let validators_with_commission = vector::empty();\n        vector::for_each_reverse(validators, |validator| {\n            let validator_with_commission = ValidatorConfigurationWithCommission {\n                validator_config: validator,\n                commission_percentage: 0,\n                join_during_genesis: true,\n            };\n            vector::push_back(&mut validators_with_commission, validator_with_commission);\n        });\n\n        create_initialize_validators_with_commission(aptos_framework, false, validators_with_commission);\n    }\n\n    fun create_initialize_validator(\n        aptos_framework: &signer,\n        commission_config: &ValidatorConfigurationWithCommission,\n        use_staking_contract: bool,\n    ) {\n        let validator = &commission_config.validator_config;\n\n        let owner = &create_account(aptos_framework, validator.owner_address, validator.stake_amount);\n        create_account(aptos_framework, validator.operator_address, 0);\n        create_account(aptos_framework, validator.voter_address, 0);\n\n        // Initialize the stake pool and join the validator set.\n        let pool_address = if (use_staking_contract) {\n            staking_contract::create_staking_contract(\n                owner,\n                validator.operator_address,\n                validator.voter_address,\n                validator.stake_amount,\n                commission_config.commission_percentage,\n                x\"\",\n            );\n            staking_contract::stake_pool_address(validator.owner_address, validator.operator_address)\n        } else {\n            stake::initialize_stake_owner(\n                owner,\n                validator.stake_amount,\n                validator.operator_address,\n                validator.voter_address,\n            );\n            validator.owner_address\n        };\n\n        if (commission_config.join_during_genesis) {\n            initialize_validator(pool_address, validator);\n        };\n    }\n\n    fun initialize_validator(pool_address: address, validator: &ValidatorConfiguration) {\n        let operator = &create_signer(validator.operator_address);\n\n        stake::rotate_consensus_key(\n            operator,\n            pool_address,\n            validator.consensus_pubkey,\n            validator.proof_of_possession,\n        );\n        stake::update_network_and_fullnode_addresses(\n            operator,\n            pool_address,\n            validator.network_addresses,\n            validator.full_node_network_addresses,\n        );\n        stake::join_validator_set_internal(operator, pool_address);\n    }\n\n    /// The last step of genesis.\n    fun set_genesis_end(aptos_framework: &signer) {\n        chain_status::set_genesis_end(aptos_framework);\n    }\n\n    #[verify_only]\n    use std::features;\n\n    #[verify_only]\n    fun initialize_for_verification(\n        gas_schedule: vector<u8>,\n        chain_id: u8,\n        initial_version: u64,\n        consensus_config: vector<u8>,\n        execution_config: vector<u8>,\n        epoch_interval_microsecs: u64,\n        minimum_stake: u64,\n        maximum_stake: u64,\n        recurring_lockup_duration_secs: u64,\n        allow_validator_set_change: bool,\n        rewards_rate: u64,\n        rewards_rate_denominator: u64,\n        voting_power_increase_limit: u64,\n        aptos_framework: &signer,\n        min_voting_threshold: u128,\n        required_proposer_stake: u64,\n        voting_duration_secs: u64,\n        accounts: vector<AccountMap>,\n        employee_vesting_start: u64,\n        employee_vesting_period_duration: u64,\n        employees: vector<EmployeeAccountMap>,\n        validators: vector<ValidatorConfigurationWithCommission>\n    ) {\n        initialize(\n            gas_schedule,\n            chain_id,\n            initial_version,\n            consensus_config,\n            execution_config,\n            epoch_interval_microsecs,\n            minimum_stake,\n            maximum_stake,\n            recurring_lockup_duration_secs,\n            allow_validator_set_change,\n            rewards_rate,\n            rewards_rate_denominator,\n            voting_power_increase_limit\n        );\n        features::change_feature_flags_for_verification(aptos_framework, vector[1, 2], vector[]);\n        initialize_aptos_coin(aptos_framework);\n        aptos_governance::initialize_for_verification(\n            aptos_framework,\n            min_voting_threshold,\n            required_proposer_stake,\n            voting_duration_secs\n        );\n        create_accounts(aptos_framework, accounts);\n        create_employee_validators(employee_vesting_start, employee_vesting_period_duration, employees);\n        create_initialize_validators_with_commission(aptos_framework, true, validators);\n        set_genesis_end(aptos_framework);\n    }\n\n    #[test_only]\n    public fun setup() {\n        initialize(\n            x\"000000000000000000\", // empty gas schedule\n            4u8, // TESTING chain ID\n            0,\n            x\"12\",\n            x\"13\",\n            1,\n            0,\n            1,\n            1,\n            true,\n            1,\n            1,\n            30,\n        )\n    }\n\n    #[test]\n    fun test_setup() {\n        setup();\n        assert!(account::exists_at(@aptos_framework), 1);\n        assert!(account::exists_at(@0x2), 1);\n        assert!(account::exists_at(@0x3), 1);\n        assert!(account::exists_at(@0x4), 1);\n        assert!(account::exists_at(@0x5), 1);\n        assert!(account::exists_at(@0x6), 1);\n        assert!(account::exists_at(@0x7), 1);\n        assert!(account::exists_at(@0x8), 1);\n        assert!(account::exists_at(@0x9), 1);\n        assert!(account::exists_at(@0xa), 1);\n    }\n\n    #[test(aptos_framework = @0x1)]\n    fun test_create_account(aptos_framework: &signer) {\n        setup();\n        initialize_aptos_coin(aptos_framework);\n\n        let addr = @0x121341; // 01 -> 0a are taken\n        let test_signer_before = create_account(aptos_framework, addr, 15);\n        let test_signer_after = create_account(aptos_framework, addr, 500);\n        assert!(test_signer_before == test_signer_after, 0);\n        assert!(coin::balance<AptosCoin>(addr) == 15, 1);\n    }\n\n    #[test(aptos_framework = @0x1)]\n    fun test_create_accounts(aptos_framework: &signer) {\n        setup();\n        initialize_aptos_coin(aptos_framework);\n\n        // 01 -> 0a are taken\n        let addr0 = @0x121341;\n        let addr1 = @0x121345;\n\n        let accounts = vector[\n            AccountMap {\n                account_address: addr0,\n                balance: 12345,\n            },\n            AccountMap {\n                account_address: addr1,\n                balance: 67890,\n            },\n        ];\n\n        create_accounts(aptos_framework, accounts);\n        assert!(coin::balance<AptosCoin>(addr0) == 12345, 0);\n        assert!(coin::balance<AptosCoin>(addr1) == 67890, 1);\n\n        create_account(aptos_framework, addr0, 23456);\n        assert!(coin::balance<AptosCoin>(addr0) == 12345, 2);\n    }\n}\n","name":"genesis.move"},{"content":"/// Define the GovernanceProposal that will be used as part of on-chain governance by AptosGovernance.\n///\n/// This is separate from the AptosGovernance module to avoid circular dependency between AptosGovernance and Stake.\nmodule aptos_framework::governance_proposal {\n    friend aptos_framework::aptos_governance;\n\n    struct GovernanceProposal has store, drop {}\n\n    /// Create and return a GovernanceProposal resource. Can only be called by AptosGovernance\n    public(friend) fun create_proposal(): GovernanceProposal {\n        GovernanceProposal {}\n    }\n\n    /// Useful for AptosGovernance to create an empty proposal as proof.\n    public(friend) fun create_empty_proposal(): GovernanceProposal {\n        create_proposal()\n    }\n\n    #[test_only]\n    public fun create_test_proposal(): GovernanceProposal {\n        create_empty_proposal()\n    }\n}\n","name":"governance_proposal.move"},{"content":"/// A module for generating globally unique identifiers\nmodule aptos_framework::guid {\n    friend aptos_framework::account;\n    friend aptos_framework::object;\n\n    /// A globally unique identifier derived from the sender's address and a counter\n    struct GUID has drop, store {\n        id: ID\n    }\n\n    /// A non-privileged identifier that can be freely created by anyone. Useful for looking up GUID's.\n    struct ID has copy, drop, store {\n        /// If creation_num is `i`, this is the `i+1`th GUID created by `addr`\n        creation_num: u64,\n        /// Address that created the GUID\n        addr: address\n    }\n\n    /// GUID generator must be published ahead of first usage of `create_with_capability` function.\n    const EGUID_GENERATOR_NOT_PUBLISHED: u64 = 0;\n\n    /// Create and return a new GUID from a trusted module.\n    public(friend) fun create(addr: address, creation_num_ref: &mut u64): GUID {\n        let creation_num = *creation_num_ref;\n        *creation_num_ref = creation_num + 1;\n        GUID {\n            id: ID {\n                creation_num,\n                addr,\n            }\n        }\n    }\n\n    /// Create a non-privileged id from `addr` and `creation_num`\n    public fun create_id(addr: address, creation_num: u64): ID {\n        ID { creation_num, addr }\n    }\n\n    /// Get the non-privileged ID associated with a GUID\n    public fun id(guid: &GUID): ID {\n        guid.id\n    }\n\n    /// Return the account address that created the GUID\n    public fun creator_address(guid: &GUID): address {\n        guid.id.addr\n    }\n\n    /// Return the account address that created the guid::ID\n    public fun id_creator_address(id: &ID): address {\n        id.addr\n    }\n\n    /// Return the creation number associated with the GUID\n    public fun creation_num(guid: &GUID): u64 {\n        guid.id.creation_num\n    }\n\n    /// Return the creation number associated with the guid::ID\n    public fun id_creation_num(id: &ID): u64 {\n        id.creation_num\n    }\n\n    /// Return true if the GUID's ID is `id`\n    public fun eq_id(guid: &GUID, id: &ID): bool {\n        &guid.id == id\n    }\n}\n","name":"guid.move"},{"content":"/// JWK functions and structs.\n///\n/// Note: An important design constraint for this module is that the JWK consensus Rust code is unable to\n/// spawn a VM and make a Move function call. Instead, the JWK consensus Rust code will have to directly\n/// write some of the resources in this file. As a result, the structs in this file are declared so as to\n/// have a simple layout which is easily accessible in Rust.\nmodule aptos_framework::jwks {\n    use std::error;\n    use std::option;\n    use std::option::Option;\n    use std::string;\n    use std::string::{String, utf8};\n    use std::vector;\n    use aptos_std::comparator::{compare_u8_vector, is_greater_than, is_equal};\n    use aptos_std::copyable_any;\n    use aptos_std::copyable_any::Any;\n    use aptos_framework::chain_status;\n    use aptos_framework::config_buffer;\n    use aptos_framework::event::emit;\n    use aptos_framework::reconfiguration;\n    use aptos_framework::system_addresses;\n    #[test_only]\n    use aptos_framework::account::create_account_for_test;\n\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    const EUNEXPECTED_EPOCH: u64 = 1;\n    const EUNEXPECTED_VERSION: u64 = 2;\n    const EUNKNOWN_PATCH_VARIANT: u64 = 3;\n    const EUNKNOWN_JWK_VARIANT: u64 = 4;\n    const EISSUER_NOT_FOUND: u64 = 5;\n    const EJWK_ID_NOT_FOUND: u64 = 6;\n\n    const ENATIVE_MISSING_RESOURCE_VALIDATOR_SET: u64 = 0x0101;\n    const ENATIVE_MISSING_RESOURCE_OBSERVED_JWKS: u64 = 0x0102;\n    const ENATIVE_INCORRECT_VERSION: u64 = 0x0103;\n    const ENATIVE_MULTISIG_VERIFICATION_FAILED: u64 = 0x0104;\n    const ENATIVE_NOT_ENOUGH_VOTING_POWER: u64 = 0x0105;\n\n    /// An OIDC provider.\n    struct OIDCProvider has copy, drop, store {\n        /// The utf-8 encoded issuer string. E.g., b\"https://www.facebook.com\".\n        name: vector<u8>,\n\n        /// The ut8-8 encoded OpenID configuration URL of the provider.\n        /// E.g., b\"https://www.facebook.com/.well-known/openid-configuration/\".\n        config_url: vector<u8>,\n    }\n\n    /// A list of OIDC providers whose JWKs should be watched by validators. Maintained by governance proposals.\n    struct SupportedOIDCProviders has copy, drop, key, store {\n        providers: vector<OIDCProvider>,\n    }\n\n    /// An JWK variant that represents the JWKs which were observed but not yet supported by Aptos.\n    /// Observing `UnsupportedJWK`s means the providers adopted a new key type/format, and the system should be updated.\n    struct UnsupportedJWK has copy, drop, store {\n        id: vector<u8>,\n        payload: vector<u8>,\n    }\n\n    /// A JWK variant where `kty` is `RSA`.\n    struct RSA_JWK has copy, drop, store {\n        kid: String,\n        kty: String,\n        alg: String,\n        e: String,\n        n: String,\n    }\n\n    /// A JSON web key.\n    struct JWK has copy, drop, store {\n        /// A `JWK` variant packed as an `Any`.\n        /// Currently the variant type is one of the following.\n        /// - `RSA_JWK`\n        /// - `UnsupportedJWK`\n        variant: Any,\n    }\n\n    /// A provider and its `JWK`s.\n    struct ProviderJWKs has copy, drop, store {\n        /// The utf-8 encoding of the issuer string (e.g., \"https://www.facebook.com\").\n        issuer: vector<u8>,\n\n        /// A version number is needed by JWK consensus to dedup the updates.\n        /// e.g, when on chain version = 5, multiple nodes can propose an update with version = 6.\n        /// Bumped every time the JWKs for the current issuer is updated.\n        /// The Rust authenticator only uses the latest version.\n        version: u64,\n\n        /// Vector of `JWK`'s sorted by their unique ID (from `get_jwk_id`) in dictionary order.\n        jwks: vector<JWK>,\n    }\n\n    /// Multiple `ProviderJWKs` objects, indexed by issuer and key ID.\n    struct AllProvidersJWKs has copy, drop, store {\n        /// Vector of `ProviderJWKs` sorted by `ProviderJWKs::issuer` in dictionary order.\n        entries: vector<ProviderJWKs>,\n    }\n\n    /// The `AllProvidersJWKs` that validators observed and agreed on.\n    struct ObservedJWKs has copy, drop, key, store {\n        jwks: AllProvidersJWKs,\n    }\n\n    #[event]\n    /// When `ObservedJWKs` is updated, this event is sent to resync the JWK consensus state in all validators.\n    struct ObservedJWKsUpdated has drop, store {\n        epoch: u64,\n        jwks: AllProvidersJWKs,\n    }\n\n    /// A small edit or patch that is applied to a `AllProvidersJWKs` to obtain `PatchedJWKs`.\n    struct Patch has copy, drop, store {\n        /// A `Patch` variant packed as an `Any`.\n        /// Currently the variant type is one of the following.\n        /// - `PatchRemoveAll`\n        /// - `PatchRemoveIssuer`\n        /// - `PatchRemoveJWK`\n        /// - `PatchUpsertJWK`\n        variant: Any,\n    }\n\n    /// A `Patch` variant to remove all JWKs.\n    struct PatchRemoveAll has copy, drop, store {}\n\n    /// A `Patch` variant to remove an issuer and all its JWKs.\n    struct PatchRemoveIssuer has copy, drop, store {\n        issuer: vector<u8>,\n    }\n\n    /// A `Patch` variant to remove a specific JWK of an issuer.\n    struct PatchRemoveJWK has copy, drop, store {\n        issuer: vector<u8>,\n        jwk_id: vector<u8>,\n    }\n\n    /// A `Patch` variant to upsert a JWK for an issuer.\n    struct PatchUpsertJWK has copy, drop, store {\n        issuer: vector<u8>,\n        jwk: JWK,\n    }\n\n    /// A sequence of `Patch` objects that are applied *one by one* to the `ObservedJWKs`.\n    ///\n    /// Maintained by governance proposals.\n    struct Patches has key {\n        patches: vector<Patch>,\n    }\n\n    /// The result of applying the `Patches` to the `ObservedJWKs`.\n    /// This is what applications should consume.\n    struct PatchedJWKs has drop, key {\n        jwks: AllProvidersJWKs,\n    }\n\n    //\n    // Structs end.\n    // Functions begin.\n    //\n\n    /// Get a JWK by issuer and key ID from the `PatchedJWKs`.\n    /// Abort if such a JWK does not exist.\n    /// More convenient to call from Rust, since it does not wrap the JWK in an `Option`.\n    public fun get_patched_jwk(issuer: vector<u8>, jwk_id: vector<u8>): JWK acquires PatchedJWKs {\n        option::extract(&mut try_get_patched_jwk(issuer, jwk_id))\n    }\n\n    /// Get a JWK by issuer and key ID from the `PatchedJWKs`, if it exists.\n    /// More convenient to call from Move, since it does not abort.\n    public fun try_get_patched_jwk(issuer: vector<u8>, jwk_id: vector<u8>): Option<JWK> acquires PatchedJWKs {\n        let jwks = &borrow_global<PatchedJWKs>(@aptos_framework).jwks;\n        try_get_jwk_by_issuer(jwks, issuer, jwk_id)\n    }\n\n    /// Deprecated by `upsert_oidc_provider_for_next_epoch()`.\n    ///\n    /// TODO: update all the tests that reference this function, then disable this function.\n    public fun upsert_oidc_provider(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n\n        let provider_set = borrow_global_mut<SupportedOIDCProviders>(@aptos_framework);\n\n        let old_config_url= remove_oidc_provider_internal(provider_set, name);\n        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });\n        old_config_url\n    }\n\n    /// Used in on-chain governances to update the supported OIDC providers, effective starting next epoch.\n    /// Example usage:\n    /// ```\n    /// aptos_framework::jwks::upsert_oidc_provider_for_next_epoch(\n    ///     &framework_signer,\n    ///     b\"https://accounts.google.com\",\n    ///     b\"https://accounts.google.com/.well-known/openid-configuration\"\n    /// );\n    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);\n    /// ```\n    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {\n        system_addresses::assert_aptos_framework(fx);\n\n        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {\n            config_buffer::extract<SupportedOIDCProviders>()\n        } else {\n            *borrow_global_mut<SupportedOIDCProviders>(@aptos_framework)\n        };\n\n        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);\n        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });\n        config_buffer::upsert(provider_set);\n        old_config_url\n    }\n\n    /// Deprecated by `remove_oidc_provider_for_next_epoch()`.\n    ///\n    /// TODO: update all the tests that reference this function, then disable this function.\n    public fun remove_oidc_provider(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n\n        let provider_set = borrow_global_mut<SupportedOIDCProviders>(@aptos_framework);\n        remove_oidc_provider_internal(provider_set, name)\n    }\n\n    /// Used in on-chain governances to update the supported OIDC providers, effective starting next epoch.\n    /// Example usage:\n    /// ```\n    /// aptos_framework::jwks::remove_oidc_provider_for_next_epoch(\n    ///     &framework_signer,\n    ///     b\"https://accounts.google.com\",\n    /// );\n    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);\n    /// ```\n    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {\n        system_addresses::assert_aptos_framework(fx);\n\n        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {\n            config_buffer::extract<SupportedOIDCProviders>()\n        } else {\n            *borrow_global_mut<SupportedOIDCProviders>(@aptos_framework)\n        };\n        let ret = remove_oidc_provider_internal(&mut provider_set, name);\n        config_buffer::upsert(provider_set);\n        ret\n    }\n\n    /// Only used in reconfigurations to apply the pending `SupportedOIDCProviders`, if there is any.\n    public(friend) fun on_new_epoch(framework: &signer) acquires SupportedOIDCProviders {\n        system_addresses::assert_aptos_framework(framework);\n        if (config_buffer::does_exist<SupportedOIDCProviders>()) {\n            let new_config = config_buffer::extract<SupportedOIDCProviders>();\n            if (exists<SupportedOIDCProviders>(@aptos_framework)) {\n                *borrow_global_mut<SupportedOIDCProviders>(@aptos_framework) = new_config;\n            } else {\n                move_to(framework, new_config);\n            }\n        }\n    }\n\n    /// Set the `Patches`. Only called in governance proposals.\n    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {\n        system_addresses::assert_aptos_framework(fx);\n        borrow_global_mut<Patches>(@aptos_framework).patches = patches;\n        regenerate_patched_jwks();\n    }\n\n    /// Create a `Patch` that removes all entries.\n    public fun new_patch_remove_all(): Patch {\n        Patch {\n            variant: copyable_any::pack(PatchRemoveAll {}),\n        }\n    }\n\n    /// Create a `Patch` that removes the entry of a given issuer, if exists.\n    public fun new_patch_remove_issuer(issuer: vector<u8>): Patch {\n        Patch {\n            variant: copyable_any::pack(PatchRemoveIssuer { issuer }),\n        }\n    }\n\n    /// Create a `Patch` that removes the entry of a given issuer, if exists.\n    public fun new_patch_remove_jwk(issuer: vector<u8>, jwk_id: vector<u8>): Patch {\n        Patch {\n            variant: copyable_any::pack(PatchRemoveJWK { issuer, jwk_id })\n        }\n    }\n\n    /// Create a `Patch` that upserts a JWK into an issuer's JWK set.\n    public fun new_patch_upsert_jwk(issuer: vector<u8>, jwk: JWK): Patch {\n        Patch {\n            variant: copyable_any::pack(PatchUpsertJWK { issuer, jwk })\n        }\n    }\n\n    /// Create a `JWK` of variant `RSA_JWK`.\n    public fun new_rsa_jwk(kid: String, alg: String, e: String, n: String): JWK {\n        JWK {\n            variant: copyable_any::pack(RSA_JWK {\n                kid,\n                kty: utf8(b\"RSA\"),\n                e,\n                n,\n                alg,\n            }),\n        }\n    }\n\n    /// Create a `JWK` of variant `UnsupportedJWK`.\n    public fun new_unsupported_jwk(id: vector<u8>, payload: vector<u8>): JWK {\n        JWK {\n            variant: copyable_any::pack(UnsupportedJWK { id, payload })\n        }\n    }\n\n    /// Initialize some JWK resources. Should only be invoked by genesis.\n    public fun initialize(fx: &signer) {\n        system_addresses::assert_aptos_framework(fx);\n        move_to(fx, SupportedOIDCProviders { providers: vector[] });\n        move_to(fx, ObservedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });\n        move_to(fx, Patches { patches: vector[] });\n        move_to(fx, PatchedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });\n    }\n\n    /// Helper function that removes an OIDC provider from the `SupportedOIDCProviders`.\n    /// Returns the old config URL of the provider, if any, as an `Option`.\n    fun remove_oidc_provider_internal(provider_set: &mut SupportedOIDCProviders, name: vector<u8>): Option<vector<u8>> {\n        let (name_exists, idx) = vector::find(&provider_set.providers, |obj| {\n            let provider: &OIDCProvider = obj;\n            provider.name == name\n        });\n\n        if (name_exists) {\n            let old_provider = vector::swap_remove(&mut provider_set.providers, idx);\n            option::some(old_provider.config_url)\n        } else {\n            option::none()\n        }\n    }\n\n    /// Only used by validators to publish their observed JWK update.\n    ///\n    /// NOTE: It is assumed verification has been done to ensure each update is quorum-certified,\n    /// and its `version` equals to the on-chain version + 1.\n    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {\n        system_addresses::assert_aptos_framework(fx);\n        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);\n        vector::for_each(provider_jwks_vec, |obj| {\n            let provider_jwks: ProviderJWKs = obj;\n            upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);\n        });\n\n        let epoch = reconfiguration::current_epoch();\n        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });\n        regenerate_patched_jwks();\n    }\n\n    /// Only used by governance to delete an issuer from `ObservedJWKs`, if it exists.\n    ///\n    /// Return the potentially existing `ProviderJWKs` of the given issuer.\n    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {\n        system_addresses::assert_aptos_framework(fx);\n        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);\n        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);\n\n        let epoch = reconfiguration::current_epoch();\n        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });\n        regenerate_patched_jwks();\n\n        old_value\n    }\n\n    /// Regenerate `PatchedJWKs` from `ObservedJWKs` and `Patches` and save the result.\n    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {\n        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;\n        let patches = borrow_global<Patches>(@aptos_framework);\n        vector::for_each_ref(&patches.patches, |obj|{\n            let patch: &Patch = obj;\n            apply_patch(&mut jwks, *patch);\n        });\n        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };\n    }\n\n    /// Get a JWK by issuer and key ID from a `AllProvidersJWKs`, if it exists.\n    fun try_get_jwk_by_issuer(jwks: &AllProvidersJWKs, issuer: vector<u8>, jwk_id: vector<u8>): Option<JWK> {\n        let (issuer_found, index) = vector::find(&jwks.entries, |obj| {\n            let provider_jwks: &ProviderJWKs = obj;\n            issuer == provider_jwks.issuer\n        });\n\n        if (issuer_found) {\n            try_get_jwk_by_id(vector::borrow(&jwks.entries, index), jwk_id)\n        } else {\n            option::none()\n        }\n    }\n\n    /// Get a JWK by key ID from a `ProviderJWKs`, if it exists.\n    fun try_get_jwk_by_id(provider_jwks: &ProviderJWKs, jwk_id: vector<u8>): Option<JWK> {\n        let (jwk_id_found, index) = vector::find(&provider_jwks.jwks, |obj|{\n            let jwk: &JWK = obj;\n            jwk_id == get_jwk_id(jwk)\n        });\n\n        if (jwk_id_found) {\n            option::some(*vector::borrow(&provider_jwks.jwks, index))\n        } else {\n            option::none()\n        }\n    }\n\n    /// Get the ID of a JWK.\n    fun get_jwk_id(jwk: &JWK): vector<u8> {\n        let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));\n        if (variant_type_name == b\"0x1::jwks::RSA_JWK\") {\n            let rsa = copyable_any::unpack<RSA_JWK>(jwk.variant);\n            *string::bytes(&rsa.kid)\n        } else if (variant_type_name == b\"0x1::jwks::UnsupportedJWK\") {\n            let unsupported = copyable_any::unpack<UnsupportedJWK>(jwk.variant);\n            unsupported.id\n        } else {\n            abort(error::invalid_argument(EUNKNOWN_JWK_VARIANT))\n        }\n    }\n\n    /// Upsert a `ProviderJWKs` into an `AllProvidersJWKs`. If this upsert replaced an existing entry, return it.\n    /// Maintains the sorted-by-issuer invariant in `AllProvidersJWKs`.\n    fun upsert_provider_jwks(jwks: &mut AllProvidersJWKs, provider_jwks: ProviderJWKs): Option<ProviderJWKs> {\n        // NOTE: Using a linear-time search here because we do not expect too many providers.\n        let found = false;\n        let index = 0;\n        let num_entries = vector::length(&jwks.entries);\n        while (index < num_entries) {\n            let cur_entry = vector::borrow(&jwks.entries, index);\n            let comparison = compare_u8_vector(provider_jwks.issuer, cur_entry.issuer);\n            if (is_greater_than(&comparison)) {\n                index = index + 1;\n            } else {\n                found = is_equal(&comparison);\n                break\n            }\n        };\n\n        // Now if `found == true`, `index` points to the JWK we want to update/remove; otherwise, `index` points to\n        // where we want to insert.\n        let ret = if (found) {\n            let entry = vector::borrow_mut(&mut jwks.entries, index);\n            let old_entry = option::some(*entry);\n            *entry = provider_jwks;\n            old_entry\n        } else {\n            vector::insert(&mut jwks.entries, index, provider_jwks);\n            option::none()\n        };\n\n        ret\n    }\n\n    /// Remove the entry of an issuer from a `AllProvidersJWKs` and return the entry, if exists.\n    /// Maintains the sorted-by-issuer invariant in `AllProvidersJWKs`.\n    fun remove_issuer(jwks: &mut AllProvidersJWKs, issuer: vector<u8>): Option<ProviderJWKs> {\n        let (found, index) = vector::find(&jwks.entries, |obj| {\n            let provider_jwk_set: &ProviderJWKs = obj;\n            provider_jwk_set.issuer == issuer\n        });\n\n        let ret = if (found) {\n            option::some(vector::remove(&mut jwks.entries, index))\n        } else {\n            option::none()\n        };\n\n        ret\n    }\n\n    /// Upsert a `JWK` into a `ProviderJWKs`. If this upsert replaced an existing entry, return it.\n    fun upsert_jwk(set: &mut ProviderJWKs, jwk: JWK): Option<JWK> {\n        let found = false;\n        let index = 0;\n        let num_entries = vector::length(&set.jwks);\n        while (index < num_entries) {\n            let cur_entry = vector::borrow(&set.jwks, index);\n            let comparison = compare_u8_vector(get_jwk_id(&jwk), get_jwk_id(cur_entry));\n            if (is_greater_than(&comparison)) {\n                index = index + 1;\n            } else {\n                found = is_equal(&comparison);\n                break\n            }\n        };\n\n        // Now if `found == true`, `index` points to the JWK we want to update/remove; otherwise, `index` points to\n        // where we want to insert.\n        let ret = if (found) {\n            let entry = vector::borrow_mut(&mut set.jwks, index);\n            let old_entry = option::some(*entry);\n            *entry = jwk;\n            old_entry\n        } else {\n            vector::insert(&mut set.jwks, index, jwk);\n            option::none()\n        };\n\n        ret\n    }\n\n    /// Remove the entry of a key ID from a `ProviderJWKs` and return the entry, if exists.\n    fun remove_jwk(jwks: &mut ProviderJWKs, jwk_id: vector<u8>): Option<JWK> {\n        let (found, index) = vector::find(&jwks.jwks, |obj| {\n            let jwk: &JWK = obj;\n            jwk_id == get_jwk_id(jwk)\n        });\n\n        let ret = if (found) {\n            option::some(vector::remove(&mut jwks.jwks, index))\n        } else {\n            option::none()\n        };\n\n        ret\n    }\n\n    /// Modify an `AllProvidersJWKs` object with a `Patch`.\n    /// Maintains the sorted-by-issuer invariant in `AllProvidersJWKs`.\n    fun apply_patch(jwks: &mut AllProvidersJWKs, patch: Patch) {\n        let variant_type_name = *string::bytes(copyable_any::type_name(&patch.variant));\n        if (variant_type_name == b\"0x1::jwks::PatchRemoveAll\") {\n            jwks.entries = vector[];\n        } else if (variant_type_name == b\"0x1::jwks::PatchRemoveIssuer\") {\n            let cmd = copyable_any::unpack<PatchRemoveIssuer>(patch.variant);\n            remove_issuer(jwks, cmd.issuer);\n        } else if (variant_type_name == b\"0x1::jwks::PatchRemoveJWK\") {\n            let cmd = copyable_any::unpack<PatchRemoveJWK>(patch.variant);\n            // TODO: This is inefficient: we remove the issuer, modify its JWKs & and reinsert the updated issuer. Why\n            // not just update it in place?\n            let existing_jwk_set = remove_issuer(jwks, cmd.issuer);\n            if (option::is_some(&existing_jwk_set)) {\n                let jwk_set = option::extract(&mut existing_jwk_set);\n                remove_jwk(&mut jwk_set, cmd.jwk_id);\n                upsert_provider_jwks(jwks, jwk_set);\n            };\n        } else if (variant_type_name == b\"0x1::jwks::PatchUpsertJWK\") {\n            let cmd = copyable_any::unpack<PatchUpsertJWK>(patch.variant);\n            // TODO: This is inefficient: we remove the issuer, modify its JWKs & and reinsert the updated issuer. Why\n            // not just update it in place?\n            let existing_jwk_set = remove_issuer(jwks, cmd.issuer);\n            let jwk_set = if (option::is_some(&existing_jwk_set)) {\n                option::extract(&mut existing_jwk_set)\n            } else {\n                ProviderJWKs {\n                    version: 0,\n                    issuer: cmd.issuer,\n                    jwks: vector[],\n                }\n            };\n            upsert_jwk(&mut jwk_set, cmd.jwk);\n            upsert_provider_jwks(jwks, jwk_set);\n        } else {\n            abort(std::error::invalid_argument(EUNKNOWN_PATCH_VARIANT))\n        }\n    }\n\n    //\n    // Functions end.\n    // Tests begin.\n    //\n\n    #[test_only]\n    fun initialize_for_test(aptos_framework: &signer) {\n        create_account_for_test(@aptos_framework);\n        reconfiguration::initialize_for_test(aptos_framework);\n        initialize(aptos_framework);\n    }\n\n    #[test(fx = @aptos_framework)]\n    fun test_observed_jwks_operations(fx: &signer) acquires ObservedJWKs, PatchedJWKs, Patches {\n        initialize_for_test(fx);\n        let jwk_0 = new_unsupported_jwk(b\"key_id_0\", b\"key_payload_0\");\n        let jwk_1 = new_unsupported_jwk(b\"key_id_1\", b\"key_payload_1\");\n        let jwk_2 = new_unsupported_jwk(b\"key_id_2\", b\"key_payload_2\");\n        let jwk_3 = new_unsupported_jwk(b\"key_id_3\", b\"key_payload_3\");\n        let jwk_4 = new_unsupported_jwk(b\"key_id_4\", b\"key_payload_4\");\n        let expected = AllProvidersJWKs { entries: vector[] };\n        assert!(expected == borrow_global<ObservedJWKs>(@aptos_framework).jwks, 1);\n\n        let alice_jwks_v1 = ProviderJWKs {\n            issuer: b\"alice\",\n            version: 1,\n            jwks: vector[jwk_0, jwk_1],\n        };\n        let bob_jwks_v1 = ProviderJWKs{\n            issuer: b\"bob\",\n            version: 1,\n            jwks: vector[jwk_2, jwk_3],\n        };\n        upsert_into_observed_jwks(fx, vector[bob_jwks_v1]);\n        upsert_into_observed_jwks(fx, vector[alice_jwks_v1]);\n        let expected = AllProvidersJWKs { entries: vector[\n            alice_jwks_v1,\n            bob_jwks_v1,\n        ] };\n        assert!(expected == borrow_global<ObservedJWKs>(@aptos_framework).jwks, 2);\n\n        let alice_jwks_v2 = ProviderJWKs {\n            issuer: b\"alice\",\n            version: 2,\n            jwks: vector[jwk_1, jwk_4],\n        };\n        upsert_into_observed_jwks(fx, vector[alice_jwks_v2]);\n        let expected = AllProvidersJWKs { entries: vector[\n            alice_jwks_v2,\n            bob_jwks_v1,\n        ] };\n        assert!(expected == borrow_global<ObservedJWKs>(@aptos_framework).jwks, 3);\n\n        remove_issuer_from_observed_jwks(fx, b\"alice\");\n        let expected = AllProvidersJWKs { entries: vector[bob_jwks_v1] };\n        assert!(expected == borrow_global<ObservedJWKs>(@aptos_framework).jwks, 4);\n    }\n\n    #[test]\n    fun test_apply_patch() {\n        let jwks = AllProvidersJWKs {\n            entries: vector[\n                ProviderJWKs {\n                    issuer: b\"alice\",\n                    version: 111,\n                    jwks: vector[\n                        new_rsa_jwk(\n                            utf8(b\"e4adfb436b9e197e2e1106af2c842284e4986aff\"), // kid\n                            utf8(b\"RS256\"), // alg\n                            utf8(b\"AQAB\"), // e\n                            utf8(b\"psply8S991RswM0JQJwv51fooFFvZUtYdL8avyKObshyzj7oJuJD8vkf5DKJJF1XOGi6Wv2D-U4b3htgrVXeOjAvaKTYtrQVUG_Txwjebdm2EvBJ4R6UaOULjavcSkb8VzW4l4AmP_yWoidkHq8n6vfHt9alDAONILi7jPDzRC7NvnHQ_x0hkRVh_OAmOJCpkgb0gx9-U8zSBSmowQmvw15AZ1I0buYZSSugY7jwNS2U716oujAiqtRkC7kg4gPouW_SxMleeo8PyRsHpYCfBME66m-P8Zr9Fh1Qgmqg4cWdy_6wUuNc1cbVY_7w1BpHZtZCNeQ56AHUgUFmo2LAQQ\"), // n\n                        ),\n                        new_unsupported_jwk(b\"key_id_0\", b\"key_content_0\"),\n                    ],\n                },\n                ProviderJWKs {\n                    issuer: b\"bob\",\n                    version: 222,\n                    jwks: vector[\n                        new_unsupported_jwk(b\"key_id_1\", b\"key_content_1\"),\n                        new_unsupported_jwk(b\"key_id_2\", b\"key_content_2\"),\n                    ],\n                },\n            ],\n        };\n\n        let patch = new_patch_remove_issuer(b\"alice\");\n        apply_patch(&mut jwks, patch);\n        assert!(jwks == AllProvidersJWKs {\n            entries: vector[\n                ProviderJWKs {\n                    issuer: b\"bob\",\n                    version: 222,\n                    jwks: vector[\n                        new_unsupported_jwk(b\"key_id_1\", b\"key_content_1\"),\n                        new_unsupported_jwk(b\"key_id_2\", b\"key_content_2\"),\n                    ],\n                },\n            ],\n        }, 1);\n\n        let patch = new_patch_remove_jwk(b\"bob\", b\"key_id_1\");\n        apply_patch(&mut jwks, patch);\n        assert!(jwks == AllProvidersJWKs {\n            entries: vector[\n                ProviderJWKs {\n                    issuer: b\"bob\",\n                    version: 222,\n                    jwks: vector[\n                        new_unsupported_jwk(b\"key_id_2\", b\"key_content_2\"),\n                    ],\n                },\n            ],\n        }, 1);\n\n        let patch = new_patch_upsert_jwk(b\"carl\", new_rsa_jwk(\n            utf8(b\"0ad1fec78504f447bae65bcf5afaedb65eec9e81\"), // kid\n            utf8(b\"RS256\"), // alg\n            utf8(b\"AQAB\"), // e\n            utf8(b\"sm72oBH-R2Rqt4hkjp66tz5qCtq42TMnVgZg2Pdm_zs7_-EoFyNs9sD1MKsZAFaBPXBHDiWywyaHhLgwETLN9hlJIZPzGCEtV3mXJFSYG-8L6t3kyKi9X1lUTZzbmNpE0tf-eMW-3gs3VQSBJQOcQnuiANxbSXwS3PFmi173C_5fDSuC1RoYGT6X3JqLc3DWUmBGucuQjPaUF0w6LMqEIy0W_WYbW7HImwANT6dT52T72md0JWZuAKsRRnRr_bvaUX8_e3K8Pb1K_t3dD6WSLvtmEfUnGQgLynVl3aV5sRYC0Hy_IkRgoxl2fd8AaZT1X_rdPexYpx152Pl_CHJ79Q\"), // n\n        ));\n        apply_patch(&mut jwks, patch);\n        let edit = new_patch_upsert_jwk(b\"bob\", new_unsupported_jwk(b\"key_id_2\", b\"key_content_2b\"));\n        apply_patch(&mut jwks, edit);\n        let edit = new_patch_upsert_jwk(b\"alice\", new_unsupported_jwk(b\"key_id_3\", b\"key_content_3\"));\n        apply_patch(&mut jwks, edit);\n        let edit = new_patch_upsert_jwk(b\"alice\", new_unsupported_jwk(b\"key_id_0\", b\"key_content_0b\"));\n        apply_patch(&mut jwks, edit);\n        assert!(jwks == AllProvidersJWKs {\n            entries: vector[\n                ProviderJWKs {\n                    issuer: b\"alice\",\n                    version: 0,\n                    jwks: vector[\n                        new_unsupported_jwk(b\"key_id_0\", b\"key_content_0b\"),\n                        new_unsupported_jwk(b\"key_id_3\", b\"key_content_3\"),\n                    ],\n                },\n                ProviderJWKs {\n                    issuer: b\"bob\",\n                    version: 222,\n                    jwks: vector[\n                        new_unsupported_jwk(b\"key_id_2\", b\"key_content_2b\"),\n                    ],\n                },\n                ProviderJWKs {\n                    issuer: b\"carl\",\n                    version: 0,\n                    jwks: vector[\n                        new_rsa_jwk(\n                            utf8(b\"0ad1fec78504f447bae65bcf5afaedb65eec9e81\"), // kid\n                            utf8(b\"RS256\"), // alg\n                            utf8(b\"AQAB\"), // e\n                            utf8(b\"sm72oBH-R2Rqt4hkjp66tz5qCtq42TMnVgZg2Pdm_zs7_-EoFyNs9sD1MKsZAFaBPXBHDiWywyaHhLgwETLN9hlJIZPzGCEtV3mXJFSYG-8L6t3kyKi9X1lUTZzbmNpE0tf-eMW-3gs3VQSBJQOcQnuiANxbSXwS3PFmi173C_5fDSuC1RoYGT6X3JqLc3DWUmBGucuQjPaUF0w6LMqEIy0W_WYbW7HImwANT6dT52T72md0JWZuAKsRRnRr_bvaUX8_e3K8Pb1K_t3dD6WSLvtmEfUnGQgLynVl3aV5sRYC0Hy_IkRgoxl2fd8AaZT1X_rdPexYpx152Pl_CHJ79Q\"), // n\n                        )\n                    ],\n                },\n            ],\n        }, 1);\n\n        let patch = new_patch_remove_all();\n        apply_patch(&mut jwks, patch);\n        assert!(jwks == AllProvidersJWKs { entries: vector[] }, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    fun test_patched_jwks(aptos_framework: signer) acquires ObservedJWKs, PatchedJWKs, Patches {\n        initialize_for_test(&aptos_framework);\n        let jwk_0 = new_unsupported_jwk(b\"key_id_0\", b\"key_payload_0\");\n        let jwk_1 = new_unsupported_jwk(b\"key_id_1\", b\"key_payload_1\");\n        let jwk_2 = new_unsupported_jwk(b\"key_id_2\", b\"key_payload_2\");\n        let jwk_3 = new_unsupported_jwk(b\"key_id_3\", b\"key_payload_3\");\n        let jwk_3b = new_unsupported_jwk(b\"key_id_3\", b\"key_payload_3b\");\n\n        // Fake observation from validators.\n        upsert_into_observed_jwks(&aptos_framework, vector [\n            ProviderJWKs {\n                issuer: b\"alice\",\n                version: 111,\n                jwks: vector[jwk_0, jwk_1],\n            },\n            ProviderJWKs{\n                issuer: b\"bob\",\n                version: 222,\n                jwks: vector[jwk_2, jwk_3],\n            },\n        ]);\n        assert!(jwk_3 == get_patched_jwk(b\"bob\", b\"key_id_3\"), 1);\n        assert!(option::some(jwk_3) == try_get_patched_jwk(b\"bob\", b\"key_id_3\"), 1);\n\n        // Ignore all Bob's keys.\n        set_patches(&aptos_framework, vector[\n            new_patch_remove_issuer(b\"bob\"),\n        ]);\n        assert!(option::none() == try_get_patched_jwk(b\"bob\", b\"key_id_3\"), 1);\n\n        // Update one of Bob's key..\n        set_patches(&aptos_framework, vector[\n            new_patch_upsert_jwk(b\"bob\", jwk_3b),\n        ]);\n        assert!(jwk_3b == get_patched_jwk(b\"bob\", b\"key_id_3\"), 1);\n        assert!(option::some(jwk_3b) == try_get_patched_jwk(b\"bob\", b\"key_id_3\"), 1);\n\n        // Wipe everything, then add some keys back.\n        set_patches(&aptos_framework, vector[\n            new_patch_remove_all(),\n            new_patch_upsert_jwk(b\"alice\", jwk_1),\n            new_patch_upsert_jwk(b\"bob\", jwk_3),\n        ]);\n        assert!(jwk_3 == get_patched_jwk(b\"bob\", b\"key_id_3\"), 1);\n        assert!(option::some(jwk_3) == try_get_patched_jwk(b\"bob\", b\"key_id_3\"), 1);\n    }\n}\n","name":"jwks.move"},{"content":"/// This module is responsible for configuring keyless blockchain accounts which were introduced in\n/// [AIP-61](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md).\nmodule aptos_framework::keyless_account {\n    use std::bn254_algebra;\n    use std::config_buffer;\n    use std::option;\n    use std::option::Option;\n    use std::signer;\n    use std::string::String;\n    use std::vector;\n    use aptos_std::crypto_algebra;\n    use aptos_std::ed25519;\n    use aptos_framework::chain_status;\n    use aptos_framework::system_addresses;\n\n    // The `aptos_framework::reconfiguration_with_dkg` module needs to be able to call `on_new_epoch`.\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    /// The training wheels PK needs to be 32 bytes long.\n    const E_TRAINING_WHEELS_PK_WRONG_SIZE : u64 = 1;\n\n    /// A serialized BN254 G1 point is invalid.\n    const E_INVALID_BN254_G1_SERIALIZATION: u64 = 2;\n\n    /// A serialized BN254 G2 point is invalid.\n    const E_INVALID_BN254_G2_SERIALIZATION: u64 = 3;\n\n    #[resource_group(scope = global)]\n    struct Group {}\n\n    #[resource_group_member(group = aptos_framework::keyless_account::Group)]\n    /// The 288-byte Groth16 verification key (VK) for the ZK relation that implements keyless accounts\n    struct Groth16VerificationKey has key, store, drop {\n        /// 32-byte serialization of `alpha * G`, where `G` is the generator of `G1`.\n        alpha_g1: vector<u8>,\n        /// 64-byte serialization of `alpha * H`, where `H` is the generator of `G2`.\n        beta_g2: vector<u8>,\n        /// 64-byte serialization of `gamma * H`, where `H` is the generator of `G2`.\n        gamma_g2: vector<u8>,\n        /// 64-byte serialization of `delta * H`, where `H` is the generator of `G2`.\n        delta_g2: vector<u8>,\n        /// `\\forall i \\in {0, ..., \\ell}, 64-byte serialization of gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where\n        /// `H` is the generator of `G1` and `\\ell` is 1 for the ZK relation.\n        gamma_abc_g1: vector<vector<u8>>,\n    }\n\n    #[resource_group_member(group = aptos_framework::keyless_account::Group)]\n    struct Configuration has key, store, drop, copy {\n        /// An override `aud` for the identity of a recovery service, which will help users recover their keyless accounts\n        /// associated with dapps or wallets that have disappeared.\n        /// IMPORTANT: This recovery service **cannot** on its own take over user accounts; a user must first sign in\n        /// via OAuth in the recovery service in order to allow it to rotate any of that user's keyless accounts.\n        override_aud_vals: vector<String>,\n        /// No transaction can have more than this many keyless signatures.\n        max_signatures_per_txn: u16,\n        /// How far in the future from the JWT issued at time the EPK expiry can be set.\n        max_exp_horizon_secs: u64,\n        /// The training wheels PK, if training wheels are on\n        training_wheels_pubkey: Option<vector<u8>>,\n        /// The max length of an ephemeral public key supported in our circuit (93 bytes)\n        max_commited_epk_bytes: u16,\n        /// The max length of the value of the JWT's `iss` field supported in our circuit (e.g., `\"https://accounts.google.com\"`)\n        max_iss_val_bytes: u16,\n        /// The max length of the JWT field name and value (e.g., `\"max_age\":\"18\"`) supported in our circuit\n        max_extra_field_bytes: u16,\n        /// The max length of the base64url-encoded JWT header in bytes supported in our circuit\n        max_jwt_header_b64_bytes: u32,\n    }\n\n    #[test_only]\n    public fun initialize_for_test(fx: &signer, vk: Groth16VerificationKey, constants: Configuration) {\n        system_addresses::assert_aptos_framework(fx);\n\n        move_to(fx, vk);\n        move_to(fx, constants);\n    }\n\n    public fun new_groth16_verification_key(alpha_g1: vector<u8>,\n                                            beta_g2: vector<u8>,\n                                            gamma_g2: vector<u8>,\n                                            delta_g2: vector<u8>,\n                                            gamma_abc_g1: vector<vector<u8>>\n    ): Groth16VerificationKey {\n        Groth16VerificationKey {\n            alpha_g1,\n            beta_g2,\n            gamma_g2,\n            delta_g2,\n            gamma_abc_g1,\n        }\n    }\n\n    public fun new_configuration(\n        override_aud_val: vector<String>,\n        max_signatures_per_txn: u16,\n        max_exp_horizon_secs: u64,\n        training_wheels_pubkey: Option<vector<u8>>,\n        max_commited_epk_bytes: u16,\n        max_iss_val_bytes: u16,\n        max_extra_field_bytes: u16,\n        max_jwt_header_b64_bytes: u32\n    ): Configuration {\n        Configuration {\n            override_aud_vals: override_aud_val,\n            max_signatures_per_txn,\n            max_exp_horizon_secs,\n            training_wheels_pubkey,\n            max_commited_epk_bytes,\n            max_iss_val_bytes,\n            max_extra_field_bytes,\n            max_jwt_header_b64_bytes,\n        }\n    }\n\n    /// Pre-validate the VK to actively-prevent incorrect VKs from being set on-chain.\n    fun validate_groth16_vk(vk: &Groth16VerificationKey) {\n        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.\n        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);\n        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);\n        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);\n        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);\n        for (i in 0..vector::length(&vk.gamma_abc_g1)) {\n            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);\n        };\n    }\n\n    /// Sets the Groth16 verification key, only callable during genesis. To call during governance proposals, use\n    /// `set_groth16_verification_key_for_next_epoch`.\n    ///\n    /// WARNING: See `set_groth16_verification_key_for_next_epoch` for caveats.\n    public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n        // There should not be a previous resource set here.\n        move_to(fx, vk);\n    }\n\n    /// Sets the keyless configuration, only callable during genesis. To call during governance proposals, use\n    /// `set_configuration_for_next_epoch`.\n    ///\n    /// WARNING: See `set_configuration_for_next_epoch` for caveats.\n    public fun update_configuration(fx: &signer, config: Configuration) {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n        // There should not be a previous resource set here.\n        move_to(fx, config);\n    }\n\n    #[deprecated]\n    public fun update_training_wheels(fx: &signer, pk: Option<vector<u8>>) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n\n        if (option::is_some(&pk)) {\n            assert!(vector::length(option::borrow(&pk)) == 32, E_TRAINING_WHEELS_PK_WRONG_SIZE)\n        };\n\n        let config = borrow_global_mut<Configuration>(signer::address_of(fx));\n        config.training_wheels_pubkey = pk;\n    }\n\n    #[deprecated]\n    public fun update_max_exp_horizon(fx: &signer, max_exp_horizon_secs: u64) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n\n        let config = borrow_global_mut<Configuration>(signer::address_of(fx));\n        config.max_exp_horizon_secs = max_exp_horizon_secs;\n    }\n\n    #[deprecated]\n    public fun remove_all_override_auds(fx: &signer) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n\n        let config = borrow_global_mut<Configuration>(signer::address_of(fx));\n        config.override_aud_vals = vector[];\n    }\n\n    #[deprecated]\n    public fun add_override_aud(fx: &signer, aud: String) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n        chain_status::assert_genesis();\n\n        let config = borrow_global_mut<Configuration>(signer::address_of(fx));\n        vector::push_back(&mut config.override_aud_vals, aud);\n    }\n\n    /// Queues up a change to the Groth16 verification key. The change will only be effective after reconfiguration.\n    /// Only callable via governance proposal.\n    ///\n    /// WARNING: To mitigate against DoS attacks, a VK change should be done together with a training wheels PK change,\n    /// so that old ZKPs for the old VK cannot be replayed as potentially-valid ZKPs.\n    ///\n    /// WARNING: If a malicious key is set, this would lead to stolen funds.\n    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {\n        system_addresses::assert_aptos_framework(fx);\n        validate_groth16_vk(&vk);\n        config_buffer::upsert<Groth16VerificationKey>(vk);\n    }\n\n\n    /// Queues up a change to the keyless configuration. The change will only be effective after reconfiguration. Only\n    /// callable via governance proposal.\n    ///\n    /// WARNING: A malicious `Configuration` could lead to DoS attacks, create liveness issues, or enable a malicious\n    /// recovery service provider to phish users' accounts.\n    public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {\n        system_addresses::assert_aptos_framework(fx);\n        config_buffer::upsert<Configuration>(config);\n    }\n\n    /// Convenience method to queue up a change to the training wheels PK. The change will only be effective after\n    /// reconfiguration. Only callable via governance proposal.\n    ///\n    /// WARNING: If a malicious key is set, this *could* lead to stolen funds.\n    public fun update_training_wheels_for_next_epoch(fx: &signer, pk: Option<vector<u8>>) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n\n        // If a PK is being set, validate it first.\n        if (option::is_some(&pk)) {\n            let bytes = *option::borrow(&pk);\n            let vpk = ed25519::new_validated_public_key_from_bytes(bytes);\n            assert!(option::is_some(&vpk), E_TRAINING_WHEELS_PK_WRONG_SIZE)\n        };\n\n        let config = if (config_buffer::does_exist<Configuration>()) {\n            config_buffer::extract<Configuration>()\n        } else {\n            *borrow_global<Configuration>(signer::address_of(fx))\n        };\n\n        config.training_wheels_pubkey = pk;\n\n        set_configuration_for_next_epoch(fx, config);\n    }\n\n    /// Convenience method to queues up a change to the max expiration horizon. The change will only be effective after\n    /// reconfiguration. Only callable via governance proposal.\n    public fun update_max_exp_horizon_for_next_epoch(fx: &signer, max_exp_horizon_secs: u64) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n\n        let config = if (config_buffer::does_exist<Configuration>()) {\n            config_buffer::extract<Configuration>()\n        } else {\n            *borrow_global<Configuration>(signer::address_of(fx))\n        };\n\n        config.max_exp_horizon_secs = max_exp_horizon_secs;\n\n        set_configuration_for_next_epoch(fx, config);\n    }\n\n    /// Convenience method to queue up clearing the set of override `aud`'s. The change will only be effective after\n    /// reconfiguration. Only callable via governance proposal.\n    ///\n    /// WARNING: When no override `aud` is set, recovery of keyless accounts associated with applications that disappeared\n    /// is no longer possible.\n    public fun remove_all_override_auds_for_next_epoch(fx: &signer) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n\n        let config = if (config_buffer::does_exist<Configuration>()) {\n            config_buffer::extract<Configuration>()\n        } else {\n            *borrow_global<Configuration>(signer::address_of(fx))\n        };\n\n        config.override_aud_vals = vector[];\n\n        set_configuration_for_next_epoch(fx, config);\n    }\n\n    /// Convenience method to queue up an append to to the set of override `aud`'s. The change will only be effective\n    /// after reconfiguration. Only callable via governance proposal.\n    ///\n    /// WARNING: If a malicious override `aud` is set, this *could* lead to stolen funds.\n    public fun add_override_aud_for_next_epoch(fx: &signer, aud: String) acquires Configuration {\n        system_addresses::assert_aptos_framework(fx);\n\n        let config = if (config_buffer::does_exist<Configuration>()) {\n            config_buffer::extract<Configuration>()\n        } else {\n            *borrow_global<Configuration>(signer::address_of(fx))\n        };\n\n        vector::push_back(&mut config.override_aud_vals, aud);\n\n        set_configuration_for_next_epoch(fx, config);\n    }\n\n    /// Only used in reconfigurations to apply the queued up configuration changes, if there are any.\n    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {\n        system_addresses::assert_aptos_framework(fx);\n\n        if (config_buffer::does_exist<Groth16VerificationKey>()) {\n            let vk = config_buffer::extract();\n            if (exists<Groth16VerificationKey>(@aptos_framework)) {\n                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;\n            } else {\n                move_to(fx, vk);\n            }\n        };\n\n        if (config_buffer::does_exist<Configuration>()) {\n            let config = config_buffer::extract();\n            if (exists<Configuration>(@aptos_framework)) {\n                *borrow_global_mut<Configuration>(@aptos_framework) = config;\n            } else {\n                move_to(fx, config);\n            }\n        };\n    }\n}\n","name":"keyless_account.move"},{"content":"/// ManagedCoin is built to make a simple walkthrough of the Coins module.\n/// It contains scripts you will need to initialize, mint, burn, transfer coins.\n/// By utilizing this current module, a developer can create his own coin and care less about mint and burn capabilities,\nmodule aptos_framework::managed_coin {\n    use std::string;\n    use std::error;\n    use std::signer;\n\n    use aptos_framework::coin::{Self, BurnCapability, FreezeCapability, MintCapability};\n\n    //\n    // Errors\n    //\n\n    /// Account has no capabilities (burn/mint).\n    const ENO_CAPABILITIES: u64 = 1;\n\n    //\n    // Data structures\n    //\n\n    /// Capabilities resource storing mint and burn capabilities.\n    /// The resource is stored on the account that initialized coin `CoinType`.\n    struct Capabilities<phantom CoinType> has key {\n        burn_cap: BurnCapability<CoinType>,\n        freeze_cap: FreezeCapability<CoinType>,\n        mint_cap: MintCapability<CoinType>,\n    }\n\n    //\n    // Public functions\n    //\n\n    /// Withdraw an `amount` of coin `CoinType` from `account` and burn it.\n    public entry fun burn<CoinType>(\n        account: &signer,\n        amount: u64,\n    ) acquires Capabilities {\n        let account_addr = signer::address_of(account);\n\n        assert!(\n            exists<Capabilities<CoinType>>(account_addr),\n            error::not_found(ENO_CAPABILITIES),\n        );\n\n        let capabilities = borrow_global<Capabilities<CoinType>>(account_addr);\n\n        let to_burn = coin::withdraw<CoinType>(account, amount);\n        coin::burn(to_burn, &capabilities.burn_cap);\n    }\n\n    /// Initialize new coin `CoinType` in Aptos Blockchain.\n    /// Mint and Burn Capabilities will be stored under `account` in `Capabilities` resource.\n    public entry fun initialize<CoinType>(\n        account: &signer,\n        name: vector<u8>,\n        symbol: vector<u8>,\n        decimals: u8,\n        monitor_supply: bool,\n    ) {\n        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(\n            account,\n            string::utf8(name),\n            string::utf8(symbol),\n            decimals,\n            monitor_supply,\n        );\n\n        move_to(account, Capabilities<CoinType> {\n            burn_cap,\n            freeze_cap,\n            mint_cap,\n        });\n    }\n\n    /// Create new coins `CoinType` and deposit them into dst_addr's account.\n    public entry fun mint<CoinType>(\n        account: &signer,\n        dst_addr: address,\n        amount: u64,\n    ) acquires Capabilities {\n        let account_addr = signer::address_of(account);\n\n        assert!(\n            exists<Capabilities<CoinType>>(account_addr),\n            error::not_found(ENO_CAPABILITIES),\n        );\n\n        let capabilities = borrow_global<Capabilities<CoinType>>(account_addr);\n        let coins_minted = coin::mint(amount, &capabilities.mint_cap);\n        coin::deposit(dst_addr, coins_minted);\n    }\n\n    /// Creating a resource that stores balance of `CoinType` on user's account, withdraw and deposit event handlers.\n    /// Required if user wants to start accepting deposits of `CoinType` in his account.\n    public entry fun register<CoinType>(account: &signer) {\n        coin::register<CoinType>(account);\n    }\n\n    //\n    // Tests\n    //\n\n    #[test_only]\n    use std::option;\n\n    #[test_only]\n    use aptos_framework::aggregator_factory;\n\n    #[test_only]\n    struct FakeMoney {}\n\n    #[test(source = @0xa11ce, destination = @0xb0b, mod_account = @0x1)]\n    public entry fun test_end_to_end(\n        source: signer,\n        destination: signer,\n        mod_account: signer\n    ) acquires Capabilities {\n        let source_addr = signer::address_of(&source);\n        let destination_addr = signer::address_of(&destination);\n        aptos_framework::account::create_account_for_test(source_addr);\n        aptos_framework::account::create_account_for_test(destination_addr);\n        aptos_framework::account::create_account_for_test(signer::address_of(&mod_account));\n        aggregator_factory::initialize_aggregator_factory_for_test(&mod_account);\n\n        initialize<FakeMoney>(\n            &mod_account,\n            b\"Fake Money\",\n            b\"FMD\",\n            10,\n            true\n        );\n        assert!(coin::is_coin_initialized<FakeMoney>(), 0);\n\n        coin::register<FakeMoney>(&mod_account);\n        register<FakeMoney>(&source);\n        register<FakeMoney>(&destination);\n\n        mint<FakeMoney>(&mod_account, source_addr, 50);\n        mint<FakeMoney>(&mod_account, destination_addr, 10);\n        assert!(coin::balance<FakeMoney>(source_addr) == 50, 1);\n        assert!(coin::balance<FakeMoney>(destination_addr) == 10, 2);\n\n        let supply = coin::supply<FakeMoney>();\n        assert!(option::is_some(&supply), 1);\n        assert!(option::extract(&mut supply) == 60, 2);\n\n        coin::transfer<FakeMoney>(&source, destination_addr, 10);\n        assert!(coin::balance<FakeMoney>(source_addr) == 40, 3);\n        assert!(coin::balance<FakeMoney>(destination_addr) == 20, 4);\n\n        coin::transfer<FakeMoney>(&source, signer::address_of(&mod_account), 40);\n        burn<FakeMoney>(&mod_account, 40);\n\n        assert!(coin::balance<FakeMoney>(source_addr) == 0, 1);\n\n        let new_supply = coin::supply<FakeMoney>();\n        assert!(option::extract(&mut new_supply) == 20, 2);\n    }\n\n    #[test(source = @0xa11ce, destination = @0xb0b, mod_account = @0x1)]\n    #[expected_failure(abort_code = 0x60001, location = Self)]\n    public entry fun fail_mint(\n        source: signer,\n        destination: signer,\n        mod_account: signer,\n    ) acquires Capabilities {\n        let source_addr = signer::address_of(&source);\n\n        aptos_framework::account::create_account_for_test(source_addr);\n        aptos_framework::account::create_account_for_test(signer::address_of(&destination));\n        aptos_framework::account::create_account_for_test(signer::address_of(&mod_account));\n        aggregator_factory::initialize_aggregator_factory_for_test(&mod_account);\n\n        initialize<FakeMoney>(&mod_account, b\"Fake money\", b\"FMD\", 1, true);\n        coin::register<FakeMoney>(&mod_account);\n        register<FakeMoney>(&source);\n        register<FakeMoney>(&destination);\n\n        mint<FakeMoney>(&destination, source_addr, 100);\n    }\n\n    #[test(source = @0xa11ce, destination = @0xb0b, mod_account = @0x1)]\n    #[expected_failure(abort_code = 0x60001, location = Self)]\n    public entry fun fail_burn(\n        source: signer,\n        destination: signer,\n        mod_account: signer,\n    ) acquires Capabilities {\n        let source_addr = signer::address_of(&source);\n\n        aptos_framework::account::create_account_for_test(source_addr);\n        aptos_framework::account::create_account_for_test(signer::address_of(&destination));\n        aptos_framework::account::create_account_for_test(signer::address_of(&mod_account));\n        aggregator_factory::initialize_aggregator_factory_for_test(&mod_account);\n\n        initialize<FakeMoney>(&mod_account, b\"Fake money\", b\"FMD\", 1, true);\n        coin::register<FakeMoney>(&mod_account);\n        register<FakeMoney>(&source);\n        register<FakeMoney>(&destination);\n\n        mint<FakeMoney>(&mod_account, source_addr, 100);\n        burn<FakeMoney>(&destination, 10);\n    }\n}\n","name":"managed_coin.move"},{"content":"/// Enhanced multisig account standard on Aptos. This is different from the native multisig scheme support enforced via\n/// the account's auth key.\n///\n/// This module allows creating a flexible and powerful multisig account with seamless support for updating owners\n/// without changing the auth key. Users can choose to store transaction payloads waiting for owner signatures on chain\n/// or off chain (primary consideration is decentralization/transparency vs gas cost).\n///\n/// The multisig account is a resource account underneath. By default, it has no auth key and can only be controlled via\n/// the special multisig transaction flow. However, owners can create a transaction to change the auth key to match a\n/// private key off chain if so desired.\n///\n/// Transactions need to be executed in order of creation, similar to transactions for a normal Aptos account (enforced\n/// with account nonce).\n///\n/// The flow is like below:\n/// 1. Owners can create a new multisig account by calling create (signer is default single owner) or with\n/// create_with_owners where multiple initial owner addresses can be specified. This is different (and easier) from\n/// the native multisig scheme where the owners' public keys have to be specified. Here, only addresses are needed.\n/// 2. Owners can be added/removed any time by calling add_owners or remove_owners. The transactions to do still need\n/// to follow the k-of-n scheme specified for the multisig account.\n/// 3. To create a new transaction, an owner can call create_transaction with the transaction payload. This will store\n/// the full transaction payload on chain, which adds decentralization (censorship is not possible as the data is\n/// available on chain) and makes it easier to fetch all transactions waiting for execution. If saving gas is desired,\n/// an owner can alternatively call create_transaction_with_hash where only the payload hash is stored. Later execution\n/// will be verified using the hash. Only owners can create transactions and a transaction id (incremeting id) will be\n/// assigned.\n/// 4. To approve or reject a transaction, other owners can call approve() or reject() with the transaction id.\n/// 5. If there are enough approvals, any owner can execute the transaction using the special MultisigTransaction type\n/// with the transaction id if the full payload is already stored on chain or with the transaction payload if only a\n/// hash is stored. Transaction execution will first check with this module that the transaction payload has gotten\n/// enough signatures. If so, it will be executed as the multisig account. The owner who executes will pay for gas.\n/// 6. If there are enough rejections, any owner can finalize the rejection by calling execute_rejected_transaction().\n///\n/// Note that this multisig account model is not designed to use with a large number of owners. The more owners there\n/// are, the more expensive voting on transactions will become. If a large number of owners is designed, such as in a\n/// flat governance structure, clients are encouraged to write their own modules on top of this multisig account module\n/// and implement the governance voting logic on top.\nmodule aptos_framework::multisig_account {\n    use aptos_framework::account::{Self, SignerCapability, new_event_handle, create_resource_address};\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::chain_id;\n    use aptos_framework::create_signer::create_signer;\n    use aptos_framework::coin;\n    use aptos_framework::event::{EventHandle, emit_event, emit};\n    use aptos_framework::timestamp::now_seconds;\n    use aptos_std::simple_map::{Self, SimpleMap};\n    use aptos_std::table::{Self, Table};\n    use std::bcs::to_bytes;\n    use std::error;\n    use std::hash::sha3_256;\n    use std::option::{Self, Option};\n    use std::signer::address_of;\n    use std::string::String;\n    use std::vector;\n\n    /// The salt used to create a resource account during multisig account creation.\n    /// This is used to avoid conflicts with other modules that also create resource accounts with the same owner\n    /// account.\n    const DOMAIN_SEPARATOR: vector<u8> = b\"aptos_framework::multisig_account\";\n\n    // Any error codes > 2000 can be thrown as part of transaction prologue.\n    /// Owner list cannot contain the same address more than once.\n    const EDUPLICATE_OWNER: u64 = 1;\n    /// Specified account is not a multisig account.\n    const EACCOUNT_NOT_MULTISIG: u64 = 2002;\n    /// Account executing this operation is not an owner of the multisig account.\n    const ENOT_OWNER: u64 = 2003;\n    /// Transaction payload cannot be empty.\n    const EPAYLOAD_CANNOT_BE_EMPTY: u64 = 4;\n    /// Multisig account must have at least one owner.\n    const ENOT_ENOUGH_OWNERS: u64 = 5;\n    /// Transaction with specified id cannot be found.\n    const ETRANSACTION_NOT_FOUND: u64 = 2006;\n    /// Provided target function does not match the hash stored in the on-chain transaction.\n    const EPAYLOAD_DOES_NOT_MATCH_HASH: u64 = 2008;\n    /// Transaction has not received enough approvals to be executed.\n    const ENOT_ENOUGH_APPROVALS: u64 = 2009;\n    /// Transaction has not received enough rejections to be officially rejected.\n    const ENOT_ENOUGH_REJECTIONS: u64 = 10;\n    /// Number of signatures required must be more than zero and at most the total number of owners.\n    const EINVALID_SIGNATURES_REQUIRED: u64 = 11;\n    /// Payload hash must be exactly 32 bytes (sha3-256).\n    const EINVALID_PAYLOAD_HASH: u64 = 12;\n    /// The multisig account itself cannot be an owner.\n    const EOWNER_CANNOT_BE_MULTISIG_ACCOUNT_ITSELF: u64 = 13;\n    /// Multisig accounts has not been enabled on this current network yet.\n    const EMULTISIG_ACCOUNTS_NOT_ENABLED_YET: u64 = 14;\n    /// The number of metadata keys and values don't match.\n    const ENUMBER_OF_METADATA_KEYS_AND_VALUES_DONT_MATCH: u64 = 15;\n    /// The specified metadata contains duplicate attributes (keys).\n    const EDUPLICATE_METADATA_KEY: u64 = 16;\n    /// The sequence number provided is invalid. It must be between [1, next pending transaction - 1].\n    const EINVALID_SEQUENCE_NUMBER: u64 = 17;\n    /// Provided owners to remove and new owners overlap.\n    const EOWNERS_TO_REMOVE_NEW_OWNERS_OVERLAP: u64 = 18;\n    /// The number of pending transactions has exceeded the maximum allowed.\n    const EMAX_PENDING_TRANSACTIONS_EXCEEDED: u64 = 19;\n    /// The multisig v2 enhancement feature is not enabled.\n    const EMULTISIG_V2_ENHANCEMENT_NOT_ENABLED: u64 = 20;\n\n\n    const ZERO_AUTH_KEY: vector<u8> = x\"0000000000000000000000000000000000000000000000000000000000000000\";\n\n    const MAX_PENDING_TRANSACTIONS: u64 = 20;\n\n    /// Represents a multisig account's configurations and transactions.\n    /// This will be stored in the multisig account (created as a resource account separate from any owner accounts).\n    struct MultisigAccount has key {\n        // The list of all owner addresses.\n        owners: vector<address>,\n        // The number of signatures required to pass a transaction (k in k-of-n).\n        num_signatures_required: u64,\n        // Map from transaction id (incrementing id) to transactions to execute for this multisig account.\n        // Already executed transactions are deleted to save on storage but can always be accessed via events.\n        transactions: Table<u64, MultisigTransaction>,\n        // The sequence number assigned to the last executed or rejected transaction. Used to enforce in-order\n        // executions of proposals, similar to sequence number for a normal (single-user) account.\n        last_executed_sequence_number: u64,\n        // The sequence number to assign to the next transaction. This is not always last_executed_sequence_number + 1\n        // as there can be multiple pending transactions. The number of pending transactions should be equal to\n        // next_sequence_number - (last_executed_sequence_number + 1).\n        next_sequence_number: u64,\n        // The signer capability controlling the multisig (resource) account. This can be exchanged for the signer.\n        // Currently not used as the MultisigTransaction can validate and create a signer directly in the VM but\n        // this can be useful to have for on-chain composability in the future.\n        signer_cap: Option<SignerCapability>,\n        // The multisig account's metadata such as name, description, etc. This can be updated through the multisig\n        // transaction flow (i.e. self-update).\n        // Note: Attributes can be arbitrarily set by the multisig account and thus will only be used for off-chain\n        // display purposes only. They don't change any on-chain semantics of the multisig account.\n        metadata: SimpleMap<String, vector<u8>>,\n\n        // Events.\n        add_owners_events: EventHandle<AddOwnersEvent>,\n        remove_owners_events: EventHandle<RemoveOwnersEvent>,\n        update_signature_required_events: EventHandle<UpdateSignaturesRequiredEvent>,\n        create_transaction_events: EventHandle<CreateTransactionEvent>,\n        vote_events: EventHandle<VoteEvent>,\n        execute_rejected_transaction_events: EventHandle<ExecuteRejectedTransactionEvent>,\n        execute_transaction_events: EventHandle<TransactionExecutionSucceededEvent>,\n        transaction_execution_failed_events: EventHandle<TransactionExecutionFailedEvent>,\n        metadata_updated_events: EventHandle<MetadataUpdatedEvent>,\n    }\n\n    /// A transaction to be executed in a multisig account.\n    /// This must contain either the full transaction payload or its hash (stored as bytes).\n    struct MultisigTransaction has copy, drop, store {\n        payload: Option<vector<u8>>,\n        payload_hash: Option<vector<u8>>,\n        // Mapping from owner adress to vote (yes for approve, no for reject). Uses a simple map to deduplicate.\n        votes: SimpleMap<address, bool>,\n        // The owner who created this transaction.\n        creator: address,\n        // The timestamp in seconds when the transaction was created.\n        creation_time_secs: u64,\n    }\n\n    /// Contains information about execution failure.\n    struct ExecutionError has copy, drop, store {\n        // The module where the error occurs.\n        abort_location: String,\n        // There are 3 error types, stored as strings:\n        // 1. VMError. Indicates an error from the VM, e.g. out of gas, invalid auth key, etc.\n        // 2. MoveAbort. Indicates an abort, e.g. assertion failure, from inside the executed Move code.\n        // 3. MoveExecutionFailure. Indicates an error from Move code where the VM could not continue. For example,\n        // arithmetic failures.\n        error_type: String,\n        // The detailed error code explaining which error occurred.\n        error_code: u64,\n    }\n\n    /// Used only for verifying multisig account creation on top of existing accounts.\n    struct MultisigAccountCreationMessage has copy, drop {\n        // Chain id is included to prevent cross-chain replay.\n        chain_id: u8,\n        // Account address is included to prevent cross-account replay (when multiple accounts share the same auth key).\n        account_address: address,\n        // Sequence number is not needed for replay protection as the multisig account can only be created once.\n        // But it's included to ensure timely execution of account creation.\n        sequence_number: u64,\n        // The list of owners for the multisig account.\n        owners: vector<address>,\n        // The number of signatures required (signature threshold).\n        num_signatures_required: u64,\n    }\n\n    /// Used only for verifying multisig account creation on top of existing accounts and rotating the auth key to 0x0.\n    struct MultisigAccountCreationWithAuthKeyRevocationMessage has copy, drop {\n        // Chain id is included to prevent cross-chain replay.\n        chain_id: u8,\n        // Account address is included to prevent cross-account replay (when multiple accounts share the same auth key).\n        account_address: address,\n        // Sequence number is not needed for replay protection as the multisig account can only be created once.\n        // But it's included to ensure timely execution of account creation.\n        sequence_number: u64,\n        // The list of owners for the multisig account.\n        owners: vector<address>,\n        // The number of signatures required (signature threshold).\n        num_signatures_required: u64,\n    }\n\n    /// Event emitted when new owners are added to the multisig account.\n    struct AddOwnersEvent has drop, store {\n        owners_added: vector<address>,\n    }\n\n    #[event]\n    struct AddOwners has drop, store {\n        multisig_account: address,\n        owners_added: vector<address>,\n    }\n\n    /// Event emitted when new owners are removed from the multisig account.\n    struct RemoveOwnersEvent has drop, store {\n        owners_removed: vector<address>,\n    }\n\n    #[event]\n    struct RemoveOwners has drop, store {\n        multisig_account: address,\n        owners_removed: vector<address>,\n    }\n\n    /// Event emitted when the number of signatures required is updated.\n    struct UpdateSignaturesRequiredEvent has drop, store {\n        old_num_signatures_required: u64,\n        new_num_signatures_required: u64,\n    }\n\n    #[event]\n    struct UpdateSignaturesRequired has drop, store {\n        multisig_account: address,\n        old_num_signatures_required: u64,\n        new_num_signatures_required: u64,\n    }\n\n    /// Event emitted when a transaction is created.\n    struct CreateTransactionEvent has drop, store {\n        creator: address,\n        sequence_number: u64,\n        transaction: MultisigTransaction,\n    }\n\n    #[event]\n    struct CreateTransaction has drop, store {\n        multisig_account: address,\n        creator: address,\n        sequence_number: u64,\n        transaction: MultisigTransaction,\n    }\n\n    /// Event emitted when an owner approves or rejects a transaction.\n    struct VoteEvent has drop, store {\n        owner: address,\n        sequence_number: u64,\n        approved: bool,\n    }\n\n    #[event]\n    struct Vote has drop, store {\n        multisig_account: address,\n        owner: address,\n        sequence_number: u64,\n        approved: bool,\n    }\n\n    /// Event emitted when a transaction is officially rejected because the number of rejections has reached the\n    /// number of signatures required.\n    struct ExecuteRejectedTransactionEvent has drop, store {\n        sequence_number: u64,\n        num_rejections: u64,\n        executor: address,\n    }\n\n    #[event]\n    struct ExecuteRejectedTransaction has drop, store {\n        multisig_account: address,\n        sequence_number: u64,\n        num_rejections: u64,\n        executor: address,\n    }\n\n    /// Event emitted when a transaction is executed.\n    struct TransactionExecutionSucceededEvent has drop, store {\n        executor: address,\n        sequence_number: u64,\n        transaction_payload: vector<u8>,\n        num_approvals: u64,\n    }\n\n    #[event]\n    struct TransactionExecutionSucceeded has drop, store {\n        multisig_account: address,\n        executor: address,\n        sequence_number: u64,\n        transaction_payload: vector<u8>,\n        num_approvals: u64,\n    }\n\n    /// Event emitted when a transaction's execution failed.\n    struct TransactionExecutionFailedEvent has drop, store {\n        executor: address,\n        sequence_number: u64,\n        transaction_payload: vector<u8>,\n        num_approvals: u64,\n        execution_error: ExecutionError,\n    }\n\n    #[event]\n    struct TransactionExecutionFailed has drop, store {\n        multisig_account: address,\n        executor: address,\n        sequence_number: u64,\n        transaction_payload: vector<u8>,\n        num_approvals: u64,\n        execution_error: ExecutionError,\n    }\n\n    /// Event emitted when a transaction's metadata is updated.\n    struct MetadataUpdatedEvent has drop, store {\n        old_metadata: SimpleMap<String, vector<u8>>,\n        new_metadata: SimpleMap<String, vector<u8>>,\n    }\n\n    #[event]\n    struct MetadataUpdated has drop, store {\n        multisig_account: address,\n        old_metadata: SimpleMap<String, vector<u8>>,\n        new_metadata: SimpleMap<String, vector<u8>>,\n    }\n\n    ////////////////////////// View functions ///////////////////////////////\n\n    #[view]\n    /// Return the multisig account's metadata.\n    public fun metadata(multisig_account: address): SimpleMap<String, vector<u8>> acquires MultisigAccount {\n        borrow_global<MultisigAccount>(multisig_account).metadata\n    }\n\n    #[view]\n    /// Return the number of signatures required to execute or execute-reject a transaction in the provided\n    /// multisig account.\n    public fun num_signatures_required(multisig_account: address): u64 acquires MultisigAccount {\n        borrow_global<MultisigAccount>(multisig_account).num_signatures_required\n    }\n\n    #[view]\n    /// Return a vector of all of the provided multisig account's owners.\n    public fun owners(multisig_account: address): vector<address> acquires MultisigAccount {\n        borrow_global<MultisigAccount>(multisig_account).owners\n    }\n\n    #[view]\n    /// Return true if the provided owner is an owner of the provided multisig account.\n    public fun is_owner(owner: address, multisig_account: address): bool acquires MultisigAccount {\n        vector::contains(&borrow_global<MultisigAccount>(multisig_account).owners, &owner)\n    }\n\n    #[view]\n    /// Return the transaction with the given transaction id.\n    public fun get_transaction(\n        multisig_account: address,\n        sequence_number: u64,\n    ): MultisigTransaction acquires MultisigAccount {\n        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);\n        assert!(\n            sequence_number > 0 && sequence_number < multisig_account_resource.next_sequence_number,\n            error::invalid_argument(EINVALID_SEQUENCE_NUMBER),\n        );\n        *table::borrow(&multisig_account_resource.transactions, sequence_number)\n    }\n\n    #[view]\n    /// Return all pending transactions.\n    public fun get_pending_transactions(\n        multisig_account: address\n    ): vector<MultisigTransaction> acquires MultisigAccount {\n        let pending_transactions: vector<MultisigTransaction> = vector[];\n        let multisig_account = borrow_global<MultisigAccount>(multisig_account);\n        let i = multisig_account.last_executed_sequence_number + 1;\n        let next_sequence_number = multisig_account.next_sequence_number;\n        while (i < next_sequence_number) {\n            vector::push_back(&mut pending_transactions, *table::borrow(&multisig_account.transactions, i));\n            i = i + 1;\n        };\n        pending_transactions\n    }\n\n    #[view]\n    /// Return the payload for the next transaction in the queue.\n    public fun get_next_transaction_payload(\n        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {\n        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);\n        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;\n        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);\n\n        if (option::is_some(&transaction.payload)) {\n            *option::borrow(&transaction.payload)\n        } else {\n            provided_payload\n        }\n    }\n\n    #[view]\n    /// Return true if the transaction with given transaction id can be executed now.\n    public fun can_be_executed(multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {\n        assert_valid_sequence_number(multisig_account, sequence_number);\n        let (num_approvals, _) = num_approvals_and_rejections(multisig_account, sequence_number);\n        sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&\n            num_approvals >= num_signatures_required(multisig_account)\n    }\n\n    #[view]\n    /// Return true if the owner can execute the transaction with given transaction id now.\n    public fun can_execute(owner: address, multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {\n        assert_valid_sequence_number(multisig_account, sequence_number);\n        let (num_approvals, _) = num_approvals_and_rejections(multisig_account, sequence_number);\n        if (!has_voted_for_approval(multisig_account, sequence_number, owner)) {\n            num_approvals = num_approvals + 1;\n        };\n        is_owner(owner, multisig_account) &&\n            sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&\n            num_approvals >= num_signatures_required(multisig_account)\n    }\n\n    #[view]\n    /// Return true if the transaction with given transaction id can be officially rejected.\n    public fun can_be_rejected(multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {\n        assert_valid_sequence_number(multisig_account, sequence_number);\n        let (_, num_rejections) = num_approvals_and_rejections(multisig_account, sequence_number);\n        sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&\n            num_rejections >= num_signatures_required(multisig_account)\n    }\n\n    #[view]\n    /// Return true if the owner can execute the \"rejected\" transaction with given transaction id now.\n    public fun can_reject(owner: address, multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {\n        assert_valid_sequence_number(multisig_account, sequence_number);\n        let (_, num_rejections) = num_approvals_and_rejections(multisig_account, sequence_number);\n        if (!has_voted_for_rejection(multisig_account, sequence_number, owner)) {\n            num_rejections = num_rejections + 1;\n        };\n        is_owner(owner, multisig_account) &&\n            sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&\n            num_rejections >= num_signatures_required(multisig_account)\n    }\n\n    #[view]\n    /// Return the predicted address for the next multisig account if created from the given creator address.\n    public fun get_next_multisig_account_address(creator: address): address {\n        let owner_nonce = account::get_sequence_number(creator);\n        create_resource_address(&creator, create_multisig_account_seed(to_bytes(&owner_nonce)))\n    }\n\n    #[view]\n    /// Return the id of the last transaction that was executed (successful or failed) or removed.\n    public fun last_resolved_sequence_number(multisig_account: address): u64 acquires MultisigAccount {\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        multisig_account_resource.last_executed_sequence_number\n    }\n\n    #[view]\n    /// Return the id of the next transaction created.\n    public fun next_sequence_number(multisig_account: address): u64 acquires MultisigAccount {\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        multisig_account_resource.next_sequence_number\n    }\n\n    #[view]\n    /// Return a bool tuple indicating whether an owner has voted and if so, whether they voted yes or no.\n    public fun vote(\n        multisig_account: address, sequence_number: u64, owner: address): (bool, bool) acquires MultisigAccount {\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        assert!(\n            sequence_number > 0 && sequence_number < multisig_account_resource.next_sequence_number,\n            error::invalid_argument(EINVALID_SEQUENCE_NUMBER),\n        );\n        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);\n        let votes = &transaction.votes;\n        let voted = simple_map::contains_key(votes, &owner);\n        let vote = voted && *simple_map::borrow(votes, &owner);\n        (voted, vote)\n    }\n\n    #[view]\n    public fun available_transaction_queue_capacity(multisig_account: address): u64 acquires MultisigAccount {\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        let num_pending_transactions = multisig_account_resource.next_sequence_number - multisig_account_resource.last_executed_sequence_number - 1;\n        if (num_pending_transactions > MAX_PENDING_TRANSACTIONS) {\n            0\n        } else {\n            MAX_PENDING_TRANSACTIONS - num_pending_transactions\n        }\n    }\n\n    ////////////////////////// Multisig account creation functions ///////////////////////////////\n\n    /// Creates a new multisig account on top of an existing account.\n    ///\n    /// This offers a migration path for an existing account with a multi-ed25519 auth key (native multisig account).\n    /// In order to ensure a malicious module cannot obtain backdoor control over an existing account, a signed message\n    /// with a valid signature from the account's auth key is required.\n    ///\n    /// Note that this does not revoke auth key-based control over the account. Owners should separately rotate the auth\n    /// key after they are fully migrated to the new multisig account. Alternatively, they can call\n    /// create_with_existing_account_and_revoke_auth_key instead.\n    public entry fun create_with_existing_account(\n        multisig_address: address,\n        owners: vector<address>,\n        num_signatures_required: u64,\n        account_scheme: u8,\n        account_public_key: vector<u8>,\n        create_multisig_account_signed_message: vector<u8>,\n        metadata_keys: vector<String>,\n        metadata_values: vector<vector<u8>>,\n    ) acquires MultisigAccount {\n        // Verify that the `MultisigAccountCreationMessage` has the right information and is signed by the account\n        // owner's key.\n        let proof_challenge = MultisigAccountCreationMessage {\n            chain_id: chain_id::get(),\n            account_address: multisig_address,\n            sequence_number: account::get_sequence_number(multisig_address),\n            owners,\n            num_signatures_required,\n        };\n        account::verify_signed_message(\n            multisig_address,\n            account_scheme,\n            account_public_key,\n            create_multisig_account_signed_message,\n            proof_challenge,\n        );\n\n        // We create the signer for the multisig account here since this is required to add the MultisigAccount resource\n        // This should be safe and authorized because we have verified the signed message from the existing account\n        // that authorizes creating a multisig account with the specified owners and signature threshold.\n        let multisig_account = &create_signer(multisig_address);\n        create_with_owners_internal(\n            multisig_account,\n            owners,\n            num_signatures_required,\n            option::none<SignerCapability>(),\n            metadata_keys,\n            metadata_values,\n        );\n    }\n\n    /// Creates a new multisig account on top of an existing account and immediately rotate the origin auth key to 0x0.\n    ///\n    /// Note: If the original account is a resource account, this does not revoke all control over it as if any\n    /// SignerCapability of the resource account still exists, it can still be used to generate the signer for the\n    /// account.\n    public entry fun create_with_existing_account_and_revoke_auth_key(\n        multisig_address: address,\n        owners: vector<address>,\n        num_signatures_required: u64,\n        account_scheme: u8,\n        account_public_key: vector<u8>,\n        create_multisig_account_signed_message: vector<u8>,\n        metadata_keys: vector<String>,\n        metadata_values: vector<vector<u8>>,\n    ) acquires MultisigAccount {\n        // Verify that the `MultisigAccountCreationMessage` has the right information and is signed by the account\n        // owner's key.\n        let proof_challenge = MultisigAccountCreationWithAuthKeyRevocationMessage {\n            chain_id: chain_id::get(),\n            account_address: multisig_address,\n            sequence_number: account::get_sequence_number(multisig_address),\n            owners,\n            num_signatures_required,\n        };\n        account::verify_signed_message(\n            multisig_address,\n            account_scheme,\n            account_public_key,\n            create_multisig_account_signed_message,\n            proof_challenge,\n        );\n\n        // We create the signer for the multisig account here since this is required to add the MultisigAccount resource\n        // This should be safe and authorized because we have verified the signed message from the existing account\n        // that authorizes creating a multisig account with the specified owners and signature threshold.\n        let multisig_account = &create_signer(multisig_address);\n        create_with_owners_internal(\n            multisig_account,\n            owners,\n            num_signatures_required,\n            option::none<SignerCapability>(),\n            metadata_keys,\n            metadata_values,\n        );\n\n        // Rotate the account's auth key to 0x0, which effectively revokes control via auth key.\n        let multisig_address = address_of(multisig_account);\n        account::rotate_authentication_key_internal(multisig_account, ZERO_AUTH_KEY);\n        // This also needs to revoke any signer capability or rotation capability that exists for the account to\n        // completely remove all access to the account.\n        if (account::is_signer_capability_offered(multisig_address)) {\n            account::revoke_any_signer_capability(multisig_account);\n        };\n        if (account::is_rotation_capability_offered(multisig_address)) {\n            account::revoke_any_rotation_capability(multisig_account);\n        };\n    }\n\n    /// Creates a new multisig account and add the signer as a single owner.\n    public entry fun create(\n        owner: &signer,\n        num_signatures_required: u64,\n        metadata_keys: vector<String>,\n        metadata_values: vector<vector<u8>>,\n    ) acquires MultisigAccount {\n        create_with_owners(owner, vector[], num_signatures_required, metadata_keys, metadata_values);\n    }\n\n    /// Creates a new multisig account with the specified additional owner list and signatures required.\n    ///\n    /// @param additional_owners The owner account who calls this function cannot be in the additional_owners and there\n    /// cannot be any duplicate owners in the list.\n    /// @param num_signatures_required The number of signatures required to execute a transaction. Must be at least 1 and\n    /// at most the total number of owners.\n    public entry fun create_with_owners(\n        owner: &signer,\n        additional_owners: vector<address>,\n        num_signatures_required: u64,\n        metadata_keys: vector<String>,\n        metadata_values: vector<vector<u8>>,\n    ) acquires MultisigAccount {\n        let (multisig_account, multisig_signer_cap) = create_multisig_account(owner);\n        vector::push_back(&mut additional_owners, address_of(owner));\n        create_with_owners_internal(\n            &multisig_account,\n            additional_owners,\n            num_signatures_required,\n            option::some(multisig_signer_cap),\n            metadata_keys,\n            metadata_values,\n        );\n    }\n\n    /// Like `create_with_owners`, but removes the calling account after creation.\n    ///\n    /// This is for creating a vanity multisig account from a bootstrapping account that should not\n    /// be an owner after the vanity multisig address has been secured.\n    public entry fun create_with_owners_then_remove_bootstrapper(\n        bootstrapper: &signer,\n        owners: vector<address>,\n        num_signatures_required: u64,\n        metadata_keys: vector<String>,\n        metadata_values: vector<vector<u8>>,\n    ) acquires MultisigAccount {\n        let bootstrapper_address = address_of(bootstrapper);\n        create_with_owners(\n            bootstrapper,\n            owners,\n            num_signatures_required,\n            metadata_keys,\n            metadata_values\n        );\n        update_owner_schema(\n            get_next_multisig_account_address(bootstrapper_address),\n            vector[],\n            vector[bootstrapper_address],\n            option::none()\n        );\n    }\n\n    fun create_with_owners_internal(\n        multisig_account: &signer,\n        owners: vector<address>,\n        num_signatures_required: u64,\n        multisig_account_signer_cap: Option<SignerCapability>,\n        metadata_keys: vector<String>,\n        metadata_values: vector<vector<u8>>,\n    ) acquires MultisigAccount {\n        assert!(features::multisig_accounts_enabled(), error::unavailable(EMULTISIG_ACCOUNTS_NOT_ENABLED_YET));\n        assert!(\n            num_signatures_required > 0 && num_signatures_required <= vector::length(&owners),\n            error::invalid_argument(EINVALID_SIGNATURES_REQUIRED),\n        );\n\n        let multisig_address = address_of(multisig_account);\n        validate_owners(&owners, multisig_address);\n        move_to(multisig_account, MultisigAccount {\n            owners,\n            num_signatures_required,\n            transactions: table::new<u64, MultisigTransaction>(),\n            metadata: simple_map::create<String, vector<u8>>(),\n            // First transaction will start at id 1 instead of 0.\n            last_executed_sequence_number: 0,\n            next_sequence_number: 1,\n            signer_cap: multisig_account_signer_cap,\n            add_owners_events: new_event_handle<AddOwnersEvent>(multisig_account),\n            remove_owners_events: new_event_handle<RemoveOwnersEvent>(multisig_account),\n            update_signature_required_events: new_event_handle<UpdateSignaturesRequiredEvent>(multisig_account),\n            create_transaction_events: new_event_handle<CreateTransactionEvent>(multisig_account),\n            vote_events: new_event_handle<VoteEvent>(multisig_account),\n            execute_rejected_transaction_events: new_event_handle<ExecuteRejectedTransactionEvent>(multisig_account),\n            execute_transaction_events: new_event_handle<TransactionExecutionSucceededEvent>(multisig_account),\n            transaction_execution_failed_events: new_event_handle<TransactionExecutionFailedEvent>(multisig_account),\n            metadata_updated_events: new_event_handle<MetadataUpdatedEvent>(multisig_account),\n        });\n\n        update_metadata_internal(multisig_account, metadata_keys, metadata_values, false);\n    }\n\n    ////////////////////////// Self-updates ///////////////////////////////\n\n    /// Similar to add_owners, but only allow adding one owner.\n    entry fun add_owner(multisig_account: &signer, new_owner: address) acquires MultisigAccount {\n        add_owners(multisig_account, vector[new_owner]);\n    }\n\n    /// Add new owners to the multisig account. This can only be invoked by the multisig account itself, through the\n    /// proposal flow.\n    ///\n    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This\n    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to\n    /// maliciously alter the owners list.\n    entry fun add_owners(\n        multisig_account: &signer, new_owners: vector<address>) acquires MultisigAccount {\n        update_owner_schema(\n            address_of(multisig_account),\n            new_owners,\n            vector[],\n            option::none()\n        );\n    }\n\n    /// Add owners then update number of signatures required, in a single operation.\n    entry fun add_owners_and_update_signatures_required(\n        multisig_account: &signer,\n        new_owners: vector<address>,\n        new_num_signatures_required: u64\n    ) acquires MultisigAccount {\n        update_owner_schema(\n            address_of(multisig_account),\n            new_owners,\n            vector[],\n            option::some(new_num_signatures_required)\n        );\n    }\n\n    /// Similar to remove_owners, but only allow removing one owner.\n    entry fun remove_owner(\n        multisig_account: &signer, owner_to_remove: address) acquires MultisigAccount {\n        remove_owners(multisig_account, vector[owner_to_remove]);\n    }\n\n    /// Remove owners from the multisig account. This can only be invoked by the multisig account itself, through the\n    /// proposal flow.\n    ///\n    /// This function skips any owners who are not in the multisig account's list of owners.\n    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This\n    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to\n    /// maliciously alter the owners list.\n    entry fun remove_owners(\n        multisig_account: &signer, owners_to_remove: vector<address>) acquires MultisigAccount {\n        update_owner_schema(\n            address_of(multisig_account),\n            vector[],\n            owners_to_remove,\n            option::none()\n        );\n    }\n\n    /// Swap an owner in for an old one, without changing required signatures.\n    entry fun swap_owner(\n        multisig_account: &signer,\n        to_swap_in: address,\n        to_swap_out: address\n    ) acquires MultisigAccount {\n        update_owner_schema(\n            address_of(multisig_account),\n            vector[to_swap_in],\n            vector[to_swap_out],\n            option::none()\n        );\n    }\n\n    /// Swap owners in and out, without changing required signatures.\n    entry fun swap_owners(\n        multisig_account: &signer,\n        to_swap_in: vector<address>,\n        to_swap_out: vector<address>\n    ) acquires MultisigAccount {\n        update_owner_schema(\n            address_of(multisig_account),\n            to_swap_in,\n            to_swap_out,\n            option::none()\n        );\n    }\n\n    /// Swap owners in and out, updating number of required signatures.\n    entry fun swap_owners_and_update_signatures_required(\n        multisig_account: &signer,\n        new_owners: vector<address>,\n        owners_to_remove: vector<address>,\n        new_num_signatures_required: u64\n    ) acquires MultisigAccount {\n        update_owner_schema(\n            address_of(multisig_account),\n            new_owners,\n            owners_to_remove,\n            option::some(new_num_signatures_required)\n        );\n    }\n\n    /// Update the number of signatures required to execute transaction in the specified multisig account.\n    ///\n    /// This can only be invoked by the multisig account itself, through the proposal flow.\n    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This\n    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to\n    /// maliciously alter the number of signatures required.\n    entry fun update_signatures_required(\n        multisig_account: &signer, new_num_signatures_required: u64) acquires MultisigAccount {\n        update_owner_schema(\n            address_of(multisig_account),\n            vector[],\n            vector[],\n            option::some(new_num_signatures_required)\n        );\n    }\n\n    /// Allow the multisig account to update its own metadata. Note that this overrides the entire existing metadata.\n    /// If any attributes are not specified in the metadata, they will be removed!\n    ///\n    /// This can only be invoked by the multisig account itself, through the proposal flow.\n    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This\n    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to\n    /// maliciously alter the number of signatures required.\n    entry fun update_metadata(\n        multisig_account: &signer, keys: vector<String>, values: vector<vector<u8>>) acquires MultisigAccount {\n        update_metadata_internal(multisig_account, keys, values, true);\n    }\n\n    fun update_metadata_internal(\n        multisig_account: &signer,\n        keys: vector<String>,\n        values: vector<vector<u8>>,\n        emit_event: bool,\n    ) acquires MultisigAccount {\n        let num_attributes = vector::length(&keys);\n        assert!(\n            num_attributes == vector::length(&values),\n            error::invalid_argument(ENUMBER_OF_METADATA_KEYS_AND_VALUES_DONT_MATCH),\n        );\n\n        let multisig_address = address_of(multisig_account);\n        assert_multisig_account_exists(multisig_address);\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_address);\n        let old_metadata = multisig_account_resource.metadata;\n        multisig_account_resource.metadata = simple_map::create<String, vector<u8>>();\n        let metadata = &mut multisig_account_resource.metadata;\n        let i = 0;\n        while (i < num_attributes) {\n            let key = *vector::borrow(&keys, i);\n            let value = *vector::borrow(&values, i);\n            assert!(\n                !simple_map::contains_key(metadata, &key),\n                error::invalid_argument(EDUPLICATE_METADATA_KEY),\n            );\n\n            simple_map::add(metadata, key, value);\n            i = i + 1;\n        };\n\n        if (emit_event) {\n            if (std::features::module_event_migration_enabled()) {\n                emit(\n                    MetadataUpdated {\n                        multisig_account: multisig_address,\n                        old_metadata,\n                        new_metadata: multisig_account_resource.metadata,\n                    }\n                )\n            };\n            emit_event(\n                &mut multisig_account_resource.metadata_updated_events,\n                MetadataUpdatedEvent {\n                    old_metadata,\n                    new_metadata: multisig_account_resource.metadata,\n                }\n            );\n        };\n    }\n\n    ////////////////////////// Multisig transaction flow ///////////////////////////////\n\n    /// Create a multisig transaction, which will have one approval initially (from the creator).\n    public entry fun create_transaction(\n        owner: &signer,\n        multisig_account: address,\n        payload: vector<u8>,\n    ) acquires MultisigAccount {\n        assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));\n\n        assert_multisig_account_exists(multisig_account);\n        assert_is_owner(owner, multisig_account);\n\n        let creator = address_of(owner);\n        let transaction = MultisigTransaction {\n            payload: option::some(payload),\n            payload_hash: option::none<vector<u8>>(),\n            votes: simple_map::create<address, bool>(),\n            creator,\n            creation_time_secs: now_seconds(),\n        };\n        add_transaction(creator, multisig_account, transaction);\n    }\n\n    /// Create a multisig transaction with a transaction hash instead of the full payload.\n    /// This means the payload will be stored off chain for gas saving. Later, during execution, the executor will need\n    /// to provide the full payload, which will be validated against the hash stored on-chain.\n    public entry fun create_transaction_with_hash(\n        owner: &signer,\n        multisig_account: address,\n        payload_hash: vector<u8>,\n    ) acquires MultisigAccount {\n        // Payload hash is a sha3-256 hash, so it must be exactly 32 bytes.\n        assert!(vector::length(&payload_hash) == 32, error::invalid_argument(EINVALID_PAYLOAD_HASH));\n\n        assert_multisig_account_exists(multisig_account);\n        assert_is_owner(owner, multisig_account);\n\n        let creator = address_of(owner);\n        let transaction = MultisigTransaction {\n            payload: option::none<vector<u8>>(),\n            payload_hash: option::some(payload_hash),\n            votes: simple_map::create<address, bool>(),\n            creator,\n            creation_time_secs: now_seconds(),\n        };\n        add_transaction(creator, multisig_account, transaction);\n    }\n\n    /// Approve a multisig transaction.\n    public entry fun approve_transaction(\n        owner: &signer, multisig_account: address, sequence_number: u64) acquires MultisigAccount {\n        vote_transanction(owner, multisig_account, sequence_number, true);\n    }\n\n    /// Reject a multisig transaction.\n    public entry fun reject_transaction(\n        owner: &signer, multisig_account: address, sequence_number: u64) acquires MultisigAccount {\n        vote_transanction(owner, multisig_account, sequence_number, false);\n    }\n\n    /// Generic function that can be used to either approve or reject a multisig transaction\n    /// Retained for backward compatibility: the function with the typographical error in its name\n    /// will continue to be an accessible entry point.\n    public entry fun vote_transanction(\n        owner: &signer, multisig_account: address, sequence_number: u64, approved: bool) acquires MultisigAccount {\n        assert_multisig_account_exists(multisig_account);\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        assert_is_owner_internal(owner, multisig_account_resource);\n\n        assert!(\n            table::contains(&multisig_account_resource.transactions, sequence_number),\n            error::not_found(ETRANSACTION_NOT_FOUND),\n        );\n        let transaction = table::borrow_mut(&mut multisig_account_resource.transactions, sequence_number);\n        let votes = &mut transaction.votes;\n        let owner_addr = address_of(owner);\n\n        if (simple_map::contains_key(votes, &owner_addr)) {\n            *simple_map::borrow_mut(votes, &owner_addr) = approved;\n        } else {\n            simple_map::add(votes, owner_addr, approved);\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                Vote {\n                    multisig_account,\n                    owner: owner_addr,\n                    sequence_number,\n                    approved,\n                }\n            );\n        };\n        emit_event(\n            &mut multisig_account_resource.vote_events,\n            VoteEvent {\n                owner: owner_addr,\n                sequence_number,\n                approved,\n            }\n        );\n    }\n\n    /// Generic function that can be used to either approve or reject a multisig transaction\n    public entry fun vote_transaction(\n        owner: &signer, multisig_account: address, sequence_number: u64, approved: bool) acquires MultisigAccount {\n        assert!(features::multisig_v2_enhancement_feature_enabled(), error::invalid_state(EMULTISIG_V2_ENHANCEMENT_NOT_ENABLED));\n        vote_transanction(owner, multisig_account, sequence_number, approved);\n    }\n\n    /// Generic function that can be used to either approve or reject a batch of transactions within a specified range.\n    public entry fun vote_transactions(\n        owner: &signer, multisig_account: address, starting_sequence_number: u64, final_sequence_number: u64, approved: bool) acquires MultisigAccount {\n        assert!(features::multisig_v2_enhancement_feature_enabled(), error::invalid_state(EMULTISIG_V2_ENHANCEMENT_NOT_ENABLED));\n        let sequence_number = starting_sequence_number;\n        while(sequence_number <= final_sequence_number) {\n            vote_transanction(owner, multisig_account, sequence_number, approved);\n            sequence_number = sequence_number + 1;\n        }\n    }\n\n    /// Remove the next transaction if it has sufficient owner rejections.\n    public entry fun execute_rejected_transaction(\n        owner: &signer,\n        multisig_account: address,\n    ) acquires MultisigAccount {\n        assert_multisig_account_exists(multisig_account);\n        assert_is_owner(owner, multisig_account);\n\n        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;\n        let owner_addr = address_of(owner);\n        if(features::multisig_v2_enhancement_feature_enabled()) {\n            // Implicitly vote for rejection if the owner has not voted for rejection yet.\n            if (!has_voted_for_rejection(multisig_account, sequence_number, owner_addr)) {\n                reject_transaction(owner, multisig_account, sequence_number);\n            }\n        };\n\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        let (_, num_rejections) = remove_executed_transaction(multisig_account_resource);\n        assert!(\n            num_rejections >= multisig_account_resource.num_signatures_required,\n            error::invalid_state(ENOT_ENOUGH_REJECTIONS),\n        );\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                ExecuteRejectedTransaction {\n                    multisig_account,\n                    sequence_number,\n                    num_rejections,\n                    executor: address_of(owner),\n                }\n            );\n        };\n        emit_event(\n            &mut multisig_account_resource.execute_rejected_transaction_events,\n            ExecuteRejectedTransactionEvent {\n                sequence_number,\n                num_rejections,\n                executor: owner_addr,\n            }\n        );\n    }\n\n    /// Remove the next transactions until the final_sequence_number if they have sufficient owner rejections.\n    public entry fun execute_rejected_transactions(\n        owner: &signer,\n        multisig_account: address,\n        final_sequence_number: u64,\n    ) acquires MultisigAccount {\n        assert!(features::multisig_v2_enhancement_feature_enabled(), error::invalid_state(EMULTISIG_V2_ENHANCEMENT_NOT_ENABLED));\n        assert!(last_resolved_sequence_number(multisig_account) < final_sequence_number, error::invalid_argument(EINVALID_SEQUENCE_NUMBER));\n        assert!(final_sequence_number < next_sequence_number(multisig_account), error::invalid_argument(EINVALID_SEQUENCE_NUMBER));\n        while(last_resolved_sequence_number(multisig_account) < final_sequence_number) {\n            execute_rejected_transaction(owner, multisig_account);\n        }\n    }\n\n    ////////////////////////// To be called by VM only ///////////////////////////////\n\n    /// Called by the VM as part of transaction prologue, which is invoked during mempool transaction validation and as\n    /// the first step of transaction execution.\n    ///\n    /// Transaction payload is optional if it's already stored on chain for the transaction.\n    fun validate_multisig_transaction(\n        owner: &signer, multisig_account: address, payload: vector<u8>) acquires MultisigAccount {\n        assert_multisig_account_exists(multisig_account);\n        assert_is_owner(owner, multisig_account);\n        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;\n        assert_transaction_exists(multisig_account, sequence_number);\n\n        if(features::multisig_v2_enhancement_feature_enabled()) {\n            assert!(\n                can_execute(address_of(owner), multisig_account, sequence_number),\n                error::invalid_argument(ENOT_ENOUGH_APPROVALS),\n            );\n        }\n        else {\n            assert!(\n                can_be_executed(multisig_account, sequence_number),\n                error::invalid_argument(ENOT_ENOUGH_APPROVALS),\n            );\n        };\n\n        // If the transaction payload is not stored on chain, verify that the provided payload matches the hashes stored\n        // on chain.\n        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);\n        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);\n        if (option::is_some(&transaction.payload_hash)) {\n            let payload_hash = option::borrow(&transaction.payload_hash);\n            assert!(\n                sha3_256(payload) == *payload_hash,\n                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH_HASH),\n            );\n        };\n    }\n\n    /// Post-execution cleanup for a successful multisig transaction execution.\n    /// This function is private so no other code can call this beside the VM itself as part of MultisigTransaction.\n    fun successful_transaction_execution_cleanup(\n        executor: address,\n        multisig_account: address,\n        transaction_payload: vector<u8>,\n    ) acquires MultisigAccount {\n        let num_approvals = transaction_execution_cleanup_common(executor, multisig_account);\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                TransactionExecutionSucceeded {\n                    multisig_account,\n                    sequence_number: multisig_account_resource.last_executed_sequence_number,\n                    transaction_payload,\n                    num_approvals,\n                    executor,\n                }\n            );\n        };\n        emit_event(\n            &mut multisig_account_resource.execute_transaction_events,\n            TransactionExecutionSucceededEvent {\n                sequence_number: multisig_account_resource.last_executed_sequence_number,\n                transaction_payload,\n                num_approvals,\n                executor,\n            }\n        );\n    }\n\n    /// Post-execution cleanup for a failed multisig transaction execution.\n    /// This function is private so no other code can call this beside the VM itself as part of MultisigTransaction.\n    fun failed_transaction_execution_cleanup(\n        executor: address,\n        multisig_account: address,\n        transaction_payload: vector<u8>,\n        execution_error: ExecutionError,\n    ) acquires MultisigAccount {\n        let num_approvals = transaction_execution_cleanup_common(executor, multisig_account);\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                TransactionExecutionFailed {\n                    multisig_account,\n                    executor,\n                    sequence_number: multisig_account_resource.last_executed_sequence_number,\n                    transaction_payload,\n                    num_approvals,\n                    execution_error,\n                }\n            );\n        };\n        emit_event(\n            &mut multisig_account_resource.transaction_execution_failed_events,\n            TransactionExecutionFailedEvent {\n                executor,\n                sequence_number: multisig_account_resource.last_executed_sequence_number,\n                transaction_payload,\n                num_approvals,\n                execution_error,\n            }\n        );\n    }\n\n    ////////////////////////// Private functions ///////////////////////////////\n\n    inline fun transaction_execution_cleanup_common(executor: address, multisig_account: address): u64 acquires MultisigAccount {\n        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;\n        let implicit_approval = !has_voted_for_approval(multisig_account, sequence_number, executor);\n\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n        let (num_approvals, _) = remove_executed_transaction(multisig_account_resource);\n\n        if(features::multisig_v2_enhancement_feature_enabled() && implicit_approval) {\n            if (std::features::module_event_migration_enabled()) {\n                emit(\n                    Vote {\n                        multisig_account,\n                        owner: executor,\n                        sequence_number,\n                        approved: true,\n                    }\n                );\n            };\n            num_approvals = num_approvals + 1;\n            emit_event(\n                &mut multisig_account_resource.vote_events,\n                VoteEvent {\n                    owner: executor,\n                    sequence_number,\n                    approved: true,\n                }\n            );\n        };\n\n        num_approvals\n    }\n\n    // Remove the next transaction in the queue as it's been executed and return the number of approvals it had.\n    fun remove_executed_transaction(multisig_account_resource: &mut MultisigAccount): (u64, u64) {\n        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;\n        let transaction = table::remove(&mut multisig_account_resource.transactions, sequence_number);\n        multisig_account_resource.last_executed_sequence_number = sequence_number;\n        num_approvals_and_rejections_internal(&multisig_account_resource.owners, &transaction)\n    }\n\n    inline fun add_transaction(\n        creator: address,\n        multisig_account: address,\n        transaction: MultisigTransaction\n    ) {\n        if(features::multisig_v2_enhancement_feature_enabled()) {\n            assert!(\n                available_transaction_queue_capacity(multisig_account) > 0,\n                error::invalid_state(EMAX_PENDING_TRANSACTIONS_EXCEEDED)\n            );\n        };\n\n        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);\n\n        // The transaction creator also automatically votes for the transaction.\n        simple_map::add(&mut transaction.votes, creator, true);\n\n        let sequence_number = multisig_account_resource.next_sequence_number;\n        multisig_account_resource.next_sequence_number = sequence_number + 1;\n        table::add(&mut multisig_account_resource.transactions, sequence_number, transaction);\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                CreateTransaction { multisig_account: multisig_account, creator, sequence_number, transaction }\n            );\n        };\n        emit_event(\n            &mut multisig_account_resource.create_transaction_events,\n            CreateTransactionEvent { creator, sequence_number, transaction },\n        );\n    }\n\n    fun create_multisig_account(owner: &signer): (signer, SignerCapability) {\n        let owner_nonce = account::get_sequence_number(address_of(owner));\n        let (multisig_signer, multisig_signer_cap) =\n            account::create_resource_account(owner, create_multisig_account_seed(to_bytes(&owner_nonce)));\n        // Register the account to receive APT as this is not done by default as part of the resource account creation\n        // flow.\n        if (!coin::is_account_registered<AptosCoin>(address_of(&multisig_signer))) {\n            coin::register<AptosCoin>(&multisig_signer);\n        };\n\n        (multisig_signer, multisig_signer_cap)\n    }\n\n    fun create_multisig_account_seed(seed: vector<u8>): vector<u8> {\n        // Generate a seed that will be used to create the resource account that hosts the multisig account.\n        let multisig_account_seed = vector::empty<u8>();\n        vector::append(&mut multisig_account_seed, DOMAIN_SEPARATOR);\n        vector::append(&mut multisig_account_seed, seed);\n\n        multisig_account_seed\n    }\n\n    fun validate_owners(owners: &vector<address>, multisig_account: address) {\n        let distinct_owners: vector<address> = vector[];\n        vector::for_each_ref(owners, |owner| {\n            let owner = *owner;\n            assert!(owner != multisig_account, error::invalid_argument(EOWNER_CANNOT_BE_MULTISIG_ACCOUNT_ITSELF));\n            let (found, _) = vector::index_of(&distinct_owners, &owner);\n            assert!(!found, error::invalid_argument(EDUPLICATE_OWNER));\n            vector::push_back(&mut distinct_owners, owner);\n        });\n    }\n\n    inline fun assert_is_owner_internal(owner: &signer, multisig_account: &MultisigAccount) {\n        assert!(\n            vector::contains(&multisig_account.owners, &address_of(owner)),\n            error::permission_denied(ENOT_OWNER),\n        );\n    }\n\n    inline fun assert_is_owner(owner: &signer, multisig_account: address) acquires MultisigAccount {\n        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);\n        assert_is_owner_internal(owner, multisig_account_resource);\n    }\n\n    inline fun num_approvals_and_rejections_internal(owners: &vector<address>, transaction: &MultisigTransaction): (u64, u64) {\n        let num_approvals = 0;\n        let num_rejections = 0;\n\n        let votes = &transaction.votes;\n        vector::for_each_ref(owners, |owner| {\n            if (simple_map::contains_key(votes, owner)) {\n                if (*simple_map::borrow(votes, owner)) {\n                    num_approvals = num_approvals + 1;\n                } else {\n                    num_rejections = num_rejections + 1;\n                };\n            }\n        });\n\n        (num_approvals, num_rejections)\n    }\n\n    inline fun num_approvals_and_rejections(multisig_account: address, sequence_number: u64): (u64, u64) acquires MultisigAccount {\n        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);\n        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);\n        num_approvals_and_rejections_internal(&multisig_account_resource.owners, transaction)\n    }\n\n    inline fun has_voted_for_approval(multisig_account: address, sequence_number: u64, owner: address): bool acquires MultisigAccount {\n        let (voted, vote) = vote(multisig_account, sequence_number, owner);\n        voted && vote\n    }\n\n    inline fun has_voted_for_rejection(multisig_account: address, sequence_number: u64, owner: address): bool acquires MultisigAccount {\n        let (voted, vote) = vote(multisig_account, sequence_number, owner);\n        voted && !vote\n    }\n\n    inline fun assert_multisig_account_exists(multisig_account: address) {\n        assert!(exists<MultisigAccount>(multisig_account), error::invalid_state(EACCOUNT_NOT_MULTISIG));\n    }\n\n    inline fun assert_valid_sequence_number(multisig_account: address, sequence_number: u64) acquires MultisigAccount {\n        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);\n        assert!(\n            sequence_number > 0 && sequence_number < multisig_account_resource.next_sequence_number,\n            error::invalid_argument(EINVALID_SEQUENCE_NUMBER),\n        );\n    }\n\n    inline fun assert_transaction_exists(multisig_account: address, sequence_number: u64) acquires MultisigAccount {\n        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);\n        assert!(\n            table::contains(&multisig_account_resource.transactions, sequence_number),\n            error::not_found(ETRANSACTION_NOT_FOUND),\n        );\n    }\n\n    /// Add new owners, remove owners to remove, update signatures required.\n    fun update_owner_schema(\n        multisig_address: address,\n        new_owners: vector<address>,\n        owners_to_remove: vector<address>,\n        optional_new_num_signatures_required: Option<u64>,\n    ) acquires MultisigAccount {\n        assert_multisig_account_exists(multisig_address);\n        let multisig_account_ref_mut =\n            borrow_global_mut<MultisigAccount>(multisig_address);\n        // Verify no overlap between new owners and owners to remove.\n        vector::for_each_ref(&new_owners, |new_owner_ref| {\n            assert!(\n                !vector::contains(&owners_to_remove, new_owner_ref),\n                error::invalid_argument(EOWNERS_TO_REMOVE_NEW_OWNERS_OVERLAP)\n            )\n        });\n        // If new owners provided, try to add them and emit an event.\n        if (vector::length(&new_owners) > 0) {\n            vector::append(&mut multisig_account_ref_mut.owners, new_owners);\n            validate_owners(\n                &multisig_account_ref_mut.owners,\n                multisig_address\n            );\n            if (std::features::module_event_migration_enabled()) {\n                emit(AddOwners { multisig_account: multisig_address, owners_added: new_owners });\n            };\n            emit_event(\n                &mut multisig_account_ref_mut.add_owners_events,\n                AddOwnersEvent { owners_added: new_owners }\n            );\n        };\n        // If owners to remove provided, try to remove them.\n        if (vector::length(&owners_to_remove) > 0) {\n            let owners_ref_mut = &mut multisig_account_ref_mut.owners;\n            let owners_removed = vector[];\n            vector::for_each_ref(&owners_to_remove, |owner_to_remove_ref| {\n                let (found, index) =\n                    vector::index_of(owners_ref_mut, owner_to_remove_ref);\n                if (found) {\n                    vector::push_back(\n                        &mut owners_removed,\n                        vector::swap_remove(owners_ref_mut, index)\n                    );\n                }\n            });\n            // Only emit event if owner(s) actually removed.\n            if (vector::length(&owners_removed) > 0) {\n                if (std::features::module_event_migration_enabled()) {\n                    emit(\n                        RemoveOwners { multisig_account: multisig_address, owners_removed }\n                    );\n                };\n                emit_event(\n                    &mut multisig_account_ref_mut.remove_owners_events,\n                    RemoveOwnersEvent { owners_removed }\n                );\n            }\n        };\n        // If new signature count provided, try to update count.\n        if (option::is_some(&optional_new_num_signatures_required)) {\n            let new_num_signatures_required =\n                option::extract(&mut optional_new_num_signatures_required);\n            assert!(\n                new_num_signatures_required > 0,\n                error::invalid_argument(EINVALID_SIGNATURES_REQUIRED)\n            );\n            let old_num_signatures_required =\n                multisig_account_ref_mut.num_signatures_required;\n            // Only apply update and emit event if a change indicated.\n            if (new_num_signatures_required != old_num_signatures_required) {\n                multisig_account_ref_mut.num_signatures_required =\n                    new_num_signatures_required;\n                if (std::features::module_event_migration_enabled()) {\n                    emit(\n                        UpdateSignaturesRequired {\n                            multisig_account: multisig_address,\n                            old_num_signatures_required,\n                            new_num_signatures_required,\n                        }\n                    );\n                };\n                emit_event(\n                    &mut multisig_account_ref_mut.update_signature_required_events,\n                    UpdateSignaturesRequiredEvent {\n                        old_num_signatures_required,\n                        new_num_signatures_required,\n                    }\n                );\n            }\n        };\n        // Verify number of owners.\n        let num_owners = vector::length(&multisig_account_ref_mut.owners);\n        assert!(\n            num_owners >= multisig_account_ref_mut.num_signatures_required,\n            error::invalid_state(ENOT_ENOUGH_OWNERS)\n        );\n    }\n\n    ////////////////////////// Tests ///////////////////////////////\n\n    #[test_only]\n    use aptos_framework::aptos_account::create_account;\n    #[test_only]\n    use aptos_framework::timestamp;\n    #[test_only]\n    use aptos_std::from_bcs;\n    #[test_only]\n    use aptos_std::multi_ed25519;\n    #[test_only]\n    use std::string::utf8;\n    use std::features;\n    #[test_only]\n    use aptos_framework::aptos_coin;\n    #[test_only]\n    use aptos_framework::coin::{destroy_mint_cap, destroy_burn_cap};\n\n    #[test_only]\n    const PAYLOAD: vector<u8> = vector[1, 2, 3];\n    #[test_only]\n    const ERROR_TYPE: vector<u8> = b\"MoveAbort\";\n    #[test_only]\n    const ABORT_LOCATION: vector<u8> = b\"abort_location\";\n    #[test_only]\n    const ERROR_CODE: u64 = 10;\n\n    #[test_only]\n    fun execution_error(): ExecutionError {\n        ExecutionError {\n            abort_location: utf8(ABORT_LOCATION),\n            error_type: utf8(ERROR_TYPE),\n            error_code: ERROR_CODE,\n        }\n    }\n\n    #[test_only]\n    fun setup() {\n        let framework_signer = &create_signer(@0x1);\n        features::change_feature_flags_for_testing(\n            framework_signer, vector[features::get_multisig_accounts_feature(), features::get_multisig_v2_enhancement_feature()], vector[]);\n        timestamp::set_time_has_started_for_testing(framework_signer);\n        chain_id::initialize_for_test(framework_signer, 1);\n        let (burn, mint) = aptos_coin::initialize_for_test(framework_signer);\n        destroy_mint_cap(mint);\n        destroy_burn_cap(burn);\n    }\n\n    #[test_only]\n    fun setup_disabled() {\n        let framework_signer = &create_signer(@0x1);\n        features::change_feature_flags_for_testing(\n            framework_signer, vector[], vector[features::get_multisig_accounts_feature()]);\n        timestamp::set_time_has_started_for_testing(framework_signer);\n        chain_id::initialize_for_test(framework_signer, 1);\n        let (burn, mint) = aptos_coin::initialize_for_test(framework_signer);\n        destroy_mint_cap(mint);\n        destroy_burn_cap(burn);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_end_to_end(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        // Create three transactions.\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        create_transaction(owner_2, multisig_account, PAYLOAD);\n        create_transaction_with_hash(owner_3, multisig_account, sha3_256(PAYLOAD));\n        assert!(get_pending_transactions(multisig_account) == vector[\n            get_transaction(multisig_account, 1),\n            get_transaction(multisig_account, 2),\n            get_transaction(multisig_account, 3),\n        ], 0);\n\n        // Owner 3 doesn't need to explicitly approve as they created the transaction.\n        approve_transaction(owner_1, multisig_account, 3);\n        // Third transaction has 2 approvals but cannot be executed out-of-order.\n        assert!(!can_be_executed(multisig_account, 3), 0);\n\n        // Owner 1 doesn't need to explicitly approve as they created the transaction.\n        approve_transaction(owner_2, multisig_account, 1);\n        // First transaction has 2 approvals so it can be executed.\n        assert!(can_be_executed(multisig_account, 1), 1);\n        // First transaction was executed successfully.\n        successful_transaction_execution_cleanup(owner_2_addr, multisig_account, vector[]);\n        assert!(get_pending_transactions(multisig_account) == vector[\n            get_transaction(multisig_account, 2),\n            get_transaction(multisig_account, 3),\n        ], 0);\n\n        reject_transaction(owner_1, multisig_account, 2);\n        reject_transaction(owner_3, multisig_account, 2);\n        // Second transaction has 1 approval (owner 3) and 2 rejections (owners 1 & 2) and thus can be removed.\n        assert!(can_be_rejected(multisig_account, 2), 2);\n        execute_rejected_transaction(owner_1, multisig_account);\n        assert!(get_pending_transactions(multisig_account) == vector[\n            get_transaction(multisig_account, 3),\n        ], 0);\n\n        // Third transaction can be executed now but execution fails.\n        failed_transaction_execution_cleanup(owner_3_addr, multisig_account, PAYLOAD, execution_error());\n        assert!(get_pending_transactions(multisig_account) == vector[], 0);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_end_to_end_with_implicit_votes(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        // Create three transactions.\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        create_transaction(owner_2, multisig_account, PAYLOAD);\n        assert!(get_pending_transactions(multisig_account) == vector[\n            get_transaction(multisig_account, 1),\n            get_transaction(multisig_account, 2),\n        ], 0);\n\n        reject_transaction(owner_2, multisig_account, 1);\n        // Owner 2 can execute the transaction, implicitly voting to approve it,\n        // which overrides their previous vote for rejection.\n        assert!(can_execute(owner_2_addr, multisig_account, 1), 1);\n        // First transaction was executed successfully.\n        successful_transaction_execution_cleanup(owner_2_addr, multisig_account,vector[]);\n        assert!(get_pending_transactions(multisig_account) == vector[\n            get_transaction(multisig_account, 2),\n        ], 0);\n\n        reject_transaction(owner_1, multisig_account, 2);\n        // Owner 3 can execute-reject the transaction, implicitly voting to reject it.\n        assert!(can_reject(owner_3_addr, multisig_account, 2), 2);\n        execute_rejected_transaction(owner_3, multisig_account);\n        assert!(get_pending_transactions(multisig_account) == vector[], 0);\n    }\n\n    #[test(owner = @0x123)]\n    public entry fun test_create_with_single_owner(owner: &signer) acquires MultisigAccount {\n        setup();\n        let owner_addr = address_of(owner);\n        create_account(owner_addr);\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(owner_addr);\n        assert_multisig_account_exists(multisig_account);\n        assert!(owners(multisig_account) == vector[owner_addr], 0);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_create_with_as_many_sigs_required_as_num_owners(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        create_account(owner_1_addr);\n        create_with_owners(owner_1, vector[address_of(owner_2), address_of(owner_3)], 3, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        assert_multisig_account_exists(multisig_account);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x1000B, location = Self)]\n    public entry fun test_create_with_zero_signatures_required_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 0, vector[], vector[]);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x1000B, location = Self)]\n    public entry fun test_create_with_too_many_signatures_required_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 2, vector[], vector[]);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    #[expected_failure(abort_code = 0x10001, location = Self)]\n    public entry fun test_create_with_duplicate_owners_should_fail(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner_1));\n        create_with_owners(\n            owner_1,\n            vector[\n                // Duplicate owner 2 addresses.\n                address_of(owner_2),\n                address_of(owner_3),\n                address_of(owner_2),\n            ],\n            2,\n            vector[],\n            vector[]);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0xD000E, location = Self)]\n    public entry fun test_create_with_without_feature_flag_enabled_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup_disabled();\n        create_account(address_of(owner));\n        create(owner, 2, vector[], vector[]);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    #[expected_failure(abort_code = 0x10001, location = Self)]\n    public entry fun test_create_with_creator_in_additional_owners_list_should_fail(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner_1));\n        create_with_owners(owner_1, vector[\n            // Duplicate owner 1 addresses.\n            address_of(owner_1),\n            address_of(owner_2),\n            address_of(owner_3),\n        ], 2,\n            vector[],\n            vector[],\n        );\n    }\n\n    #[test]\n    public entry fun test_create_multisig_account_on_top_of_existing_multi_ed25519_account()\n    acquires MultisigAccount {\n        setup();\n        let (curr_sk, curr_pk) = multi_ed25519::generate_keys(2, 3);\n        let pk_unvalidated = multi_ed25519::public_key_to_unvalidated(&curr_pk);\n        let auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&pk_unvalidated);\n        let multisig_address = from_bcs::to_address(auth_key);\n        create_account(multisig_address);\n\n        let expected_owners = vector[@0x123, @0x124, @0x125];\n        let proof = MultisigAccountCreationMessage {\n            chain_id: chain_id::get(),\n            account_address: multisig_address,\n            sequence_number: account::get_sequence_number(multisig_address),\n            owners: expected_owners,\n            num_signatures_required: 2,\n        };\n        let signed_proof = multi_ed25519::sign_struct(&curr_sk, proof);\n        create_with_existing_account(\n            multisig_address,\n            expected_owners,\n            2,\n            1, // MULTI_ED25519_SCHEME\n            multi_ed25519::unvalidated_public_key_to_bytes(&pk_unvalidated),\n            multi_ed25519::signature_to_bytes(&signed_proof),\n            vector[],\n            vector[],\n        );\n        assert_multisig_account_exists(multisig_address);\n        assert!(owners(multisig_address) == expected_owners, 0);\n    }\n\n    #[test]\n    public entry fun test_create_multisig_account_on_top_of_existing_multi_ed25519_account_and_revoke_auth_key()\n    acquires MultisigAccount {\n        setup();\n        let (curr_sk, curr_pk) = multi_ed25519::generate_keys(2, 3);\n        let pk_unvalidated = multi_ed25519::public_key_to_unvalidated(&curr_pk);\n        let auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&pk_unvalidated);\n        let multisig_address = from_bcs::to_address(auth_key);\n        create_account(multisig_address);\n\n        // Create both a signer capability and rotation capability offers\n        account::set_rotation_capability_offer(multisig_address, @0x123);\n        account::set_signer_capability_offer(multisig_address, @0x123);\n\n        let expected_owners = vector[@0x123, @0x124, @0x125];\n        let proof = MultisigAccountCreationWithAuthKeyRevocationMessage {\n            chain_id: chain_id::get(),\n            account_address: multisig_address,\n            sequence_number: account::get_sequence_number(multisig_address),\n            owners: expected_owners,\n            num_signatures_required: 2,\n        };\n        let signed_proof = multi_ed25519::sign_struct(&curr_sk, proof);\n        create_with_existing_account_and_revoke_auth_key(\n            multisig_address,\n            expected_owners,\n            2,\n            1, // MULTI_ED25519_SCHEME\n            multi_ed25519::unvalidated_public_key_to_bytes(&pk_unvalidated),\n            multi_ed25519::signature_to_bytes(&signed_proof),\n            vector[],\n            vector[],\n        );\n        assert_multisig_account_exists(multisig_address);\n        assert!(owners(multisig_address) == expected_owners, 0);\n        assert!(account::get_authentication_key(multisig_address) == ZERO_AUTH_KEY, 1);\n        // Verify that all capability offers have been wiped.\n        assert!(!account::is_rotation_capability_offered(multisig_address), 2);\n        assert!(!account::is_signer_capability_offered(multisig_address), 3);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_update_signatures_required(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        create_account(owner_1_addr);\n        create_with_owners(owner_1, vector[address_of(owner_2), address_of(owner_3)], 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        assert!(num_signatures_required(multisig_account) == 1, 0);\n        update_signatures_required(&create_signer(multisig_account), 2);\n        assert!(num_signatures_required(multisig_account) == 2, 1);\n        // As many signatures required as number of owners (3).\n        update_signatures_required(&create_signer(multisig_account), 3);\n        assert!(num_signatures_required(multisig_account) == 3, 2);\n    }\n\n    #[test(owner = @0x123)]\n    public entry fun test_update_metadata(owner: &signer) acquires MultisigAccount {\n        setup();\n        let owner_addr = address_of(owner);\n        create_account(owner_addr);\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(owner_addr);\n        update_metadata(\n            &create_signer(multisig_account),\n            vector[utf8(b\"key1\"), utf8(b\"key2\")],\n            vector[vector[1], vector[2]],\n        );\n        let updated_metadata = metadata(multisig_account);\n        assert!(simple_map::length(&updated_metadata) == 2, 0);\n        assert!(simple_map::borrow(&updated_metadata, &utf8(b\"key1\")) == &vector[1], 0);\n        assert!(simple_map::borrow(&updated_metadata, &utf8(b\"key2\")) == &vector[2], 0);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x1000B, location = Self)]\n    public entry fun test_update_with_zero_signatures_required_should_fail(\n        owner: & signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        update_signatures_required(&create_signer(multisig_account), 0);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x30005, location = Self)]\n    public entry fun test_update_with_too_many_signatures_required_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        update_signatures_required(&create_signer(multisig_account), 2);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_add_owners(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner_1));\n        create(owner_1, 1, vector[], vector[]);\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        let multisig_signer = &create_signer(multisig_account);\n        assert!(owners(multisig_account) == vector[owner_1_addr], 0);\n        // Adding an empty vector of new owners should be no-op.\n        add_owners(multisig_signer, vector[]);\n        assert!(owners(multisig_account) == vector[owner_1_addr], 1);\n        add_owners(multisig_signer, vector[owner_2_addr, owner_3_addr]);\n        assert!(owners(multisig_account) == vector[owner_1_addr, owner_2_addr, owner_3_addr], 2);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_remove_owners(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        let multisig_signer = &create_signer(multisig_account);\n        assert!(owners(multisig_account) == vector[owner_2_addr, owner_3_addr, owner_1_addr], 0);\n        // Removing an empty vector of owners should be no-op.\n        remove_owners(multisig_signer, vector[]);\n        assert!(owners(multisig_account) == vector[owner_2_addr, owner_3_addr, owner_1_addr], 1);\n        remove_owners(multisig_signer, vector[owner_2_addr]);\n        assert!(owners(multisig_account) == vector[owner_1_addr, owner_3_addr], 2);\n        // Removing owners that don't exist should be no-op.\n        remove_owners(multisig_signer, vector[@0x130]);\n        assert!(owners(multisig_account) == vector[owner_1_addr, owner_3_addr], 3);\n        // Removing with duplicate owners should still work.\n        remove_owners(multisig_signer, vector[owner_3_addr, owner_3_addr, owner_3_addr]);\n        assert!(owners(multisig_account) == vector[owner_1_addr], 4);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    #[expected_failure(abort_code = 0x30005, location = Self)]\n    public entry fun test_remove_all_owners_should_fail(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        assert!(owners(multisig_account) == vector[owner_2_addr, owner_3_addr, owner_1_addr], 0);\n        let multisig_signer = &create_signer(multisig_account);\n        remove_owners(multisig_signer, vector[owner_1_addr, owner_2_addr, owner_3_addr]);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    #[expected_failure(abort_code = 0x30005, location = Self)]\n    public entry fun test_remove_owners_with_fewer_remaining_than_signature_threshold_should_fail(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        let multisig_signer = &create_signer(multisig_account);\n        // Remove 2 owners so there's one left, which is less than the signature threshold of 2.\n        remove_owners(multisig_signer, vector[owner_2_addr, owner_3_addr]);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_create_transaction(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        let transaction = get_transaction(multisig_account, 1);\n        assert!(transaction.creator == owner_1_addr, 0);\n        assert!(option::is_some(&transaction.payload), 1);\n        assert!(option::is_none(&transaction.payload_hash), 2);\n        let payload = option::extract(&mut transaction.payload);\n        assert!(payload == PAYLOAD, 4);\n        // Automatic yes vote from creator.\n        assert!(simple_map::length(&transaction.votes) == 1, 5);\n        assert!(*simple_map::borrow(&transaction.votes, &owner_1_addr), 5);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x10004, location = Self)]\n    public entry fun test_create_transaction_with_empty_payload_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create_transaction(owner, multisig_account, vector[]);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x124)]\n    #[expected_failure(abort_code = 0x507D3, location = Self)]\n    public entry fun test_create_transaction_with_non_owner_should_fail(\n        owner: &signer, non_owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create_transaction(non_owner, multisig_account, PAYLOAD);\n    }\n\n    #[test(owner = @0x123)]\n    public entry fun test_create_transaction_with_hashes(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create_transaction_with_hash(owner, multisig_account, sha3_256(PAYLOAD));\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x1000C, location = Self)]\n    public entry fun test_create_transaction_with_empty_hash_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create_transaction_with_hash(owner, multisig_account, vector[]);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x124)]\n    #[expected_failure(abort_code = 0x507D3, location = Self)]\n    public entry fun test_create_transaction_with_hashes_and_non_owner_should_fail(\n        owner: &signer, non_owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create_transaction_with_hash(non_owner, multisig_account, sha3_256(PAYLOAD));\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_approve_transaction(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        approve_transaction(owner_2, multisig_account, 1);\n        approve_transaction(owner_3, multisig_account, 1);\n        let transaction = get_transaction(multisig_account, 1);\n        assert!(simple_map::length(&transaction.votes) == 3, 0);\n        assert!(*simple_map::borrow(&transaction.votes, &owner_1_addr), 1);\n        assert!(*simple_map::borrow(&transaction.votes, &owner_2_addr), 2);\n        assert!(*simple_map::borrow(&transaction.votes, &owner_3_addr), 3);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_validate_transaction_should_not_consider_removed_owners(\n        owner_1: &signer, owner_2: &signer, owner_3: & signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        // Owner 1 and 2 approved but then owner 1 got removed.\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        approve_transaction(owner_2, multisig_account, 1);\n        // Before owner 1 is removed, the transaction technically has sufficient approvals.\n        assert!(can_be_executed(multisig_account, 1), 0);\n        let multisig_signer = &create_signer(multisig_account);\n        remove_owners(multisig_signer, vector[owner_1_addr]);\n        // Now that owner 1 is removed, their approval should be invalidated and the transaction no longer\n        // has enough approvals to be executed.\n        assert!(!can_be_executed(multisig_account, 1), 1);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x607D6, location = Self)]\n    public entry fun test_approve_transaction_with_invalid_sequence_number_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        approve_transaction(owner, multisig_account, 2);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x124)]\n    #[expected_failure(abort_code = 0x507D3, location = Self)]\n    public entry fun test_approve_transaction_with_non_owner_should_fail(\n        owner: &signer, non_owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        approve_transaction(non_owner, multisig_account, 1);\n    }\n\n    #[test(owner = @0x123)]\n    public entry fun test_approval_transaction_after_rejecting(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        let owner_addr = address_of(owner);\n        create_account(owner_addr);\n        let multisig_account = get_next_multisig_account_address(owner_addr);\n        create(owner, 1, vector[], vector[]);\n\n        create_transaction(owner, multisig_account, PAYLOAD);\n        reject_transaction(owner, multisig_account, 1);\n        approve_transaction(owner, multisig_account, 1);\n        let transaction = get_transaction(multisig_account, 1);\n        assert!(*simple_map::borrow(&transaction.votes, &owner_addr), 1);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_reject_transaction(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        reject_transaction(owner_1, multisig_account, 1);\n        reject_transaction(owner_2, multisig_account, 1);\n        reject_transaction(owner_3, multisig_account, 1);\n        let transaction = get_transaction(multisig_account, 1);\n        assert!(simple_map::length(&transaction.votes) == 3, 0);\n        assert!(!*simple_map::borrow(&transaction.votes, &owner_1_addr), 1);\n        assert!(!*simple_map::borrow(&transaction.votes, &owner_2_addr), 2);\n        assert!(!*simple_map::borrow(&transaction.votes, &owner_3_addr), 3);\n    }\n\n    #[test(owner = @0x123)]\n    public entry fun test_reject_transaction_after_approving(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        let owner_addr = address_of(owner);\n        create_account(owner_addr);\n        let multisig_account = get_next_multisig_account_address(owner_addr);\n        create(owner, 1, vector[], vector[]);\n\n        create_transaction(owner, multisig_account, PAYLOAD);\n        reject_transaction(owner, multisig_account, 1);\n        let transaction = get_transaction(multisig_account, 1);\n        assert!(!*simple_map::borrow(&transaction.votes, &owner_addr), 1);\n    }\n\n    #[test(owner = @0x123)]\n    #[expected_failure(abort_code = 0x607D6, location = Self)]\n    public entry fun test_reject_transaction_with_invalid_sequence_number_should_fail(\n        owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        reject_transaction(owner, multisig_account, 2);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x124)]\n    #[expected_failure(abort_code = 0x507D3, location = Self)]\n    public entry fun test_reject_transaction_with_non_owner_should_fail(\n        owner: &signer, non_owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        reject_transaction(non_owner, multisig_account, 1);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_execute_transaction_successful(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        // Owner 1 doesn't need to explicitly approve as they created the transaction.\n        approve_transaction(owner_2, multisig_account, 1);\n        assert!(can_be_executed(multisig_account, 1), 1);\n        assert!(table::contains(&borrow_global<MultisigAccount>(multisig_account).transactions, 1), 0);\n        successful_transaction_execution_cleanup(owner_3_addr, multisig_account, vector[]);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_execute_transaction_failed(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        // Owner 1 doesn't need to explicitly approve as they created the transaction.\n        approve_transaction(owner_2, multisig_account, 1);\n        assert!(can_be_executed(multisig_account, 1), 1);\n        assert!(table::contains(&borrow_global<MultisigAccount>(multisig_account).transactions, 1), 0);\n        failed_transaction_execution_cleanup(owner_3_addr, multisig_account, vector[], execution_error());\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_execute_transaction_with_full_payload(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction_with_hash(owner_3, multisig_account, sha3_256(PAYLOAD));\n        // Owner 3 doesn't need to explicitly approve as they created the transaction.\n        approve_transaction(owner_1, multisig_account, 1);\n        assert!(can_be_executed(multisig_account, 1), 1);\n        assert!(table::contains(&borrow_global<MultisigAccount>(multisig_account).transactions, 1), 0);\n        successful_transaction_execution_cleanup(owner_3_addr, multisig_account, PAYLOAD);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    public entry fun test_execute_rejected_transaction(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        reject_transaction(owner_2, multisig_account, 1);\n        reject_transaction(owner_3, multisig_account, 1);\n        assert!(can_be_rejected(multisig_account, 1), 1);\n        assert!(table::contains(&borrow_global<MultisigAccount>(multisig_account).transactions, 1), 0);\n        execute_rejected_transaction(owner_3, multisig_account);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x124)]\n    #[expected_failure(abort_code = 0x507D3, location = Self)]\n    public entry fun test_execute_rejected_transaction_with_non_owner_should_fail(\n        owner: &signer, non_owner: &signer) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n\n        create_transaction(owner, multisig_account, PAYLOAD);\n        reject_transaction(owner, multisig_account, 1);\n        execute_rejected_transaction(non_owner, multisig_account);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    #[expected_failure(abort_code = 0x3000A, location = Self)]\n    public entry fun test_execute_rejected_transaction_without_sufficient_rejections_should_fail(\n        owner_1: &signer, owner_2: &signer, owner_3: &signer) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_account = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(owner_1, vector[owner_2_addr, owner_3_addr], 2, vector[], vector[]);\n\n        create_transaction(owner_1, multisig_account, PAYLOAD);\n        approve_transaction(owner_2, multisig_account, 1);\n        execute_rejected_transaction(owner_3, multisig_account);\n    }\n\n    #[test(\n        owner_1 = @0x123,\n        owner_2 = @0x124,\n        owner_3 = @0x125\n    )]\n    #[expected_failure(abort_code = 0x10012, location = Self)]\n    fun test_update_owner_schema_overlap_should_fail(\n        owner_1: &signer,\n        owner_2: &signer,\n        owner_3: &signer\n    ) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_address = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(\n            owner_1,\n            vector[owner_2_addr, owner_3_addr],\n            2,\n            vector[],\n            vector[]\n        );\n        update_owner_schema(\n            multisig_address,\n            vector[owner_1_addr],\n            vector[owner_1_addr],\n            option::none()\n        );\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    #[expected_failure(abort_code = 196627, location = Self)]\n    fun test_max_pending_transaction_limit_should_fail(\n        owner_1: &signer,\n        owner_2: &signer,\n        owner_3: &signer\n    ) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_address = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(\n            owner_1,\n            vector[owner_2_addr, owner_3_addr],\n            2,\n            vector[],\n            vector[]\n        );\n\n        let remaining_iterations = MAX_PENDING_TRANSACTIONS + 1;\n        while (remaining_iterations > 0) {\n            create_transaction(owner_1, multisig_address, PAYLOAD);\n            remaining_iterations = remaining_iterations - 1;\n        }\n    }\n\n    #[test_only]\n    fun create_transaction_with_eviction(\n        owner: &signer,\n        multisig_account: address,\n        payload: vector<u8>,\n    ) acquires MultisigAccount {\n        while(available_transaction_queue_capacity(multisig_account) == 0) {\n            execute_rejected_transaction(owner, multisig_account)\n        };\n        create_transaction(owner, multisig_account, payload);\n    }\n\n    #[test_only]\n    fun vote_all_transactions(\n        owner: &signer, multisig_account: address, approved: bool) acquires MultisigAccount {\n        let starting_sequence_number = last_resolved_sequence_number(multisig_account) + 1;\n        let final_sequence_number = next_sequence_number(multisig_account) - 1;\n        vote_transactions(owner, multisig_account, starting_sequence_number, final_sequence_number, approved);\n    }\n\n    #[test(owner_1 = @0x123, owner_2 = @0x124, owner_3 = @0x125)]\n    fun test_dos_mitigation_end_to_end(\n        owner_1: &signer,\n        owner_2: &signer,\n        owner_3: &signer\n    ) acquires MultisigAccount {\n        setup();\n        let owner_1_addr = address_of(owner_1);\n        let owner_2_addr = address_of(owner_2);\n        let owner_3_addr = address_of(owner_3);\n        create_account(owner_1_addr);\n        let multisig_address = get_next_multisig_account_address(owner_1_addr);\n        create_with_owners(\n            owner_1,\n            vector[owner_2_addr, owner_3_addr],\n            2,\n            vector[],\n            vector[]\n        );\n\n        // owner_3 is compromised and creates a bunch of bogus transactions.\n        let remaining_iterations = MAX_PENDING_TRANSACTIONS;\n        while (remaining_iterations > 0) {\n            create_transaction(owner_3, multisig_address, PAYLOAD);\n            remaining_iterations = remaining_iterations - 1;\n        };\n\n        // No one can create a transaction anymore because the transaction queue is full.\n        assert!(available_transaction_queue_capacity(multisig_address) == 0, 0);\n\n        // owner_1 and owner_2 vote \"no\" on all transactions.\n        vote_all_transactions(owner_1, multisig_address, false);\n        vote_all_transactions(owner_2, multisig_address, false);\n\n        // owner_1 evicts a transaction and creates a transaction to remove the compromised owner.\n        // Note that `PAYLOAD` is a placeholder and is not actually executed in this unit test.\n        create_transaction_with_eviction(owner_1, multisig_address, PAYLOAD);\n\n        // owner_2 approves the eviction transaction.\n        approve_transaction(owner_2, multisig_address, 11);\n\n        // owner_1 flushes the transaction queue except for the eviction transaction.\n        execute_rejected_transactions(owner_1, multisig_address, 10);\n\n        // execute the eviction transaction to remove the compromised owner.\n        assert!(can_be_executed(multisig_address, 11), 0);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_create_transaction_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(non_owner, multisig_account, PAYLOAD);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_create_transaction_with_hash_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction_with_hash(non_owner, multisig_account, sha3_256(PAYLOAD));\n    }\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_reject_transaction_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        reject_transaction(non_owner, multisig_account, 1);\n    }\n\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_approve_transaction_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        approve_transaction(non_owner, multisig_account, 1);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_vote_transaction_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        vote_transaction(non_owner, multisig_account, 1, true);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_vote_transactions_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        vote_transactions(non_owner, multisig_account, 1, 1, true);\n    }\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_execute_rejected_transaction_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        reject_transaction(owner, multisig_account, 1);\n        execute_rejected_transaction(non_owner, multisig_account);\n    }\n\n\n    #[test(owner = @0x123, non_owner = @0x234)]\n    #[expected_failure(abort_code = 329683, location = Self)]\n    public entry fun test_execute_rejected_transactions_should_fail_if_not_owner(\n        owner: &signer,\n        non_owner: &signer\n    ) acquires MultisigAccount {\n        setup();\n        create_account(address_of(owner));\n        let multisig_account = get_next_multisig_account_address(address_of(owner));\n        create(owner, 1, vector[], vector[]);\n        // Transaction is created with id 1.\n        create_transaction(owner, multisig_account, PAYLOAD);\n        reject_transaction(owner, multisig_account, 1);\n        execute_rejected_transactions(non_owner, multisig_account, 1);\n    }\n}\n","name":"multisig_account.move"},{"content":"/// This defines the Move object model with the following properties:\n/// - Simplified storage interface that supports a heterogeneous collection of resources to be\n///   stored together. This enables data types to share a common core data layer (e.g., tokens),\n///   while having richer extensions (e.g., concert ticket, sword).\n/// - Globally accessible data and ownership model that enables creators and developers to dictate\n///   the application and lifetime of data.\n/// - Extensible programming model that supports individualization of user applications that\n///   leverage the core framework including tokens.\n/// - Support emitting events directly, thus improving discoverability of events associated with\n///   objects.\n/// - Considerate of the underlying system by leveraging resource groups for gas efficiency,\n///   avoiding costly deserialization and serialization costs, and supporting deletability.\n///\n/// TODO:\n/// * There is no means to borrow an object or a reference to an object. We are exploring how to\n///   make it so that a reference to a global object can be returned from a function.\nmodule aptos_framework::object {\n    use std::bcs;\n    use std::error;\n    use std::hash;\n    use std::signer;\n    use std::vector;\n\n    use aptos_std::from_bcs;\n\n    use aptos_framework::account;\n    use aptos_framework::transaction_context;\n    use aptos_framework::create_signer::create_signer;\n    use aptos_framework::event;\n    use aptos_framework::guid;\n\n    friend aptos_framework::coin;\n    friend aptos_framework::primary_fungible_store;\n\n    /// An object already exists at this address\n    const EOBJECT_EXISTS: u64 = 1;\n    /// An object does not exist at this address\n    const EOBJECT_DOES_NOT_EXIST: u64 = 2;\n    /// The object does not have ungated transfers enabled\n    const ENO_UNGATED_TRANSFERS: u64 = 3;\n    /// The caller does not have ownership permissions\n    const ENOT_OBJECT_OWNER: u64 = 4;\n    /// The object does not allow for deletion\n    const ECANNOT_DELETE: u64 = 5;\n    /// Exceeds maximum nesting for an object transfer.\n    const EMAXIMUM_NESTING: u64 = 6;\n    /// The resource is not stored at the specified address.\n    const ERESOURCE_DOES_NOT_EXIST: u64 = 7;\n    /// Cannot reclaim objects that weren't burnt.\n    const EOBJECT_NOT_BURNT: u64 = 8;\n    /// Object is untransferable any operations that might result in a transfer are disallowed.\n    const ENOT_MOVABLE: u64 = 9;\n\n    /// Explicitly separate the GUID space between Object and Account to prevent accidental overlap.\n    const INIT_GUID_CREATION_NUM: u64 = 0x4000000000000;\n\n    /// Maximum nesting from one object to another. That is objects can technically have infinte\n    /// nesting, but any checks such as transfer will only be evaluated this deep.\n    const MAXIMUM_OBJECT_NESTING: u8 = 8;\n\n    /// generate_unique_address uses this for domain separation within its native implementation\n    const DERIVE_AUID_ADDRESS_SCHEME: u8 = 0xFB;\n\n    /// Scheme identifier used to generate an object's address `obj_addr` as derived from another object.\n    /// The object's address is generated as:\n    /// ```\n    ///     obj_addr = sha3_256(account addr | derived from object's address | 0xFC)\n    /// ```\n    ///\n    /// This 0xFC constant serves as a domain separation tag to prevent existing authentication key and resource account\n    /// derivation to produce an object address.\n    const OBJECT_DERIVED_SCHEME: u8 = 0xFC;\n\n    /// Scheme identifier used to generate an object's address `obj_addr` via a fresh GUID generated by the creator at\n    /// `source_addr`. The object's address is generated as:\n    /// ```\n    ///     obj_addr = sha3_256(guid | 0xFD)\n    /// ```\n    /// where `guid = account::create_guid(create_signer(source_addr))`\n    ///\n    /// This 0xFD constant serves as a domain separation tag to prevent existing authentication key and resource account\n    /// derivation to produce an object address.\n    const OBJECT_FROM_GUID_ADDRESS_SCHEME: u8 = 0xFD;\n\n    /// Scheme identifier used to generate an object's address `obj_addr` from the creator's `source_addr` and a `seed` as:\n    ///     obj_addr = sha3_256(source_addr | seed | 0xFE).\n    ///\n    /// This 0xFE constant serves as a domain separation tag to prevent existing authentication key and resource account\n    /// derivation to produce an object address.\n    const OBJECT_FROM_SEED_ADDRESS_SCHEME: u8 = 0xFE;\n\n    /// Address where unwanted objects can be forcefully transferred to.\n    const BURN_ADDRESS: address = @0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// The core of the object model that defines ownership, transferability, and events.\n    struct ObjectCore has key {\n        /// Used by guid to guarantee globally unique objects and create event streams\n        guid_creation_num: u64,\n        /// The address (object or account) that owns this object\n        owner: address,\n        /// Object transferring is a common operation, this allows for disabling and enabling\n        /// transfers bypassing the use of a TransferRef.\n        allow_ungated_transfer: bool,\n        /// Emitted events upon transferring of ownership.\n        transfer_events: event::EventHandle<TransferEvent>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// This is added to objects that are burnt (ownership transferred to BURN_ADDRESS).\n    struct TombStone has key {\n        /// Track the previous owner before the object is burnt so they can reclaim later if so desired.\n        original_owner: address,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// The existence of this renders all `TransferRef`s irrelevant. The object cannot be moved.\n    struct Untransferable has key {}\n\n    #[resource_group(scope = global)]\n    /// A shared resource group for storing object resources together in storage.\n    struct ObjectGroup {}\n\n    /// A pointer to an object -- these can only provide guarantees based upon the underlying data\n    /// type, that is the validity of T existing at an address is something that cannot be verified\n    /// by any other module than the module that defined T. Similarly, the module that defines T\n    /// can remove it from storage at any point in time.\n    struct Object<phantom T> has copy, drop, store {\n        inner: address,\n    }\n\n    /// This is a one time ability given to the creator to configure the object as necessary\n    struct ConstructorRef has drop {\n        self: address,\n        /// True if the object can be deleted. Named objects are not deletable.\n        can_delete: bool,\n    }\n\n    /// Used to remove an object from storage.\n    struct DeleteRef has drop, store {\n        self: address,\n    }\n\n    /// Used to create events or move additional resources into object storage.\n    struct ExtendRef has drop, store {\n        self: address,\n    }\n\n    /// Used to create LinearTransferRef, hence ownership transfer.\n    struct TransferRef has drop, store {\n        self: address,\n    }\n\n    /// Used to perform transfers. This locks transferring ability to a single time use bound to\n    /// the current owner.\n    struct LinearTransferRef has drop {\n        self: address,\n        owner: address,\n    }\n\n    /// Used to create derived objects from a given objects.\n    struct DeriveRef has drop, store {\n        self: address,\n    }\n\n    /// Emitted whenever the object's owner field is changed.\n    struct TransferEvent has drop, store {\n        object: address,\n        from: address,\n        to: address,\n    }\n\n    #[event]\n    /// Emitted whenever the object's owner field is changed.\n    struct Transfer has drop, store {\n        object: address,\n        from: address,\n        to: address,\n    }\n\n    #[view]\n    public fun is_untransferable<T: key>(object: Object<T>): bool {\n        exists<Untransferable>(object.inner)\n    }\n\n    #[view]\n    public fun is_burnt<T: key>(object: Object<T>): bool {\n        exists<TombStone>(object.inner)\n    }\n\n    /// Produces an ObjectId from the given address. This is not verified.\n    public fun address_to_object<T: key>(object: address): Object<T> {\n        assert!(exists<ObjectCore>(object), error::not_found(EOBJECT_DOES_NOT_EXIST));\n        assert!(exists_at<T>(object), error::not_found(ERESOURCE_DOES_NOT_EXIST));\n        Object<T> { inner: object }\n    }\n\n    /// Returns true if there exists an object or the remnants of an object.\n    public fun is_object(object: address): bool {\n        exists<ObjectCore>(object)\n    }\n\n    /// Returns true if there exists an object with resource T.\n    public fun object_exists<T: key>(object: address): bool {\n        exists<ObjectCore>(object) && exists_at<T>(object)\n    }\n\n    /// Derives an object address from source material: sha3_256([creator address | seed | 0xFE]).\n    public fun create_object_address(source: &address, seed: vector<u8>): address {\n        let bytes = bcs::to_bytes(source);\n        vector::append(&mut bytes, seed);\n        vector::push_back(&mut bytes, OBJECT_FROM_SEED_ADDRESS_SCHEME);\n        from_bcs::to_address(hash::sha3_256(bytes))\n    }\n\n    native fun create_user_derived_object_address_impl(source: address, derive_from: address): address;\n\n    /// Derives an object address from the source address and an object: sha3_256([source | object addr | 0xFC]).\n    public fun create_user_derived_object_address(source: address, derive_from: address): address {\n        if (std::features::object_native_derived_address_enabled()) {\n            create_user_derived_object_address_impl(source, derive_from)\n        } else {\n            let bytes = bcs::to_bytes(&source);\n            vector::append(&mut bytes, bcs::to_bytes(&derive_from));\n            vector::push_back(&mut bytes, OBJECT_DERIVED_SCHEME);\n            from_bcs::to_address(hash::sha3_256(bytes))\n        }\n    }\n\n    /// Derives an object from an Account GUID.\n    public fun create_guid_object_address(source: address, creation_num: u64): address {\n        let id = guid::create_id(source, creation_num);\n        let bytes = bcs::to_bytes(&id);\n        vector::push_back(&mut bytes, OBJECT_FROM_GUID_ADDRESS_SCHEME);\n        from_bcs::to_address(hash::sha3_256(bytes))\n    }\n\n    native fun exists_at<T: key>(object: address): bool;\n\n    /// Returns the address of within an ObjectId.\n    public fun object_address<T: key>(object: &Object<T>): address {\n        object.inner\n    }\n\n    /// Convert Object<X> to Object<Y>.\n    public fun convert<X: key, Y: key>(object: Object<X>): Object<Y> {\n        address_to_object<Y>(object.inner)\n    }\n\n    /// Create a new named object and return the ConstructorRef. Named objects can be queried globally\n    /// by knowing the user generated seed used to create them. Named objects cannot be deleted.\n    public fun create_named_object(creator: &signer, seed: vector<u8>): ConstructorRef {\n        let creator_address = signer::address_of(creator);\n        let obj_addr = create_object_address(&creator_address, seed);\n        create_object_internal(creator_address, obj_addr, false)\n    }\n\n    /// Create a new object whose address is derived based on the creator account address and another object.\n    /// Derivde objects, similar to named objects, cannot be deleted.\n    public(friend) fun create_user_derived_object(creator_address: address, derive_ref: &DeriveRef): ConstructorRef {\n        let obj_addr = create_user_derived_object_address(creator_address, derive_ref.self);\n        create_object_internal(creator_address, obj_addr, false)\n    }\n\n    /// Create a new object by generating a random unique address based on transaction hash.\n    /// The unique address is computed sha3_256([transaction hash | auid counter | 0xFB]).\n    /// The created object is deletable as we can guarantee the same unique address can\n    /// never be regenerated with future txs.\n    public fun create_object(owner_address: address): ConstructorRef {\n        let unique_address = transaction_context::generate_auid_address();\n        create_object_internal(owner_address, unique_address, true)\n    }\n\n    /// Same as `create_object` except the object to be created will be undeletable.\n    public fun create_sticky_object(owner_address: address): ConstructorRef {\n        let unique_address = transaction_context::generate_auid_address();\n        create_object_internal(owner_address, unique_address, false)\n    }\n\n    /// Create a sticky object at a specific address. Only used by aptos_framework::coin.\n    public(friend) fun create_sticky_object_at_address(\n        owner_address: address,\n        object_address: address,\n    ): ConstructorRef {\n        create_object_internal(owner_address, object_address, false)\n    }\n\n    #[deprecated]\n    /// Use `create_object` instead.\n    /// Create a new object from a GUID generated by an account.\n    /// As the GUID creation internally increments a counter, two transactions that executes\n    /// `create_object_from_account` function for the same creator run sequentially.\n    /// Therefore, using `create_object` method for creating objects is preferrable as it\n    /// doesn't have the same bottlenecks.\n    public fun create_object_from_account(creator: &signer): ConstructorRef {\n        let guid = account::create_guid(creator);\n        create_object_from_guid(signer::address_of(creator), guid)\n    }\n\n    #[deprecated]\n    /// Use `create_object` instead.\n    /// Create a new object from a GUID generated by an object.\n    /// As the GUID creation internally increments a counter, two transactions that executes\n    /// `create_object_from_object` function for the same creator run sequentially.\n    /// Therefore, using `create_object` method for creating objects is preferrable as it\n    /// doesn't have the same bottlenecks.\n    public fun create_object_from_object(creator: &signer): ConstructorRef acquires ObjectCore {\n        let guid = create_guid(creator);\n        create_object_from_guid(signer::address_of(creator), guid)\n    }\n\n    fun create_object_from_guid(creator_address: address, guid: guid::GUID): ConstructorRef {\n        let bytes = bcs::to_bytes(&guid);\n        vector::push_back(&mut bytes, OBJECT_FROM_GUID_ADDRESS_SCHEME);\n        let obj_addr = from_bcs::to_address(hash::sha3_256(bytes));\n        create_object_internal(creator_address, obj_addr, true)\n    }\n\n    fun create_object_internal(\n        creator_address: address,\n        object: address,\n        can_delete: bool,\n    ): ConstructorRef {\n        assert!(!exists<ObjectCore>(object), error::already_exists(EOBJECT_EXISTS));\n\n        let object_signer = create_signer(object);\n        let guid_creation_num = INIT_GUID_CREATION_NUM;\n        let transfer_events_guid = guid::create(object, &mut guid_creation_num);\n\n        move_to(\n            &object_signer,\n            ObjectCore {\n                guid_creation_num,\n                owner: creator_address,\n                allow_ungated_transfer: true,\n                transfer_events: event::new_event_handle(transfer_events_guid),\n            },\n        );\n        ConstructorRef { self: object, can_delete }\n    }\n\n    // Creation helpers\n\n    /// Generates the DeleteRef, which can be used to remove ObjectCore from global storage.\n    public fun generate_delete_ref(ref: &ConstructorRef): DeleteRef {\n        assert!(ref.can_delete, error::permission_denied(ECANNOT_DELETE));\n        DeleteRef { self: ref.self }\n    }\n\n    /// Generates the ExtendRef, which can be used to add new events and resources to the object.\n    public fun generate_extend_ref(ref: &ConstructorRef): ExtendRef {\n        ExtendRef { self: ref.self }\n    }\n\n    /// Generates the TransferRef, which can be used to manage object transfers.\n    public fun generate_transfer_ref(ref: &ConstructorRef): TransferRef {\n        assert!(!exists<Untransferable>(ref.self), error::permission_denied(ENOT_MOVABLE));\n        TransferRef { self: ref.self }\n    }\n\n    /// Generates the DeriveRef, which can be used to create determnistic derived objects from the current object.\n    public fun generate_derive_ref(ref: &ConstructorRef): DeriveRef {\n        DeriveRef { self: ref.self }\n    }\n\n    /// Create a signer for the ConstructorRef\n    public fun generate_signer(ref: &ConstructorRef): signer {\n        create_signer(ref.self)\n    }\n\n    /// Returns the address associated with the constructor\n    public fun address_from_constructor_ref(ref: &ConstructorRef): address {\n        ref.self\n    }\n\n    /// Returns an Object<T> from within a ConstructorRef\n    public fun object_from_constructor_ref<T: key>(ref: &ConstructorRef): Object<T> {\n        address_to_object<T>(ref.self)\n    }\n\n    /// Returns whether or not the ConstructorRef can be used to create DeleteRef\n    public fun can_generate_delete_ref(ref: &ConstructorRef): bool {\n        ref.can_delete\n    }\n\n    // Signer required functions\n\n    /// Create a guid for the object, typically used for events\n    public fun create_guid(object: &signer): guid::GUID acquires ObjectCore {\n        let addr = signer::address_of(object);\n        let object_data = borrow_global_mut<ObjectCore>(addr);\n        guid::create(addr, &mut object_data.guid_creation_num)\n    }\n\n    /// Generate a new event handle.\n    public fun new_event_handle<T: drop + store>(\n        object: &signer,\n    ): event::EventHandle<T> acquires ObjectCore {\n        event::new_event_handle(create_guid(object))\n    }\n\n    // Deletion helpers\n\n    /// Returns the address associated with the constructor\n    public fun address_from_delete_ref(ref: &DeleteRef): address {\n        ref.self\n    }\n\n    /// Returns an Object<T> from within a DeleteRef.\n    public fun object_from_delete_ref<T: key>(ref: &DeleteRef): Object<T> {\n        address_to_object<T>(ref.self)\n    }\n\n    /// Removes from the specified Object from global storage.\n    public fun delete(ref: DeleteRef) acquires Untransferable, ObjectCore {\n        let object_core = move_from<ObjectCore>(ref.self);\n        let ObjectCore {\n            guid_creation_num: _,\n            owner: _,\n            allow_ungated_transfer: _,\n            transfer_events,\n        } = object_core;\n\n        if (exists<Untransferable>(ref.self)) {\n          let Untransferable {} = move_from<Untransferable>(ref.self);\n        };\n\n        event::destroy_handle(transfer_events);\n    }\n\n    // Extension helpers\n\n    /// Create a signer for the ExtendRef\n    public fun generate_signer_for_extending(ref: &ExtendRef): signer {\n        create_signer(ref.self)\n    }\n\n    /// Returns an address from within a ExtendRef.\n    public fun address_from_extend_ref(ref: &ExtendRef): address {\n        ref.self\n    }\n\n    // Transfer functionality\n\n    /// Disable direct transfer, transfers can only be triggered via a TransferRef\n    public fun disable_ungated_transfer(ref: &TransferRef) acquires ObjectCore {\n        let object = borrow_global_mut<ObjectCore>(ref.self);\n        object.allow_ungated_transfer = false;\n    }\n\n    /// Prevent moving of the object\n    public fun set_untransferable(ref: &ConstructorRef) acquires ObjectCore {\n        let object = borrow_global_mut<ObjectCore>(ref.self);\n        object.allow_ungated_transfer = false;\n        let object_signer = generate_signer(ref);\n        move_to(&object_signer, Untransferable {});\n    }\n\n    /// Enable direct transfer.\n    public fun enable_ungated_transfer(ref: &TransferRef) acquires ObjectCore {\n        assert!(!exists<Untransferable>(ref.self), error::permission_denied(ENOT_MOVABLE));\n        let object = borrow_global_mut<ObjectCore>(ref.self);\n        object.allow_ungated_transfer = true;\n    }\n\n    /// Create a LinearTransferRef for a one-time transfer. This requires that the owner at the\n    /// time of generation is the owner at the time of transferring.\n    public fun generate_linear_transfer_ref(ref: &TransferRef): LinearTransferRef acquires ObjectCore {\n        assert!(!exists<Untransferable>(ref.self), error::permission_denied(ENOT_MOVABLE));\n        let owner = owner(Object<ObjectCore> { inner: ref.self });\n        LinearTransferRef {\n            self: ref.self,\n            owner,\n        }\n    }\n\n    /// Transfer to the destination address using a LinearTransferRef.\n    public fun transfer_with_ref(ref: LinearTransferRef, to: address) acquires ObjectCore {\n        assert!(!exists<Untransferable>(ref.self), error::permission_denied(ENOT_MOVABLE));\n        let object = borrow_global_mut<ObjectCore>(ref.self);\n        assert!(\n            object.owner == ref.owner,\n            error::permission_denied(ENOT_OBJECT_OWNER),\n        );\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                Transfer {\n                    object: ref.self,\n                    from: object.owner,\n                    to,\n                },\n            );\n        };\n        event::emit_event(\n            &mut object.transfer_events,\n            TransferEvent {\n                object: ref.self,\n                from: object.owner,\n                to,\n            },\n        );\n        object.owner = to;\n    }\n\n    /// Entry function that can be used to transfer, if allow_ungated_transfer is set true.\n    public entry fun transfer_call(\n        owner: &signer,\n        object: address,\n        to: address,\n    ) acquires ObjectCore {\n        transfer_raw(owner, object, to)\n    }\n\n    /// Transfers ownership of the object (and all associated resources) at the specified address\n    /// for Object<T> to the \"to\" address.\n    public entry fun transfer<T: key>(\n        owner: &signer,\n        object: Object<T>,\n        to: address,\n    ) acquires ObjectCore {\n        transfer_raw(owner, object.inner, to)\n    }\n\n    /// Attempts to transfer using addresses only. Transfers the given object if\n    /// allow_ungated_transfer is set true. Note, that this allows the owner of a nested object to\n    /// transfer that object, so long as allow_ungated_transfer is enabled at each stage in the\n    /// hierarchy.\n    public fun transfer_raw(\n        owner: &signer,\n        object: address,\n        to: address,\n    ) acquires ObjectCore {\n        let owner_address = signer::address_of(owner);\n        verify_ungated_and_descendant(owner_address, object);\n        transfer_raw_inner(object, to);\n    }\n\n    inline fun transfer_raw_inner(object: address, to: address) acquires ObjectCore {\n        let object_core = borrow_global_mut<ObjectCore>(object);\n        if (object_core.owner != to) {\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(\n                    Transfer {\n                        object,\n                        from: object_core.owner,\n                        to,\n                    },\n                );\n            };\n            event::emit_event(\n                &mut object_core.transfer_events,\n                TransferEvent {\n                    object,\n                    from: object_core.owner,\n                    to,\n                },\n            );\n            object_core.owner = to;\n        };\n    }\n\n    /// Transfer the given object to another object. See `transfer` for more information.\n    public entry fun transfer_to_object<O: key, T: key>(\n        owner: &signer,\n        object: Object<O>,\n        to: Object<T>,\n    ) acquires ObjectCore {\n        transfer(owner, object, to.inner)\n    }\n\n    /// This checks that the destination address is eventually owned by the owner and that each\n    /// object between the two allows for ungated transfers. Note, this is limited to a depth of 8\n    /// objects may have cyclic dependencies.\n    fun verify_ungated_and_descendant(owner: address, destination: address) acquires ObjectCore {\n        let current_address = destination;\n        assert!(\n            exists<ObjectCore>(current_address),\n            error::not_found(EOBJECT_DOES_NOT_EXIST),\n        );\n\n        let object = borrow_global<ObjectCore>(current_address);\n        assert!(\n            object.allow_ungated_transfer,\n            error::permission_denied(ENO_UNGATED_TRANSFERS),\n        );\n\n        let current_address = object.owner;\n        let count = 0;\n        while (owner != current_address) {\n            count = count + 1;\n            if (std::features::max_object_nesting_check_enabled()) {\n                assert!(count < MAXIMUM_OBJECT_NESTING, error::out_of_range(EMAXIMUM_NESTING))\n            };\n            // At this point, the first object exists and so the more likely case is that the\n            // object's owner is not an object. So we return a more sensible error.\n            assert!(\n                exists<ObjectCore>(current_address),\n                error::permission_denied(ENOT_OBJECT_OWNER),\n            );\n            let object = borrow_global<ObjectCore>(current_address);\n            assert!(\n                object.allow_ungated_transfer,\n                error::permission_denied(ENO_UNGATED_TRANSFERS),\n            );\n            current_address = object.owner;\n        };\n    }\n\n    /// Forcefully transfer an unwanted object to BURN_ADDRESS, ignoring whether ungated_transfer is allowed.\n    /// This only works for objects directly owned and for simplicity does not apply to indirectly owned objects.\n    /// Original owners can reclaim burnt objects any time in the future by calling unburn.\n    public entry fun burn<T: key>(owner: &signer, object: Object<T>) acquires ObjectCore {\n        let original_owner = signer::address_of(owner);\n        assert!(is_owner(object, original_owner), error::permission_denied(ENOT_OBJECT_OWNER));\n        let object_addr = object.inner;\n        move_to(&create_signer(object_addr), TombStone { original_owner });\n        transfer_raw_inner(object_addr, BURN_ADDRESS);\n    }\n\n    /// Allow origin owners to reclaim any objects they previous burnt.\n    public entry fun unburn<T: key>(\n        original_owner: &signer,\n        object: Object<T>,\n    ) acquires TombStone, ObjectCore {\n        let object_addr = object.inner;\n        assert!(exists<TombStone>(object_addr), error::invalid_argument(EOBJECT_NOT_BURNT));\n\n        let TombStone { original_owner: original_owner_addr } = move_from<TombStone>(object_addr);\n        assert!(original_owner_addr == signer::address_of(original_owner), error::permission_denied(ENOT_OBJECT_OWNER));\n        transfer_raw_inner(object_addr, original_owner_addr);\n    }\n\n    /// Accessors\n    /// Return true if ungated transfer is allowed.\n    public fun ungated_transfer_allowed<T: key>(object: Object<T>): bool acquires ObjectCore {\n        assert!(\n            exists<ObjectCore>(object.inner),\n            error::not_found(EOBJECT_DOES_NOT_EXIST),\n        );\n        borrow_global<ObjectCore>(object.inner).allow_ungated_transfer\n    }\n\n    /// Return the current owner.\n    public fun owner<T: key>(object: Object<T>): address acquires ObjectCore {\n        assert!(\n            exists<ObjectCore>(object.inner),\n            error::not_found(EOBJECT_DOES_NOT_EXIST),\n        );\n        borrow_global<ObjectCore>(object.inner).owner\n    }\n\n    /// Return true if the provided address is the current owner.\n    public fun is_owner<T: key>(object: Object<T>, owner: address): bool acquires ObjectCore {\n        owner(object) == owner\n    }\n\n    /// Return true if the provided address has indirect or direct ownership of the provided object.\n    public fun owns<T: key>(object: Object<T>, owner: address): bool acquires ObjectCore {\n        let current_address = object_address(&object);\n        if (current_address == owner) {\n            return true\n        };\n\n        assert!(\n            exists<ObjectCore>(current_address),\n            error::not_found(EOBJECT_DOES_NOT_EXIST),\n        );\n\n        let object = borrow_global<ObjectCore>(current_address);\n        let current_address = object.owner;\n\n        let count = 0;\n        while (owner != current_address) {\n            count = count + 1;\n            if (std::features::max_object_nesting_check_enabled()) {\n                assert!(count < MAXIMUM_OBJECT_NESTING, error::out_of_range(EMAXIMUM_NESTING))\n            };\n            if (!exists<ObjectCore>(current_address)) {\n                return false\n            };\n\n            let object = borrow_global<ObjectCore>(current_address);\n            current_address = object.owner;\n        };\n        true\n    }\n\n    /// Returns the root owner of an object. As objects support nested ownership, it can be useful\n    /// to determine the identity of the starting point of ownership.\n    public fun root_owner<T: key>(object: Object<T>): address acquires ObjectCore {\n        let obj_owner = owner(object);\n        while (is_object(obj_owner)) {\n            obj_owner = owner(address_to_object<ObjectCore>(obj_owner));\n        };\n        obj_owner\n    }\n\n    #[test_only]\n    use std::option::{Self, Option};\n\n    #[test_only]\n    const EHERO_DOES_NOT_EXIST: u64 = 0x100;\n    #[test_only]\n    const EWEAPON_DOES_NOT_EXIST: u64 = 0x101;\n\n    #[test_only]\n    struct HeroEquipEvent has drop, store {\n        weapon_id: Option<Object<Weapon>>,\n    }\n\n    #[test_only]\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct Hero has key {\n        equip_events: event::EventHandle<HeroEquipEvent>,\n        weapon: Option<Object<Weapon>>,\n    }\n\n    #[test_only]\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    struct Weapon has key {}\n\n    #[test_only]\n    public fun create_hero(creator: &signer): (ConstructorRef, Object<Hero>) acquires ObjectCore {\n        let hero_constructor_ref = create_named_object(creator, b\"hero\");\n        let hero_signer = generate_signer(&hero_constructor_ref);\n        let guid_for_equip_events = create_guid(&hero_signer);\n        move_to(\n            &hero_signer,\n            Hero {\n                weapon: option::none(),\n                equip_events: event::new_event_handle(guid_for_equip_events),\n            },\n        );\n\n        let hero = object_from_constructor_ref<Hero>(&hero_constructor_ref);\n        (hero_constructor_ref, hero)\n    }\n\n    #[test_only]\n    public fun create_weapon(creator: &signer): (ConstructorRef, Object<Weapon>) {\n        let weapon_constructor_ref = create_named_object(creator, b\"weapon\");\n        let weapon_signer = generate_signer(&weapon_constructor_ref);\n        move_to(&weapon_signer, Weapon {});\n        let weapon = object_from_constructor_ref<Weapon>(&weapon_constructor_ref);\n        (weapon_constructor_ref, weapon)\n    }\n\n    #[test_only]\n    public fun hero_equip(\n        owner: &signer,\n        hero: Object<Hero>,\n        weapon: Object<Weapon>,\n    ) acquires Hero, ObjectCore {\n        transfer_to_object(owner, weapon, hero);\n        let hero_obj = borrow_global_mut<Hero>(object_address(&hero));\n        option::fill(&mut hero_obj.weapon, weapon);\n        event::emit_event(\n            &mut hero_obj.equip_events,\n            HeroEquipEvent { weapon_id: option::some(weapon) },\n        );\n    }\n\n    #[test_only]\n    public fun hero_unequip(\n        owner: &signer,\n        hero: Object<Hero>,\n        weapon: Object<Weapon>,\n    ) acquires Hero, ObjectCore {\n        transfer(owner, weapon, signer::address_of(owner));\n        let hero = borrow_global_mut<Hero>(object_address(&hero));\n        option::extract(&mut hero.weapon);\n        event::emit_event(\n            &mut hero.equip_events,\n            HeroEquipEvent { weapon_id: option::none() },\n        );\n    }\n\n    #[test(creator = @0x123)]\n    fun test_object(creator: &signer) acquires Hero, ObjectCore {\n        let (_, hero) = create_hero(creator);\n        let (_, weapon) = create_weapon(creator);\n\n        assert!(owns(weapon, @0x123), 0);\n        hero_equip(creator, hero, weapon);\n        assert!(owns(weapon, @0x123), 1);\n        hero_unequip(creator, hero, weapon);\n        assert!(root_owner(hero) == @0x123, 2);\n        assert!(root_owner(weapon) == @0x123, 3);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_linear_transfer(creator: &signer) acquires ObjectCore {\n        let (hero_constructor, hero) = create_hero(creator);\n        assert!(root_owner(hero) == @0x123, 0);\n\n        let transfer_ref = generate_transfer_ref(&hero_constructor);\n        let linear_transfer_ref = generate_linear_transfer_ref(&transfer_ref);\n        transfer_with_ref(linear_transfer_ref, @0x456);\n        assert!(owner(hero) == @0x456, 1);\n        assert!(owns(hero, @0x456), 2);\n        assert!(root_owner(hero) == @0x456, 3);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_bad_linear_transfer(creator: &signer) acquires ObjectCore {\n        let (hero_constructor, hero) = create_hero(creator);\n        let transfer_ref = generate_transfer_ref(&hero_constructor);\n        let linear_transfer_ref_good = generate_linear_transfer_ref(&transfer_ref);\n        // This will contain the address of the creator\n        let linear_transfer_ref_bad = generate_linear_transfer_ref(&transfer_ref);\n        transfer_with_ref(linear_transfer_ref_good, @0x456);\n        assert!(owner(hero) == @0x456, 0);\n        transfer_with_ref(linear_transfer_ref_bad, @0x789);\n    }\n\n    #[test(fx = @std)]\n    fun test_correct_auid(fx: signer) {\n        use std::features;\n        let feature = features::get_auids();\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n\n        let auid1 = aptos_framework::transaction_context::generate_auid_address();\n        let bytes = aptos_framework::transaction_context::get_transaction_hash();\n        std::vector::push_back(&mut bytes, 1);\n        std::vector::push_back(&mut bytes, 0);\n        std::vector::push_back(&mut bytes, 0);\n        std::vector::push_back(&mut bytes, 0);\n        std::vector::push_back(&mut bytes, 0);\n        std::vector::push_back(&mut bytes, 0);\n        std::vector::push_back(&mut bytes, 0);\n        std::vector::push_back(&mut bytes, 0);\n        std::vector::push_back(&mut bytes, DERIVE_AUID_ADDRESS_SCHEME);\n        let auid2 = aptos_framework::from_bcs::to_address(std::hash::sha3_256(bytes));\n        assert!(auid1 == auid2, 0);\n    }\n\n    #[test(fx = @std)]\n    fun test_correct_derived_object_address(fx: signer) {\n        use std::features;\n        use aptos_framework::object;\n        let feature = features::get_object_native_derived_address_feature();\n\n        let source = @0x12345;\n        let derive_from = @0x7890;\n\n        features::change_feature_flags_for_testing(&fx, vector[], vector[feature]);\n        let in_move = object::create_user_derived_object_address(source, derive_from);\n\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n        let in_native = object::create_user_derived_object_address(source, derive_from);\n\n        assert!(in_move == in_native, 0);\n\n        let bytes = bcs::to_bytes(&source);\n        vector::append(&mut bytes, bcs::to_bytes(&derive_from));\n        vector::push_back(&mut bytes, OBJECT_DERIVED_SCHEME);\n        let directly = from_bcs::to_address(hash::sha3_256(bytes));\n\n        assert!(directly == in_native, 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_burn_and_unburn(creator: &signer) acquires ObjectCore, TombStone {\n        let (hero_constructor, hero) = create_hero(creator);\n        // Freeze the object.\n        let transfer_ref = generate_transfer_ref(&hero_constructor);\n        disable_ungated_transfer(&transfer_ref);\n\n        // Owner should be able to burn, despite ungated transfer disallowed.\n        burn(creator, hero);\n        assert!(owner(hero) == BURN_ADDRESS, 0);\n        assert!(!ungated_transfer_allowed(hero), 0);\n\n        // Owner should be able to reclaim.\n        unburn(creator, hero);\n        assert!(owner(hero) == signer::address_of(creator), 0);\n        // Object still frozen.\n        assert!(!ungated_transfer_allowed(hero), 0);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_burn_indirectly_owned_should_fail(creator: &signer) acquires ObjectCore {\n        let (_, hero) = create_hero(creator);\n        let (_, weapon) = create_weapon(creator);\n        transfer_to_object(creator, weapon, hero);\n\n        // Owner should be not be able to burn weapon directly.\n        assert!(owner(weapon) == object_address(&hero), 0);\n        assert!(owns(weapon, signer::address_of(creator)), 0);\n        burn(creator, weapon);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10008, location = Self)]\n    fun test_unburn_object_not_burnt_should_fail(creator: &signer) acquires ObjectCore, TombStone {\n        let (_, hero) = create_hero(creator);\n        unburn(creator, hero);\n    }\n\n    #[test_only]\n    fun create_simple_object(creator: &signer, seed: vector<u8>): Object<ObjectCore> {\n        object_from_constructor_ref<ObjectCore>(&create_named_object(creator, seed))\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 131078, location = Self)]\n    fun test_exceeding_maximum_object_nesting_owns_should_fail(creator: &signer) acquires ObjectCore {\n        use std::features;\n        let feature = features::get_max_object_nesting_check_feature();\n        let fx = account::create_signer_for_test(@0x1);\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n\n        let obj1 = create_simple_object(creator, b\"1\");\n        let obj2 = create_simple_object(creator, b\"2\");\n        let obj3 = create_simple_object(creator, b\"3\");\n        let obj4 = create_simple_object(creator, b\"4\");\n        let obj5 = create_simple_object(creator, b\"5\");\n        let obj6 = create_simple_object(creator, b\"6\");\n        let obj7 = create_simple_object(creator, b\"7\");\n        let obj8 = create_simple_object(creator, b\"8\");\n        let obj9 = create_simple_object(creator, b\"9\");\n\n        transfer(creator, obj1, object_address(&obj2));\n        transfer(creator, obj2, object_address(&obj3));\n        transfer(creator, obj3, object_address(&obj4));\n        transfer(creator, obj4, object_address(&obj5));\n        transfer(creator, obj5, object_address(&obj6));\n        transfer(creator, obj6, object_address(&obj7));\n        transfer(creator, obj7, object_address(&obj8));\n        transfer(creator, obj8, object_address(&obj9));\n\n        assert!(owns(obj9, signer::address_of(creator)), 1);\n        assert!(owns(obj8, signer::address_of(creator)), 1);\n        assert!(owns(obj7, signer::address_of(creator)), 1);\n        assert!(owns(obj6, signer::address_of(creator)), 1);\n        assert!(owns(obj5, signer::address_of(creator)), 1);\n        assert!(owns(obj4, signer::address_of(creator)), 1);\n        assert!(owns(obj3, signer::address_of(creator)), 1);\n        assert!(owns(obj2, signer::address_of(creator)), 1);\n\n        // Calling `owns` should fail as the nesting is too deep.\n        assert!(owns(obj1, signer::address_of(creator)), 1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 131078, location = Self)]\n    fun test_exceeding_maximum_object_nesting_transfer_should_fail(creator: &signer) acquires ObjectCore {\n        use std::features;\n        let feature = features::get_max_object_nesting_check_feature();\n        let fx = account::create_signer_for_test(@0x1);\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n\n        let obj1 = create_simple_object(creator, b\"1\");\n        let obj2 = create_simple_object(creator, b\"2\");\n        let obj3 = create_simple_object(creator, b\"3\");\n        let obj4 = create_simple_object(creator, b\"4\");\n        let obj5 = create_simple_object(creator, b\"5\");\n        let obj6 = create_simple_object(creator, b\"6\");\n        let obj7 = create_simple_object(creator, b\"7\");\n        let obj8 = create_simple_object(creator, b\"8\");\n        let obj9 = create_simple_object(creator, b\"9\");\n\n        transfer(creator, obj1, object_address(&obj2));\n        transfer(creator, obj2, object_address(&obj3));\n        transfer(creator, obj3, object_address(&obj4));\n        transfer(creator, obj4, object_address(&obj5));\n        transfer(creator, obj5, object_address(&obj6));\n        transfer(creator, obj6, object_address(&obj7));\n        transfer(creator, obj7, object_address(&obj8));\n        transfer(creator, obj8, object_address(&obj9));\n\n        // This should fail as the nesting is too deep.\n        transfer(creator, obj1, @0x1);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 131078, location = Self)]\n    fun test_cyclic_ownership_transfer_should_fail(creator: &signer) acquires ObjectCore {\n        use std::features;\n        let feature = features::get_max_object_nesting_check_feature();\n        let fx = account::create_signer_for_test(@0x1);\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n\n        let obj1 = create_simple_object(creator, b\"1\");\n        // This creates a cycle (self-loop) in ownership.\n        transfer(creator, obj1, object_address(&obj1));\n        // This should fails as the ownership is cyclic.\n        transfer(creator, obj1, object_address(&obj1));\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 131078, location = Self)]\n    fun test_cyclic_ownership_owns_should_fail(creator: &signer) acquires ObjectCore {\n        use std::features;\n        let feature = features::get_max_object_nesting_check_feature();\n        let fx = account::create_signer_for_test(@0x1);\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n\n        let obj1 = create_simple_object(creator, b\"1\");\n        // This creates a cycle (self-loop) in ownership.\n        transfer(creator, obj1, object_address(&obj1));\n        // This should fails as the ownership is cyclic.\n        let _ = owns(obj1, signer::address_of(creator));\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327683, location = Self)]\n    fun test_untransferable_direct_ownership_transfer(creator: &signer) acquires ObjectCore {\n        let (hero_constructor_ref, hero) = create_hero(creator);\n        set_untransferable(&hero_constructor_ref);\n        transfer(creator, hero, @0x456);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327689, location = Self)]\n    fun test_untransferable_direct_ownership_gen_transfer_ref(creator: &signer) acquires ObjectCore {\n        let (hero_constructor_ref, _) = create_hero(creator);\n        set_untransferable(&hero_constructor_ref);\n        generate_transfer_ref(&hero_constructor_ref);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327689, location = Self)]\n    fun test_untransferable_direct_ownership_gen_linear_transfer_ref(creator: &signer) acquires ObjectCore {\n        let (hero_constructor_ref, _) = create_hero(creator);\n        let transfer_ref = generate_transfer_ref(&hero_constructor_ref);\n        set_untransferable(&hero_constructor_ref);\n        generate_linear_transfer_ref(&transfer_ref);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327689, location = Self)]\n    fun test_untransferable_direct_ownership_with_linear_transfer_ref(creator: &signer) acquires ObjectCore {\n        let (hero_constructor_ref, _) = create_hero(creator);\n        let transfer_ref = generate_transfer_ref(&hero_constructor_ref);\n        let linear_transfer_ref = generate_linear_transfer_ref(&transfer_ref);\n        set_untransferable(&hero_constructor_ref);\n        transfer_with_ref(linear_transfer_ref, @0x456);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327683, location = Self)]\n    fun test_untransferable_indirect_ownership_transfer(creator: &signer) acquires ObjectCore {\n        let (_, hero) = create_hero(creator);\n        let (weapon_constructor_ref, weapon) = create_weapon(creator);\n        transfer_to_object(creator, weapon, hero);\n        set_untransferable(&weapon_constructor_ref);\n        transfer(creator, weapon, @0x456);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327689, location = Self)]\n    fun test_untransferable_indirect_ownership_gen_transfer_ref(creator: &signer) acquires ObjectCore {\n        let (_, hero) = create_hero(creator);\n        let (weapon_constructor_ref, weapon) = create_weapon(creator);\n        transfer_to_object(creator, weapon, hero);\n        set_untransferable(&weapon_constructor_ref);\n        generate_transfer_ref(&weapon_constructor_ref);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327689, location = Self)]\n    fun test_untransferable_indirect_ownership_gen_linear_transfer_ref(creator: &signer) acquires ObjectCore {\n        let (_, hero) = create_hero(creator);\n        let (weapon_constructor_ref, weapon) = create_weapon(creator);\n        transfer_to_object(creator, weapon, hero);\n        let transfer_ref = generate_transfer_ref(&weapon_constructor_ref);\n        set_untransferable(&weapon_constructor_ref);\n        generate_linear_transfer_ref(&transfer_ref);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 327689, location = Self)]\n    fun test_untransferable_indirect_ownership_with_linear_transfer_ref(creator: &signer) acquires ObjectCore {\n        let (_, hero) = create_hero(creator);\n        let (weapon_constructor_ref, weapon) = create_weapon(creator);\n        transfer_to_object(creator, weapon, hero);\n        let transfer_ref = generate_transfer_ref(&weapon_constructor_ref);\n        let linear_transfer_ref = generate_linear_transfer_ref(&transfer_ref);\n        set_untransferable(&weapon_constructor_ref);\n        transfer_with_ref(linear_transfer_ref, @0x456);\n    }\n}\n","name":"object.move"},{"content":"/// This module allows users to deploy, upgrade and freeze modules deployed to objects on-chain.\n/// This enables users to deploy modules to an object with a unique address each time they are published.\n/// This modules provides an alternative method to publish code on-chain, where code is deployed to objects rather than accounts.\n/// This is encouraged as it abstracts the necessary resources needed for deploying modules,\n/// along with the required authorization to upgrade and freeze modules.\n///\n/// The functionalities of this module are as follows.\n///\n/// Publishing modules flow:\n/// 1. Create a new object with the address derived from the publisher address and the object seed.\n/// 2. Publish the module passed in the function via `metadata_serialized` and `code` to the newly created object.\n/// 3. Emits 'Publish' event with the address of the newly created object.\n/// 4. Create a `ManagingRefs` which stores the extend ref of the newly created object.\n/// Note: This is needed to upgrade the code as the signer must be generated to upgrade the existing code in an object.\n///\n/// Upgrading modules flow:\n/// 1. Assert the `code_object` passed in the function is owned by the `publisher`.\n/// 2. Assert the `code_object` passed in the function exists in global storage.\n/// 2. Retrieve the `ExtendRef` from the `code_object` and generate the signer from this.\n/// 3. Upgrade the module with the `metadata_serialized` and `code` passed in the function.\n/// 4. Emits 'Upgrade' event with the address of the object with the upgraded code.\n/// Note: If the modules were deployed as immutable when calling `publish`, the upgrade will fail.\n///\n/// Freezing modules flow:\n/// 1. Assert the `code_object` passed in the function exists in global storage.\n/// 2. Assert the `code_object` passed in the function is owned by the `publisher`.\n/// 3. Mark all the modules in the `code_object` as immutable.\n/// 4. Emits 'Freeze' event with the address of the object with the frozen code.\n/// Note: There is no unfreeze function as this gives no benefit if the user can freeze/unfreeze modules at will.\n///       Once modules are marked as immutable, they cannot be made mutable again.\nmodule aptos_framework::object_code_deployment {\n    use std::bcs;\n    use std::error;\n    use std::features;\n    use std::signer;\n    use std::vector;\n    use aptos_framework::account;\n    use aptos_framework::code;\n    use aptos_framework::code::PackageRegistry;\n    use aptos_framework::event;\n    use aptos_framework::object;\n    use aptos_framework::object::{ExtendRef, Object};\n\n    /// Object code deployment feature not supported.\n    const EOBJECT_CODE_DEPLOYMENT_NOT_SUPPORTED: u64 = 1;\n    /// Not the owner of the `code_object`\n    const ENOT_CODE_OBJECT_OWNER: u64 = 2;\n    /// `code_object` does not exist.\n    const ECODE_OBJECT_DOES_NOT_EXIST: u64 = 3;\n\n    const OBJECT_CODE_DEPLOYMENT_DOMAIN_SEPARATOR: vector<u8> = b\"aptos_framework::object_code_deployment\";\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Internal struct, attached to the object, that holds Refs we need to manage the code deployment (i.e. upgrades).\n    struct ManagingRefs has key {\n        /// We need to keep the extend ref to be able to generate the signer to upgrade existing code.\n        extend_ref: ExtendRef,\n    }\n\n    #[event]\n    /// Event emitted when code is published to an object.\n    struct Publish has drop, store {\n        object_address: address,\n    }\n\n    #[event]\n    /// Event emitted when code in an existing object is upgraded.\n    struct Upgrade has drop, store {\n        object_address: address,\n    }\n\n    #[event]\n    /// Event emitted when code in an existing object is made immutable.\n    struct Freeze has drop, store {\n        object_address: address,\n    }\n\n    /// Creates a new object with a unique address derived from the publisher address and the object seed.\n    /// Publishes the code passed in the function to the newly created object.\n    /// The caller must provide package metadata describing the package via `metadata_serialized` and\n    /// the code to be published via `code`. This contains a vector of modules to be deployed on-chain.\n    public entry fun publish(\n        publisher: &signer,\n        metadata_serialized: vector<u8>,\n        code: vector<vector<u8>>,\n    ) {\n        assert!(\n            features::is_object_code_deployment_enabled(),\n            error::unavailable(EOBJECT_CODE_DEPLOYMENT_NOT_SUPPORTED),\n        );\n\n        let publisher_address = signer::address_of(publisher);\n        let object_seed = object_seed(publisher_address);\n        let constructor_ref = &object::create_named_object(publisher, object_seed);\n        let code_signer = &object::generate_signer(constructor_ref);\n        code::publish_package_txn(code_signer, metadata_serialized, code);\n\n        event::emit(Publish { object_address: signer::address_of(code_signer), });\n\n        move_to(code_signer, ManagingRefs {\n            extend_ref: object::generate_extend_ref(constructor_ref),\n        });\n    }\n\n    inline fun object_seed(publisher: address): vector<u8> {\n        let sequence_number = account::get_sequence_number(publisher) + 1;\n        let seeds = vector[];\n        vector::append(&mut seeds, bcs::to_bytes(&OBJECT_CODE_DEPLOYMENT_DOMAIN_SEPARATOR));\n        vector::append(&mut seeds, bcs::to_bytes(&sequence_number));\n        seeds\n    }\n\n    /// Upgrades the existing modules at the `code_object` address with the new modules passed in `code`,\n    /// along with the metadata `metadata_serialized`.\n    /// Note: If the modules were deployed as immutable when calling `publish`, the upgrade will fail.\n    /// Requires the publisher to be the owner of the `code_object`.\n    public entry fun upgrade(\n        publisher: &signer,\n        metadata_serialized: vector<u8>,\n        code: vector<vector<u8>>,\n        code_object: Object<PackageRegistry>,\n    ) acquires ManagingRefs {\n        let publisher_address = signer::address_of(publisher);\n        assert!(\n            object::is_owner(code_object, publisher_address),\n            error::permission_denied(ENOT_CODE_OBJECT_OWNER),\n        );\n\n        let code_object_address = object::object_address(&code_object);\n        assert!(exists<ManagingRefs>(code_object_address), error::not_found(ECODE_OBJECT_DOES_NOT_EXIST));\n\n        let extend_ref = &borrow_global<ManagingRefs>(code_object_address).extend_ref;\n        let code_signer = &object::generate_signer_for_extending(extend_ref);\n        code::publish_package_txn(code_signer, metadata_serialized, code);\n\n        event::emit(Upgrade { object_address: signer::address_of(code_signer), });\n    }\n\n    /// Make an existing upgradable package immutable. Once this is called, the package cannot be made upgradable again.\n    /// Each `code_object` should only have one package, as one package is deployed per object in this module.\n    /// Requires the `publisher` to be the owner of the `code_object`.\n    public entry fun freeze_code_object(publisher: &signer, code_object: Object<PackageRegistry>) {\n        code::freeze_code_object(publisher, code_object);\n\n        event::emit(Freeze { object_address: object::object_address(&code_object), });\n    }\n}\n","name":"object_code_deployment.move"},{"content":"/// This module provides a way for creators of fungible assets to enable support for creating primary (deterministic)\n/// stores for their users. This is useful for assets that are meant to be used as a currency, as it allows users to\n/// easily create a store for their account and deposit/withdraw/transfer fungible assets to/from it.\n///\n/// The transfer flow works as below:\n/// 1. The sender calls `transfer` on the fungible asset metadata object to transfer `amount` of fungible asset to\n///   `recipient`.\n/// 2. The fungible asset metadata object calls `ensure_primary_store_exists` to ensure that both the sender's and the\n/// recipient's primary stores exist. If either doesn't, it will be created.\n/// 3. The fungible asset metadata object calls `withdraw` on the sender's primary store to withdraw `amount` of\n/// fungible asset from it. This emits a withdraw event.\n/// 4. The fungible asset metadata object calls `deposit` on the recipient's primary store to deposit `amount` of\n/// fungible asset to it. This emits an deposit event.\nmodule aptos_framework::primary_fungible_store {\n    use aptos_framework::dispatchable_fungible_asset;\n    use aptos_framework::fungible_asset::{Self, FungibleAsset, FungibleStore, Metadata, MintRef, TransferRef, BurnRef};\n    use aptos_framework::object::{Self, Object, ConstructorRef, DeriveRef};\n\n    use std::features;\n    use std::option::Option;\n    use std::signer;\n    use std::string::String;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// A resource that holds the derive ref for the fungible asset metadata object. This is used to create primary\n    /// stores for users with deterministic addresses so that users can easily deposit/withdraw/transfer fungible\n    /// assets.\n    struct DeriveRefPod has key {\n        metadata_derive_ref: DeriveRef,\n    }\n\n    /// Create a fungible asset with primary store support. When users transfer fungible assets to each other, their\n    /// primary stores will be created automatically if they don't exist. Primary stores have deterministic addresses\n    /// so that users can easily deposit/withdraw/transfer fungible assets.\n    public fun create_primary_store_enabled_fungible_asset(\n        constructor_ref: &ConstructorRef,\n        maximum_supply: Option<u128>,\n        name: String,\n        symbol: String,\n        decimals: u8,\n        icon_uri: String,\n        project_uri: String,\n    ) {\n        fungible_asset::add_fungibility(\n            constructor_ref,\n            maximum_supply,\n            name,\n            symbol,\n            decimals,\n            icon_uri,\n            project_uri,\n        );\n        let metadata_obj = &object::generate_signer(constructor_ref);\n        move_to(metadata_obj, DeriveRefPod {\n            metadata_derive_ref: object::generate_derive_ref(constructor_ref),\n        });\n    }\n\n    /// Ensure that the primary store object for the given address exists. If it doesn't, create it.\n    public fun ensure_primary_store_exists<T: key>(\n        owner: address,\n        metadata: Object<T>,\n    ): Object<FungibleStore> acquires DeriveRefPod {\n        if (!primary_store_exists(owner, metadata)) {\n            create_primary_store(owner, metadata)\n        } else {\n            primary_store(owner, metadata)\n        }\n    }\n\n    /// Create a primary store object to hold fungible asset for the given address.\n    public fun create_primary_store<T: key>(\n        owner_addr: address,\n        metadata: Object<T>,\n    ): Object<FungibleStore> acquires DeriveRefPod {\n        let metadata_addr = object::object_address(&metadata);\n        object::address_to_object<Metadata>(metadata_addr);\n        let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;\n        let constructor_ref = if (metadata_addr == @aptos_fungible_asset && features::primary_apt_fungible_store_at_user_address_enabled(\n        )) {\n            &object::create_sticky_object_at_address(owner_addr, owner_addr)\n        } else {\n            &object::create_user_derived_object(owner_addr, derive_ref)\n        };\n        // Disable ungated transfer as deterministic stores shouldn't be transferrable.\n        let transfer_ref = &object::generate_transfer_ref(constructor_ref);\n        object::disable_ungated_transfer(transfer_ref);\n\n        fungible_asset::create_store(constructor_ref, metadata)\n    }\n\n    #[view]\n    /// Get the address of the primary store for the given account.\n    public fun primary_store_address<T: key>(owner: address, metadata: Object<T>): address {\n        let metadata_addr = object::object_address(&metadata);\n        if (metadata_addr == @aptos_fungible_asset && features::primary_apt_fungible_store_at_user_address_enabled()) {\n            owner\n        } else {\n            object::create_user_derived_object_address(owner, metadata_addr)\n        }\n    }\n\n    #[view]\n    /// Get the primary store object for the given account.\n    public fun primary_store<T: key>(owner: address, metadata: Object<T>): Object<FungibleStore> {\n        let store = primary_store_address(owner, metadata);\n        object::address_to_object<FungibleStore>(store)\n    }\n\n    #[view]\n    /// Return whether the given account's primary store exists.\n    public fun primary_store_exists<T: key>(account: address, metadata: Object<T>): bool {\n        fungible_asset::store_exists(primary_store_address(account, metadata))\n    }\n\n    #[view]\n    /// Get the balance of `account`'s primary store.\n    public fun balance<T: key>(account: address, metadata: Object<T>): u64 {\n        if (primary_store_exists(account, metadata)) {\n            fungible_asset::balance(primary_store(account, metadata))\n        } else {\n            0\n        }\n    }\n\n    #[view]\n    public fun is_balance_at_least<T: key>(account: address, metadata: Object<T>, amount: u64): bool {\n        if (primary_store_exists(account, metadata)) {\n            fungible_asset::is_balance_at_least(primary_store(account, metadata), amount)\n        } else {\n            amount == 0\n        }\n    }\n\n    #[view]\n    /// Return whether the given account's primary store is frozen.\n    public fun is_frozen<T: key>(account: address, metadata: Object<T>): bool {\n        if (primary_store_exists(account, metadata)) {\n            fungible_asset::is_frozen(primary_store(account, metadata))\n        } else {\n            false\n        }\n    }\n\n    /// Withdraw `amount` of fungible asset from the given account's primary store.\n    public fun withdraw<T: key>(owner: &signer, metadata: Object<T>, amount: u64): FungibleAsset acquires DeriveRefPod {\n        let store = ensure_primary_store_exists(signer::address_of(owner), metadata);\n        // Check if the store object has been burnt or not. If so, unburn it first.\n        may_be_unburn(owner, store);\n        dispatchable_fungible_asset::withdraw(owner, store, amount)\n    }\n\n    /// Deposit fungible asset `fa` to the given account's primary store.\n    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {\n        let metadata = fungible_asset::asset_metadata(&fa);\n        let store = ensure_primary_store_exists(owner, metadata);\n        dispatchable_fungible_asset::deposit(store, fa);\n    }\n\n    /// Deposit fungible asset `fa` to the given account's primary store.\n    public(friend) fun force_deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {\n        let metadata = fungible_asset::asset_metadata(&fa);\n        let store = ensure_primary_store_exists(owner, metadata);\n        fungible_asset::deposit_internal(store, fa);\n    }\n\n    /// Transfer `amount` of fungible asset from sender's primary store to receiver's primary store.\n    public entry fun transfer<T: key>(\n        sender: &signer,\n        metadata: Object<T>,\n        recipient: address,\n        amount: u64,\n    ) acquires DeriveRefPod {\n        let sender_store = ensure_primary_store_exists(signer::address_of(sender), metadata);\n        // Check if the sender store object has been burnt or not. If so, unburn it first.\n        may_be_unburn(sender, sender_store);\n        let recipient_store = ensure_primary_store_exists(recipient, metadata);\n        dispatchable_fungible_asset::transfer(sender, sender_store, recipient_store, amount);\n    }\n\n    /// Transfer `amount` of fungible asset from sender's primary store to receiver's primary store.\n    /// Use the minimum deposit assertion api to make sure receipient will receive a minimum amount of fund.\n    public entry fun transfer_assert_minimum_deposit<T: key>(\n        sender: &signer,\n        metadata: Object<T>,\n        recipient: address,\n        amount: u64,\n        expected: u64,\n    ) acquires DeriveRefPod {\n        let sender_store = ensure_primary_store_exists(signer::address_of(sender), metadata);\n        // Check if the sender store object has been burnt or not. If so, unburn it first.\n        may_be_unburn(sender, sender_store);\n        let recipient_store = ensure_primary_store_exists(recipient, metadata);\n        dispatchable_fungible_asset::transfer_assert_minimum_deposit(\n            sender,\n            sender_store,\n            recipient_store,\n            amount,\n            expected\n        );\n    }\n\n    /// Mint to the primary store of `owner`.\n    public fun mint(mint_ref: &MintRef, owner: address, amount: u64) acquires DeriveRefPod {\n        let primary_store = ensure_primary_store_exists(owner, fungible_asset::mint_ref_metadata(mint_ref));\n        fungible_asset::mint_to(mint_ref, primary_store, amount);\n    }\n\n    /// Burn from the primary store of `owner`.\n    public fun burn(burn_ref: &BurnRef, owner: address, amount: u64) {\n        let primary_store = primary_store(owner, fungible_asset::burn_ref_metadata(burn_ref));\n        fungible_asset::burn_from(burn_ref, primary_store, amount);\n    }\n\n    /// Freeze/Unfreeze the primary store of `owner`.\n    public fun set_frozen_flag(transfer_ref: &TransferRef, owner: address, frozen: bool) acquires DeriveRefPod {\n        let primary_store = ensure_primary_store_exists(owner, fungible_asset::transfer_ref_metadata(transfer_ref));\n        fungible_asset::set_frozen_flag(transfer_ref, primary_store, frozen);\n    }\n\n    /// Withdraw from the primary store of `owner` ignoring frozen flag.\n    public fun withdraw_with_ref(transfer_ref: &TransferRef, owner: address, amount: u64): FungibleAsset {\n        let from_primary_store = primary_store(owner, fungible_asset::transfer_ref_metadata(transfer_ref));\n        fungible_asset::withdraw_with_ref(transfer_ref, from_primary_store, amount)\n    }\n\n    /// Deposit from the primary store of `owner` ignoring frozen flag.\n    public fun deposit_with_ref(transfer_ref: &TransferRef, owner: address, fa: FungibleAsset) acquires DeriveRefPod {\n        let from_primary_store = ensure_primary_store_exists(\n            owner,\n            fungible_asset::transfer_ref_metadata(transfer_ref)\n        );\n        fungible_asset::deposit_with_ref(transfer_ref, from_primary_store, fa);\n    }\n\n    /// Transfer `amount` of FA from the primary store of `from` to that of `to` ignoring frozen flag.\n    public fun transfer_with_ref(\n        transfer_ref: &TransferRef,\n        from: address,\n        to: address,\n        amount: u64\n    ) acquires DeriveRefPod {\n        let from_primary_store = primary_store(from, fungible_asset::transfer_ref_metadata(transfer_ref));\n        let to_primary_store = ensure_primary_store_exists(to, fungible_asset::transfer_ref_metadata(transfer_ref));\n        fungible_asset::transfer_with_ref(transfer_ref, from_primary_store, to_primary_store, amount);\n    }\n\n    fun may_be_unburn(owner: &signer, store: Object<FungibleStore>) {\n        if (object::is_burnt(store)) {\n            object::unburn(owner, store);\n        };\n    }\n\n    #[test_only]\n    use aptos_framework::fungible_asset::{\n        create_test_token,\n        generate_mint_ref,\n        generate_burn_ref,\n        generate_transfer_ref\n    };\n    #[test_only]\n    use std::string;\n    #[test_only]\n    use std::option;\n\n    #[test_only]\n    public fun init_test_metadata_with_primary_store_enabled(\n        constructor_ref: &ConstructorRef\n    ): (MintRef, TransferRef, BurnRef) {\n        create_primary_store_enabled_fungible_asset(\n            constructor_ref,\n            option::some(100), // max supply\n            string::utf8(b\"TEST COIN\"),\n            string::utf8(b\"@T\"),\n            0,\n            string::utf8(b\"http://example.com/icon\"),\n            string::utf8(b\"http://example.com\"),\n        );\n        let mint_ref = generate_mint_ref(constructor_ref);\n        let burn_ref = generate_burn_ref(constructor_ref);\n        let transfer_ref = generate_transfer_ref(constructor_ref);\n        (mint_ref, transfer_ref, burn_ref)\n    }\n\n    #[test(creator = @0xcafe, aaron = @0xface)]\n    fun test_default_behavior(creator: &signer, aaron: &signer) acquires DeriveRefPod {\n        let (creator_ref, metadata) = create_test_token(creator);\n        init_test_metadata_with_primary_store_enabled(&creator_ref);\n        let creator_address = signer::address_of(creator);\n        let aaron_address = signer::address_of(aaron);\n        assert!(!primary_store_exists(creator_address, metadata), 1);\n        assert!(!primary_store_exists(aaron_address, metadata), 2);\n        assert!(balance(creator_address, metadata) == 0, 3);\n        assert!(balance(aaron_address, metadata) == 0, 4);\n        assert!(!is_frozen(creator_address, metadata), 5);\n        assert!(!is_frozen(aaron_address, metadata), 6);\n        ensure_primary_store_exists(creator_address, metadata);\n        ensure_primary_store_exists(aaron_address, metadata);\n        assert!(primary_store_exists(creator_address, metadata), 7);\n        assert!(primary_store_exists(aaron_address, metadata), 8);\n    }\n\n    #[test(creator = @0xcafe, aaron = @0xface)]\n    fun test_basic_flow(\n        creator: &signer,\n        aaron: &signer,\n    ) acquires DeriveRefPod {\n        let (creator_ref, metadata) = create_test_token(creator);\n        let (mint_ref, transfer_ref, burn_ref) = init_test_metadata_with_primary_store_enabled(&creator_ref);\n        let creator_address = signer::address_of(creator);\n        let aaron_address = signer::address_of(aaron);\n        assert!(balance(creator_address, metadata) == 0, 1);\n        assert!(balance(aaron_address, metadata) == 0, 2);\n        mint(&mint_ref, creator_address, 100);\n        transfer(creator, metadata, aaron_address, 80);\n        let fa = withdraw(aaron, metadata, 10);\n        deposit(creator_address, fa);\n        assert!(balance(creator_address, metadata) == 30, 3);\n        assert!(balance(aaron_address, metadata) == 70, 4);\n        set_frozen_flag(&transfer_ref, aaron_address, true);\n        assert!(is_frozen(aaron_address, metadata), 5);\n        let fa = withdraw_with_ref(&transfer_ref, aaron_address, 30);\n        deposit_with_ref(&transfer_ref, aaron_address, fa);\n        transfer_with_ref(&transfer_ref, aaron_address, creator_address, 20);\n        set_frozen_flag(&transfer_ref, aaron_address, false);\n        assert!(!is_frozen(aaron_address, metadata), 6);\n        burn(&burn_ref, aaron_address, 50);\n        assert!(balance(aaron_address, metadata) == 0, 7);\n    }\n\n    #[test(creator = @0xcafe, aaron = @0xface)]\n    fun test_basic_flow_with_min_balance(\n        creator: &signer,\n        aaron: &signer,\n    ) acquires DeriveRefPod {\n        let (creator_ref, metadata) = create_test_token(creator);\n        let (mint_ref, _transfer_ref, _) = init_test_metadata_with_primary_store_enabled(&creator_ref);\n        let creator_address = signer::address_of(creator);\n        let aaron_address = signer::address_of(aaron);\n        assert!(balance(creator_address, metadata) == 0, 1);\n        assert!(balance(aaron_address, metadata) == 0, 2);\n        mint(&mint_ref, creator_address, 100);\n        transfer_assert_minimum_deposit(creator, metadata, aaron_address, 80, 80);\n        let fa = withdraw(aaron, metadata, 10);\n        deposit(creator_address, fa);\n        assert!(balance(creator_address, metadata) == 30, 3);\n        assert!(balance(aaron_address, metadata) == 70, 4);\n    }\n\n    #[test(user_1 = @0xcafe, user_2 = @0xface)]\n    fun test_transfer_to_burnt_store(\n        user_1: &signer,\n        user_2: &signer,\n    ) acquires DeriveRefPod {\n        let (creator_ref, metadata) = create_test_token(user_1);\n        let (mint_ref, _, _) = init_test_metadata_with_primary_store_enabled(&creator_ref);\n        let user_1_address = signer::address_of(user_1);\n        let user_2_address = signer::address_of(user_2);\n        mint(&mint_ref, user_1_address, 100);\n        transfer(user_1, metadata, user_2_address, 80);\n\n        // User 2 burns their primary store but should still be able to transfer afterward.\n        let user_2_primary_store = primary_store(user_2_address, metadata);\n        object::burn(user_2, user_2_primary_store);\n        assert!(object::is_burnt(user_2_primary_store), 0);\n        // Balance still works\n        assert!(balance(user_2_address, metadata) == 80, 0);\n        // Deposit still works\n        transfer(user_1, metadata, user_2_address, 20);\n        transfer(user_2, metadata, user_1_address, 90);\n        assert!(balance(user_2_address, metadata) == 10, 0);\n    }\n\n    #[test(user_1 = @0xcafe, user_2 = @0xface)]\n    fun test_withdraw_from_burnt_store(\n        user_1: &signer,\n        user_2: &signer,\n    ) acquires DeriveRefPod {\n        let (creator_ref, metadata) = create_test_token(user_1);\n        let (mint_ref, _, _) = init_test_metadata_with_primary_store_enabled(&creator_ref);\n        let user_1_address = signer::address_of(user_1);\n        let user_2_address = signer::address_of(user_2);\n        mint(&mint_ref, user_1_address, 100);\n        transfer(user_1, metadata, user_2_address, 80);\n\n        // User 2 burns their primary store but should still be able to withdraw afterward.\n        let user_2_primary_store = primary_store(user_2_address, metadata);\n        object::burn(user_2, user_2_primary_store);\n        assert!(object::is_burnt(user_2_primary_store), 0);\n        let coins = withdraw(user_2, metadata, 70);\n        assert!(balance(user_2_address, metadata) == 10, 0);\n        deposit(user_2_address, coins);\n    }\n}\n","name":"primary_fungible_store.move"},{"content":"/// This module provides access to *instant* secure randomness generated by the Aptos validators, as documented in\n/// [AIP-41](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-41.md).\n///\n/// Secure randomness means (1) the randomness cannot be predicted ahead of time by validators, developers or users\n/// and (2) the randomness cannot be biased in any way by validators, developers or users.\n///\n/// Security holds under the same proof-of-stake assumption that secures the Aptos network.\nmodule aptos_framework::randomness {\n    use std::hash;\n    use std::option;\n    use std::option::Option;\n    use std::vector;\n    use aptos_framework::event;\n    use aptos_framework::system_addresses;\n    use aptos_framework::transaction_context;\n    #[test_only]\n    use aptos_std::debug;\n    #[test_only]\n    use aptos_std::table_with_length;\n\n    friend aptos_framework::block;\n\n    const DST: vector<u8> = b\"APTOS_RANDOMNESS\";\n\n    /// Randomness APIs calls must originate from a private entry function with\n    /// `#[randomness]` annotation. Otherwise, malicious users can bias randomness result.\n    const E_API_USE_IS_BIASIBLE: u64 = 1;\n\n    const MAX_U256: u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    /// 32-byte randomness seed unique to every block.\n    /// This resource is updated in every block prologue.\n    struct PerBlockRandomness has drop, key {\n        epoch: u64,\n        round: u64,\n        seed: Option<vector<u8>>,\n    }\n\n    #[event]\n    /// Event emitted every time a public randomness API in this module is called.\n    struct RandomnessGeneratedEvent has store, drop {\n    }\n\n    /// Called in genesis.move.\n    /// Must be called in tests to initialize the `PerBlockRandomness` resource.\n    public fun initialize(framework: &signer) {\n        system_addresses::assert_aptos_framework(framework);\n        if (!exists<PerBlockRandomness>(@aptos_framework)) {\n            move_to(framework, PerBlockRandomness {\n                epoch: 0,\n                round: 0,\n                seed: option::none(),\n            });\n        }\n    }\n\n    #[test_only]\n    public fun initialize_for_testing(framework: &signer) acquires  PerBlockRandomness {\n        initialize(framework);\n        set_seed(x\"0000000000000000000000000000000000000000000000000000000000000000\");\n    }\n\n    /// Invoked in block prologues to update the block-level randomness seed.\n    public(friend) fun on_new_block(vm: &signer, epoch: u64, round: u64, seed_for_new_block: Option<vector<u8>>) acquires PerBlockRandomness {\n        system_addresses::assert_vm(vm);\n        if (exists<PerBlockRandomness>(@aptos_framework)) {\n            let randomness = borrow_global_mut<PerBlockRandomness>(@aptos_framework);\n            randomness.epoch = epoch;\n            randomness.round = round;\n            randomness.seed = seed_for_new_block;\n        }\n    }\n\n    /// Generate the next 32 random bytes. Repeated calls will yield different results (assuming the collision-resistance\n    /// of the hash function).\n    fun next_32_bytes(): vector<u8> acquires PerBlockRandomness {\n        assert!(is_unbiasable(), E_API_USE_IS_BIASIBLE);\n\n        let input = DST;\n        let randomness = borrow_global<PerBlockRandomness>(@aptos_framework);\n        let seed = *option::borrow(&randomness.seed);\n\n        vector::append(&mut input, seed);\n        vector::append(&mut input, transaction_context::get_transaction_hash());\n        vector::append(&mut input, fetch_and_increment_txn_counter());\n        hash::sha3_256(input)\n    }\n\n    /// Generates a sequence of bytes uniformly at random\n    public fun bytes(n: u64): vector<u8> acquires PerBlockRandomness {\n        let v = vector[];\n        let c = 0;\n        while (c < n) {\n            let blob = next_32_bytes();\n            vector::append(&mut v, blob);\n\n            c = c + 32;\n        };\n\n        if (c > n) {\n            vector::trim(&mut v, n);\n        };\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        v\n    }\n\n    /// Generates an u8 uniformly at random.\n    public fun u8_integer(): u8 acquires PerBlockRandomness {\n        let raw = next_32_bytes();\n        let ret: u8 = vector::pop_back(&mut raw);\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        ret\n    }\n\n    /// Generates an u16 uniformly at random.\n    public fun u16_integer(): u16 acquires PerBlockRandomness {\n        let raw = next_32_bytes();\n        let i = 0;\n        let ret: u16 = 0;\n        while (i < 2) {\n            ret = ret * 256 + (vector::pop_back(&mut raw) as u16);\n            i = i + 1;\n        };\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        ret\n    }\n\n    /// Generates an u32 uniformly at random.\n    public fun u32_integer(): u32 acquires PerBlockRandomness {\n        let raw = next_32_bytes();\n        let i = 0;\n        let ret: u32 = 0;\n        while (i < 4) {\n            ret = ret * 256 + (vector::pop_back(&mut raw) as u32);\n            i = i + 1;\n        };\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        ret\n    }\n\n    /// Generates an u64 uniformly at random.\n    public fun u64_integer(): u64 acquires PerBlockRandomness {\n        let raw = next_32_bytes();\n        let i = 0;\n        let ret: u64 = 0;\n        while (i < 8) {\n            ret = ret * 256 + (vector::pop_back(&mut raw) as u64);\n            i = i + 1;\n        };\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        ret\n    }\n\n    /// Generates an u128 uniformly at random.\n    public fun u128_integer(): u128 acquires PerBlockRandomness {\n        let raw = next_32_bytes();\n        let i = 0;\n        let ret: u128 = 0;\n        while (i < 16) {\n            ret = ret * 256 + (vector::pop_back(&mut raw) as u128);\n            i = i + 1;\n        };\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        ret\n    }\n\n    /// Generates a u256 uniformly at random.\n    public fun u256_integer(): u256 acquires PerBlockRandomness {\n        event::emit(RandomnessGeneratedEvent {});\n        u256_integer_internal()\n    }\n\n    /// Generates a u256 uniformly at random.\n    fun u256_integer_internal(): u256 acquires PerBlockRandomness {\n        let raw = next_32_bytes();\n        let i = 0;\n        let ret: u256 = 0;\n        while (i < 32) {\n            ret = ret * 256 + (vector::pop_back(&mut raw) as u256);\n            i = i + 1;\n        };\n        ret\n    }\n\n    /// Generates a number $n \\in [min_incl, max_excl)$ uniformly at random.\n    ///\n    /// NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.\n    /// If you need perfect uniformity, consider implement your own via rejection sampling.\n    public fun u8_range(min_incl: u8, max_excl: u8): u8 acquires PerBlockRandomness {\n        let range = ((max_excl - min_incl) as u256);\n        let sample = ((u256_integer_internal() % range) as u8);\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        min_incl + sample\n    }\n\n    /// Generates a number $n \\in [min_incl, max_excl)$ uniformly at random.\n    ///\n    /// NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.\n    /// If you need perfect uniformity, consider implement your own via rejection sampling.\n    public fun u16_range(min_incl: u16, max_excl: u16): u16 acquires PerBlockRandomness {\n        let range = ((max_excl - min_incl) as u256);\n        let sample = ((u256_integer_internal() % range) as u16);\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        min_incl + sample\n    }\n\n    /// Generates a number $n \\in [min_incl, max_excl)$ uniformly at random.\n    ///\n    /// NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.\n    /// If you need perfect uniformity, consider implement your own via rejection sampling.\n    public fun u32_range(min_incl: u32, max_excl: u32): u32 acquires PerBlockRandomness {\n        let range = ((max_excl - min_incl) as u256);\n        let sample = ((u256_integer_internal() % range) as u32);\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        min_incl + sample\n    }\n\n    /// Generates a number $n \\in [min_incl, max_excl)$ uniformly at random.\n    ///\n    /// NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.\n    /// If you need perfect uniformity, consider implement your own via rejection sampling.\n    public fun u64_range(min_incl: u64, max_excl: u64): u64 acquires PerBlockRandomness {\n        event::emit(RandomnessGeneratedEvent {});\n\n        u64_range_internal(min_incl, max_excl)\n    }\n\n    public fun u64_range_internal(min_incl: u64, max_excl: u64): u64 acquires PerBlockRandomness {\n        let range = ((max_excl - min_incl) as u256);\n        let sample = ((u256_integer_internal() % range) as u64);\n\n        min_incl + sample\n    }\n\n    /// Generates a number $n \\in [min_incl, max_excl)$ uniformly at random.\n    ///\n    /// NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.\n    /// If you need perfect uniformity, consider implement your own via rejection sampling.\n    public fun u128_range(min_incl: u128, max_excl: u128): u128 acquires PerBlockRandomness {\n        let range = ((max_excl - min_incl) as u256);\n        let sample = ((u256_integer_internal() % range) as u128);\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        min_incl + sample\n    }\n\n    /// Generates a number $n \\in [min_incl, max_excl)$ uniformly at random.\n    ///\n    /// NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.\n    /// If you need perfect uniformity, consider implement your own with `u256_integer()` + rejection sampling.\n    public fun u256_range(min_incl: u256, max_excl: u256): u256 acquires PerBlockRandomness {\n        let range = max_excl - min_incl;\n        let r0 = u256_integer_internal();\n        let r1 = u256_integer_internal();\n\n        // Will compute sample := (r0 + r1*2^256) % range.\n\n        let sample = r1 % range;\n        let i = 0;\n        while ({\n            spec {\n                invariant sample >= 0 && sample < max_excl - min_incl;\n            };\n            i < 256\n        }) {\n            sample = safe_add_mod(sample, sample, range);\n            i = i + 1;\n        };\n\n        let sample = safe_add_mod(sample, r0 % range, range);\n        spec {\n            assert sample >= 0 && sample < max_excl - min_incl;\n        };\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        min_incl + sample\n    }\n\n    /// Generate a permutation of `[0, 1, ..., n-1]` uniformly at random.\n    /// If n is 0, returns the empty vector.\n    public fun permutation(n: u64): vector<u64> acquires PerBlockRandomness {\n        let values = vector[];\n\n        if(n == 0) {\n            return vector[]\n        };\n\n        // Initialize into [0, 1, ..., n-1].\n        let i = 0;\n        while ({\n            spec {\n                invariant i <= n;\n                invariant len(values) == i;\n            };\n            i < n\n        }) {\n            std::vector::push_back(&mut values, i);\n            i = i + 1;\n        };\n        spec {\n            assert len(values) == n;\n        };\n\n        // Shuffle.\n        let tail = n - 1;\n        while ({\n            spec {\n                invariant tail >= 0 && tail < len(values);\n            };\n            tail > 0\n        }) {\n            let pop_position = u64_range_internal(0, tail + 1);\n            spec {\n                assert pop_position < len(values);\n            };\n            std::vector::swap(&mut values, pop_position, tail);\n            tail = tail - 1;\n        };\n\n        event::emit(RandomnessGeneratedEvent {});\n\n        values\n    }\n\n    #[test_only]\n    public fun set_seed(seed: vector<u8>) acquires PerBlockRandomness {\n        assert!(vector::length(&seed) == 32, 0);\n        let randomness = borrow_global_mut<PerBlockRandomness>(@aptos_framework);\n        randomness.seed = option::some(seed);\n    }\n\n    /// Compute `(a + b) % m`, assuming `m >= 1, 0 <= a < m, 0<= b < m`.\n    inline fun safe_add_mod(a: u256, b: u256, m: u256): u256 {\n        let neg_b = m - b;\n        if (a < neg_b) {\n            a + b\n        } else {\n            a - neg_b\n        }\n    }\n\n    #[verify_only]\n    fun safe_add_mod_for_verification(a: u256, b: u256, m: u256): u256 {\n        let neg_b = m - b;\n        if (a < neg_b) {\n            a + b\n        } else {\n            a - neg_b\n        }\n    }\n\n    /// Fetches and increments a transaction-specific 32-byte randomness-related counter.\n    /// Aborts with `E_API_USE_SUSCEPTIBLE_TO_TEST_AND_ABORT` if randomness is not unbiasable.\n    native fun fetch_and_increment_txn_counter(): vector<u8>;\n\n    /// Called in each randomness generation function to ensure certain safety invariants, namely:\n    ///  1. The transaction that led to the call of this function had a private (or friend) entry\n    ///     function as its payload.\n    ///  2. The entry function had `#[randomness]` annotation.\n    native fun is_unbiasable(): bool;\n\n    #[test]\n    fun test_safe_add_mod() {\n        assert!(2 == safe_add_mod(3, 4, 5), 1);\n        assert!(2 == safe_add_mod(4, 3, 5), 1);\n        assert!(7 == safe_add_mod(3, 4, 9), 1);\n        assert!(7 == safe_add_mod(4, 3, 9), 1);\n        assert!(0xfffffffffffffffffffffffffffffffffffffffffffffffe == safe_add_mod(0xfffffffffffffffffffffffffffffffffffffffffffffffd, 0x000000000000000000000000000000000000000000000001, 0xffffffffffffffffffffffffffffffffffffffffffffffff), 1);\n        assert!(0xfffffffffffffffffffffffffffffffffffffffffffffffe == safe_add_mod(0x000000000000000000000000000000000000000000000001, 0xfffffffffffffffffffffffffffffffffffffffffffffffd, 0xffffffffffffffffffffffffffffffffffffffffffffffff), 1);\n        assert!(0x000000000000000000000000000000000000000000000000 == safe_add_mod(0xfffffffffffffffffffffffffffffffffffffffffffffffd, 0x000000000000000000000000000000000000000000000002, 0xffffffffffffffffffffffffffffffffffffffffffffffff), 1);\n        assert!(0x000000000000000000000000000000000000000000000000 == safe_add_mod(0x000000000000000000000000000000000000000000000002, 0xfffffffffffffffffffffffffffffffffffffffffffffffd, 0xffffffffffffffffffffffffffffffffffffffffffffffff), 1);\n        assert!(0x000000000000000000000000000000000000000000000001 == safe_add_mod(0xfffffffffffffffffffffffffffffffffffffffffffffffd, 0x000000000000000000000000000000000000000000000003, 0xffffffffffffffffffffffffffffffffffffffffffffffff), 1);\n        assert!(0x000000000000000000000000000000000000000000000001 == safe_add_mod(0x000000000000000000000000000000000000000000000003, 0xfffffffffffffffffffffffffffffffffffffffffffffffd, 0xffffffffffffffffffffffffffffffffffffffffffffffff), 1);\n        assert!(0xfffffffffffffffffffffffffffffffffffffffffffffffd == safe_add_mod(0xfffffffffffffffffffffffffffffffffffffffffffffffe, 0xfffffffffffffffffffffffffffffffffffffffffffffffe, 0xffffffffffffffffffffffffffffffffffffffffffffffff), 1);\n    }\n\n    #[test(fx = @aptos_framework)]\n    fun randomness_smoke_test(fx: signer) acquires PerBlockRandomness {\n        initialize(&fx);\n        set_seed(x\"0000000000000000000000000000000000000000000000000000000000000000\");\n        // Test cases should always have no bias for any randomness call.\n        assert!(is_unbiasable(), 0);\n        let num = u64_integer();\n        debug::print(&num);\n    }\n\n    #[test_only]\n    fun assert_event_count_equals(count: u64) {\n        let events = event::emitted_events<RandomnessGeneratedEvent>();\n        assert!(vector::length(&events) == count, 0);\n    }\n\n    #[test(fx = @aptos_framework)]\n    fun test_emit_events(fx: signer) acquires PerBlockRandomness {\n        initialize_for_testing(&fx);\n\n        let c = 0;\n        assert_event_count_equals(c);\n\n        let _ = bytes(1);\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u8_integer();\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u16_integer();\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u32_integer();\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u64_integer();\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u128_integer();\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u256_integer();\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u8_range(0, 255);\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u16_range(0, 255);\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u32_range(0, 255);\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u64_range(0, 255);\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u128_range(0, 255);\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = u256_range(0, 255);\n        c = c + 1;\n        assert_event_count_equals(c);\n\n        let _ = permutation(6);\n        c = c + 1;\n        assert_event_count_equals(c);\n    }\n\n    #[test(fx = @aptos_framework)]\n    fun test_bytes(fx: signer) acquires PerBlockRandomness {\n        initialize_for_testing(&fx);\n\n        let v = bytes(0);\n        assert!(vector::length(&v) == 0, 0);\n\n        let v = bytes(1);\n        assert!(vector::length(&v) == 1, 0);\n        let v = bytes(2);\n        assert!(vector::length(&v) == 2, 0);\n        let v = bytes(3);\n        assert!(vector::length(&v) == 3, 0);\n        let v = bytes(4);\n        assert!(vector::length(&v) == 4, 0);\n        let v = bytes(30);\n        assert!(vector::length(&v) == 30, 0);\n        let v = bytes(31);\n        assert!(vector::length(&v) == 31, 0);\n        let v = bytes(32);\n        assert!(vector::length(&v) == 32, 0);\n\n        let v = bytes(33);\n        assert!(vector::length(&v) == 33, 0);\n        let v = bytes(50);\n        assert!(vector::length(&v) == 50, 0);\n        let v = bytes(63);\n        assert!(vector::length(&v) == 63, 0);\n        let v = bytes(64);\n        assert!(vector::length(&v) == 64, 0);\n    }\n\n    #[test_only]\n    fun is_permutation(v: &vector<u64>): bool {\n        let present = vector[];\n\n        // Mark all elements from 0 to n-1 as not present\n        let n = vector::length(v);\n        for (i in 0..n) {\n            vector::push_back(&mut present, false);\n        };\n\n        for (i in 0..n) {\n            let e = vector::borrow(v, i);\n            let bit = vector::borrow_mut(&mut present, *e);\n            *bit = true;\n        };\n\n        for (i in 0..n) {\n            let bit = vector::borrow(&present, i);\n            if(*bit == false) {\n                return false\n            };\n        };\n\n        true\n    }\n\n    #[test(fx = @aptos_framework)]\n    fun test_permutation(fx: signer) acquires PerBlockRandomness {\n        initialize_for_testing(&fx);\n\n        let v = permutation(0);\n        assert!(vector::length(&v) == 0, 0);\n\n        test_permutation_internal(1);\n        test_permutation_internal(2);\n        test_permutation_internal(3);\n        test_permutation_internal(4);\n    }\n\n    #[test_only]\n    /// WARNING: Do not call this with a large `size`, since execution time will be \\Omega(size!), where ! is the factorial\n    /// operator.\n    fun test_permutation_internal(size: u64) acquires PerBlockRandomness {\n        let num_permutations = 1;\n        let c = 1;\n        for (i in 0..size) {\n            num_permutations = num_permutations * c;\n            c = c + 1;\n        };\n\n        let permutations = table_with_length::new<vector<u64>, bool>();\n\n        // This loop will not exit until all permutations are created\n        while(table_with_length::length(&permutations) < num_permutations) {\n            let v = permutation(size);\n            assert!(vector::length(&v) == size, 0);\n            assert!(is_permutation(&v), 0);\n\n            if(table_with_length::contains(&permutations, v) == false) {\n                table_with_length::add(&mut permutations, v, true);\n            }\n        };\n\n        table_with_length::drop_unchecked(permutations);\n    }\n}\n","name":"randomness.move"},{"content":"/// Publishes configuration information for validators, and issues reconfiguration events\n/// to synchronize configuration changes for the validators.\nmodule aptos_framework::reconfiguration {\n    use std::error;\n    use std::features;\n    use std::signer;\n\n    use aptos_framework::account;\n    use aptos_framework::event;\n    use aptos_framework::stake;\n    use aptos_framework::system_addresses;\n    use aptos_framework::timestamp;\n    use aptos_framework::chain_status;\n    use aptos_framework::reconfiguration_state;\n    use aptos_framework::storage_gas;\n    use aptos_framework::transaction_fee;\n\n    friend aptos_framework::aptos_governance;\n    friend aptos_framework::block;\n    friend aptos_framework::consensus_config;\n    friend aptos_framework::execution_config;\n    friend aptos_framework::gas_schedule;\n    friend aptos_framework::genesis;\n    friend aptos_framework::version;\n    friend aptos_framework::reconfiguration_with_dkg;\n\n    #[event]\n    /// Event that signals consensus to start a new epoch,\n    /// with new configuration information. This is also called a\n    /// \"reconfiguration event\"\n    struct NewEpochEvent has drop, store {\n        epoch: u64,\n    }\n\n    #[event]\n    /// Event that signals consensus to start a new epoch,\n    /// with new configuration information. This is also called a\n    /// \"reconfiguration event\"\n    struct NewEpoch has drop, store {\n        epoch: u64,\n    }\n\n    /// Holds information about state of reconfiguration\n    struct Configuration has key {\n        /// Epoch number\n        epoch: u64,\n        /// Time of last reconfiguration. Only changes on reconfiguration events.\n        last_reconfiguration_time: u64,\n        /// Event handle for reconfiguration events\n        events: event::EventHandle<NewEpochEvent>,\n    }\n\n    /// Reconfiguration will be disabled if this resource is published under the\n    /// aptos_framework system address\n    struct DisableReconfiguration has key {}\n\n    /// The `Configuration` resource is in an invalid state\n    const ECONFIGURATION: u64 = 1;\n    /// A `Reconfiguration` resource is in an invalid state\n    const ECONFIG: u64 = 2;\n    /// A `ModifyConfigCapability` is in a different state than was expected\n    const EMODIFY_CAPABILITY: u64 = 3;\n    /// An invalid block time was encountered.\n    const EINVALID_BLOCK_TIME: u64 = 4;\n    /// An invalid block time was encountered.\n    const EINVALID_GUID_FOR_EVENT: u64 = 5;\n\n    /// Only called during genesis.\n    /// Publishes `Configuration` resource. Can only be invoked by aptos framework account, and only a single time in Genesis.\n    public(friend) fun initialize(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        // assert it matches `new_epoch_event_key()`, otherwise the event can't be recognized\n        assert!(account::get_guid_next_creation_num(signer::address_of(aptos_framework)) == 2, error::invalid_state(EINVALID_GUID_FOR_EVENT));\n        move_to<Configuration>(\n            aptos_framework,\n            Configuration {\n                epoch: 0,\n                last_reconfiguration_time: 0,\n                events: account::new_event_handle<NewEpochEvent>(aptos_framework),\n            }\n        );\n    }\n\n    /// Private function to temporarily halt reconfiguration.\n    /// This function should only be used for offline WriteSet generation purpose and should never be invoked on chain.\n    fun disable_reconfiguration(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(reconfiguration_enabled(), error::invalid_state(ECONFIGURATION));\n        move_to(aptos_framework, DisableReconfiguration {})\n    }\n\n    /// Private function to resume reconfiguration.\n    /// This function should only be used for offline WriteSet generation purpose and should never be invoked on chain.\n    fun enable_reconfiguration(aptos_framework: &signer) acquires DisableReconfiguration {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        assert!(!reconfiguration_enabled(), error::invalid_state(ECONFIGURATION));\n        DisableReconfiguration {} = move_from<DisableReconfiguration>(signer::address_of(aptos_framework));\n    }\n\n    fun reconfiguration_enabled(): bool {\n        !exists<DisableReconfiguration>(@aptos_framework)\n    }\n\n    /// Signal validators to start using new configuration. Must be called from friend config modules.\n    public(friend) fun reconfigure() acquires Configuration {\n        // Do not do anything if genesis has not finished.\n        if (chain_status::is_genesis() || timestamp::now_microseconds() == 0 || !reconfiguration_enabled()) {\n            return\n        };\n\n        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);\n        let current_time = timestamp::now_microseconds();\n\n        // Do not do anything if a reconfiguration event is already emitted within this transaction.\n        //\n        // This is OK because:\n        // - The time changes in every non-empty block\n        // - A block automatically ends after a transaction that emits a reconfiguration event, which is guaranteed by\n        //   VM spec that all transactions comming after a reconfiguration transaction will be returned as Retry\n        //   status.\n        // - Each transaction must emit at most one reconfiguration event\n        //\n        // Thus, this check ensures that a transaction that does multiple \"reconfiguration required\" actions emits only\n        // one reconfiguration event.\n        //\n        if (current_time == config_ref.last_reconfiguration_time) {\n            return\n        };\n\n        reconfiguration_state::on_reconfig_start();\n\n        // Reconfiguration \"forces the block\" to end, as mentioned above. Therefore, we must process the collected fees\n        // explicitly so that staking can distribute them.\n        //\n        // This also handles the case when a validator is removed due to the governance proposal. In particular, removing\n        // the validator causes a reconfiguration. We explicitly process fees, i.e. we drain aggregatable coin and populate\n        // the fees table, prior to calling `on_new_epoch()`. That call, in turn, distributes transaction fees for all active\n        // and pending_inactive validators, which include any validator that is to be removed.\n        if (features::collect_and_distribute_gas_fees()) {\n            // All transactions after reconfiguration are Retry. Therefore, when the next\n            // block starts and tries to assign/burn collected fees it will be just 0 and\n            // nothing will be assigned.\n            transaction_fee::process_collected_fees();\n        };\n\n        // Call stake to compute the new validator set and distribute rewards and transaction fees.\n        stake::on_new_epoch();\n        storage_gas::on_reconfig();\n\n        assert!(current_time > config_ref.last_reconfiguration_time, error::invalid_state(EINVALID_BLOCK_TIME));\n        config_ref.last_reconfiguration_time = current_time;\n        spec {\n            assume config_ref.epoch + 1 <= MAX_U64;\n        };\n        config_ref.epoch = config_ref.epoch + 1;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                NewEpoch {\n                    epoch: config_ref.epoch,\n                },\n            );\n        };\n        event::emit_event<NewEpochEvent>(\n            &mut config_ref.events,\n            NewEpochEvent {\n                epoch: config_ref.epoch,\n            },\n        );\n\n        reconfiguration_state::on_reconfig_finish();\n    }\n\n    public fun last_reconfiguration_time(): u64 acquires Configuration {\n        borrow_global<Configuration>(@aptos_framework).last_reconfiguration_time\n    }\n\n    public fun current_epoch(): u64 acquires Configuration {\n        borrow_global<Configuration>(@aptos_framework).epoch\n    }\n\n    /// Emit a `NewEpochEvent` event. This function will be invoked by genesis directly to generate the very first\n    /// reconfiguration event.\n    fun emit_genesis_reconfiguration_event() acquires Configuration {\n        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);\n        assert!(config_ref.epoch == 0 && config_ref.last_reconfiguration_time == 0, error::invalid_state(ECONFIGURATION));\n        config_ref.epoch = 1;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                NewEpoch {\n                    epoch: config_ref.epoch,\n                },\n            );\n        };\n        event::emit_event<NewEpochEvent>(\n            &mut config_ref.events,\n            NewEpochEvent {\n                epoch: config_ref.epoch,\n            },\n        );\n    }\n\n    // For tests, skips the guid validation.\n    #[test_only]\n    public fun initialize_for_test(account: &signer) {\n        system_addresses::assert_aptos_framework(account);\n        move_to<Configuration>(\n            account,\n            Configuration {\n                epoch: 0,\n                last_reconfiguration_time: 0,\n                events: account::new_event_handle<NewEpochEvent>(account),\n            }\n        );\n    }\n\n    #[test_only]\n    public fun reconfigure_for_test() acquires Configuration {\n        reconfigure();\n    }\n\n    // This is used together with stake::end_epoch() for testing with last_reconfiguration_time\n    // It must be called each time an epoch changes\n    #[test_only]\n    public fun reconfigure_for_test_custom() acquires Configuration {\n        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);\n        let current_time = timestamp::now_microseconds();\n        if (current_time == config_ref.last_reconfiguration_time) {\n            return\n        };\n        config_ref.last_reconfiguration_time = current_time;\n        config_ref.epoch = config_ref.epoch + 1;\n    }\n}\n","name":"reconfiguration.move"},{"content":"/// Reconfiguration meta-state resources and util functions.\n///\n/// WARNING: `reconfiguration_state::initialize()` is required before `RECONFIGURE_WITH_DKG` can be enabled.\nmodule aptos_framework::reconfiguration_state {\n    use std::error;\n    use std::string;\n    use aptos_std::copyable_any;\n    use aptos_std::copyable_any::Any;\n    use aptos_framework::system_addresses;\n    use aptos_framework::timestamp;\n\n    friend aptos_framework::reconfiguration;\n    friend aptos_framework::reconfiguration_with_dkg;\n    friend aptos_framework::stake;\n\n    const ERECONFIG_NOT_IN_PROGRESS: u64 = 1;\n\n    /// Reconfiguration drivers update this resources to notify other modules of some reconfiguration state.\n    struct State has key {\n        /// The state variant packed as an `Any`.\n        /// Currently the variant type is one of the following.\n        /// - `ReconfigStateInactive`\n        /// - `ReconfigStateActive`\n        variant: Any,\n    }\n\n    /// A state variant indicating no reconfiguration is in progress.\n    struct StateInactive has copy, drop, store {}\n\n    /// A state variant indicating a reconfiguration is in progress.\n    struct StateActive has copy, drop, store {\n        start_time_secs: u64,\n    }\n\n    public fun is_initialized(): bool {\n        exists<State>(@aptos_framework)\n    }\n\n    public fun initialize(fx: &signer) {\n        system_addresses::assert_aptos_framework(fx);\n        if (!exists<State>(@aptos_framework)) {\n            move_to(fx, State {\n                variant: copyable_any::pack(StateInactive {})\n            })\n        }\n    }\n\n    public fun initialize_for_testing(fx: &signer) {\n        initialize(fx)\n    }\n\n    /// Return whether the reconfiguration state is marked \"in progress\".\n    public(friend) fun is_in_progress(): bool acquires State {\n        if (!exists<State>(@aptos_framework)) {\n            return false\n        };\n\n        let state = borrow_global<State>(@aptos_framework);\n        let variant_type_name = *string::bytes(copyable_any::type_name(&state.variant));\n        variant_type_name == b\"0x1::reconfiguration_state::StateActive\"\n    }\n\n    /// Called at the beginning of a reconfiguration (either immediate or async)\n    /// to mark the reconfiguration state \"in progress\" if it is currently \"stopped\".\n    ///\n    /// Also record the current time as the reconfiguration start time. (Some module, e.g., `stake.move`, needs this info).\n    public(friend) fun on_reconfig_start() acquires State {\n        if (exists<State>(@aptos_framework)) {\n            let state = borrow_global_mut<State>(@aptos_framework);\n            let variant_type_name = *string::bytes(copyable_any::type_name(&state.variant));\n            if (variant_type_name == b\"0x1::reconfiguration_state::StateInactive\") {\n                state.variant = copyable_any::pack(StateActive {\n                    start_time_secs: timestamp::now_seconds()\n                });\n            }\n        };\n    }\n\n    /// Get the unix time when the currently in-progress reconfiguration started.\n    /// Abort if the reconfiguration state is not \"in progress\".\n    public(friend) fun start_time_secs(): u64 acquires State {\n        let state = borrow_global<State>(@aptos_framework);\n        let variant_type_name = *string::bytes(copyable_any::type_name(&state.variant));\n        if (variant_type_name == b\"0x1::reconfiguration_state::StateActive\") {\n            let active = copyable_any::unpack<StateActive>(state.variant);\n            active.start_time_secs\n        } else {\n            abort(error::invalid_state(ERECONFIG_NOT_IN_PROGRESS))\n        }\n    }\n\n    /// Called at the end of every reconfiguration to mark the state as \"stopped\".\n    /// Abort if the current state is not \"in progress\".\n    public(friend) fun on_reconfig_finish() acquires State {\n        if (exists<State>(@aptos_framework)) {\n            let state = borrow_global_mut<State>(@aptos_framework);\n            let variant_type_name = *string::bytes(copyable_any::type_name(&state.variant));\n            if (variant_type_name == b\"0x1::reconfiguration_state::StateActive\") {\n                state.variant = copyable_any::pack(StateInactive {});\n            } else {\n                abort(error::invalid_state(ERECONFIG_NOT_IN_PROGRESS))\n            }\n        }\n    }\n\n    #[test(fx = @aptos_framework)]\n    fun basic(fx: &signer) acquires State {\n        // Setip.\n        timestamp::set_time_has_started_for_testing(fx);\n        initialize(fx);\n\n        // Initially no reconfig is in progress.\n        assert!(!is_in_progress(), 1);\n\n        // \"try_start\" should work.\n        timestamp::fast_forward_seconds(123);\n        on_reconfig_start();\n        assert!(is_in_progress(), 1);\n        assert!(123 == start_time_secs(), 1);\n\n        // Redundant `try_start` should be no-op.\n        timestamp::fast_forward_seconds(1);\n        on_reconfig_start();\n        assert!(is_in_progress(), 1);\n        assert!(123 == start_time_secs(), 1);\n\n        // A `finish` call should work when the state is marked \"in progess\".\n        timestamp::fast_forward_seconds(10);\n        on_reconfig_finish();\n        assert!(!is_in_progress(), 1);\n    }\n}\n","name":"reconfiguration_state.move"},{"content":"/// Reconfiguration with DKG helper functions.\nmodule aptos_framework::reconfiguration_with_dkg {\n    use std::features;\n    use std::option;\n    use aptos_framework::consensus_config;\n    use aptos_framework::dkg;\n    use aptos_framework::execution_config;\n    use aptos_framework::gas_schedule;\n    use aptos_framework::jwk_consensus_config;\n    use aptos_framework::jwks;\n    use aptos_framework::keyless_account;\n    use aptos_framework::randomness_api_v0_config;\n    use aptos_framework::randomness_config;\n    use aptos_framework::randomness_config_seqnum;\n    use aptos_framework::reconfiguration;\n    use aptos_framework::reconfiguration_state;\n    use aptos_framework::stake;\n    use aptos_framework::system_addresses;\n    friend aptos_framework::block;\n    friend aptos_framework::aptos_governance;\n\n    /// Trigger a reconfiguration with DKG.\n    /// Do nothing if one is already in progress.\n    public(friend) fun try_start() {\n        let incomplete_dkg_session = dkg::incomplete_session();\n        if (option::is_some(&incomplete_dkg_session)) {\n            let session = option::borrow(&incomplete_dkg_session);\n            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {\n                return\n            }\n        };\n        reconfiguration_state::on_reconfig_start();\n        let cur_epoch = reconfiguration::current_epoch();\n        dkg::start(\n            cur_epoch,\n            randomness_config::current(),\n            stake::cur_validator_consensus_infos(),\n            stake::next_validator_consensus_infos(),\n        );\n    }\n\n    /// Clear incomplete DKG session, if it exists.\n    /// Apply buffered on-chain configs (except for ValidatorSet, which is done inside `reconfiguration::reconfigure()`).\n    /// Re-enable validator set changes.\n    /// Run the default reconfiguration to enter the new epoch.\n    public(friend) fun finish(framework: &signer) {\n        system_addresses::assert_aptos_framework(framework);\n        dkg::try_clear_incomplete_session(framework);\n        consensus_config::on_new_epoch(framework);\n        execution_config::on_new_epoch(framework);\n        gas_schedule::on_new_epoch(framework);\n        std::version::on_new_epoch(framework);\n        features::on_new_epoch(framework);\n        jwk_consensus_config::on_new_epoch(framework);\n        jwks::on_new_epoch(framework);\n        keyless_account::on_new_epoch(framework);\n        randomness_config_seqnum::on_new_epoch(framework);\n        randomness_config::on_new_epoch(framework);\n        randomness_api_v0_config::on_new_epoch(framework);\n        reconfiguration::reconfigure();\n    }\n\n    /// Complete the current reconfiguration with DKG.\n    /// Abort if no DKG is in progress.\n    fun finish_with_dkg_result(account: &signer, dkg_result: vector<u8>) {\n        dkg::finish(dkg_result);\n        finish(account);\n    }\n}\n","name":"reconfiguration_with_dkg.move"},{"content":"/// A resource account is used to manage resources independent of an account managed by a user.\n/// This contains several utilities to make using resource accounts more effective.\n///\n/// ## Resource Accounts to manage liquidity pools\n///\n/// A dev wishing to use resource accounts for a liquidity pool, would likely do the following:\n///\n///  1. Create a new account using `resource_account::create_resource_account`. This creates the\n///     account, stores the `signer_cap` within a `resource_account::Container`, and rotates the key to\n///     the current account's authentication key or a provided authentication key.\n///  2. Define the liquidity pool module's address to be the same as the resource account.\n///  3. Construct a package-publishing transaction for the resource account using the\n///     authentication key used in step 1.\n///  4. In the liquidity pool module's `init_module` function, call `retrieve_resource_account_cap`\n///     which will retrieve the `signer_cap` and rotate the resource account's authentication key to\n///     `0x0`, effectively locking it off.\n///  5. When adding a new coin, the liquidity pool will load the capability and hence the `signer` to\n///     register and store new `LiquidityCoin` resources.\n///\n/// Code snippets to help:\n///\n/// ```\n/// fun init_module(resource_account: &signer) {\n///   let dev_address = @DEV_ADDR;\n///   let signer_cap = retrieve_resource_account_cap(resource_account, dev_address);\n///   let lp = LiquidityPoolInfo { signer_cap: signer_cap, ... };\n///   move_to(resource_account, lp);\n/// }\n/// ```\n///\n/// Later on during a coin registration:\n/// ```\n/// public fun add_coin<X, Y>(lp: &LP, x: Coin<x>, y: Coin<y>) {\n///     if(!exists<LiquidityCoin<X, Y>(LP::Address(lp), LiquidityCoin<X, Y>)) {\n///         let mint, burn = Coin::initialize<LiquidityCoin<X, Y>>(...);\n///         move_to(&create_signer_with_capability(&lp.cap), LiquidityCoin<X, Y>{ mint, burn });\n///     }\n///     ...\n/// }\n/// ```\n/// ## Resource accounts to manage an account for module publishing (i.e., contract account)\n///\n/// A dev wishes to have an account dedicated to managing a contract. The contract itself does not\n/// require signer post initialization. The dev could do the following:\n/// 1. Create a new account using `resource_account::create_resource_account_and_publish_package`.\n/// This creates the account and publishes the package for that account.\n/// 2. At a later point in time, the account creator can move the signer capability to the module.\n///\n/// ```\n/// struct MyModuleResource has key {\n///     ...\n///     resource_signer_cap: Option<SignerCapability>,\n/// }\n///\n/// public fun provide_signer_capability(resource_signer_cap: SignerCapability) {\n///    let account_addr = account::get_signer_capability_address(resource_signer_cap);\n///    let resource_addr = type_info::account_address(&type_info::type_of<MyModuleResource>());\n///    assert!(account_addr == resource_addr, EADDRESS_MISMATCH);\n///    let module = borrow_global_mut<MyModuleResource>(account_addr);\n///    module.resource_signer_cap = option::some(resource_signer_cap);\n/// }\n/// ```\nmodule aptos_framework::resource_account {\n    use std::error;\n    use std::signer;\n    use std::vector;\n    use aptos_framework::account;\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::coin;\n    use aptos_std::simple_map::{Self, SimpleMap};\n\n    /// Container resource not found in account\n    const ECONTAINER_NOT_PUBLISHED: u64 = 1;\n    /// The resource account was not created by the specified source account\n    const EUNAUTHORIZED_NOT_OWNER: u64 = 2;\n\n    const ZERO_AUTH_KEY: vector<u8> = x\"0000000000000000000000000000000000000000000000000000000000000000\";\n\n    struct Container has key {\n        store: SimpleMap<address, account::SignerCapability>,\n    }\n\n    /// Creates a new resource account and rotates the authentication key to either\n    /// the optional auth key if it is non-empty (though auth keys are 32-bytes)\n    /// or the source accounts current auth key.\n    public entry fun create_resource_account(\n        origin: &signer,\n        seed: vector<u8>,\n        optional_auth_key: vector<u8>,\n    ) acquires Container {\n        let (resource, resource_signer_cap) = account::create_resource_account(origin, seed);\n        rotate_account_authentication_key_and_store_capability(\n            origin,\n            resource,\n            resource_signer_cap,\n            optional_auth_key,\n        );\n    }\n\n    /// Creates a new resource account, transfer the amount of coins from the origin to the resource\n    /// account, and rotates the authentication key to either the optional auth key if it is\n    /// non-empty (though auth keys are 32-bytes) or the source accounts current auth key. Note,\n    /// this function adds additional resource ownership to the resource account and should only be\n    /// used for resource accounts that need access to `Coin<AptosCoin>`.\n    public entry fun create_resource_account_and_fund(\n        origin: &signer,\n        seed: vector<u8>,\n        optional_auth_key: vector<u8>,\n        fund_amount: u64,\n    ) acquires Container {\n        let (resource, resource_signer_cap) = account::create_resource_account(origin, seed);\n        coin::register<AptosCoin>(&resource);\n        coin::transfer<AptosCoin>(origin, signer::address_of(&resource), fund_amount);\n        rotate_account_authentication_key_and_store_capability(\n            origin,\n            resource,\n            resource_signer_cap,\n            optional_auth_key,\n        );\n    }\n\n    /// Creates a new resource account, publishes the package under this account transaction under\n    /// this account and leaves the signer cap readily available for pickup.\n    public entry fun create_resource_account_and_publish_package(\n        origin: &signer,\n        seed: vector<u8>,\n        metadata_serialized: vector<u8>,\n        code: vector<vector<u8>>,\n    ) acquires Container {\n        let (resource, resource_signer_cap) = account::create_resource_account(origin, seed);\n        aptos_framework::code::publish_package_txn(&resource, metadata_serialized, code);\n        rotate_account_authentication_key_and_store_capability(\n            origin,\n            resource,\n            resource_signer_cap,\n            ZERO_AUTH_KEY,\n        );\n    }\n\n    fun rotate_account_authentication_key_and_store_capability(\n        origin: &signer,\n        resource: signer,\n        resource_signer_cap: account::SignerCapability,\n        optional_auth_key: vector<u8>,\n    ) acquires Container {\n        let origin_addr = signer::address_of(origin);\n        if (!exists<Container>(origin_addr)) {\n            move_to(origin, Container { store: simple_map::create() })\n        };\n\n        let container = borrow_global_mut<Container>(origin_addr);\n        let resource_addr = signer::address_of(&resource);\n        simple_map::add(&mut container.store, resource_addr, resource_signer_cap);\n\n        let auth_key = if (vector::is_empty(&optional_auth_key)) {\n            account::get_authentication_key(origin_addr)\n        } else {\n            optional_auth_key\n        };\n        account::rotate_authentication_key_internal(&resource, auth_key);\n    }\n\n    /// When called by the resource account, it will retrieve the capability associated with that\n    /// account and rotate the account's auth key to 0x0 making the account inaccessible without\n    /// the SignerCapability.\n    public fun retrieve_resource_account_cap(\n        resource: &signer,\n        source_addr: address,\n    ): account::SignerCapability acquires Container {\n        assert!(exists<Container>(source_addr), error::not_found(ECONTAINER_NOT_PUBLISHED));\n\n        let resource_addr = signer::address_of(resource);\n        let (resource_signer_cap, empty_container) = {\n            let container = borrow_global_mut<Container>(source_addr);\n            assert!(\n                simple_map::contains_key(&container.store, &resource_addr),\n                error::invalid_argument(EUNAUTHORIZED_NOT_OWNER)\n            );\n            let (_resource_addr, signer_cap) = simple_map::remove(&mut container.store, &resource_addr);\n            (signer_cap, simple_map::length(&container.store) == 0)\n        };\n\n        if (empty_container) {\n            let container = move_from(source_addr);\n            let Container { store } = container;\n            simple_map::destroy_empty(store);\n        };\n\n        account::rotate_authentication_key_internal(resource, ZERO_AUTH_KEY);\n        resource_signer_cap\n    }\n\n    #[test(user = @0x1111)]\n    public entry fun test_create_account_and_retrieve_cap(user: signer) acquires Container {\n        let user_addr = signer::address_of(&user);\n        account::create_account(user_addr);\n\n        let seed = x\"01\";\n\n        create_resource_account(&user, copy seed, vector::empty());\n        let container = borrow_global<Container>(user_addr);\n\n        let resource_addr = aptos_framework::account::create_resource_address(&user_addr, seed);\n        let resource_cap = simple_map::borrow(&container.store, &resource_addr);\n\n        let resource = account::create_signer_with_capability(resource_cap);\n        let _resource_cap = retrieve_resource_account_cap(&resource, user_addr);\n    }\n\n    #[test(user = @0x1111)]\n    #[expected_failure(abort_code = 0x10002, location = aptos_std::simple_map)]\n    public entry fun test_create_account_and_retrieve_cap_resource_address_does_not_exist(\n        user: signer\n    ) acquires Container {\n        let user_addr = signer::address_of(&user);\n        account::create_account(user_addr);\n\n        let seed = x\"01\";\n        let seed2 = x\"02\";\n\n        create_resource_account(&user, seed2, vector::empty());\n        let container = borrow_global<Container>(user_addr);\n\n        let resource_addr = account::create_resource_address(&user_addr, seed);\n        let resource_cap = simple_map::borrow(&container.store, &resource_addr);\n\n        let resource = account::create_signer_with_capability(resource_cap);\n        let _resource_cap = retrieve_resource_account_cap(&resource, user_addr);\n    }\n\n    #[test(framework = @0x1, user = @0x1234)]\n    public entry fun with_coin(framework: signer, user: signer) acquires Container {\n        let user_addr = signer::address_of(&user);\n        let (burn, mint) = aptos_framework::aptos_coin::initialize_for_test(&framework);\n        aptos_framework::aptos_account::create_account(copy user_addr);\n\n        let coin = coin::mint<AptosCoin>(100, &mint);\n        coin::deposit(copy user_addr, coin);\n\n        let seed = x\"01\";\n        create_resource_account_and_fund(&user, copy seed, vector::empty(), 10);\n\n        let resource_addr = aptos_framework::account::create_resource_address(&user_addr, seed);\n        coin::transfer<AptosCoin>(&user, resource_addr, 10);\n\n        coin::destroy_burn_cap(burn);\n        coin::destroy_mint_cap(mint);\n    }\n\n    #[test(framework = @0x1, user = @0x2345)]\n    #[expected_failure(abort_code = 0x60005, location = aptos_framework::coin)]\n    public entry fun without_coin(framework: signer, user: signer) acquires Container {\n        let user_addr = signer::address_of(&user);\n        let (burn, mint) = aptos_framework::aptos_coin::initialize_for_test(&framework);\n        aptos_framework::aptos_account::create_account(user_addr);\n\n        let seed = x\"01\";\n        create_resource_account(&user, copy seed, vector::empty());\n\n        let resource_addr = aptos_framework::account::create_resource_address(&user_addr, seed);\n        let coin = coin::mint<AptosCoin>(100, &mint);\n        coin::deposit(resource_addr, coin);\n\n        coin::destroy_burn_cap(burn);\n        coin::destroy_mint_cap(mint);\n    }\n}\n","name":"resource_account.move"},{"content":"///\n/// Validator lifecycle:\n/// 1. Prepare a validator node set up and call stake::initialize_validator\n/// 2. Once ready to deposit stake (or have funds assigned by a staking service in exchange for ownership capability),\n/// call stake::add_stake (or *_with_cap versions if called from the staking service)\n/// 3. Call stake::join_validator_set (or _with_cap version) to join the active validator set. Changes are effective in\n/// the next epoch.\n/// 4. Validate and gain rewards. The stake will automatically be locked up for a fixed duration (set by governance) and\n/// automatically renewed at expiration.\n/// 5. At any point, if the validator operator wants to update the consensus key or network/fullnode addresses, they can\n/// call stake::rotate_consensus_key and stake::update_network_and_fullnode_addresses. Similar to changes to stake, the\n/// changes to consensus key/network/fullnode addresses are only effective in the next epoch.\n/// 6. Validator can request to unlock their stake at any time. However, their stake will only become withdrawable when\n/// their current lockup expires. This can be at most as long as the fixed lockup duration.\n/// 7. After exiting, the validator can either explicitly leave the validator set by calling stake::leave_validator_set\n/// or if their stake drops below the min required, they would get removed at the end of the epoch.\n/// 8. Validator can always rejoin the validator set by going through steps 2-3 again.\n/// 9. An owner can always switch operators by calling stake::set_operator.\n/// 10. An owner can always switch designated voter by calling stake::set_designated_voter.\nmodule aptos_framework::stake {\n    use std::error;\n    use std::features;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::vector;\n    use aptos_std::bls12381;\n    use aptos_std::math64::min;\n    use aptos_std::table::{Self, Table};\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::account;\n    use aptos_framework::coin::{Self, Coin, MintCapability};\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::timestamp;\n    use aptos_framework::system_addresses;\n    use aptos_framework::staking_config::{Self, StakingConfig, StakingRewardsConfig};\n    use aptos_framework::chain_status;\n\n    friend aptos_framework::block;\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration;\n    friend aptos_framework::reconfiguration_with_dkg;\n    friend aptos_framework::transaction_fee;\n\n    /// Validator Config not published.\n    const EVALIDATOR_CONFIG: u64 = 1;\n    /// Not enough stake to join validator set.\n    const ESTAKE_TOO_LOW: u64 = 2;\n    /// Too much stake to join validator set.\n    const ESTAKE_TOO_HIGH: u64 = 3;\n    /// Account is already a validator or pending validator.\n    const EALREADY_ACTIVE_VALIDATOR: u64 = 4;\n    /// Account is not a validator.\n    const ENOT_VALIDATOR: u64 = 5;\n    /// Can't remove last validator.\n    const ELAST_VALIDATOR: u64 = 6;\n    /// Total stake exceeds maximum allowed.\n    const ESTAKE_EXCEEDS_MAX: u64 = 7;\n    /// Account is already registered as a validator candidate.\n    const EALREADY_REGISTERED: u64 = 8;\n    /// Account does not have the right operator capability.\n    const ENOT_OPERATOR: u64 = 9;\n    /// Validators cannot join or leave post genesis on this test network.\n    const ENO_POST_GENESIS_VALIDATOR_SET_CHANGE_ALLOWED: u64 = 10;\n    /// Invalid consensus public key\n    const EINVALID_PUBLIC_KEY: u64 = 11;\n    /// Validator set exceeds the limit\n    const EVALIDATOR_SET_TOO_LARGE: u64 = 12;\n    /// Voting power increase has exceeded the limit for this current epoch.\n    const EVOTING_POWER_INCREASE_EXCEEDS_LIMIT: u64 = 13;\n    /// Stake pool does not exist at the provided pool address.\n    const ESTAKE_POOL_DOES_NOT_EXIST: u64 = 14;\n    /// Owner capability does not exist at the provided account.\n    const EOWNER_CAP_NOT_FOUND: u64 = 15;\n    /// An account cannot own more than one owner capability.\n    const EOWNER_CAP_ALREADY_EXISTS: u64 = 16;\n    /// Validator is not defined in the ACL of entities allowed to be validators\n    const EINELIGIBLE_VALIDATOR: u64 = 17;\n    /// Cannot update stake pool's lockup to earlier than current lockup.\n    const EINVALID_LOCKUP: u64 = 18;\n    /// Table to store collected transaction fees for each validator already exists.\n    const EFEES_TABLE_ALREADY_EXISTS: u64 = 19;\n    /// Validator set change temporarily disabled because of in-progress reconfiguration.\n    const ERECONFIGURATION_IN_PROGRESS: u64 = 20;\n\n    /// Validator status enum. We can switch to proper enum later once Move supports it.\n    const VALIDATOR_STATUS_PENDING_ACTIVE: u64 = 1;\n    const VALIDATOR_STATUS_ACTIVE: u64 = 2;\n    const VALIDATOR_STATUS_PENDING_INACTIVE: u64 = 3;\n    const VALIDATOR_STATUS_INACTIVE: u64 = 4;\n\n    /// Limit the maximum size to u16::max, it's the current limit of the bitvec\n    /// https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-bitvec/src/lib.rs#L20\n    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;\n\n    /// Limit the maximum value of `rewards_rate` in order to avoid any arithmetic overflow.\n    const MAX_REWARDS_RATE: u64 = 1000000;\n\n    const MAX_U64: u128 = 18446744073709551615;\n\n    /// Capability that represents ownership and can be used to control the validator and the associated stake pool.\n    /// Having this be separate from the signer for the account that the validator resources are hosted at allows\n    /// modules to have control over a validator.\n    struct OwnerCapability has key, store {\n        pool_address: address,\n    }\n\n    /// Each validator has a separate StakePool resource and can provide a stake.\n    /// Changes in stake for an active validator:\n    /// 1. If a validator calls add_stake, the newly added stake is moved to pending_active.\n    /// 2. If validator calls unlock, their stake is moved to pending_inactive.\n    /// 2. When the next epoch starts, any pending_inactive stake is moved to inactive and can be withdrawn.\n    ///    Any pending_active stake is moved to active and adds to the validator's voting power.\n    ///\n    /// Changes in stake for an inactive validator:\n    /// 1. If a validator calls add_stake, the newly added stake is moved directly to active.\n    /// 2. If validator calls unlock, their stake is moved directly to inactive.\n    /// 3. When the next epoch starts, the validator can be activated if their active stake is more than the minimum.\n    struct StakePool has key {\n        // active stake\n        active: Coin<AptosCoin>,\n        // inactive stake, can be withdrawn\n        inactive: Coin<AptosCoin>,\n        // pending activation for next epoch\n        pending_active: Coin<AptosCoin>,\n        // pending deactivation for next epoch\n        pending_inactive: Coin<AptosCoin>,\n        locked_until_secs: u64,\n        // Track the current operator of the validator node.\n        // This allows the operator to be different from the original account and allow for separation of\n        // the validator operations and ownership.\n        // Only the account holding OwnerCapability of the staking pool can update this.\n        operator_address: address,\n\n        // Track the current vote delegator of the staking pool.\n        // Only the account holding OwnerCapability of the staking pool can update this.\n        delegated_voter: address,\n\n        // The events emitted for the entire StakePool's lifecycle.\n        initialize_validator_events: EventHandle<RegisterValidatorCandidateEvent>,\n        set_operator_events: EventHandle<SetOperatorEvent>,\n        add_stake_events: EventHandle<AddStakeEvent>,\n        reactivate_stake_events: EventHandle<ReactivateStakeEvent>,\n        rotate_consensus_key_events: EventHandle<RotateConsensusKeyEvent>,\n        update_network_and_fullnode_addresses_events: EventHandle<UpdateNetworkAndFullnodeAddressesEvent>,\n        increase_lockup_events: EventHandle<IncreaseLockupEvent>,\n        join_validator_set_events: EventHandle<JoinValidatorSetEvent>,\n        distribute_rewards_events: EventHandle<DistributeRewardsEvent>,\n        unlock_stake_events: EventHandle<UnlockStakeEvent>,\n        withdraw_stake_events: EventHandle<WithdrawStakeEvent>,\n        leave_validator_set_events: EventHandle<LeaveValidatorSetEvent>,\n    }\n\n    /// Validator info stored in validator address.\n    struct ValidatorConfig has key, copy, store, drop {\n        consensus_pubkey: vector<u8>,\n        network_addresses: vector<u8>,\n        // to make it compatible with previous definition, remove later\n        fullnode_addresses: vector<u8>,\n        // Index in the active set if the validator corresponding to this stake pool is active.\n        validator_index: u64,\n    }\n\n    /// Consensus information per validator, stored in ValidatorSet.\n    struct ValidatorInfo has copy, store, drop {\n        addr: address,\n        voting_power: u64,\n        config: ValidatorConfig,\n    }\n\n    /// Full ValidatorSet, stored in @aptos_framework.\n    /// 1. join_validator_set adds to pending_active queue.\n    /// 2. leave_valdiator_set moves from active to pending_inactive queue.\n    /// 3. on_new_epoch processes two pending queues and refresh ValidatorInfo from the owner's address.\n    struct ValidatorSet has copy, key, drop, store {\n        consensus_scheme: u8,\n        // Active validators for the current epoch.\n        active_validators: vector<ValidatorInfo>,\n        // Pending validators to leave in next epoch (still active).\n        pending_inactive: vector<ValidatorInfo>,\n        // Pending validators to join in next epoch.\n        pending_active: vector<ValidatorInfo>,\n        // Current total voting power.\n        total_voting_power: u128,\n        // Total voting power waiting to join in the next epoch.\n        total_joining_power: u128,\n    }\n\n    /// AptosCoin capabilities, set during genesis and stored in @CoreResource account.\n    /// This allows the Stake module to mint rewards to stakers.\n    struct AptosCoinCapabilities has key {\n        mint_cap: MintCapability<AptosCoin>,\n    }\n\n    struct IndividualValidatorPerformance has store, drop {\n        successful_proposals: u64,\n        failed_proposals: u64,\n    }\n\n    struct ValidatorPerformance has key {\n        validators: vector<IndividualValidatorPerformance>,\n    }\n\n    struct RegisterValidatorCandidateEvent has drop, store {\n        pool_address: address,\n    }\n\n    #[event]\n    struct RegisterValidatorCandidate has drop, store {\n        pool_address: address,\n    }\n\n    struct SetOperatorEvent has drop, store {\n        pool_address: address,\n        old_operator: address,\n        new_operator: address,\n    }\n\n    #[event]\n    struct SetOperator has drop, store {\n        pool_address: address,\n        old_operator: address,\n        new_operator: address,\n    }\n\n    struct AddStakeEvent has drop, store {\n        pool_address: address,\n        amount_added: u64,\n    }\n\n    #[event]\n    struct AddStake has drop, store {\n        pool_address: address,\n        amount_added: u64,\n    }\n\n    struct ReactivateStakeEvent has drop, store {\n        pool_address: address,\n        amount: u64,\n    }\n\n    #[event]\n    struct ReactivateStake has drop, store {\n        pool_address: address,\n        amount: u64,\n    }\n\n    struct RotateConsensusKeyEvent has drop, store {\n        pool_address: address,\n        old_consensus_pubkey: vector<u8>,\n        new_consensus_pubkey: vector<u8>,\n    }\n\n    #[event]\n    struct RotateConsensusKey has drop, store {\n        pool_address: address,\n        old_consensus_pubkey: vector<u8>,\n        new_consensus_pubkey: vector<u8>,\n    }\n\n    struct UpdateNetworkAndFullnodeAddressesEvent has drop, store {\n        pool_address: address,\n        old_network_addresses: vector<u8>,\n        new_network_addresses: vector<u8>,\n        old_fullnode_addresses: vector<u8>,\n        new_fullnode_addresses: vector<u8>,\n    }\n\n    #[event]\n    struct UpdateNetworkAndFullnodeAddresses has drop, store {\n        pool_address: address,\n        old_network_addresses: vector<u8>,\n        new_network_addresses: vector<u8>,\n        old_fullnode_addresses: vector<u8>,\n        new_fullnode_addresses: vector<u8>,\n    }\n\n    struct IncreaseLockupEvent has drop, store {\n        pool_address: address,\n        old_locked_until_secs: u64,\n        new_locked_until_secs: u64,\n    }\n\n    #[event]\n    struct IncreaseLockup has drop, store {\n        pool_address: address,\n        old_locked_until_secs: u64,\n        new_locked_until_secs: u64,\n    }\n\n    struct JoinValidatorSetEvent has drop, store {\n        pool_address: address,\n    }\n\n    #[event]\n    struct JoinValidatorSet has drop, store {\n        pool_address: address,\n    }\n\n    struct DistributeRewardsEvent has drop, store {\n        pool_address: address,\n        rewards_amount: u64,\n    }\n\n    #[event]\n    struct DistributeRewards has drop, store {\n        pool_address: address,\n        rewards_amount: u64,\n    }\n\n    struct UnlockStakeEvent has drop, store {\n        pool_address: address,\n        amount_unlocked: u64,\n    }\n\n    #[event]\n    struct UnlockStake has drop, store {\n        pool_address: address,\n        amount_unlocked: u64,\n    }\n\n    struct WithdrawStakeEvent has drop, store {\n        pool_address: address,\n        amount_withdrawn: u64,\n    }\n\n    #[event]\n    struct WithdrawStake has drop, store {\n        pool_address: address,\n        amount_withdrawn: u64,\n    }\n\n    struct LeaveValidatorSetEvent has drop, store {\n        pool_address: address,\n    }\n\n    #[event]\n    struct LeaveValidatorSet has drop, store {\n        pool_address: address,\n    }\n\n    /// Stores transaction fees assigned to validators. All fees are distributed to validators\n    /// at the end of the epoch.\n    struct ValidatorFees has key {\n        fees_table: Table<address, Coin<AptosCoin>>,\n    }\n\n    /// Initializes the resource storing information about collected transaction fees per validator.\n    /// Used by `transaction_fee.move` to initialize fee collection and distribution.\n    public(friend) fun initialize_validator_fees(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(\n            !exists<ValidatorFees>(@aptos_framework),\n            error::already_exists(EFEES_TABLE_ALREADY_EXISTS)\n        );\n        move_to(aptos_framework, ValidatorFees { fees_table: table::new() });\n    }\n\n    /// Stores the transaction fee collected to the specified validator address.\n    public(friend) fun add_transaction_fee(validator_addr: address, fee: Coin<AptosCoin>) acquires ValidatorFees {\n        let fees_table = &mut borrow_global_mut<ValidatorFees>(@aptos_framework).fees_table;\n        if (table::contains(fees_table, validator_addr)) {\n            let collected_fee = table::borrow_mut(fees_table, validator_addr);\n            coin::merge(collected_fee, fee);\n        } else {\n            table::add(fees_table, validator_addr, fee);\n        }\n    }\n\n    #[view]\n    /// Return the lockup expiration of the stake pool at `pool_address`.\n    /// This will throw an error if there's no stake pool at `pool_address`.\n    public fun get_lockup_secs(pool_address: address): u64 acquires StakePool {\n        assert_stake_pool_exists(pool_address);\n        borrow_global<StakePool>(pool_address).locked_until_secs\n    }\n\n    #[view]\n    /// Return the remaining lockup of the stake pool at `pool_address`.\n    /// This will throw an error if there's no stake pool at `pool_address`.\n    public fun get_remaining_lockup_secs(pool_address: address): u64 acquires StakePool {\n        assert_stake_pool_exists(pool_address);\n        let lockup_time = borrow_global<StakePool>(pool_address).locked_until_secs;\n        if (lockup_time <= timestamp::now_seconds()) {\n            0\n        } else {\n            lockup_time - timestamp::now_seconds()\n        }\n    }\n\n    #[view]\n    /// Return the different stake amounts for `pool_address` (whether the validator is active or not).\n    /// The returned amounts are for (active, inactive, pending_active, pending_inactive) stake respectively.\n    public fun get_stake(pool_address: address): (u64, u64, u64, u64) acquires StakePool {\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global<StakePool>(pool_address);\n        (\n            coin::value(&stake_pool.active),\n            coin::value(&stake_pool.inactive),\n            coin::value(&stake_pool.pending_active),\n            coin::value(&stake_pool.pending_inactive),\n        )\n    }\n\n    #[view]\n    /// Returns the validator's state.\n    public fun get_validator_state(pool_address: address): u64 acquires ValidatorSet {\n        let validator_set = borrow_global<ValidatorSet>(@aptos_framework);\n        if (option::is_some(&find_validator(&validator_set.pending_active, pool_address))) {\n            VALIDATOR_STATUS_PENDING_ACTIVE\n        } else if (option::is_some(&find_validator(&validator_set.active_validators, pool_address))) {\n            VALIDATOR_STATUS_ACTIVE\n        } else if (option::is_some(&find_validator(&validator_set.pending_inactive, pool_address))) {\n            VALIDATOR_STATUS_PENDING_INACTIVE\n        } else {\n            VALIDATOR_STATUS_INACTIVE\n        }\n    }\n\n    #[view]\n    /// Return the voting power of the validator in the current epoch.\n    /// This is the same as the validator's total active and pending_inactive stake.\n    public fun get_current_epoch_voting_power(pool_address: address): u64 acquires StakePool, ValidatorSet {\n        assert_stake_pool_exists(pool_address);\n        let validator_state = get_validator_state(pool_address);\n        // Both active and pending inactive validators can still vote in the current epoch.\n        if (validator_state == VALIDATOR_STATUS_ACTIVE || validator_state == VALIDATOR_STATUS_PENDING_INACTIVE) {\n            let active_stake = coin::value(&borrow_global<StakePool>(pool_address).active);\n            let pending_inactive_stake = coin::value(&borrow_global<StakePool>(pool_address).pending_inactive);\n            active_stake + pending_inactive_stake\n        } else {\n            0\n        }\n    }\n\n    #[view]\n    /// Return the delegated voter of the validator at `pool_address`.\n    public fun get_delegated_voter(pool_address: address): address acquires StakePool {\n        assert_stake_pool_exists(pool_address);\n        borrow_global<StakePool>(pool_address).delegated_voter\n    }\n\n    #[view]\n    /// Return the operator of the validator at `pool_address`.\n    public fun get_operator(pool_address: address): address acquires StakePool {\n        assert_stake_pool_exists(pool_address);\n        borrow_global<StakePool>(pool_address).operator_address\n    }\n\n    /// Return the pool address in `owner_cap`.\n    public fun get_owned_pool_address(owner_cap: &OwnerCapability): address {\n        owner_cap.pool_address\n    }\n\n    #[view]\n    /// Return the validator index for `pool_address`.\n    public fun get_validator_index(pool_address: address): u64 acquires ValidatorConfig {\n        assert_stake_pool_exists(pool_address);\n        borrow_global<ValidatorConfig>(pool_address).validator_index\n    }\n\n    #[view]\n    /// Return the number of successful and failed proposals for the proposal at the given validator index.\n    public fun get_current_epoch_proposal_counts(validator_index: u64): (u64, u64) acquires ValidatorPerformance {\n        let validator_performances = &borrow_global<ValidatorPerformance>(@aptos_framework).validators;\n        let validator_performance = vector::borrow(validator_performances, validator_index);\n        (validator_performance.successful_proposals, validator_performance.failed_proposals)\n    }\n\n    #[view]\n    /// Return the validator's config.\n    public fun get_validator_config(\n        pool_address: address\n    ): (vector<u8>, vector<u8>, vector<u8>) acquires ValidatorConfig {\n        assert_stake_pool_exists(pool_address);\n        let validator_config = borrow_global<ValidatorConfig>(pool_address);\n        (validator_config.consensus_pubkey, validator_config.network_addresses, validator_config.fullnode_addresses)\n    }\n\n    #[view]\n    public fun stake_pool_exists(addr: address): bool {\n        exists<StakePool>(addr)\n    }\n\n    /// Initialize validator set to the core resource account.\n    public(friend) fun initialize(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        move_to(aptos_framework, ValidatorSet {\n            consensus_scheme: 0,\n            active_validators: vector::empty(),\n            pending_active: vector::empty(),\n            pending_inactive: vector::empty(),\n            total_voting_power: 0,\n            total_joining_power: 0,\n        });\n\n        move_to(aptos_framework, ValidatorPerformance {\n            validators: vector::empty(),\n        });\n    }\n\n    /// This is only called during Genesis, which is where MintCapability<AptosCoin> can be created.\n    /// Beyond genesis, no one can create AptosCoin mint/burn capabilities.\n    public(friend) fun store_aptos_coin_mint_cap(aptos_framework: &signer, mint_cap: MintCapability<AptosCoin>) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        move_to(aptos_framework, AptosCoinCapabilities { mint_cap })\n    }\n\n    /// Allow on chain governance to remove validators from the validator set.\n    public fun remove_validators(\n        aptos_framework: &signer,\n        validators: &vector<address>,\n    ) acquires ValidatorSet {\n        assert_reconfig_not_in_progress();\n        system_addresses::assert_aptos_framework(aptos_framework);\n        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);\n        let active_validators = &mut validator_set.active_validators;\n        let pending_inactive = &mut validator_set.pending_inactive;\n        spec {\n            update ghost_active_num = len(active_validators);\n            update ghost_pending_inactive_num = len(pending_inactive);\n        };\n        let len_validators = vector::length(validators);\n        let i = 0;\n        // Remove each validator from the validator set.\n        while ({\n            spec {\n                invariant i <= len_validators;\n                invariant spec_validators_are_initialized(active_validators);\n                invariant spec_validator_indices_are_valid(active_validators);\n                invariant spec_validators_are_initialized(pending_inactive);\n                invariant spec_validator_indices_are_valid(pending_inactive);\n                invariant ghost_active_num + ghost_pending_inactive_num == len(active_validators) + len(pending_inactive);\n            };\n            i < len_validators\n        }) {\n            let validator = *vector::borrow(validators, i);\n            let validator_index = find_validator(active_validators, validator);\n            if (option::is_some(&validator_index)) {\n                let validator_info = vector::swap_remove(active_validators, *option::borrow(&validator_index));\n                vector::push_back(pending_inactive, validator_info);\n                spec {\n                    update ghost_active_num = ghost_active_num - 1;\n                    update ghost_pending_inactive_num = ghost_pending_inactive_num + 1;\n                };\n            };\n            i = i + 1;\n        };\n    }\n\n    /// Initialize the validator account and give ownership to the signing account\n    /// except it leaves the ValidatorConfig to be set by another entity.\n    /// Note: this triggers setting the operator and owner, set it to the account's address\n    /// to set later.\n    public entry fun initialize_stake_owner(\n        owner: &signer,\n        initial_stake_amount: u64,\n        operator: address,\n        voter: address,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, ValidatorSet {\n        initialize_owner(owner);\n        move_to(owner, ValidatorConfig {\n            consensus_pubkey: vector::empty(),\n            network_addresses: vector::empty(),\n            fullnode_addresses: vector::empty(),\n            validator_index: 0,\n        });\n\n        if (initial_stake_amount > 0) {\n            add_stake(owner, initial_stake_amount);\n        };\n\n        let account_address = signer::address_of(owner);\n        if (account_address != operator) {\n            set_operator(owner, operator)\n        };\n        if (account_address != voter) {\n            set_delegated_voter(owner, voter)\n        };\n    }\n\n    /// Initialize the validator account and give ownership to the signing account.\n    public entry fun initialize_validator(\n        account: &signer,\n        consensus_pubkey: vector<u8>,\n        proof_of_possession: vector<u8>,\n        network_addresses: vector<u8>,\n        fullnode_addresses: vector<u8>,\n    ) acquires AllowedValidators {\n        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.\n        let pubkey_from_pop = &mut bls12381::public_key_from_bytes_with_pop(\n            consensus_pubkey,\n            &proof_of_possession_from_bytes(proof_of_possession)\n        );\n        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));\n\n        initialize_owner(account);\n        move_to(account, ValidatorConfig {\n            consensus_pubkey,\n            network_addresses,\n            fullnode_addresses,\n            validator_index: 0,\n        });\n    }\n\n    fun initialize_owner(owner: &signer) acquires AllowedValidators {\n        let owner_address = signer::address_of(owner);\n        assert!(is_allowed(owner_address), error::not_found(EINELIGIBLE_VALIDATOR));\n        assert!(!stake_pool_exists(owner_address), error::already_exists(EALREADY_REGISTERED));\n\n        move_to(owner, StakePool {\n            active: coin::zero<AptosCoin>(),\n            pending_active: coin::zero<AptosCoin>(),\n            pending_inactive: coin::zero<AptosCoin>(),\n            inactive: coin::zero<AptosCoin>(),\n            locked_until_secs: 0,\n            operator_address: owner_address,\n            delegated_voter: owner_address,\n            // Events.\n            initialize_validator_events: account::new_event_handle<RegisterValidatorCandidateEvent>(owner),\n            set_operator_events: account::new_event_handle<SetOperatorEvent>(owner),\n            add_stake_events: account::new_event_handle<AddStakeEvent>(owner),\n            reactivate_stake_events: account::new_event_handle<ReactivateStakeEvent>(owner),\n            rotate_consensus_key_events: account::new_event_handle<RotateConsensusKeyEvent>(owner),\n            update_network_and_fullnode_addresses_events: account::new_event_handle<UpdateNetworkAndFullnodeAddressesEvent>(\n                owner\n            ),\n            increase_lockup_events: account::new_event_handle<IncreaseLockupEvent>(owner),\n            join_validator_set_events: account::new_event_handle<JoinValidatorSetEvent>(owner),\n            distribute_rewards_events: account::new_event_handle<DistributeRewardsEvent>(owner),\n            unlock_stake_events: account::new_event_handle<UnlockStakeEvent>(owner),\n            withdraw_stake_events: account::new_event_handle<WithdrawStakeEvent>(owner),\n            leave_validator_set_events: account::new_event_handle<LeaveValidatorSetEvent>(owner),\n        });\n\n        move_to(owner, OwnerCapability { pool_address: owner_address });\n    }\n\n    /// Extract and return owner capability from the signing account.\n    public fun extract_owner_cap(owner: &signer): OwnerCapability acquires OwnerCapability {\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        move_from<OwnerCapability>(owner_address)\n    }\n\n    /// Deposit `owner_cap` into `account`. This requires `account` to not already have ownership of another\n    /// staking pool.\n    public fun deposit_owner_cap(owner: &signer, owner_cap: OwnerCapability) {\n        assert!(!exists<OwnerCapability>(signer::address_of(owner)), error::not_found(EOWNER_CAP_ALREADY_EXISTS));\n        move_to(owner, owner_cap);\n    }\n\n    /// Destroy `owner_cap`.\n    public fun destroy_owner_cap(owner_cap: OwnerCapability) {\n        let OwnerCapability { pool_address: _ } = owner_cap;\n    }\n\n    /// Allows an owner to change the operator of the stake pool.\n    public entry fun set_operator(owner: &signer, new_operator: address) acquires OwnerCapability, StakePool {\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        let ownership_cap = borrow_global<OwnerCapability>(owner_address);\n        set_operator_with_cap(ownership_cap, new_operator);\n    }\n\n    /// Allows an account with ownership capability to change the operator of the stake pool.\n    public fun set_operator_with_cap(owner_cap: &OwnerCapability, new_operator: address) acquires StakePool {\n        let pool_address = owner_cap.pool_address;\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        let old_operator = stake_pool.operator_address;\n        stake_pool.operator_address = new_operator;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                SetOperator {\n                    pool_address,\n                    old_operator,\n                    new_operator,\n                },\n            );\n        };\n\n        event::emit_event(\n            &mut stake_pool.set_operator_events,\n            SetOperatorEvent {\n                pool_address,\n                old_operator,\n                new_operator,\n            },\n        );\n    }\n\n    /// Allows an owner to change the delegated voter of the stake pool.\n    public entry fun set_delegated_voter(owner: &signer, new_voter: address) acquires OwnerCapability, StakePool {\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        let ownership_cap = borrow_global<OwnerCapability>(owner_address);\n        set_delegated_voter_with_cap(ownership_cap, new_voter);\n    }\n\n    /// Allows an owner to change the delegated voter of the stake pool.\n    public fun set_delegated_voter_with_cap(owner_cap: &OwnerCapability, new_voter: address) acquires StakePool {\n        let pool_address = owner_cap.pool_address;\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        stake_pool.delegated_voter = new_voter;\n    }\n\n    /// Add `amount` of coins from the `account` owning the StakePool.\n    public entry fun add_stake(owner: &signer, amount: u64) acquires OwnerCapability, StakePool, ValidatorSet {\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        let ownership_cap = borrow_global<OwnerCapability>(owner_address);\n        add_stake_with_cap(ownership_cap, coin::withdraw<AptosCoin>(owner, amount));\n    }\n\n    /// Add `coins` into `pool_address`. this requires the corresponding `owner_cap` to be passed in.\n    public fun add_stake_with_cap(owner_cap: &OwnerCapability, coins: Coin<AptosCoin>) acquires StakePool, ValidatorSet {\n        assert_reconfig_not_in_progress();\n        let pool_address = owner_cap.pool_address;\n        assert_stake_pool_exists(pool_address);\n\n        let amount = coin::value(&coins);\n        if (amount == 0) {\n            coin::destroy_zero(coins);\n            return\n        };\n\n        // Only track and validate voting power increase for active and pending_active validator.\n        // Pending_inactive validator will be removed from the validator set in the next epoch.\n        // Inactive validator's total stake will be tracked when they join the validator set.\n        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);\n        // Search directly rather using get_validator_state to save on unnecessary loops.\n        if (option::is_some(&find_validator(&validator_set.active_validators, pool_address)) ||\n            option::is_some(&find_validator(&validator_set.pending_active, pool_address))) {\n            update_voting_power_increase(amount);\n        };\n\n        // Add to pending_active if it's a current validator because the stake is not counted until the next epoch.\n        // Otherwise, the delegation can be added to active directly as the validator is also activated in the epoch.\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        if (is_current_epoch_validator(pool_address)) {\n            coin::merge<AptosCoin>(&mut stake_pool.pending_active, coins);\n        } else {\n            coin::merge<AptosCoin>(&mut stake_pool.active, coins);\n        };\n\n        let (_, maximum_stake) = staking_config::get_required_stake(&staking_config::get());\n        let voting_power = get_next_epoch_voting_power(stake_pool);\n        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_EXCEEDS_MAX));\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                AddStake {\n                    pool_address,\n                    amount_added: amount,\n                },\n            );\n        };\n        event::emit_event(\n            &mut stake_pool.add_stake_events,\n            AddStakeEvent {\n                pool_address,\n                amount_added: amount,\n            },\n        );\n    }\n\n    /// Move `amount` of coins from pending_inactive to active.\n    public entry fun reactivate_stake(owner: &signer, amount: u64) acquires OwnerCapability, StakePool {\n        assert_reconfig_not_in_progress();\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        let ownership_cap = borrow_global<OwnerCapability>(owner_address);\n        reactivate_stake_with_cap(ownership_cap, amount);\n    }\n\n    public fun reactivate_stake_with_cap(owner_cap: &OwnerCapability, amount: u64) acquires StakePool {\n        assert_reconfig_not_in_progress();\n        let pool_address = owner_cap.pool_address;\n        assert_stake_pool_exists(pool_address);\n\n        // Cap the amount to reactivate by the amount in pending_inactive.\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        let total_pending_inactive = coin::value(&stake_pool.pending_inactive);\n        amount = min(amount, total_pending_inactive);\n\n        // Since this does not count as a voting power change (pending inactive still counts as voting power in the\n        // current epoch), stake can be immediately moved from pending inactive to active.\n        // We also don't need to check voting power increase as there's none.\n        let reactivated_coins = coin::extract(&mut stake_pool.pending_inactive, amount);\n        coin::merge(&mut stake_pool.active, reactivated_coins);\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                ReactivateStake {\n                    pool_address,\n                    amount,\n                },\n            );\n        };\n        event::emit_event(\n            &mut stake_pool.reactivate_stake_events,\n            ReactivateStakeEvent {\n                pool_address,\n                amount,\n            },\n        );\n    }\n\n    /// Rotate the consensus key of the validator, it'll take effect in next epoch.\n    public entry fun rotate_consensus_key(\n        operator: &signer,\n        pool_address: address,\n        new_consensus_pubkey: vector<u8>,\n        proof_of_possession: vector<u8>,\n    ) acquires StakePool, ValidatorConfig {\n        assert_reconfig_not_in_progress();\n        assert_stake_pool_exists(pool_address);\n\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));\n\n        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));\n        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);\n        let old_consensus_pubkey = validator_info.consensus_pubkey;\n        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.\n        let pubkey_from_pop = &mut bls12381::public_key_from_bytes_with_pop(\n            new_consensus_pubkey,\n            &proof_of_possession_from_bytes(proof_of_possession)\n        );\n        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));\n        validator_info.consensus_pubkey = new_consensus_pubkey;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                RotateConsensusKey {\n                    pool_address,\n                    old_consensus_pubkey,\n                    new_consensus_pubkey,\n                },\n            );\n        };\n        event::emit_event(\n            &mut stake_pool.rotate_consensus_key_events,\n            RotateConsensusKeyEvent {\n                pool_address,\n                old_consensus_pubkey,\n                new_consensus_pubkey,\n            },\n        );\n    }\n\n    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.\n    public entry fun update_network_and_fullnode_addresses(\n        operator: &signer,\n        pool_address: address,\n        new_network_addresses: vector<u8>,\n        new_fullnode_addresses: vector<u8>,\n    ) acquires StakePool, ValidatorConfig {\n        assert_reconfig_not_in_progress();\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));\n        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));\n        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);\n        let old_network_addresses = validator_info.network_addresses;\n        validator_info.network_addresses = new_network_addresses;\n        let old_fullnode_addresses = validator_info.fullnode_addresses;\n        validator_info.fullnode_addresses = new_fullnode_addresses;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                UpdateNetworkAndFullnodeAddresses {\n                    pool_address,\n                    old_network_addresses,\n                    new_network_addresses,\n                    old_fullnode_addresses,\n                    new_fullnode_addresses,\n                },\n            );\n        };\n        event::emit_event(\n            &mut stake_pool.update_network_and_fullnode_addresses_events,\n            UpdateNetworkAndFullnodeAddressesEvent {\n                pool_address,\n                old_network_addresses,\n                new_network_addresses,\n                old_fullnode_addresses,\n                new_fullnode_addresses,\n            },\n        );\n\n    }\n\n    /// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.\n    public entry fun increase_lockup(owner: &signer) acquires OwnerCapability, StakePool {\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        let ownership_cap = borrow_global<OwnerCapability>(owner_address);\n        increase_lockup_with_cap(ownership_cap);\n    }\n\n    /// Unlock from active delegation, it's moved to pending_inactive if locked_until_secs < current_time or\n    /// directly inactive if it's not from an active validator.\n    public fun increase_lockup_with_cap(owner_cap: &OwnerCapability) acquires StakePool {\n        let pool_address = owner_cap.pool_address;\n        assert_stake_pool_exists(pool_address);\n        let config = staking_config::get();\n\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        let old_locked_until_secs = stake_pool.locked_until_secs;\n        let new_locked_until_secs = timestamp::now_seconds() + staking_config::get_recurring_lockup_duration(&config);\n        assert!(old_locked_until_secs < new_locked_until_secs, error::invalid_argument(EINVALID_LOCKUP));\n        stake_pool.locked_until_secs = new_locked_until_secs;\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                IncreaseLockup {\n                    pool_address,\n                    old_locked_until_secs,\n                    new_locked_until_secs,\n                },\n            );\n        };\n        event::emit_event(\n            &mut stake_pool.increase_lockup_events,\n            IncreaseLockupEvent {\n                pool_address,\n                old_locked_until_secs,\n                new_locked_until_secs,\n            },\n        );\n    }\n\n    /// This can only called by the operator of the validator/staking pool.\n    public entry fun join_validator_set(\n        operator: &signer,\n        pool_address: address\n    ) acquires StakePool, ValidatorConfig, ValidatorSet {\n        assert!(\n            staking_config::get_allow_validator_set_change(&staking_config::get()),\n            error::invalid_argument(ENO_POST_GENESIS_VALIDATOR_SET_CHANGE_ALLOWED),\n        );\n\n        join_validator_set_internal(operator, pool_address);\n    }\n\n    /// Request to have `pool_address` join the validator set. Can only be called after calling `initialize_validator`.\n    /// If the validator has the required stake (more than minimum and less than maximum allowed), they will be\n    /// added to the pending_active queue. All validators in this queue will be added to the active set when the next\n    /// epoch starts (eligibility will be rechecked).\n    ///\n    /// This internal version can only be called by the Genesis module during Genesis.\n    public(friend) fun join_validator_set_internal(\n        operator: &signer,\n        pool_address: address\n    ) acquires StakePool, ValidatorConfig, ValidatorSet {\n        assert_reconfig_not_in_progress();\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));\n        assert!(\n            get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE,\n            error::invalid_state(EALREADY_ACTIVE_VALIDATOR),\n        );\n\n        let config = staking_config::get();\n        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);\n        let voting_power = get_next_epoch_voting_power(stake_pool);\n        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));\n        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));\n\n        // Track and validate voting power increase.\n        update_voting_power_increase(voting_power);\n\n        // Add validator to pending_active, to be activated in the next epoch.\n        let validator_config = borrow_global_mut<ValidatorConfig>(pool_address);\n        assert!(!vector::is_empty(&validator_config.consensus_pubkey), error::invalid_argument(EINVALID_PUBLIC_KEY));\n\n        // Validate the current validator set size has not exceeded the limit.\n        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);\n        vector::push_back(\n            &mut validator_set.pending_active,\n            generate_validator_info(pool_address, stake_pool, *validator_config)\n        );\n        let validator_set_size = vector::length(&validator_set.active_validators) + vector::length(\n            &validator_set.pending_active\n        );\n        assert!(validator_set_size <= MAX_VALIDATOR_SET_SIZE, error::invalid_argument(EVALIDATOR_SET_TOO_LARGE));\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(JoinValidatorSet { pool_address });\n        };\n        event::emit_event(\n            &mut stake_pool.join_validator_set_events,\n            JoinValidatorSetEvent { pool_address },\n        );\n    }\n\n    /// Similar to unlock_with_cap but will use ownership capability from the signing account.\n    public entry fun unlock(owner: &signer, amount: u64) acquires OwnerCapability, StakePool {\n        assert_reconfig_not_in_progress();\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        let ownership_cap = borrow_global<OwnerCapability>(owner_address);\n        unlock_with_cap(amount, ownership_cap);\n    }\n\n    /// Unlock `amount` from the active stake. Only possible if the lockup has expired.\n    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {\n        assert_reconfig_not_in_progress();\n        // Short-circuit if amount to unlock is 0 so we don't emit events.\n        if (amount == 0) {\n            return\n        };\n\n        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into\n        // inactive in the earliest possible epoch transition.\n        let pool_address = owner_cap.pool_address;\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        // Cap amount to unlock by maximum active stake.\n        let amount = min(amount, coin::value(&stake_pool.active));\n        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);\n        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                UnlockStake {\n                    pool_address,\n                    amount_unlocked: amount,\n                },\n            );\n        };\n        event::emit_event(\n            &mut stake_pool.unlock_stake_events,\n            UnlockStakeEvent {\n                pool_address,\n                amount_unlocked: amount,\n            },\n        );\n    }\n\n    /// Withdraw from `account`'s inactive stake.\n    public entry fun withdraw(\n        owner: &signer,\n        withdraw_amount: u64\n    ) acquires OwnerCapability, StakePool, ValidatorSet {\n        let owner_address = signer::address_of(owner);\n        assert_owner_cap_exists(owner_address);\n        let ownership_cap = borrow_global<OwnerCapability>(owner_address);\n        let coins = withdraw_with_cap(ownership_cap, withdraw_amount);\n        coin::deposit<AptosCoin>(owner_address, coins);\n    }\n\n    /// Withdraw from `pool_address`'s inactive stake with the corresponding `owner_cap`.\n    public fun withdraw_with_cap(\n        owner_cap: &OwnerCapability,\n        withdraw_amount: u64\n    ): Coin<AptosCoin> acquires StakePool, ValidatorSet {\n        assert_reconfig_not_in_progress();\n        let pool_address = owner_cap.pool_address;\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        // There's an edge case where a validator unlocks their stake and leaves the validator set before\n        // the stake is fully unlocked (the current lockup cycle has not expired yet).\n        // This can leave their stake stuck in pending_inactive even after the current lockup cycle expires.\n        if (get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE &&\n            timestamp::now_seconds() >= stake_pool.locked_until_secs) {\n            let pending_inactive_stake = coin::extract_all(&mut stake_pool.pending_inactive);\n            coin::merge(&mut stake_pool.inactive, pending_inactive_stake);\n        };\n\n        // Cap withdraw amount by total inactive coins.\n        withdraw_amount = min(withdraw_amount, coin::value(&stake_pool.inactive));\n        if (withdraw_amount == 0) return coin::zero<AptosCoin>();\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                WithdrawStake {\n                    pool_address,\n                    amount_withdrawn: withdraw_amount,\n                },\n            );\n        };\n        event::emit_event(\n            &mut stake_pool.withdraw_stake_events,\n            WithdrawStakeEvent {\n                pool_address,\n                amount_withdrawn: withdraw_amount,\n            },\n        );\n\n        coin::extract(&mut stake_pool.inactive, withdraw_amount)\n    }\n\n    /// Request to have `pool_address` leave the validator set. The validator is only actually removed from the set when\n    /// the next epoch starts.\n    /// The last validator in the set cannot leave. This is an edge case that should never happen as long as the network\n    /// is still operational.\n    ///\n    /// Can only be called by the operator of the validator/staking pool.\n    public entry fun leave_validator_set(\n        operator: &signer,\n        pool_address: address\n    ) acquires StakePool, ValidatorSet {\n        assert_reconfig_not_in_progress();\n        let config = staking_config::get();\n        assert!(\n            staking_config::get_allow_validator_set_change(&config),\n            error::invalid_argument(ENO_POST_GENESIS_VALIDATOR_SET_CHANGE_ALLOWED),\n        );\n\n        assert_stake_pool_exists(pool_address);\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        // Account has to be the operator.\n        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));\n\n        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);\n        // If the validator is still pending_active, directly kick the validator out.\n        let maybe_pending_active_index = find_validator(&validator_set.pending_active, pool_address);\n        if (option::is_some(&maybe_pending_active_index)) {\n            vector::swap_remove(\n                &mut validator_set.pending_active, option::extract(&mut maybe_pending_active_index));\n\n            // Decrease the voting power increase as the pending validator's voting power was added when they requested\n            // to join. Now that they changed their mind, their voting power should not affect the joining limit of this\n            // epoch.\n            let validator_stake = (get_next_epoch_voting_power(stake_pool) as u128);\n            // total_joining_power should be larger than validator_stake but just in case there has been a small\n            // rounding error somewhere that can lead to an underflow, we still want to allow this transaction to\n            // succeed.\n            if (validator_set.total_joining_power > validator_stake) {\n                validator_set.total_joining_power = validator_set.total_joining_power - validator_stake;\n            } else {\n                validator_set.total_joining_power = 0;\n            };\n        } else {\n            // Validate that the validator is already part of the validator set.\n            let maybe_active_index = find_validator(&validator_set.active_validators, pool_address);\n            assert!(option::is_some(&maybe_active_index), error::invalid_state(ENOT_VALIDATOR));\n            let validator_info = vector::swap_remove(\n                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));\n            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));\n            vector::push_back(&mut validator_set.pending_inactive, validator_info);\n\n            if (std::features::module_event_migration_enabled()) {\n                event::emit(LeaveValidatorSet { pool_address });\n            };\n            event::emit_event(\n                &mut stake_pool.leave_validator_set_events,\n                LeaveValidatorSetEvent {\n                    pool_address,\n                },\n            );\n        };\n    }\n\n    /// Returns true if the current validator can still vote in the current epoch.\n    /// This includes validators that requested to leave but are still in the pending_inactive queue and will be removed\n    /// when the epoch starts.\n    public fun is_current_epoch_validator(pool_address: address): bool acquires ValidatorSet {\n        assert_stake_pool_exists(pool_address);\n        let validator_state = get_validator_state(pool_address);\n        validator_state == VALIDATOR_STATUS_ACTIVE || validator_state == VALIDATOR_STATUS_PENDING_INACTIVE\n    }\n\n    /// Update the validator performance (proposal statistics). This is only called by block::prologue().\n    /// This function cannot abort.\n    public(friend) fun update_performance_statistics(\n        proposer_index: Option<u64>,\n        failed_proposer_indices: vector<u64>\n    ) acquires ValidatorPerformance {\n        // Validator set cannot change until the end of the epoch, so the validator index in arguments should\n        // match with those of the validators in ValidatorPerformance resource.\n        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);\n        let validator_len = vector::length(&validator_perf.validators);\n\n        spec {\n            update ghost_valid_perf = validator_perf;\n            update ghost_proposer_idx = proposer_index;\n        };\n        // proposer_index is an option because it can be missing (for NilBlocks)\n        if (option::is_some(&proposer_index)) {\n            let cur_proposer_index = option::extract(&mut proposer_index);\n            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,\n            // this ensures that this function doesn't abort if there are out of bounds errors.\n            if (cur_proposer_index < validator_len) {\n                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);\n                spec {\n                    assume validator.successful_proposals + 1 <= MAX_U64;\n                };\n                validator.successful_proposals = validator.successful_proposals + 1;\n            };\n        };\n\n        let f = 0;\n        let f_len = vector::length(&failed_proposer_indices);\n        while ({\n            spec {\n                invariant len(validator_perf.validators) == validator_len;\n                invariant (option::spec_is_some(ghost_proposer_idx) && option::spec_borrow(\n                    ghost_proposer_idx\n                ) < validator_len) ==>\n                    (validator_perf.validators[option::spec_borrow(ghost_proposer_idx)].successful_proposals ==\n                        ghost_valid_perf.validators[option::spec_borrow(ghost_proposer_idx)].successful_proposals + 1);\n            };\n            f < f_len\n        }) {\n            let validator_index = *vector::borrow(&failed_proposer_indices, f);\n            if (validator_index < validator_len) {\n                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);\n                spec {\n                    assume validator.failed_proposals + 1 <= MAX_U64;\n                };\n                validator.failed_proposals = validator.failed_proposals + 1;\n            };\n            f = f + 1;\n        };\n    }\n\n    /// Triggered during a reconfiguration. This function shouldn't abort.\n    ///\n    /// 1. Distribute transaction fees and rewards to stake pools of active and pending inactive validators (requested\n    /// to leave but not yet removed).\n    /// 2. Officially move pending active stake to active and move pending inactive stake to inactive.\n    /// The staking pool's voting power in this new epoch will be updated to the total active stake.\n    /// 3. Add pending active validators to the active set if they satisfy requirements so they can vote and remove\n    /// pending inactive validators so they no longer can vote.\n    /// 4. The validator's voting power in the validator set is updated to be the corresponding staking pool's voting\n    /// power.\n    public(friend) fun on_new_epoch(\n    ) acquires StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);\n        let config = staking_config::get();\n        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);\n\n        // Process pending stake and distribute transaction fees and rewards for each currently active validator.\n        vector::for_each_ref(&validator_set.active_validators, |validator| {\n            let validator: &ValidatorInfo = validator;\n            update_stake_pool(validator_perf, validator.addr, &config);\n        });\n\n        // Process pending stake and distribute transaction fees and rewards for each currently pending_inactive validator\n        // (requested to leave but not removed yet).\n        vector::for_each_ref(&validator_set.pending_inactive, |validator| {\n            let validator: &ValidatorInfo = validator;\n            update_stake_pool(validator_perf, validator.addr, &config);\n        });\n\n        // Activate currently pending_active validators.\n        append(&mut validator_set.active_validators, &mut validator_set.pending_active);\n\n        // Officially deactivate all pending_inactive validators. They will now no longer receive rewards.\n        validator_set.pending_inactive = vector::empty();\n\n        // Update active validator set so that network address/public key change takes effect.\n        // Moreover, recalculate the total voting power, and deactivate the validator whose\n        // voting power is less than the minimum required stake.\n        let next_epoch_validators = vector::empty();\n        let (minimum_stake, _) = staking_config::get_required_stake(&config);\n        let vlen = vector::length(&validator_set.active_validators);\n        let total_voting_power = 0;\n        let i = 0;\n        while ({\n            spec {\n                invariant spec_validators_are_initialized(next_epoch_validators);\n                invariant i <= vlen;\n            };\n            i < vlen\n        }) {\n            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);\n            let pool_address = old_validator_info.addr;\n            let validator_config = borrow_global_mut<ValidatorConfig>(pool_address);\n            let stake_pool = borrow_global_mut<StakePool>(pool_address);\n            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);\n\n            // A validator needs at least the min stake required to join the validator set.\n            if (new_validator_info.voting_power >= minimum_stake) {\n                spec {\n                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;\n                };\n                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);\n                vector::push_back(&mut next_epoch_validators, new_validator_info);\n            };\n            i = i + 1;\n        };\n\n        validator_set.active_validators = next_epoch_validators;\n        validator_set.total_voting_power = total_voting_power;\n        validator_set.total_joining_power = 0;\n\n        // Update validator indices, reset performance scores, and renew lockups.\n        validator_perf.validators = vector::empty();\n        let recurring_lockup_duration_secs = staking_config::get_recurring_lockup_duration(&config);\n        let vlen = vector::length(&validator_set.active_validators);\n        let validator_index = 0;\n        while ({\n            spec {\n                invariant spec_validators_are_initialized(validator_set.active_validators);\n                invariant len(validator_set.pending_active) == 0;\n                invariant len(validator_set.pending_inactive) == 0;\n                invariant 0 <= validator_index && validator_index <= vlen;\n                invariant vlen == len(validator_set.active_validators);\n                invariant forall i in 0..validator_index:\n                    global<ValidatorConfig>(validator_set.active_validators[i].addr).validator_index < validator_index;\n                invariant forall i in 0..validator_index:\n                    validator_set.active_validators[i].config.validator_index < validator_index;\n                invariant len(validator_perf.validators) == validator_index;\n            };\n            validator_index < vlen\n        }) {\n            let validator_info = vector::borrow_mut(&mut validator_set.active_validators, validator_index);\n            validator_info.config.validator_index = validator_index;\n            let validator_config = borrow_global_mut<ValidatorConfig>(validator_info.addr);\n            validator_config.validator_index = validator_index;\n\n            vector::push_back(&mut validator_perf.validators, IndividualValidatorPerformance {\n                successful_proposals: 0,\n                failed_proposals: 0,\n            });\n\n            // Automatically renew a validator's lockup for validators that will still be in the validator set in the\n            // next epoch.\n            let stake_pool = borrow_global_mut<StakePool>(validator_info.addr);\n            let now_secs = timestamp::now_seconds();\n            let reconfig_start_secs = if (chain_status::is_operating()) {\n                get_reconfig_start_time_secs()\n            } else {\n                now_secs\n            };\n            if (stake_pool.locked_until_secs <= reconfig_start_secs) {\n                spec {\n                    assume now_secs + recurring_lockup_duration_secs <= MAX_U64;\n                };\n                stake_pool.locked_until_secs = now_secs + recurring_lockup_duration_secs;\n            };\n\n            validator_index = validator_index + 1;\n        };\n\n        if (features::periodical_reward_rate_decrease_enabled()) {\n            // Update rewards rate after reward distribution.\n            staking_config::calculate_and_save_latest_epoch_rewards_rate();\n        };\n    }\n\n    /// Return the `ValidatorConsensusInfo` of each current validator, sorted by current validator index.\n    public fun cur_validator_consensus_infos(): vector<ValidatorConsensusInfo> acquires ValidatorSet {\n        let validator_set = borrow_global<ValidatorSet>(@aptos_framework);\n        validator_consensus_infos_from_validator_set(validator_set)\n    }\n\n\n    public fun next_validator_consensus_infos(): vector<ValidatorConsensusInfo> acquires ValidatorSet, ValidatorPerformance, StakePool, ValidatorFees, ValidatorConfig {\n        // Init.\n        let cur_validator_set = borrow_global<ValidatorSet>(@aptos_framework);\n        let staking_config = staking_config::get();\n        let validator_perf = borrow_global<ValidatorPerformance>(@aptos_framework);\n        let (minimum_stake, _) = staking_config::get_required_stake(&staking_config);\n        let (rewards_rate, rewards_rate_denominator) = staking_config::get_reward_rate(&staking_config);\n\n        // Compute new validator set.\n        let new_active_validators = vector[];\n        let num_new_actives = 0;\n        let candidate_idx = 0;\n        let new_total_power = 0;\n        let num_cur_actives = vector::length(&cur_validator_set.active_validators);\n        let num_cur_pending_actives = vector::length(&cur_validator_set.pending_active);\n        spec {\n            assume num_cur_actives + num_cur_pending_actives <= MAX_U64;\n        };\n        let num_candidates = num_cur_actives + num_cur_pending_actives;\n        while ({\n            spec {\n                invariant candidate_idx <= num_candidates;\n                invariant spec_validators_are_initialized(new_active_validators);\n                invariant len(new_active_validators) == num_new_actives;\n                invariant forall i in 0..len(new_active_validators):\n                    new_active_validators[i].config.validator_index == i;\n                invariant num_new_actives <= candidate_idx;\n                invariant spec_validators_are_initialized(new_active_validators);\n            };\n            candidate_idx < num_candidates\n        }) {\n            let candidate_in_current_validator_set = candidate_idx < num_cur_actives;\n            let candidate = if (candidate_idx < num_cur_actives) {\n                vector::borrow(&cur_validator_set.active_validators, candidate_idx)\n            } else {\n                vector::borrow(&cur_validator_set.pending_active, candidate_idx - num_cur_actives)\n            };\n            let stake_pool = borrow_global<StakePool>(candidate.addr);\n            let cur_active = coin::value(&stake_pool.active);\n            let cur_pending_active = coin::value(&stake_pool.pending_active);\n            let cur_pending_inactive = coin::value(&stake_pool.pending_inactive);\n\n            let cur_reward = if (candidate_in_current_validator_set && cur_active > 0) {\n                spec {\n                    assert candidate.config.validator_index < len(validator_perf.validators);\n                };\n                let cur_perf = vector::borrow(&validator_perf.validators, candidate.config.validator_index);\n                spec {\n                    assume cur_perf.successful_proposals + cur_perf.failed_proposals <= MAX_U64;\n                };\n                calculate_rewards_amount(cur_active, cur_perf.successful_proposals, cur_perf.successful_proposals + cur_perf.failed_proposals, rewards_rate, rewards_rate_denominator)\n            } else {\n                0\n            };\n\n            let cur_fee = 0;\n            if (features::collect_and_distribute_gas_fees()) {\n                let fees_table = &borrow_global<ValidatorFees>(@aptos_framework).fees_table;\n                if (table::contains(fees_table, candidate.addr)) {\n                    let fee_coin = table::borrow(fees_table, candidate.addr);\n                    cur_fee = coin::value(fee_coin);\n                }\n            };\n\n            let lockup_expired = get_reconfig_start_time_secs() >= stake_pool.locked_until_secs;\n            spec {\n                assume cur_active + cur_pending_active + cur_reward + cur_fee <= MAX_U64;\n                assume cur_active + cur_pending_inactive + cur_pending_active + cur_reward + cur_fee <= MAX_U64;\n            };\n            let new_voting_power =\n                cur_active\n                + if (lockup_expired) { 0 } else { cur_pending_inactive }\n                + cur_pending_active\n                + cur_reward + cur_fee;\n\n            if (new_voting_power >= minimum_stake) {\n                let config = *borrow_global<ValidatorConfig>(candidate.addr);\n                config.validator_index = num_new_actives;\n                let new_validator_info = ValidatorInfo {\n                    addr: candidate.addr,\n                    voting_power: new_voting_power,\n                    config,\n                };\n\n                // Update ValidatorSet.\n                spec {\n                    assume new_total_power + new_voting_power <= MAX_U128;\n                };\n                new_total_power = new_total_power + (new_voting_power as u128);\n                vector::push_back(&mut new_active_validators, new_validator_info);\n                num_new_actives = num_new_actives + 1;\n\n            };\n            candidate_idx = candidate_idx + 1;\n        };\n\n        let new_validator_set = ValidatorSet {\n            consensus_scheme: cur_validator_set.consensus_scheme,\n            active_validators: new_active_validators,\n            pending_inactive: vector[],\n            pending_active: vector[],\n            total_voting_power: new_total_power,\n            total_joining_power: 0,\n        };\n\n        validator_consensus_infos_from_validator_set(&new_validator_set)\n    }\n\n    fun validator_consensus_infos_from_validator_set(validator_set: &ValidatorSet): vector<ValidatorConsensusInfo> {\n        let validator_consensus_infos = vector[];\n\n        let num_active = vector::length(&validator_set.active_validators);\n        let num_pending_inactive = vector::length(&validator_set.pending_inactive);\n        spec {\n            assume num_active + num_pending_inactive <= MAX_U64;\n        };\n        let total = num_active + num_pending_inactive;\n\n        // Pre-fill the return value with dummy values.\n        let idx = 0;\n        while ({\n            spec {\n                invariant idx <= len(validator_set.active_validators) + len(validator_set.pending_inactive);\n                invariant len(validator_consensus_infos) == idx;\n                invariant len(validator_consensus_infos) <= len(validator_set.active_validators) + len(validator_set.pending_inactive);\n            };\n            idx < total\n        }) {\n            vector::push_back(&mut validator_consensus_infos, validator_consensus_info::default());\n            idx = idx + 1;\n        };\n        spec {\n            assert len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);\n            assert spec_validator_indices_are_valid_config(validator_set.active_validators,\n                len(validator_set.active_validators) + len(validator_set.pending_inactive));\n        };\n\n        vector::for_each_ref(&validator_set.active_validators, |obj| {\n            let vi: &ValidatorInfo = obj;\n            spec {\n                assume len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);\n                assert vi.config.validator_index < len(validator_consensus_infos);\n            };\n            let vci = vector::borrow_mut(&mut validator_consensus_infos, vi.config.validator_index);\n            *vci = validator_consensus_info::new(\n                vi.addr,\n                vi.config.consensus_pubkey,\n                vi.voting_power\n            );\n            spec {\n                assert len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);\n            };\n        });\n\n        vector::for_each_ref(&validator_set.pending_inactive, |obj| {\n            let vi: &ValidatorInfo = obj;\n            spec {\n                assume len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);\n                assert vi.config.validator_index < len(validator_consensus_infos);\n            };\n            let vci = vector::borrow_mut(&mut validator_consensus_infos, vi.config.validator_index);\n            *vci = validator_consensus_info::new(\n                vi.addr,\n                vi.config.consensus_pubkey,\n                vi.voting_power\n            );\n            spec {\n                assert len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);\n            };\n        });\n\n        validator_consensus_infos\n    }\n\n    fun addresses_from_validator_infos(infos: &vector<ValidatorInfo>): vector<address> {\n        vector::map_ref(infos, |obj| {\n            let info: &ValidatorInfo = obj;\n            info.addr\n        })\n    }\n\n    /// Calculate the stake amount of a stake pool for the next epoch.\n    /// Update individual validator's stake pool if `commit == true`.\n    ///\n    /// 1. distribute transaction fees to active/pending_inactive delegations\n    /// 2. distribute rewards to active/pending_inactive delegations\n    /// 3. process pending_active, pending_inactive correspondingly\n    /// This function shouldn't abort.\n    fun update_stake_pool(\n        validator_perf: &ValidatorPerformance,\n        pool_address: address,\n        staking_config: &StakingConfig,\n    ) acquires StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorFees {\n        let stake_pool = borrow_global_mut<StakePool>(pool_address);\n        let validator_config = borrow_global<ValidatorConfig>(pool_address);\n        let cur_validator_perf = vector::borrow(&validator_perf.validators, validator_config.validator_index);\n        let num_successful_proposals = cur_validator_perf.successful_proposals;\n        spec {\n            // The following addition should not overflow because `num_total_proposals` cannot be larger than 86400,\n            // the maximum number of proposals in a day (1 proposal per second).\n            assume cur_validator_perf.successful_proposals + cur_validator_perf.failed_proposals <= MAX_U64;\n        };\n        let num_total_proposals = cur_validator_perf.successful_proposals + cur_validator_perf.failed_proposals;\n        let (rewards_rate, rewards_rate_denominator) = staking_config::get_reward_rate(staking_config);\n        let rewards_active = distribute_rewards(\n            &mut stake_pool.active,\n            num_successful_proposals,\n            num_total_proposals,\n            rewards_rate,\n            rewards_rate_denominator\n        );\n        let rewards_pending_inactive = distribute_rewards(\n            &mut stake_pool.pending_inactive,\n            num_successful_proposals,\n            num_total_proposals,\n            rewards_rate,\n            rewards_rate_denominator\n        );\n        spec {\n            assume rewards_active + rewards_pending_inactive <= MAX_U64;\n        };\n        let rewards_amount = rewards_active + rewards_pending_inactive;\n        // Pending active stake can now be active.\n        coin::merge(&mut stake_pool.active, coin::extract_all(&mut stake_pool.pending_active));\n\n        // Additionally, distribute transaction fees.\n        if (features::collect_and_distribute_gas_fees()) {\n            let fees_table = &mut borrow_global_mut<ValidatorFees>(@aptos_framework).fees_table;\n            if (table::contains(fees_table, pool_address)) {\n                let coin = table::remove(fees_table, pool_address);\n                coin::merge(&mut stake_pool.active, coin);\n            };\n        };\n\n        // Pending inactive stake is only fully unlocked and moved into inactive if the current lockup cycle has expired\n        let current_lockup_expiration = stake_pool.locked_until_secs;\n        if (get_reconfig_start_time_secs() >= current_lockup_expiration) {\n            coin::merge(\n                &mut stake_pool.inactive,\n                coin::extract_all(&mut stake_pool.pending_inactive),\n            );\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(DistributeRewards { pool_address, rewards_amount });\n        };\n        event::emit_event(\n            &mut stake_pool.distribute_rewards_events,\n            DistributeRewardsEvent {\n                pool_address,\n                rewards_amount,\n            },\n        );\n    }\n\n    /// Assuming we are in a middle of a reconfiguration (no matter it is immediate or async), get its start time.\n    fun get_reconfig_start_time_secs(): u64 {\n        if (reconfiguration_state::is_initialized()) {\n            reconfiguration_state::start_time_secs()\n        } else {\n            timestamp::now_seconds()\n        }\n    }\n\n    /// Calculate the rewards amount.\n    fun calculate_rewards_amount(\n        stake_amount: u64,\n        num_successful_proposals: u64,\n        num_total_proposals: u64,\n        rewards_rate: u64,\n        rewards_rate_denominator: u64,\n    ): u64 {\n        spec {\n            // The following condition must hold because\n            // (1) num_successful_proposals <= num_total_proposals, and\n            // (2) `num_total_proposals` cannot be larger than 86400, the maximum number of proposals\n            //     in a day (1 proposal per second), and `num_total_proposals` is reset to 0 every epoch.\n            assume num_successful_proposals * MAX_REWARDS_RATE <= MAX_U64;\n        };\n        // The rewards amount is equal to (stake amount * rewards rate * performance multiplier).\n        // We do multiplication in u128 before division to avoid the overflow and minimize the rounding error.\n        let rewards_numerator = (stake_amount as u128) * (rewards_rate as u128) * (num_successful_proposals as u128);\n        let rewards_denominator = (rewards_rate_denominator as u128) * (num_total_proposals as u128);\n        if (rewards_denominator > 0) {\n            ((rewards_numerator / rewards_denominator) as u64)\n        } else {\n            0\n        }\n    }\n\n    /// Mint rewards corresponding to current epoch's `stake` and `num_successful_votes`.\n    fun distribute_rewards(\n        stake: &mut Coin<AptosCoin>,\n        num_successful_proposals: u64,\n        num_total_proposals: u64,\n        rewards_rate: u64,\n        rewards_rate_denominator: u64,\n    ): u64 acquires AptosCoinCapabilities {\n        let stake_amount = coin::value(stake);\n        let rewards_amount = if (stake_amount > 0) {\n            calculate_rewards_amount(\n                stake_amount,\n                num_successful_proposals,\n                num_total_proposals,\n                rewards_rate,\n                rewards_rate_denominator\n            )\n        } else {\n            0\n        };\n        if (rewards_amount > 0) {\n            let mint_cap = &borrow_global<AptosCoinCapabilities>(@aptos_framework).mint_cap;\n            let rewards = coin::mint(rewards_amount, mint_cap);\n            coin::merge(stake, rewards);\n        };\n        rewards_amount\n    }\n\n    fun append<T>(v1: &mut vector<T>, v2: &mut vector<T>) {\n        while (!vector::is_empty(v2)) {\n            vector::push_back(v1, vector::pop_back(v2));\n        }\n    }\n\n    fun find_validator(v: &vector<ValidatorInfo>, addr: address): Option<u64> {\n        let i = 0;\n        let len = vector::length(v);\n        while ({\n            spec {\n                invariant !(exists j in 0..i: v[j].addr == addr);\n            };\n            i < len\n        }) {\n            if (vector::borrow(v, i).addr == addr) {\n                return option::some(i)\n            };\n            i = i + 1;\n        };\n        option::none()\n    }\n\n    fun generate_validator_info(addr: address, stake_pool: &StakePool, config: ValidatorConfig): ValidatorInfo {\n        let voting_power = get_next_epoch_voting_power(stake_pool);\n        ValidatorInfo {\n            addr,\n            voting_power,\n            config,\n        }\n    }\n\n    /// Returns validator's next epoch voting power, including pending_active, active, and pending_inactive stake.\n    fun get_next_epoch_voting_power(stake_pool: &StakePool): u64 {\n        let value_pending_active = coin::value(&stake_pool.pending_active);\n        let value_active = coin::value(&stake_pool.active);\n        let value_pending_inactive = coin::value(&stake_pool.pending_inactive);\n        spec {\n            assume value_pending_active + value_active + value_pending_inactive <= MAX_U64;\n        };\n        value_pending_active + value_active + value_pending_inactive\n    }\n\n    fun update_voting_power_increase(increase_amount: u64) acquires ValidatorSet {\n        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);\n        let voting_power_increase_limit =\n            (staking_config::get_voting_power_increase_limit(&staking_config::get()) as u128);\n        validator_set.total_joining_power = validator_set.total_joining_power + (increase_amount as u128);\n\n        // Only validator voting power increase if the current validator set's voting power > 0.\n        if (validator_set.total_voting_power > 0) {\n            assert!(\n                validator_set.total_joining_power <= validator_set.total_voting_power * voting_power_increase_limit / 100,\n                error::invalid_argument(EVOTING_POWER_INCREASE_EXCEEDS_LIMIT),\n            );\n        }\n    }\n\n    fun assert_stake_pool_exists(pool_address: address) {\n        assert!(stake_pool_exists(pool_address), error::invalid_argument(ESTAKE_POOL_DOES_NOT_EXIST));\n    }\n\n    /// This provides an ACL for Testnet purposes. In testnet, everyone is a whale, a whale can be a validator.\n    /// This allows a testnet to bring additional entities into the validator set without compromising the\n    /// security of the testnet. This will NOT be enabled in Mainnet.\n    struct AllowedValidators has key {\n        accounts: vector<address>,\n    }\n\n    public fun configure_allowed_validators(\n        aptos_framework: &signer,\n        accounts: vector<address>\n    ) acquires AllowedValidators {\n        let aptos_framework_address = signer::address_of(aptos_framework);\n        system_addresses::assert_aptos_framework(aptos_framework);\n        if (!exists<AllowedValidators>(aptos_framework_address)) {\n            move_to(aptos_framework, AllowedValidators { accounts });\n        } else {\n            let allowed = borrow_global_mut<AllowedValidators>(aptos_framework_address);\n            allowed.accounts = accounts;\n        }\n    }\n\n    fun is_allowed(account: address): bool acquires AllowedValidators {\n        if (!exists<AllowedValidators>(@aptos_framework)) {\n            true\n        } else {\n            let allowed = borrow_global<AllowedValidators>(@aptos_framework);\n            vector::contains(&allowed.accounts, &account)\n        }\n    }\n\n    fun assert_owner_cap_exists(owner: address) {\n        assert!(exists<OwnerCapability>(owner), error::not_found(EOWNER_CAP_NOT_FOUND));\n    }\n\n    fun assert_reconfig_not_in_progress() {\n        assert!(!reconfiguration_state::is_in_progress(), error::invalid_state(ERECONFIGURATION_IN_PROGRESS));\n    }\n\n    #[test_only]\n    use aptos_framework::aptos_coin;\n    use aptos_std::bls12381::proof_of_possession_from_bytes;\n    use aptos_framework::reconfiguration_state;\n    use aptos_framework::validator_consensus_info;\n    use aptos_framework::validator_consensus_info::ValidatorConsensusInfo;\n    #[test_only]\n    use aptos_std::fixed_point64;\n\n    #[test_only]\n    const EPOCH_DURATION: u64 = 60;\n\n    #[test_only]\n    const LOCKUP_CYCLE_SECONDS: u64 = 3600;\n\n    #[test_only]\n    public fun initialize_for_test(aptos_framework: &signer) {\n        reconfiguration_state::initialize(aptos_framework);\n        initialize_for_test_custom(aptos_framework, 100, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 100, 1000000);\n    }\n\n    #[test_only]\n    public fun join_validator_set_for_test(\n        pk: &bls12381::PublicKey,\n        pop: &bls12381::ProofOfPossession,\n        operator: &signer,\n        pool_address: address,\n        should_end_epoch: bool,\n    ) acquires AptosCoinCapabilities, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        let pk_bytes = bls12381::public_key_to_bytes(pk);\n        let pop_bytes = bls12381::proof_of_possession_to_bytes(pop);\n        rotate_consensus_key(operator, pool_address, pk_bytes, pop_bytes);\n        join_validator_set(operator, pool_address);\n        if (should_end_epoch) {\n            end_epoch();\n        }\n    }\n\n    #[test_only]\n    public fun fast_forward_to_unlock(pool_address: address)\n    acquires AptosCoinCapabilities, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        let expiration_time = get_lockup_secs(pool_address);\n        timestamp::update_global_time_for_test_secs(expiration_time);\n        end_epoch();\n    }\n\n    // Convenient function for setting up all required stake initializations.\n    #[test_only]\n    public fun initialize_for_test_custom(\n        aptos_framework: &signer,\n        minimum_stake: u64,\n        maximum_stake: u64,\n        recurring_lockup_secs: u64,\n        allow_validator_set_change: bool,\n        rewards_rate_numerator: u64,\n        rewards_rate_denominator: u64,\n        voting_power_increase_limit: u64,\n    ) {\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n        reconfiguration_state::initialize(aptos_framework);\n        if (!exists<ValidatorSet>(@aptos_framework)) {\n            initialize(aptos_framework);\n        };\n        staking_config::initialize_for_test(\n            aptos_framework,\n            minimum_stake,\n            maximum_stake,\n            recurring_lockup_secs,\n            allow_validator_set_change,\n            rewards_rate_numerator,\n            rewards_rate_denominator,\n            voting_power_increase_limit,\n        );\n\n        if (!exists<AptosCoinCapabilities>(@aptos_framework)) {\n            let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(aptos_framework);\n            store_aptos_coin_mint_cap(aptos_framework, mint_cap);\n            coin::destroy_burn_cap<AptosCoin>(burn_cap);\n        };\n    }\n\n    // This function assumes the stake module already the capability to mint aptos coins.\n    #[test_only]\n    public fun mint_coins(amount: u64): Coin<AptosCoin> acquires AptosCoinCapabilities {\n        let mint_cap = &borrow_global<AptosCoinCapabilities>(@aptos_framework).mint_cap;\n        coin::mint(amount, mint_cap)\n    }\n\n    #[test_only]\n    public fun mint(account: &signer, amount: u64) acquires AptosCoinCapabilities {\n        coin::register<AptosCoin>(account);\n        coin::deposit(signer::address_of(account), mint_coins(amount));\n    }\n\n    #[test_only]\n    public fun mint_and_add_stake(\n        account: &signer, amount: u64) acquires AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorSet {\n        mint(account, amount);\n        add_stake(account, amount);\n    }\n\n    #[test_only]\n    public fun initialize_test_validator(\n        public_key: &bls12381::PublicKey,\n        proof_of_possession: &bls12381::ProofOfPossession,\n        validator: &signer,\n        amount: u64,\n        should_join_validator_set: bool,\n        should_end_epoch: bool,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        let validator_address = signer::address_of(validator);\n        if (!account::exists_at(signer::address_of(validator))) {\n            account::create_account_for_test(validator_address);\n        };\n\n        let pk_bytes = bls12381::public_key_to_bytes(public_key);\n        let pop_bytes = bls12381::proof_of_possession_to_bytes(proof_of_possession);\n        initialize_validator(validator, pk_bytes, pop_bytes, vector::empty(), vector::empty());\n\n        if (amount > 0) {\n            mint_and_add_stake(validator, amount);\n        };\n\n        if (should_join_validator_set) {\n            join_validator_set(validator, validator_address);\n        };\n        if (should_end_epoch) {\n            end_epoch();\n        };\n    }\n\n    #[test_only]\n    public fun create_validator_set(\n        aptos_framework: &signer,\n        active_validator_addresses: vector<address>,\n        public_keys: vector<bls12381::PublicKey>,\n    ) {\n        let active_validators = vector::empty<ValidatorInfo>();\n        let i = 0;\n        while (i < vector::length(&active_validator_addresses)) {\n            let validator_address = vector::borrow(&active_validator_addresses, i);\n            let pk = vector::borrow(&public_keys, i);\n            vector::push_back(&mut active_validators, ValidatorInfo {\n                addr: *validator_address,\n                voting_power: 0,\n                config: ValidatorConfig {\n                    consensus_pubkey: bls12381::public_key_to_bytes(pk),\n                    network_addresses: b\"\",\n                    fullnode_addresses: b\"\",\n                    validator_index: 0,\n                }\n            });\n            i = i + 1;\n        };\n\n        move_to(aptos_framework, ValidatorSet {\n            consensus_scheme: 0,\n            // active validators for the current epoch\n            active_validators,\n            // pending validators to leave in next epoch (still active)\n            pending_inactive: vector::empty<ValidatorInfo>(),\n            // pending validators to join in next epoch\n            pending_active: vector::empty<ValidatorInfo>(),\n            total_voting_power: 0,\n            total_joining_power: 0,\n        });\n    }\n\n    #[test_only]\n    public fun create_stake_pool(\n        account: &signer,\n        active: Coin<AptosCoin>,\n        pending_inactive: Coin<AptosCoin>,\n        locked_until_secs: u64,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, ValidatorSet {\n        let account_address = signer::address_of(account);\n        initialize_stake_owner(account, 0, account_address, account_address);\n        let stake_pool = borrow_global_mut<StakePool>(account_address);\n        coin::merge(&mut stake_pool.active, active);\n        coin::merge(&mut stake_pool.pending_inactive, pending_inactive);\n        stake_pool.locked_until_secs = locked_until_secs;\n    }\n\n    // Allows unit tests to set custom validator performances.\n    #[test_only]\n    public fun update_validator_performances_for_test(\n        proposer_index: Option<u64>,\n        failed_proposer_indices: vector<u64>,\n    ) acquires ValidatorPerformance {\n        update_performance_statistics(proposer_index, failed_proposer_indices);\n    }\n\n    #[test_only]\n    public fun generate_identity(): (bls12381::SecretKey, bls12381::PublicKey, bls12381::ProofOfPossession) {\n        let (sk, pkpop) = bls12381::generate_keys();\n        let pop = bls12381::generate_proof_of_possession(&sk);\n        let unvalidated_pk = bls12381::public_key_with_pop_to_normal(&pkpop);\n        (sk, unvalidated_pk, pop)\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_inactive_validator_can_add_stake_if_exceeding_max_allowed(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, false, false);\n\n        // Add more stake to exceed max. This should fail.\n        mint_and_add_stake(validator, 9901);\n    }\n\n    #[test(aptos_framework = @0x1, validator_1 = @0x123, validator_2 = @0x234)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_pending_active_validator_cannot_add_stake_if_exceeding_max_allowed(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 100000);\n        // Have one validator join the set to ensure the validator set is not empty when main validator joins.\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, true);\n\n        // Validator 2 joins validator set but epoch has not ended so validator is in pending_active state.\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, false);\n\n        // Add more stake to exceed max. This should fail.\n        mint_and_add_stake(validator_2, 9901);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_active_validator_cannot_add_stake_if_exceeding_max_allowed(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        // Validator joins validator set and waits for epoch end so it's in the validator set.\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Add more stake to exceed max. This should fail.\n        mint_and_add_stake(validator, 9901);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_active_validator_with_pending_inactive_stake_cannot_add_stake_if_exceeding_max_allowed(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        // Validator joins validator set and waits for epoch end so it's in the validator set.\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Request to unlock 50 coins, which go to pending_inactive. Validator has 50 remaining in active.\n        unlock(validator, 50);\n        assert_validator_state(signer::address_of(validator), 50, 0, 0, 50, 0);\n\n        // Add 9901 more. Total stake is 50 (active) + 50 (pending_inactive) + 9901 > 10000 so still exceeding max.\n        mint_and_add_stake(validator, 9901);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_pending_inactive_cannot_add_stake_if_exceeding_max_allowed(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, true);\n\n        // Leave validator set so validator is in pending_inactive state.\n        leave_validator_set(validator_1, signer::address_of(validator_1));\n\n        // Add 9901 more. Total stake is 50 (active) + 50 (pending_inactive) + 9901 > 10000 so still exceeding max.\n        mint_and_add_stake(validator_1, 9901);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_end_to_end(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Validator has a lockup now that they've joined the validator set.\n        let validator_address = signer::address_of(validator);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 1);\n\n        // Validator adds more stake while already being active.\n        // The added stake should go to pending_active to wait for activation when next epoch starts.\n        mint(validator, 900);\n        add_stake(validator, 100);\n        assert!(coin::balance<AptosCoin>(validator_address) == 800, 2);\n        assert_validator_state(validator_address, 100, 0, 100, 0, 0);\n\n        // Pending_active stake is activated in the new epoch.\n        // Rewards of 1 coin are also distributed for the existing active stake of 100 coins.\n        end_epoch();\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 3);\n        assert_validator_state(validator_address, 201, 0, 0, 0, 0);\n\n        // Request unlock of 100 coins. These 100 coins are moved to pending_inactive and will be unlocked when the\n        // current lockup expires.\n        unlock(validator, 100);\n        assert_validator_state(validator_address, 101, 0, 0, 100, 0);\n\n        // Enough time has passed so the current lockup cycle should have ended.\n        // The first epoch after the lockup cycle ended should automatically move unlocked (pending_inactive) stake\n        // to inactive.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n        // Rewards were also minted to pending_inactive, which got all moved to inactive.\n        assert_validator_state(validator_address, 102, 101, 0, 0, 0);\n        // Lockup is renewed and validator is still active.\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 4);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 5);\n\n        // Validator withdraws from inactive stake multiple times.\n        withdraw(validator, 50);\n        assert!(coin::balance<AptosCoin>(validator_address) == 850, 6);\n        assert_validator_state(validator_address, 102, 51, 0, 0, 0);\n        withdraw(validator, 51);\n        assert!(coin::balance<AptosCoin>(validator_address) == 901, 7);\n        assert_validator_state(validator_address, 102, 0, 0, 0, 0);\n\n        // Enough time has passed again and the validator's lockup is renewed once more. Validator is still active.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 8);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 9);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_inactive_validator_with_existing_lockup_join_validator_set(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, false, false);\n\n        // Validator sets lockup before even joining the set and lets half of lockup pass by.\n        increase_lockup(validator);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS / 2);\n        let validator_address = signer::address_of(validator);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS / 2, 1);\n\n        // Join the validator set with an existing lockup\n        join_validator_set(validator, validator_address);\n\n        // Validator is added to the set but lockup time shouldn't have changed.\n        end_epoch();\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 2);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS / 2 - EPOCH_DURATION, 3);\n        assert_validator_state(validator_address, 100, 0, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x10012, location = Self)]\n    public entry fun test_cannot_reduce_lockup(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, false, false);\n\n        // Increase lockup.\n        increase_lockup(validator);\n        // Reduce recurring lockup to 0.\n        staking_config::update_recurring_lockup_duration_secs(aptos_framework, 1);\n        // INcrease lockup should now fail because the new lockup < old lockup.\n        increase_lockup(validator);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]\n    #[expected_failure(abort_code = 0x1000D, location = Self)]\n    public entry fun test_inactive_validator_cannot_join_if_exceed_increase_limit(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // Only 50% voting power increase is allowed in each epoch.\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 50);\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, false, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, false, false);\n\n        // Validator 1 needs to be in the set so validator 2's added stake counts against the limit.\n        join_validator_set(validator_1, signer::address_of(validator_1));\n        end_epoch();\n\n        // Validator 2 joins the validator set but their stake would lead to exceeding the voting power increase limit.\n        // Therefore, this should fail.\n        join_validator_set(validator_2, signer::address_of(validator_2));\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]\n    public entry fun test_pending_active_validator_can_add_more_stake(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 10000);\n        // Need 1 validator to be in the active validator set so joining limit works.\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, false, true);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, false, false);\n\n        // Add more stake while still pending_active.\n        let validator_2_address = signer::address_of(validator_2);\n        join_validator_set(validator_2, validator_2_address);\n        assert!(get_validator_state(validator_2_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 0);\n        mint_and_add_stake(validator_2, 100);\n        assert_validator_state(validator_2_address, 200, 0, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]\n    #[expected_failure(abort_code = 0x1000D, location = Self)]\n    public entry fun test_pending_active_validator_cannot_add_more_stake_than_limit(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // 100% voting power increase is allowed in each epoch.\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 100);\n        // Need 1 validator to be in the active validator set so joining limit works.\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, true);\n\n        // Validator 2 joins the validator set but epoch has not ended so they're still pending_active.\n        // Current voting power increase is already 100%. This is not failing yet.\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, false);\n\n        // Add more stake, which now exceeds the 100% limit. This should fail.\n        mint_and_add_stake(validator_2, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_pending_active_validator_leaves_validator_set(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        // Validator joins but epoch hasn't ended, so the validator is still pending_active.\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, false);\n        let validator_address = signer::address_of(validator);\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 0);\n\n        // Check that voting power increase is tracked.\n        assert!(borrow_global<ValidatorSet>(@aptos_framework).total_joining_power == 100, 0);\n\n        // Leave the validator set immediately.\n        leave_validator_set(validator, validator_address);\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_INACTIVE, 1);\n\n        // Check that voting power increase has been decreased when the pending active validator leaves.\n        assert!(borrow_global<ValidatorSet>(@aptos_framework).total_joining_power == 0, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x1000D, location = Self)]\n    public entry fun test_active_validator_cannot_add_more_stake_than_limit_in_multiple_epochs(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // Only 50% voting power increase is allowed in each epoch.\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 50);\n        // Add initial stake and join the validator set.\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        let validator_address = signer::address_of(validator);\n        assert_validator_state(validator_address, 100, 0, 0, 0, 0);\n        end_epoch();\n        assert_validator_state(validator_address, 110, 0, 0, 0, 0);\n        end_epoch();\n        assert_validator_state(validator_address, 121, 0, 0, 0, 0);\n        // Add more than 50% limit. The following line should fail.\n        mint_and_add_stake(validator, 99);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x1000D, location = Self)]\n    public entry fun test_active_validator_cannot_add_more_stake_than_limit(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // Only 50% voting power increase is allowed in each epoch.\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 50);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Add more than 50% limit. This should fail.\n        mint_and_add_stake(validator, 51);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_validator_unlock_partial_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // Reward rate = 10%.\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 100);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Unlock half of the coins.\n        let validator_address = signer::address_of(validator);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 1);\n        unlock(validator, 50);\n        assert_validator_state(validator_address, 50, 0, 0, 50, 0);\n\n        // Enough time has passed so the current lockup cycle should have ended.\n        // 50 coins should have unlocked while the remaining 51 (50 + rewards) should stay locked for another cycle.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 2);\n        // Validator received rewards in both active and pending inactive.\n        assert_validator_state(validator_address, 55, 55, 0, 0, 0);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 3);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_validator_can_withdraw_all_stake_and_rewards_at_once(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n        let validator_address = signer::address_of(validator);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 0);\n\n        // One more epoch passes to generate rewards.\n        end_epoch();\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 1);\n        assert_validator_state(validator_address, 101, 0, 0, 0, 0);\n\n        // Unlock all coins while still having a lockup.\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS - EPOCH_DURATION, 2);\n        unlock(validator, 101);\n        assert_validator_state(validator_address, 0, 0, 0, 101, 0);\n\n        // One more epoch passes while the current lockup cycle (3600 secs) has not ended.\n        timestamp::fast_forward_seconds(1000);\n        end_epoch();\n        // Validator should not be removed from the validator set since their 100 coins in pending_inactive state should\n        // still count toward voting power.\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 3);\n        assert_validator_state(validator_address, 0, 0, 0, 102, 0);\n\n        // Enough time has passed so the current lockup cycle should have ended. Funds are now fully unlocked.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n        assert_validator_state(validator_address, 0, 103, 0, 0, 0);\n        // Validator ahs been kicked out of the validator set as their stake is 0 now.\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_INACTIVE, 4);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_validator_unlocking_more_than_available_stake_should_cap(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, false, false);\n\n        // Validator unlocks more stake than they have active. This should limit the unlock to 100.\n        unlock(validator, 200);\n        assert_validator_state(signer::address_of(validator), 0, 0, 0, 100, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_validator_withdraw_should_cap_by_inactive_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        // Initial balance = 900 (idle) + 100 (staked) = 1000.\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n        mint(validator, 900);\n\n        // Validator unlocks stake.\n        unlock(validator, 100);\n        // Enough time has passed so the stake is fully unlocked.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n\n        // Validator can only withdraw a max of 100 unlocked coins even if they request to withdraw more than 100.\n        withdraw(validator, 200);\n        let validator_address = signer::address_of(validator);\n        // Receive back all coins with an extra 1 for rewards.\n        assert!(coin::balance<AptosCoin>(validator_address) == 1001, 2);\n        assert_validator_state(validator_address, 0, 0, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_validator_can_reactivate_pending_inactive_stake(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Validator unlocks stake, which gets moved into pending_inactive.\n        unlock(validator, 50);\n        let validator_address = signer::address_of(validator);\n        assert_validator_state(validator_address, 50, 0, 0, 50, 0);\n\n        // Validator can reactivate pending_inactive stake.\n        reactivate_stake(validator, 50);\n        assert_validator_state(validator_address, 100, 0, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_validator_reactivate_more_than_available_pending_inactive_stake_should_cap(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Validator tries to reactivate more than available pending_inactive stake, which should limit to 50.\n        unlock(validator, 50);\n        let validator_address = signer::address_of(validator);\n        assert_validator_state(validator_address, 50, 0, 0, 50, 0);\n        reactivate_stake(validator, 51);\n        assert_validator_state(validator_address, 100, 0, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_active_validator_having_insufficient_remaining_stake_after_withdrawal_gets_kicked(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        // Unlock enough coins that the remaining is not enough to meet the min required.\n        let validator_address = signer::address_of(validator);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 1);\n        unlock(validator, 50);\n        assert_validator_state(validator_address, 50, 0, 0, 50, 0);\n\n        // Enough time has passed so the current lockup cycle should have ended.\n        // 50 coins should have unlocked while the remaining 51 (50 + rewards) is not enough so the validator is kicked\n        // from the validator set.\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 2);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_INACTIVE, 2);\n        assert_validator_state(validator_address, 50, 50, 0, 0, 0);\n        // Lockup is no longer renewed since the validator is no longer a part of the validator set.\n        assert!(get_remaining_lockup_secs(validator_address) == 0, 3);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, validator_2 = @0x234)]\n    public entry fun test_active_validator_leaves_staking_but_still_has_a_lockup(\n        aptos_framework: &signer,\n        validator: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator, 100, true, false);\n        // We need a second validator here just so the first validator can leave.\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, true);\n\n        // Leave the validator set while still having a lockup.\n        let validator_address = signer::address_of(validator);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 0);\n        leave_validator_set(validator, validator_address);\n        // Validator is in pending_inactive state but is technically still part of the validator set.\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_PENDING_INACTIVE, 2);\n        assert_validator_state(validator_address, 100, 0, 0, 0, 1);\n        end_epoch();\n\n        // Epoch has ended so validator is no longer part of the validator set.\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_INACTIVE, 3);\n        // However, their stake, including rewards, should still subject to the existing lockup.\n        assert_validator_state(validator_address, 101, 0, 0, 0, 1);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS - EPOCH_DURATION, 4);\n\n        // If they try to unlock, their stake is moved to pending_inactive and would only be withdrawable after the\n        // lockup has expired.\n        unlock(validator, 50);\n        assert_validator_state(validator_address, 51, 0, 0, 50, 1);\n        // A couple of epochs passed but lockup has not expired so the validator's stake remains the same.\n        end_epoch();\n        end_epoch();\n        end_epoch();\n        assert_validator_state(validator_address, 51, 0, 0, 50, 1);\n        // Fast forward enough so the lockup expires. Now the validator can just call withdraw directly to withdraw\n        // pending_inactive stakes.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        withdraw(validator, 50);\n        assert_validator_state(validator_address, 51, 0, 0, 0, 1);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123, validator_2 = @0x234)]\n    public entry fun test_active_validator_leaves_staking_and_rejoins_with_expired_lockup_should_be_renewed(\n        aptos_framework: &signer,\n        validator: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator, 100, true, false);\n        // We need a second validator here just so the first validator can leave.\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, true);\n\n        // Leave the validator set while still having a lockup.\n        let validator_address = signer::address_of(validator);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 0);\n        leave_validator_set(validator, validator_address);\n        end_epoch();\n\n        // Fast forward enough so the lockup expires.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        assert!(get_remaining_lockup_secs(validator_address) == 0, 1);\n\n        // Validator rejoins the validator set. Once the current epoch ends, their lockup should be automatically\n        // renewed.\n        join_validator_set(validator, validator_address);\n        end_epoch();\n        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_ACTIVE, 2);\n        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 2);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]\n    public entry fun test_pending_inactive_validator_does_not_count_in_increase_limit(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // Only 50% voting power increase is allowed in each epoch.\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 10, 50);\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, false);\n        // We need a second validator here just so the first validator can leave.\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, true);\n\n        // Validator 1 leaves the validator set. Epoch has not ended so they're still pending_inactive.\n        leave_validator_set(validator_1, signer::address_of(validator_1));\n        // Validator 1 adds more stake. This should not succeed as it should not count as a voting power increase.\n        mint_and_add_stake(validator_1, 51);\n    }\n\n    #[test(aptos_framework = @0x1, validator_1 = @0x123, validator_2 = @0x234, validator_3 = @0x345)]\n    public entry fun test_multiple_validators_join_and_leave(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n        validator_3: &signer\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        let validator_1_address = signer::address_of(validator_1);\n        let validator_2_address = signer::address_of(validator_2);\n        let validator_3_address = signer::address_of(validator_3);\n\n        initialize_for_test_custom(aptos_framework, 100, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 100, 100);\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let pk_1_bytes = bls12381::public_key_to_bytes(&pk_1);\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        let (_sk_3, pk_3, pop_3) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, false, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, false, false);\n        initialize_test_validator(&pk_3, &pop_3, validator_3, 100, false, false);\n\n        // Validator 1 and 2 join the validator set.\n        join_validator_set(validator_2, validator_2_address);\n        join_validator_set(validator_1, validator_1_address);\n        end_epoch();\n        assert!(get_validator_state(validator_1_address) == VALIDATOR_STATUS_ACTIVE, 0);\n        assert!(get_validator_state(validator_2_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Validator indices is the reverse order of the joining order.\n        assert_validator_state(validator_1_address, 100, 0, 0, 0, 0);\n        assert_validator_state(validator_2_address, 100, 0, 0, 0, 1);\n        let validator_set = borrow_global<ValidatorSet>(@aptos_framework);\n        let validator_config_1 = vector::borrow(&validator_set.active_validators, 0);\n        assert!(validator_config_1.addr == validator_1_address, 2);\n        assert!(validator_config_1.config.validator_index == 0, 3);\n        let validator_config_2 = vector::borrow(&validator_set.active_validators, 1);\n        assert!(validator_config_2.addr == validator_2_address, 4);\n        assert!(validator_config_2.config.validator_index == 1, 5);\n\n        // Validator 1 rotates consensus key. Validator 2 leaves. Validator 3 joins.\n        let (_sk_1b, pk_1b, pop_1b) = generate_identity();\n        let pk_1b_bytes = bls12381::public_key_to_bytes(&pk_1b);\n        let pop_1b_bytes = bls12381::proof_of_possession_to_bytes(&pop_1b);\n        rotate_consensus_key(validator_1, validator_1_address, pk_1b_bytes, pop_1b_bytes);\n        leave_validator_set(validator_2, validator_2_address);\n        join_validator_set(validator_3, validator_3_address);\n        // Validator 2 is not effectively removed until next epoch.\n        assert!(get_validator_state(validator_2_address) == VALIDATOR_STATUS_PENDING_INACTIVE, 6);\n        assert!(\n            vector::borrow(\n                &borrow_global<ValidatorSet>(@aptos_framework).pending_inactive,\n                0\n            ).addr == validator_2_address,\n            0\n        );\n        // Validator 3 is not effectively added until next epoch.\n        assert!(get_validator_state(validator_3_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 7);\n        assert!(\n            vector::borrow(\n                &borrow_global<ValidatorSet>(@aptos_framework).pending_active,\n                0\n            ).addr == validator_3_address,\n            0\n        );\n        assert!(\n            vector::borrow(\n                &borrow_global<ValidatorSet>(@aptos_framework).active_validators,\n                0\n            ).config.consensus_pubkey == pk_1_bytes,\n            0\n        );\n\n        // Changes applied after new epoch\n        end_epoch();\n        assert!(get_validator_state(validator_1_address) == VALIDATOR_STATUS_ACTIVE, 8);\n        assert_validator_state(validator_1_address, 101, 0, 0, 0, 0);\n        assert!(get_validator_state(validator_2_address) == VALIDATOR_STATUS_INACTIVE, 9);\n        // The validator index of validator 2 stays the same but this doesn't matter as the next time they rejoin the\n        // validator set, their index will get set correctly.\n        assert_validator_state(validator_2_address, 101, 0, 0, 0, 1);\n        assert!(get_validator_state(validator_3_address) == VALIDATOR_STATUS_ACTIVE, 10);\n        assert_validator_state(validator_3_address, 100, 0, 0, 0, 1);\n        assert!(\n            vector::borrow(\n                &borrow_global<ValidatorSet>(@aptos_framework).active_validators,\n                0\n            ).config.consensus_pubkey == pk_1b_bytes,\n            0\n        );\n\n        // Validators without enough stake will be removed.\n        unlock(validator_1, 50);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n        assert!(get_validator_state(validator_1_address) == VALIDATOR_STATUS_INACTIVE, 11);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_delegated_staking_with_owner_cap(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test_custom(aptos_framework, 100, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 100, 100);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 0, false, false);\n        let owner_cap = extract_owner_cap(validator);\n\n        // Add stake when the validator is not yet activated.\n        add_stake_with_cap(&owner_cap, mint_coins(100));\n        let pool_address = signer::address_of(validator);\n        assert_validator_state(pool_address, 100, 0, 0, 0, 0);\n\n        // Join the validator set with enough stake.\n        join_validator_set(validator, pool_address);\n        end_epoch();\n        assert!(get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 0);\n\n        // Unlock the entire stake.\n        unlock_with_cap(100, &owner_cap);\n        assert_validator_state(pool_address, 0, 0, 0, 100, 0);\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n\n        // Withdraw stake + rewards.\n        assert_validator_state(pool_address, 0, 101, 0, 0, 0);\n        let coins = withdraw_with_cap(&owner_cap, 101);\n        assert!(coin::value(&coins) == 101, 1);\n        assert_validator_state(pool_address, 0, 0, 0, 0, 0);\n\n        // Operator can separately rotate consensus key.\n        let (_sk_new, pk_new, pop_new) = generate_identity();\n        let pk_new_bytes = bls12381::public_key_to_bytes(&pk_new);\n        let pop_new_bytes = bls12381::proof_of_possession_to_bytes(&pop_new);\n        rotate_consensus_key(validator, pool_address, pk_new_bytes, pop_new_bytes);\n        let validator_config = borrow_global<ValidatorConfig>(pool_address);\n        assert!(validator_config.consensus_pubkey == pk_new_bytes, 2);\n\n        // Operator can update network and fullnode addresses.\n        update_network_and_fullnode_addresses(validator, pool_address, b\"1\", b\"2\");\n        let validator_config = borrow_global<ValidatorConfig>(pool_address);\n        assert!(validator_config.network_addresses == b\"1\", 3);\n        assert!(validator_config.fullnode_addresses == b\"2\", 4);\n\n        // Cleanups.\n        coin::register<AptosCoin>(validator);\n        coin::deposit(pool_address, coins);\n        deposit_owner_cap(validator, owner_cap);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x1000A, location = Self)]\n    public entry fun test_validator_cannot_join_post_genesis(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test_custom(aptos_framework, 100, 10000, LOCKUP_CYCLE_SECONDS, false, 1, 100, 100);\n\n        // Joining the validator set should fail as post genesis validator set change is not allowed.\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x1000E, location = Self)]\n    public entry fun test_invalid_pool_address(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n        join_validator_set(validator, @0x234);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x1000A, location = Self)]\n    public entry fun test_validator_cannot_leave_post_genesis(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test_custom(aptos_framework, 100, 10000, LOCKUP_CYCLE_SECONDS, false, 1, 100, 100);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, false, false);\n\n        // Bypass the check to join. This is the same function called during Genesis.\n        let validator_address = signer::address_of(validator);\n        join_validator_set_internal(validator, validator_address);\n        end_epoch();\n\n        // Leaving the validator set should fail as post genesis validator set change is not allowed.\n        leave_validator_set(validator, validator_address);\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        validator_1 = @aptos_framework,\n        validator_2 = @0x2,\n        validator_3 = @0x3,\n        validator_4 = @0x4,\n        validator_5 = @0x5\n    )]\n    fun test_validator_consensus_infos_from_validator_set(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n        validator_3: &signer,\n        validator_4: &signer,\n        validator_5: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        let v1_addr = signer::address_of(validator_1);\n        let v2_addr = signer::address_of(validator_2);\n        let v3_addr = signer::address_of(validator_3);\n        let v4_addr = signer::address_of(validator_4);\n        let v5_addr = signer::address_of(validator_5);\n\n        initialize_for_test(aptos_framework);\n\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        let (_sk_3, pk_3, pop_3) = generate_identity();\n        let (_sk_4, pk_4, pop_4) = generate_identity();\n        let (_sk_5, pk_5, pop_5) = generate_identity();\n        let pk_1_bytes = bls12381::public_key_to_bytes(&pk_1);\n        let pk_3_bytes = bls12381::public_key_to_bytes(&pk_3);\n        let pk_5_bytes = bls12381::public_key_to_bytes(&pk_5);\n\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 101, false, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 102, false, false);\n        initialize_test_validator(&pk_3, &pop_3, validator_3, 103, false, false);\n        initialize_test_validator(&pk_4, &pop_4, validator_4, 104, false, false);\n        initialize_test_validator(&pk_5, &pop_5, validator_5, 105, false, false);\n\n        join_validator_set(validator_3, v3_addr);\n        join_validator_set(validator_1, v1_addr);\n        join_validator_set(validator_5, v5_addr);\n        end_epoch();\n        let vci_vec_0 = validator_consensus_infos_from_validator_set(borrow_global<ValidatorSet>(@aptos_framework));\n        let vci_addrs = vector::map_ref(&vci_vec_0, |obj|{\n            let vci: &ValidatorConsensusInfo = obj;\n            validator_consensus_info::get_addr(vci)\n        });\n        let vci_pks = vector::map_ref(&vci_vec_0, |obj|{\n            let vci: &ValidatorConsensusInfo = obj;\n            validator_consensus_info::get_pk_bytes(vci)\n        });\n        let vci_voting_powers = vector::map_ref(&vci_vec_0, |obj|{\n            let vci: &ValidatorConsensusInfo = obj;\n            validator_consensus_info::get_voting_power(vci)\n        });\n        assert!(vector[@0x5, @aptos_framework, @0x3] == vci_addrs, 1);\n        assert!(vector[pk_5_bytes, pk_1_bytes, pk_3_bytes] == vci_pks, 2);\n        assert!(vector[105, 101, 103] == vci_voting_powers, 3);\n        leave_validator_set(validator_3, v3_addr);\n        let vci_vec_1 = validator_consensus_infos_from_validator_set(borrow_global<ValidatorSet>(@aptos_framework));\n        assert!(vci_vec_0 == vci_vec_1, 11);\n        join_validator_set(validator_2, v2_addr);\n        let vci_vec_2 = validator_consensus_infos_from_validator_set(borrow_global<ValidatorSet>(@aptos_framework));\n        assert!(vci_vec_0 == vci_vec_2, 12);\n        leave_validator_set(validator_1, v1_addr);\n        let vci_vec_3 = validator_consensus_infos_from_validator_set(borrow_global<ValidatorSet>(@aptos_framework));\n        assert!(vci_vec_0 == vci_vec_3, 13);\n        join_validator_set(validator_4, v4_addr);\n        let vci_vec_4 = validator_consensus_infos_from_validator_set(borrow_global<ValidatorSet>(@aptos_framework));\n        assert!(vci_vec_0 == vci_vec_4, 14);\n    }\n\n    #[test(\n        aptos_framework = @aptos_framework,\n        validator_1 = @aptos_framework,\n        validator_2 = @0x2,\n        validator_3 = @0x3,\n        validator_4 = @0x4,\n        validator_5 = @0x5\n    )]\n    public entry fun test_staking_validator_index(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n        validator_3: &signer,\n        validator_4: &signer,\n        validator_5: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        let v1_addr = signer::address_of(validator_1);\n        let v2_addr = signer::address_of(validator_2);\n        let v3_addr = signer::address_of(validator_3);\n        let v4_addr = signer::address_of(validator_4);\n        let v5_addr = signer::address_of(validator_5);\n\n        initialize_for_test(aptos_framework);\n\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        let (_sk_3, pk_3, pop_3) = generate_identity();\n        let (_sk_4, pk_4, pop_4) = generate_identity();\n        let (_sk_5, pk_5, pop_5) = generate_identity();\n\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, false, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, false, false);\n        initialize_test_validator(&pk_3, &pop_3, validator_3, 100, false, false);\n        initialize_test_validator(&pk_4, &pop_4, validator_4, 100, false, false);\n        initialize_test_validator(&pk_5, &pop_5, validator_5, 100, false, false);\n\n        join_validator_set(validator_3, v3_addr);\n        end_epoch();\n        assert!(get_validator_index(v3_addr) == 0, 0);\n\n        join_validator_set(validator_4, v4_addr);\n        end_epoch();\n        assert!(get_validator_index(v3_addr) == 0, 1);\n        assert!(get_validator_index(v4_addr) == 1, 2);\n\n        join_validator_set(validator_1, v1_addr);\n        join_validator_set(validator_2, v2_addr);\n        // pending_inactive is appended in reverse order\n        end_epoch();\n        assert!(get_validator_index(v3_addr) == 0, 6);\n        assert!(get_validator_index(v4_addr) == 1, 7);\n        assert!(get_validator_index(v2_addr) == 2, 8);\n        assert!(get_validator_index(v1_addr) == 3, 9);\n\n        join_validator_set(validator_5, v5_addr);\n        end_epoch();\n        assert!(get_validator_index(v3_addr) == 0, 10);\n        assert!(get_validator_index(v4_addr) == 1, 11);\n        assert!(get_validator_index(v2_addr) == 2, 12);\n        assert!(get_validator_index(v1_addr) == 3, 13);\n        assert!(get_validator_index(v5_addr) == 4, 14);\n\n        // after swap remove, it's 3,4,2,5\n        leave_validator_set(validator_1, v1_addr);\n        // after swap remove, it's 5,4,2\n        leave_validator_set(validator_3, v3_addr);\n        end_epoch();\n\n        assert!(get_validator_index(v5_addr) == 0, 15);\n        assert!(get_validator_index(v4_addr) == 1, 16);\n        assert!(get_validator_index(v2_addr) == 2, 17);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]\n    public entry fun test_validator_rewards_are_performance_based(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n\n        let validator_1_address = signer::address_of(validator_1);\n        let validator_2_address = signer::address_of(validator_2);\n\n        // Both validators join the set.\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, true);\n\n        // Validator 2 failed proposal.\n        let failed_proposer_indices = vector::empty<u64>();\n        let validator_1_index = borrow_global<ValidatorConfig>(validator_1_address).validator_index;\n        let validator_2_index = borrow_global<ValidatorConfig>(validator_2_address).validator_index;\n        vector::push_back(&mut failed_proposer_indices, validator_2_index);\n        let proposer_indices = option::some(validator_1_index);\n        update_performance_statistics(proposer_indices, failed_proposer_indices);\n        end_epoch();\n\n        // Validator 2 received no rewards. Validator 1 didn't fail proposals, so it still receives rewards.\n        assert_validator_state(validator_1_address, 101, 0, 0, 0, 1);\n        assert_validator_state(validator_2_address, 100, 0, 0, 0, 0);\n\n        // Validator 2 decides to leave. Both validators failed proposals.\n        unlock(validator_2, 100);\n        leave_validator_set(validator_2, validator_2_address);\n        let failed_proposer_indices = vector::empty<u64>();\n        let validator_1_index = borrow_global<ValidatorConfig>(validator_1_address).validator_index;\n        let validator_2_index = borrow_global<ValidatorConfig>(validator_2_address).validator_index;\n        vector::push_back(&mut failed_proposer_indices, validator_1_index);\n        vector::push_back(&mut failed_proposer_indices, validator_2_index);\n        update_performance_statistics(option::none(), failed_proposer_indices);\n        // Fast forward so validator 2's stake is fully unlocked.\n        timestamp::fast_forward_seconds(LOCKUP_CYCLE_SECONDS);\n        end_epoch();\n\n        // Validator 1 and 2 received no additional rewards due to failed proposals\n        assert_validator_state(validator_1_address, 101, 0, 0, 0, 0);\n        assert_validator_state(validator_2_address, 0, 100, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]\n    public entry fun test_validator_rewards_rate_decrease_over_time(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n\n        let genesis_time_in_secs = timestamp::now_seconds();\n\n        let validator_1_address = signer::address_of(validator_1);\n        let validator_2_address = signer::address_of(validator_2);\n\n        // Both validators join the set.\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 1000, true, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 10000, true, true);\n\n        // One epoch passed. Validator 1 and validator 2 should receive rewards at rewards rate = 1% every epoch.\n        end_epoch();\n        assert_validator_state(validator_1_address, 1010, 0, 0, 0, 1);\n        assert_validator_state(validator_2_address, 10100, 0, 0, 0, 0);\n\n        // Enable rewards rate decrease. Initially rewards rate is still 1% every epoch. Rewards rate halves every year.\n        let one_year_in_secs: u64 = 31536000;\n        staking_config::initialize_rewards(\n            aptos_framework,\n            fixed_point64::create_from_rational(1, 100),\n            fixed_point64::create_from_rational(3, 1000),\n            one_year_in_secs,\n            genesis_time_in_secs,\n            fixed_point64::create_from_rational(50, 100),\n        );\n        features::change_feature_flags_for_testing(aptos_framework, vector[features::get_periodical_reward_rate_decrease_feature()], vector[]);\n\n        // For some reason, this epoch is very long. It has been 1 year since genesis when the epoch ends.\n        timestamp::fast_forward_seconds(one_year_in_secs - EPOCH_DURATION * 3);\n        end_epoch();\n        // Validator 1 and validator 2 should still receive rewards at rewards rate = 1% every epoch. Rewards rate has halved after this epoch.\n        assert_validator_state(validator_1_address, 1020, 0, 0, 0, 1);\n        assert_validator_state(validator_2_address, 10200, 0, 0, 0, 0);\n\n        // For some reason, this epoch is also very long. One year passed.\n        timestamp::fast_forward_seconds(one_year_in_secs - EPOCH_DURATION);\n        end_epoch();\n        // Validator 1 and validator 2 should still receive rewards at rewards rate = 0.5% every epoch. Rewards rate has halved after this epoch.\n        assert_validator_state(validator_1_address, 1025, 0, 0, 0, 1);\n        assert_validator_state(validator_2_address, 10250, 0, 0, 0, 0);\n\n        end_epoch();\n        // Rewards rate has halved but cannot become lower than min_rewards_rate.\n        // Validator 1 and validator 2 should receive rewards at rewards rate = 0.3% every epoch.\n        assert_validator_state(validator_1_address, 1028, 0, 0, 0, 1);\n        assert_validator_state(validator_2_address, 10280, 0, 0, 0, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_update_performance_statistics_should_not_fail_due_to_out_of_bounds(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n\n        let validator_address = signer::address_of(validator);\n        let (_sk, pk, pop) = generate_identity();\n        initialize_test_validator(&pk, &pop, validator, 100, true, true);\n\n        let valid_validator_index = borrow_global<ValidatorConfig>(validator_address).validator_index;\n        let out_of_bounds_index = valid_validator_index + 100;\n\n        // Invalid validator index in the failed proposers vector should not lead to abort.\n        let failed_proposer_indices = vector::empty<u64>();\n        vector::push_back(&mut failed_proposer_indices, valid_validator_index);\n        vector::push_back(&mut failed_proposer_indices, out_of_bounds_index);\n        update_performance_statistics(option::none(), failed_proposer_indices);\n        end_epoch();\n\n        // Validator received no rewards due to failing to propose.\n        assert_validator_state(validator_address, 100, 0, 0, 0, 0);\n\n        // Invalid validator index in the proposer should not lead to abort.\n        let proposer_index_optional = option::some(out_of_bounds_index);\n        update_performance_statistics(proposer_index_optional, vector::empty<u64>());\n        end_epoch();\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    #[expected_failure(abort_code = 0x1000B, location = Self)]\n    public entry fun test_invalid_config(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorSet {\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 100, 100);\n\n        // Call initialize_stake_owner, which only initializes the stake pool but not validator config.\n        let validator_address = signer::address_of(validator);\n        account::create_account_for_test(validator_address);\n        initialize_stake_owner(validator, 0, validator_address, validator_address);\n        mint_and_add_stake(validator, 100);\n\n        // Join the validator set with enough stake. This should fail because the validator didn't initialize validator\n        // config.\n        join_validator_set(validator, validator_address);\n    }\n\n    #[test(aptos_framework = @aptos_framework, validator = @0x123)]\n    public entry fun test_valid_config(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorSet {\n        initialize_for_test_custom(aptos_framework, 50, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 100, 100);\n\n        // Call initialize_stake_owner, which only initializes the stake pool but not validator config.\n        let validator_address = signer::address_of(validator);\n        account::create_account_for_test(validator_address);\n        initialize_stake_owner(validator, 0, validator_address, validator_address);\n        mint_and_add_stake(validator, 100);\n\n        // Initialize validator config.\n        let validator_address = signer::address_of(validator);\n        let (_sk_new, pk_new, pop_new) = generate_identity();\n        let pk_new_bytes = bls12381::public_key_to_bytes(&pk_new);\n        let pop_new_bytes = bls12381::proof_of_possession_to_bytes(&pop_new);\n        rotate_consensus_key(validator, validator_address, pk_new_bytes, pop_new_bytes);\n\n        // Join the validator set with enough stake. This now wouldn't fail since the validator config already exists.\n        join_validator_set(validator, validator_address);\n    }\n\n    #[test]\n    public entry fun test_rewards_calculation() {\n        let stake_amount = 2000;\n        let num_successful_proposals = 199;\n        let num_total_proposals = 200;\n        let rewards_rate = 700;\n        let rewards_rate_denominator = 777;\n        let rewards_amount = calculate_rewards_amount(\n            stake_amount,\n            num_successful_proposals,\n            num_total_proposals,\n            rewards_rate,\n            rewards_rate_denominator\n        );\n        // Consider `amount_imprecise` and `amount_precise` defined as follows:\n        // amount_imprecise = (stake_amount * rewards_rate / rewards_rate_denominator) * num_successful_proposals / num_total_proposals\n        // amount_precise = stake_amount * rewards_rate * num_successful_proposals / (rewards_rate_denominator * num_total_proposals)\n        // Although they are equivalent in the real arithmetic, they are not in the integer arithmetic due to a rounding error.\n        // With the test parameters above, `amount_imprecise` is equal to 1791 because of an unbounded rounding error\n        // while `amount_precise` is equal to 1792. We expect the output of `calculate_rewards_amount` to be 1792.\n        assert!(rewards_amount == 1792, 0);\n\n        let stake_amount = 100000000000000000;\n        let num_successful_proposals = 9999;\n        let num_total_proposals = 10000;\n        let rewards_rate = 3141592;\n        let rewards_rate_denominator = 10000000;\n        // This should not abort due to an arithmetic overflow.\n        let rewards_amount = calculate_rewards_amount(\n            stake_amount,\n            num_successful_proposals,\n            num_total_proposals,\n            rewards_rate,\n            rewards_rate_denominator\n        );\n        assert!(rewards_amount == 31412778408000000, 0);\n    }\n\n    #[test_only]\n    public fun set_validator_perf_at_least_one_block() acquires ValidatorPerformance {\n        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);\n        vector::for_each_mut(&mut validator_perf.validators, |validator|{\n            let validator: &mut IndividualValidatorPerformance = validator;\n            if (validator.successful_proposals + validator.failed_proposals < 1) {\n                validator.successful_proposals = 1;\n            };\n        });\n    }\n\n    #[test(aptos_framework = @0x1, validator_1 = @0x123, validator_2 = @0x234)]\n    public entry fun test_removing_validator_from_active_set(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        initialize_for_test(aptos_framework);\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, true);\n        assert!(vector::length(&borrow_global<ValidatorSet>(@aptos_framework).active_validators) == 2, 0);\n\n        // Remove validator 1 from the active validator set. Only validator 2 remains.\n        let validator_to_remove = signer::address_of(validator_1);\n        remove_validators(aptos_framework, &vector[validator_to_remove]);\n        assert!(vector::length(&borrow_global<ValidatorSet>(@aptos_framework).active_validators) == 1, 0);\n        assert!(get_validator_state(validator_to_remove) == VALIDATOR_STATUS_PENDING_INACTIVE, 1);\n    }\n\n    #[test_only]\n    public fun end_epoch(\n    ) acquires StakePool, AptosCoinCapabilities, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // Set the number of blocks to 1, to give out rewards to non-failing validators.\n        set_validator_perf_at_least_one_block();\n        timestamp::fast_forward_seconds(EPOCH_DURATION);\n        reconfiguration_state::on_reconfig_start();\n        on_new_epoch();\n        reconfiguration_state::on_reconfig_finish();\n    }\n\n    #[test_only]\n    public fun assert_stake_pool(\n        pool_address: address,\n        active_stake: u64,\n        inactive_stake: u64,\n        pending_active_stake: u64,\n        pending_inactive_stake: u64,\n    ) acquires StakePool {\n        let stake_pool = borrow_global<StakePool>(pool_address);\n        let actual_active_stake = coin::value(&stake_pool.active);\n        assert!(actual_active_stake == active_stake, actual_active_stake);\n        let actual_inactive_stake = coin::value(&stake_pool.inactive);\n        assert!(actual_inactive_stake == inactive_stake, actual_inactive_stake);\n        let actual_pending_active_stake = coin::value(&stake_pool.pending_active);\n        assert!(actual_pending_active_stake == pending_active_stake, actual_pending_active_stake);\n        let actual_pending_inactive_stake = coin::value(&stake_pool.pending_inactive);\n        assert!(actual_pending_inactive_stake == pending_inactive_stake, actual_pending_inactive_stake);\n    }\n\n    #[test_only]\n    public fun assert_validator_state(\n        pool_address: address,\n        active_stake: u64,\n        inactive_stake: u64,\n        pending_active_stake: u64,\n        pending_inactive_stake: u64,\n        validator_index: u64,\n    ) acquires StakePool, ValidatorConfig {\n        assert_stake_pool(pool_address, active_stake, inactive_stake, pending_active_stake, pending_inactive_stake);\n        let validator_config = borrow_global<ValidatorConfig>(pool_address);\n        assert!(validator_config.validator_index == validator_index, validator_config.validator_index);\n    }\n\n    #[test(aptos_framework = @0x1, validator = @0x123)]\n    public entry fun test_allowed_validators(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, ValidatorSet {\n        let addr = signer::address_of(validator);\n        let (burn, mint) = aptos_coin::initialize_for_test(aptos_framework);\n        configure_allowed_validators(aptos_framework, vector[addr]);\n\n        account::create_account_for_test(addr);\n        coin::register<AptosCoin>(validator);\n        initialize_stake_owner(validator, 0, addr, addr);\n        coin::destroy_burn_cap(burn);\n        coin::destroy_mint_cap(mint);\n    }\n\n    #[test(aptos_framework = @0x1, validator = @0x123)]\n    #[expected_failure(abort_code = 0x60011, location = Self)]\n    public entry fun test_not_allowed_validators(\n        aptos_framework: &signer,\n        validator: &signer,\n    ) acquires AllowedValidators, OwnerCapability, StakePool, ValidatorSet {\n        configure_allowed_validators(aptos_framework, vector[]);\n        let (burn, mint) = aptos_coin::initialize_for_test(aptos_framework);\n\n        let addr = signer::address_of(validator);\n        account::create_account_for_test(addr);\n        coin::register<AptosCoin>(validator);\n        initialize_stake_owner(validator, 0, addr, addr);\n        coin::destroy_burn_cap(burn);\n        coin::destroy_mint_cap(mint);\n    }\n\n    #[test_only]\n    public fun with_rewards(amount: u64): u64 {\n        let (numerator, denominator) = staking_config::get_reward_rate(&staking_config::get());\n        amount + amount * numerator / denominator\n    }\n\n    #[test_only]\n    public fun get_validator_fee(validator_addr: address): u64 acquires ValidatorFees {\n        let fees_table = &borrow_global<ValidatorFees>(@aptos_framework).fees_table;\n        let coin = table::borrow(fees_table, validator_addr);\n        coin::value(coin)\n    }\n\n    #[test_only]\n    public fun assert_no_fees_for_validator(validator_addr: address) acquires ValidatorFees {\n        let fees_table = &borrow_global<ValidatorFees>(@aptos_framework).fees_table;\n        assert!(!table::contains(fees_table, validator_addr), 0);\n    }\n\n    #[test_only]\n    const COLLECT_AND_DISTRIBUTE_GAS_FEES: u64 = 6;\n\n    #[test(aptos_framework = @0x1, validator_1 = @0x123, validator_2 = @0x234, validator_3 = @0x345)]\n    fun test_distribute_validator_fees(\n        aptos_framework: &signer,\n        validator_1: &signer,\n        validator_2: &signer,\n        validator_3: &signer,\n    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorPerformance, ValidatorSet, ValidatorFees {\n        // Make sure that fees collection and distribution is enabled.\n        features::change_feature_flags_for_testing(aptos_framework, vector[COLLECT_AND_DISTRIBUTE_GAS_FEES], vector[]);\n        assert!(features::collect_and_distribute_gas_fees(), 0);\n\n        // Initialize staking and validator fees table.\n        initialize_for_test(aptos_framework);\n        initialize_validator_fees(aptos_framework);\n\n        let validator_1_address = signer::address_of(validator_1);\n        let validator_2_address = signer::address_of(validator_2);\n        let validator_3_address = signer::address_of(validator_3);\n\n        // Validators join the set and epoch ends.\n        let (_sk_1, pk_1, pop_1) = generate_identity();\n        let (_sk_2, pk_2, pop_2) = generate_identity();\n        let (_sk_3, pk_3, pop_3) = generate_identity();\n        initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, false);\n        initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, false);\n        initialize_test_validator(&pk_3, &pop_3, validator_3, 100, true, true);\n\n        // Next, simulate fees collection during three blocks, where proposers are\n        // validators 1, 2, and 1 again.\n        add_transaction_fee(validator_1_address, mint_coins(100));\n        add_transaction_fee(validator_2_address, mint_coins(500));\n        add_transaction_fee(validator_1_address, mint_coins(200));\n\n        // Fess have to be assigned to the right validators, but not\n        // distributed yet.\n        assert!(get_validator_fee(validator_1_address) == 300, 0);\n        assert!(get_validator_fee(validator_2_address) == 500, 0);\n        assert_no_fees_for_validator(validator_3_address);\n        assert_validator_state(validator_1_address, 100, 0, 0, 0, 2);\n        assert_validator_state(validator_2_address, 100, 0, 0, 0, 1);\n        assert_validator_state(validator_3_address, 100, 0, 0, 0, 0);\n\n        end_epoch();\n\n        // Epoch ended. Validators must have recieved their rewards and, most importantly,\n        // their fees.\n        assert_no_fees_for_validator(validator_1_address);\n        assert_no_fees_for_validator(validator_2_address);\n        assert_no_fees_for_validator(validator_3_address);\n        assert_validator_state(validator_1_address, 401, 0, 0, 0, 2);\n        assert_validator_state(validator_2_address, 601, 0, 0, 0, 1);\n        assert_validator_state(validator_3_address, 101, 0, 0, 0, 0);\n    }\n}\n","name":"stake.move"},{"content":"/// Allow stakers and operators to enter a staking contract with reward sharing.\n/// The main accounting logic in a staking contract consists of 2 parts:\n/// 1. Tracks how much commission needs to be paid out to the operator. This is tracked with an increasing principal\n/// amount that's updated every time the operator requests commission, the staker withdraws funds, or the staker\n/// switches operators.\n/// 2. Distributions of funds to operators (commissions) and stakers (stake withdrawals) use the shares model provided\n/// by the pool_u64 to track shares that increase in price as the stake pool accumulates rewards.\n///\n/// Example flow:\n/// 1. A staker creates a staking contract with an operator by calling create_staking_contract() with 100 coins of\n/// initial stake and commission = 10%. This means the operator will receive 10% of any accumulated rewards. A new stake\n/// pool will be created and hosted in a separate account that's controlled by the staking contract.\n/// 2. The operator sets up a validator node and, once ready, joins the validator set by calling stake::join_validator_set\n/// 3. After some time, the stake pool gains rewards and now has 150 coins.\n/// 4. Operator can now call request_commission. 10% of (150 - 100) = 5 coins will be unlocked from the stake pool. The\n/// staker's principal is now updated from 100 to 145 (150 coins - 5 coins of commission). The pending distribution pool\n/// has 5 coins total and the operator owns all 5 shares of it.\n/// 5. Some more time has passed. The pool now has 50 more coins in rewards and a total balance of 195. The operator\n/// calls request_commission again. Since the previous 5 coins have now become withdrawable, it'll be deposited into the\n/// operator's account first. Their new commission will be 10% of (195 coins - 145 principal) = 5 coins. Principal is\n/// updated to be 190 (195 - 5). Pending distribution pool has 5 coins and operator owns all 5 shares.\n/// 6. Staker calls unlock_stake to unlock 50 coins of stake, which gets added to the pending distribution pool. Based\n/// on shares math, staker will be owning 50 shares and operator still owns 5 shares of the 55-coin pending distribution\n/// pool.\n/// 7. Some time passes and the 55 coins become fully withdrawable from the stake pool. Due to accumulated rewards, the\n/// 55 coins become 70 coins. Calling distribute() distributes 6 coins to the operator and 64 coins to the validator.\nmodule aptos_framework::staking_contract {\n    use std::bcs;\n    use std::error;\n    use std::features;\n    use std::signer;\n    use std::vector;\n\n    use aptos_std::pool_u64::{Self, Pool};\n    use aptos_std::simple_map::{Self, SimpleMap};\n\n    use aptos_framework::account::{Self, SignerCapability};\n    use aptos_framework::aptos_account;\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::coin::{Self, Coin};\n    use aptos_framework::event::{EventHandle, emit, emit_event};\n    use aptos_framework::stake::{Self, OwnerCapability};\n    use aptos_framework::staking_config;\n\n    const SALT: vector<u8> = b\"aptos_framework::staking_contract\";\n\n    /// Store amount must be at least the min stake required for a stake pool to join the validator set.\n    const EINSUFFICIENT_STAKE_AMOUNT: u64 = 1;\n    /// Commission percentage has to be between 0 and 100.\n    const EINVALID_COMMISSION_PERCENTAGE: u64 = 2;\n    /// Staker has no staking contracts.\n    const ENO_STAKING_CONTRACT_FOUND_FOR_STAKER: u64 = 3;\n    /// No staking contract between the staker and operator found.\n    const ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR: u64 = 4;\n    /// Staking contracts can't be merged.\n    const ECANT_MERGE_STAKING_CONTRACTS: u64 = 5;\n    /// The staking contract already exists and cannot be re-created.\n    const ESTAKING_CONTRACT_ALREADY_EXISTS: u64 = 6;\n    /// Not enough active stake to withdraw. Some stake might still pending and will be active in the next epoch.\n    const EINSUFFICIENT_ACTIVE_STAKE_TO_WITHDRAW: u64 = 7;\n    /// Caller must be either the staker, operator, or beneficiary.\n    const ENOT_STAKER_OR_OPERATOR_OR_BENEFICIARY: u64 = 8;\n    /// Chaning beneficiaries for operators is not supported.\n    const EOPERATOR_BENEFICIARY_CHANGE_NOT_SUPPORTED: u64 = 9;\n\n    /// Maximum number of distributions a stake pool can support.\n    const MAXIMUM_PENDING_DISTRIBUTIONS: u64 = 20;\n\n    #[resource_group(scope = module_)]\n    struct StakingGroupContainer {}\n\n    struct StakingContract has store {\n        // Recorded principal after the last commission distribution.\n        // This is only used to calculate the commission the operator should be receiving.\n        principal: u64,\n        pool_address: address,\n        // The stake pool's owner capability. This can be used to control funds in the stake pool.\n        owner_cap: OwnerCapability,\n        commission_percentage: u64,\n        // Current distributions, including operator commission withdrawals and staker's partial withdrawals.\n        distribution_pool: Pool,\n        // Just in case we need the SignerCap for stake pool account in the future.\n        signer_cap: SignerCapability,\n    }\n\n    struct Store has key {\n        staking_contracts: SimpleMap<address, StakingContract>,\n\n        // Events.\n        create_staking_contract_events: EventHandle<CreateStakingContractEvent>,\n        update_voter_events: EventHandle<UpdateVoterEvent>,\n        reset_lockup_events: EventHandle<ResetLockupEvent>,\n        add_stake_events: EventHandle<AddStakeEvent>,\n        request_commission_events: EventHandle<RequestCommissionEvent>,\n        unlock_stake_events: EventHandle<UnlockStakeEvent>,\n        switch_operator_events: EventHandle<SwitchOperatorEvent>,\n        add_distribution_events: EventHandle<AddDistributionEvent>,\n        distribute_events: EventHandle<DistributeEvent>,\n    }\n\n    struct BeneficiaryForOperator has key {\n        beneficiary_for_operator: address,\n    }\n\n    struct UpdateCommissionEvent has drop, store {\n        staker: address,\n        operator: address,\n        old_commission_percentage: u64,\n        new_commission_percentage: u64,\n    }\n\n    #[event]\n    struct UpdateCommission has drop, store {\n        staker: address,\n        operator: address,\n        old_commission_percentage: u64,\n        new_commission_percentage: u64,\n    }\n\n    #[resource_group_member(group = aptos_framework::staking_contract::StakingGroupContainer)]\n    struct StakingGroupUpdateCommissionEvent has key {\n        update_commission_events: EventHandle<UpdateCommissionEvent>,\n    }\n\n    #[event]\n    struct CreateStakingContract has drop, store {\n        operator: address,\n        voter: address,\n        pool_address: address,\n        principal: u64,\n        commission_percentage: u64,\n    }\n\n    #[event]\n    struct UpdateVoter has drop, store {\n        operator: address,\n        pool_address: address,\n        old_voter: address,\n        new_voter: address,\n    }\n\n    #[event]\n    struct ResetLockup has drop, store {\n        operator: address,\n        pool_address: address,\n    }\n\n    #[event]\n    struct AddStake has drop, store {\n        operator: address,\n        pool_address: address,\n        amount: u64\n    }\n\n    #[event]\n    struct RequestCommission has drop, store {\n        operator: address,\n        pool_address: address,\n        accumulated_rewards: u64,\n        commission_amount: u64,\n    }\n\n    #[event]\n    struct UnlockStake has drop, store {\n        operator: address,\n        pool_address: address,\n        amount: u64,\n        commission_paid: u64,\n    }\n\n    #[event]\n    struct SwitchOperator has drop, store {\n        old_operator: address,\n        new_operator: address,\n        pool_address: address,\n    }\n\n    #[event]\n    struct AddDistribution has drop, store {\n        operator: address,\n        pool_address: address,\n        amount: u64,\n    }\n\n    #[event]\n    struct Distribute has drop, store {\n        operator: address,\n        pool_address: address,\n        recipient: address,\n        amount: u64,\n    }\n\n    #[event]\n    struct SetBeneficiaryForOperator has drop, store {\n        operator: address,\n        old_beneficiary: address,\n        new_beneficiary: address,\n    }\n\n    struct CreateStakingContractEvent has drop, store {\n        operator: address,\n        voter: address,\n        pool_address: address,\n        principal: u64,\n        commission_percentage: u64,\n    }\n\n    struct UpdateVoterEvent has drop, store {\n        operator: address,\n        pool_address: address,\n        old_voter: address,\n        new_voter: address,\n    }\n\n    struct ResetLockupEvent has drop, store {\n        operator: address,\n        pool_address: address,\n    }\n\n    struct AddStakeEvent has drop, store {\n        operator: address,\n        pool_address: address,\n        amount: u64\n    }\n\n    struct RequestCommissionEvent has drop, store {\n        operator: address,\n        pool_address: address,\n        accumulated_rewards: u64,\n        commission_amount: u64,\n    }\n\n    struct UnlockStakeEvent has drop, store {\n        operator: address,\n        pool_address: address,\n        amount: u64,\n        commission_paid: u64,\n    }\n\n    struct SwitchOperatorEvent has drop, store {\n        old_operator: address,\n        new_operator: address,\n        pool_address: address,\n    }\n\n    struct AddDistributionEvent has drop, store {\n        operator: address,\n        pool_address: address,\n        amount: u64,\n    }\n\n    struct DistributeEvent has drop, store {\n        operator: address,\n        pool_address: address,\n        recipient: address,\n        amount: u64,\n    }\n\n    #[view]\n    /// Return the address of the underlying stake pool for the staking contract between the provided staker and\n    /// operator.\n    ///\n    /// This errors out the staking contract with the provided staker and operator doesn't exist.\n    public fun stake_pool_address(staker: address, operator: address): address acquires Store {\n        assert_staking_contract_exists(staker, operator);\n        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;\n        simple_map::borrow(staking_contracts, &operator).pool_address\n    }\n\n    #[view]\n    /// Return the last recorded principal (the amount that 100% belongs to the staker with commission already paid for)\n    /// for staking contract between the provided staker and operator.\n    ///\n    /// This errors out the staking contract with the provided staker and operator doesn't exist.\n    public fun last_recorded_principal(staker: address, operator: address): u64 acquires Store {\n        assert_staking_contract_exists(staker, operator);\n        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;\n        simple_map::borrow(staking_contracts, &operator).principal\n    }\n\n    #[view]\n    /// Return percentage of accumulated rewards that will be paid to the operator as commission for staking contract\n    /// between the provided staker and operator.\n    ///\n    /// This errors out the staking contract with the provided staker and operator doesn't exist.\n    public fun commission_percentage(staker: address, operator: address): u64 acquires Store {\n        assert_staking_contract_exists(staker, operator);\n        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;\n        simple_map::borrow(staking_contracts, &operator).commission_percentage\n    }\n\n    #[view]\n    /// Return a tuple of three numbers:\n    /// 1. The total active stake in the underlying stake pool\n    /// 2. The total accumulated rewards that haven't had commission paid out\n    /// 3. The commission amount owned from those accumulated rewards.\n    ///\n    /// This errors out the staking contract with the provided staker and operator doesn't exist.\n    public fun staking_contract_amounts(staker: address, operator: address): (u64, u64, u64) acquires Store {\n        assert_staking_contract_exists(staker, operator);\n        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;\n        let staking_contract = simple_map::borrow(staking_contracts, &operator);\n        get_staking_contract_amounts_internal(staking_contract)\n    }\n\n    #[view]\n    /// Return the number of pending distributions (e.g. commission, withdrawals from stakers).\n    ///\n    /// This errors out the staking contract with the provided staker and operator doesn't exist.\n    public fun pending_distribution_counts(staker: address, operator: address): u64 acquires Store {\n        assert_staking_contract_exists(staker, operator);\n        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;\n        pool_u64::shareholders_count(&simple_map::borrow(staking_contracts, &operator).distribution_pool)\n    }\n\n    #[view]\n    /// Return true if the staking contract between the provided staker and operator exists.\n    public fun staking_contract_exists(staker: address, operator: address): bool acquires Store {\n        if (!exists<Store>(staker)) {\n            return false\n        };\n\n        let store = borrow_global<Store>(staker);\n        simple_map::contains_key(&store.staking_contracts, &operator)\n    }\n\n    #[view]\n    /// Return the beneficiary address of the operator.\n    public fun beneficiary_for_operator(operator: address): address acquires BeneficiaryForOperator {\n        if (exists<BeneficiaryForOperator>(operator)) {\n            return borrow_global<BeneficiaryForOperator>(operator).beneficiary_for_operator\n        } else {\n            operator\n        }\n    }\n\n    #[view]\n    /// Return the address of the stake pool to be created with the provided staker, operator and seed.\n    public fun get_expected_stake_pool_address(\n        staker: address,\n        operator: address,\n        contract_creation_seed: vector<u8>,\n    ): address {\n        let seed = create_resource_account_seed(staker, operator, contract_creation_seed);\n        account::create_resource_address(&staker, seed)\n    }\n\n    /// Staker can call this function to create a simple staking contract with a specified operator.\n    public entry fun create_staking_contract(\n        staker: &signer,\n        operator: address,\n        voter: address,\n        amount: u64,\n        commission_percentage: u64,\n        // Optional seed used when creating the staking contract account.\n        contract_creation_seed: vector<u8>,\n    ) acquires Store {\n        let staked_coins = coin::withdraw<AptosCoin>(staker, amount);\n        create_staking_contract_with_coins(\n            staker, operator, voter, staked_coins, commission_percentage, contract_creation_seed);\n    }\n\n    /// Staker can call this function to create a simple staking contract with a specified operator.\n    public fun create_staking_contract_with_coins(\n        staker: &signer,\n        operator: address,\n        voter: address,\n        coins: Coin<AptosCoin>,\n        commission_percentage: u64,\n        // Optional seed used when creating the staking contract account.\n        contract_creation_seed: vector<u8>,\n    ): address acquires Store {\n        assert!(\n            commission_percentage >= 0 && commission_percentage <= 100,\n            error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE),\n        );\n        // The amount should be at least the min_stake_required, so the stake pool will be eligible to join the\n        // validator set.\n        let (min_stake_required, _) = staking_config::get_required_stake(&staking_config::get());\n        let principal = coin::value(&coins);\n        assert!(principal >= min_stake_required, error::invalid_argument(EINSUFFICIENT_STAKE_AMOUNT));\n\n        // Initialize Store resource if this is the first time the staker has delegated to anyone.\n        let staker_address = signer::address_of(staker);\n        if (!exists<Store>(staker_address)) {\n            move_to(staker, new_staking_contracts_holder(staker));\n        };\n\n        // Cannot create the staking contract if it already exists.\n        let store = borrow_global_mut<Store>(staker_address);\n        let staking_contracts = &mut store.staking_contracts;\n        assert!(\n            !simple_map::contains_key(staking_contracts, &operator),\n            error::already_exists(ESTAKING_CONTRACT_ALREADY_EXISTS)\n        );\n\n        // Initialize the stake pool in a new resource account. This allows the same staker to contract with multiple\n        // different operators.\n        let (stake_pool_signer, stake_pool_signer_cap, owner_cap) =\n            create_stake_pool(staker, operator, voter, contract_creation_seed);\n\n        // Add the stake to the stake pool.\n        stake::add_stake_with_cap(&owner_cap, coins);\n\n        // Create the contract record.\n        let pool_address = signer::address_of(&stake_pool_signer);\n        simple_map::add(staking_contracts, operator, StakingContract {\n            principal,\n            pool_address,\n            owner_cap,\n            commission_percentage,\n            // Make sure we don't have too many pending recipients in the distribution pool.\n            // Otherwise, a griefing attack is possible where the staker can keep switching operators and create too\n            // many pending distributions. This can lead to out-of-gas failure whenever distribute() is called.\n            distribution_pool: pool_u64::create(MAXIMUM_PENDING_DISTRIBUTIONS),\n            signer_cap: stake_pool_signer_cap,\n        });\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(CreateStakingContract { operator, voter, pool_address, principal, commission_percentage });\n        };\n        emit_event(\n            &mut store.create_staking_contract_events,\n            CreateStakingContractEvent { operator, voter, pool_address, principal, commission_percentage },\n        );\n        pool_address\n    }\n\n    /// Add more stake to an existing staking contract.\n    public entry fun add_stake(staker: &signer, operator: address, amount: u64) acquires Store {\n        let staker_address = signer::address_of(staker);\n        assert_staking_contract_exists(staker_address, operator);\n\n        let store = borrow_global_mut<Store>(staker_address);\n        let staking_contract = simple_map::borrow_mut(&mut store.staking_contracts, &operator);\n\n        // Add the stake to the stake pool.\n        let staked_coins = coin::withdraw<AptosCoin>(staker, amount);\n        stake::add_stake_with_cap(&staking_contract.owner_cap, staked_coins);\n\n        staking_contract.principal = staking_contract.principal + amount;\n        let pool_address = staking_contract.pool_address;\n        if (std::features::module_event_migration_enabled()) {\n            emit(AddStake { operator, pool_address, amount });\n        };\n        emit_event(\n            &mut store.add_stake_events,\n            AddStakeEvent { operator, pool_address, amount },\n        );\n    }\n\n    /// Convenient function to allow the staker to update the voter address in a staking contract they made.\n    public entry fun update_voter(staker: &signer, operator: address, new_voter: address) acquires Store {\n        let staker_address = signer::address_of(staker);\n        assert_staking_contract_exists(staker_address, operator);\n\n        let store = borrow_global_mut<Store>(staker_address);\n        let staking_contract = simple_map::borrow_mut(&mut store.staking_contracts, &operator);\n        let pool_address = staking_contract.pool_address;\n        let old_voter = stake::get_delegated_voter(pool_address);\n        stake::set_delegated_voter_with_cap(&staking_contract.owner_cap, new_voter);\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(UpdateVoter { operator, pool_address, old_voter, new_voter });\n        };\n        emit_event(\n            &mut store.update_voter_events,\n            UpdateVoterEvent { operator, pool_address, old_voter, new_voter },\n        );\n\n    }\n\n    /// Convenient function to allow the staker to reset their stake pool's lockup period to start now.\n    public entry fun reset_lockup(staker: &signer, operator: address) acquires Store {\n        let staker_address = signer::address_of(staker);\n        assert_staking_contract_exists(staker_address, operator);\n\n        let store = borrow_global_mut<Store>(staker_address);\n        let staking_contract = simple_map::borrow_mut(&mut store.staking_contracts, &operator);\n        let pool_address = staking_contract.pool_address;\n        stake::increase_lockup_with_cap(&staking_contract.owner_cap);\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(ResetLockup { operator, pool_address });\n        };\n        emit_event(&mut store.reset_lockup_events, ResetLockupEvent { operator, pool_address });\n    }\n\n    /// Convenience function to allow a staker to update the commission percentage paid to the operator.\n    /// TODO: fix the typo in function name. commision -> commission\n    public entry fun update_commision(\n        staker: &signer,\n        operator: address,\n        new_commission_percentage: u64\n    ) acquires Store, BeneficiaryForOperator, StakingGroupUpdateCommissionEvent {\n        assert!(\n            new_commission_percentage >= 0 && new_commission_percentage <= 100,\n            error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE),\n        );\n\n        let staker_address = signer::address_of(staker);\n        assert!(exists<Store>(staker_address), error::not_found(ENO_STAKING_CONTRACT_FOUND_FOR_STAKER));\n\n        let store = borrow_global_mut<Store>(staker_address);\n        let staking_contract = simple_map::borrow_mut(&mut store.staking_contracts, &operator);\n        distribute_internal(staker_address, operator, staking_contract, &mut store.distribute_events);\n        request_commission_internal(\n            operator,\n            staking_contract,\n            &mut store.add_distribution_events,\n            &mut store.request_commission_events,\n        );\n        let old_commission_percentage = staking_contract.commission_percentage;\n        staking_contract.commission_percentage = new_commission_percentage;\n        if (!exists<StakingGroupUpdateCommissionEvent>(staker_address)) {\n            move_to(\n                staker,\n                StakingGroupUpdateCommissionEvent {\n                    update_commission_events: account::new_event_handle<UpdateCommissionEvent>(\n                        staker\n                    )\n                }\n            )\n        };\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                UpdateCommission { staker: staker_address, operator, old_commission_percentage, new_commission_percentage }\n            );\n        };\n        emit_event(\n            &mut borrow_global_mut<StakingGroupUpdateCommissionEvent>(staker_address).update_commission_events,\n            UpdateCommissionEvent { staker: staker_address, operator, old_commission_percentage, new_commission_percentage }\n        );\n    }\n\n    /// Unlock commission amount from the stake pool. Operator needs to wait for the amount to become withdrawable\n    /// at the end of the stake pool's lockup period before they can actually can withdraw_commission.\n    ///\n    /// Only staker, operator or beneficiary can call this.\n    public entry fun request_commission(\n        account: &signer,\n        staker: address,\n        operator: address\n    ) acquires Store, BeneficiaryForOperator {\n        let account_addr = signer::address_of(account);\n        assert!(\n            account_addr == staker || account_addr == operator || account_addr == beneficiary_for_operator(operator),\n            error::unauthenticated(ENOT_STAKER_OR_OPERATOR_OR_BENEFICIARY)\n        );\n        assert_staking_contract_exists(staker, operator);\n\n        let store = borrow_global_mut<Store>(staker);\n        let staking_contract = simple_map::borrow_mut(&mut store.staking_contracts, &operator);\n        // Short-circuit if zero commission.\n        if (staking_contract.commission_percentage == 0) {\n            return\n        };\n\n        // Force distribution of any already inactive stake.\n        distribute_internal(staker, operator, staking_contract, &mut store.distribute_events);\n\n        request_commission_internal(\n            operator,\n            staking_contract,\n            &mut store.add_distribution_events,\n            &mut store.request_commission_events,\n        );\n    }\n\n    fun request_commission_internal(\n        operator: address,\n        staking_contract: &mut StakingContract,\n        add_distribution_events: &mut EventHandle<AddDistributionEvent>,\n        request_commission_events: &mut EventHandle<RequestCommissionEvent>,\n    ): u64 {\n        // Unlock just the commission portion from the stake pool.\n        let (total_active_stake, accumulated_rewards, commission_amount) =\n            get_staking_contract_amounts_internal(staking_contract);\n        staking_contract.principal = total_active_stake - commission_amount;\n\n        // Short-circuit if there's no commission to pay.\n        if (commission_amount == 0) {\n            return 0\n        };\n\n        // Add a distribution for the operator.\n        add_distribution(operator, staking_contract, operator, commission_amount, add_distribution_events);\n\n        // Request to unlock the commission from the stake pool.\n        // This won't become fully unlocked until the stake pool's lockup expires.\n        stake::unlock_with_cap(commission_amount, &staking_contract.owner_cap);\n\n        let pool_address = staking_contract.pool_address;\n        if (std::features::module_event_migration_enabled()) {\n            emit(RequestCommission { operator, pool_address, accumulated_rewards, commission_amount });\n        };\n        emit_event(\n            request_commission_events,\n            RequestCommissionEvent { operator, pool_address, accumulated_rewards, commission_amount },\n        );\n\n        commission_amount\n    }\n\n    /// Staker can call this to request withdrawal of part or all of their staking_contract.\n    /// This also triggers paying commission to the operator for accounting simplicity.\n    public entry fun unlock_stake(\n        staker: &signer,\n        operator: address,\n        amount: u64\n    ) acquires Store, BeneficiaryForOperator {\n        // Short-circuit if amount is 0.\n        if (amount == 0) return;\n\n        let staker_address = signer::address_of(staker);\n        assert_staking_contract_exists(staker_address, operator);\n\n        let store = borrow_global_mut<Store>(staker_address);\n        let staking_contract = simple_map::borrow_mut(&mut store.staking_contracts, &operator);\n\n        // Force distribution of any already inactive stake.\n        distribute_internal(staker_address, operator, staking_contract, &mut store.distribute_events);\n\n        // For simplicity, we request commission to be paid out first. This avoids having to ensure to staker doesn't\n        // withdraw into the commission portion.\n        let commission_paid = request_commission_internal(\n            operator,\n            staking_contract,\n            &mut store.add_distribution_events,\n            &mut store.request_commission_events,\n        );\n\n        // If there's less active stake remaining than the amount requested (potentially due to commission),\n        // only withdraw up to the active amount.\n        let (active, _, _, _) = stake::get_stake(staking_contract.pool_address);\n        if (active < amount) {\n            amount = active;\n        };\n        staking_contract.principal = staking_contract.principal - amount;\n\n        // Record a distribution for the staker.\n        add_distribution(operator, staking_contract, staker_address, amount, &mut store.add_distribution_events);\n\n        // Request to unlock the distribution amount from the stake pool.\n        // This won't become fully unlocked until the stake pool's lockup expires.\n        stake::unlock_with_cap(amount, &staking_contract.owner_cap);\n\n        let pool_address = staking_contract.pool_address;\n        if (std::features::module_event_migration_enabled()) {\n            emit(UnlockStake { pool_address, operator, amount, commission_paid });\n        };\n        emit_event(\n            &mut store.unlock_stake_events,\n            UnlockStakeEvent { pool_address, operator, amount, commission_paid },\n        );\n    }\n\n    /// Unlock all accumulated rewards since the last recorded principals.\n    public entry fun unlock_rewards(staker: &signer, operator: address) acquires Store, BeneficiaryForOperator {\n        let staker_address = signer::address_of(staker);\n        assert_staking_contract_exists(staker_address, operator);\n\n        // Calculate how much rewards belongs to the staker after commission is paid.\n        let (_, accumulated_rewards, unpaid_commission) = staking_contract_amounts(staker_address, operator);\n        let staker_rewards = accumulated_rewards - unpaid_commission;\n        unlock_stake(staker, operator, staker_rewards);\n    }\n\n    /// Allows staker to switch operator without going through the lenghthy process to unstake, without resetting commission.\n    public entry fun switch_operator_with_same_commission(\n        staker: &signer,\n        old_operator: address,\n        new_operator: address,\n    ) acquires Store, BeneficiaryForOperator {\n        let staker_address = signer::address_of(staker);\n        assert_staking_contract_exists(staker_address, old_operator);\n\n        let commission_percentage = commission_percentage(staker_address, old_operator);\n        switch_operator(staker, old_operator, new_operator, commission_percentage);\n    }\n\n    /// Allows staker to switch operator without going through the lenghthy process to unstake.\n    public entry fun switch_operator(\n        staker: &signer,\n        old_operator: address,\n        new_operator: address,\n        new_commission_percentage: u64,\n    ) acquires Store, BeneficiaryForOperator {\n        let staker_address = signer::address_of(staker);\n        assert_staking_contract_exists(staker_address, old_operator);\n\n        // Merging two existing staking contracts is too complex as we'd need to merge two separate stake pools.\n        let store = borrow_global_mut<Store>(staker_address);\n        let staking_contracts = &mut store.staking_contracts;\n        assert!(\n            !simple_map::contains_key(staking_contracts, &new_operator),\n            error::invalid_state(ECANT_MERGE_STAKING_CONTRACTS),\n        );\n\n        let (_, staking_contract) = simple_map::remove(staking_contracts, &old_operator);\n        // Force distribution of any already inactive stake.\n        distribute_internal(staker_address, old_operator, &mut staking_contract, &mut store.distribute_events);\n\n        // For simplicity, we request commission to be paid out first. This avoids having to ensure to staker doesn't\n        // withdraw into the commission portion.\n        request_commission_internal(\n            old_operator,\n            &mut staking_contract,\n            &mut store.add_distribution_events,\n            &mut store.request_commission_events,\n        );\n\n        // Update the staking contract's commission rate and stake pool's operator.\n        stake::set_operator_with_cap(&staking_contract.owner_cap, new_operator);\n        staking_contract.commission_percentage = new_commission_percentage;\n\n        let pool_address = staking_contract.pool_address;\n        simple_map::add(staking_contracts, new_operator, staking_contract);\n        if (std::features::module_event_migration_enabled()) {\n            emit(SwitchOperator { pool_address, old_operator, new_operator });\n        };\n        emit_event(\n            &mut store.switch_operator_events,\n            SwitchOperatorEvent { pool_address, old_operator, new_operator }\n        );\n    }\n\n    /// Allows an operator to change its beneficiary. Any existing unpaid commission rewards will be paid to the new\n    /// beneficiary. To ensures payment to the current beneficiary, one should first call `distribute` before switching\n    /// the beneficiary. An operator can set one beneficiary for staking contract pools, not a separate one for each pool.\n    public entry fun set_beneficiary_for_operator(\n        operator: &signer,\n        new_beneficiary: address\n    ) acquires BeneficiaryForOperator {\n        assert!(features::operator_beneficiary_change_enabled(), std::error::invalid_state(\n            EOPERATOR_BENEFICIARY_CHANGE_NOT_SUPPORTED\n        ));\n        // The beneficiay address of an operator is stored under the operator's address.\n        // So, the operator does not need to be validated with respect to a staking pool.\n        let operator_addr = signer::address_of(operator);\n        let old_beneficiary = beneficiary_for_operator(operator_addr);\n        if (exists<BeneficiaryForOperator>(operator_addr)) {\n            borrow_global_mut<BeneficiaryForOperator>(operator_addr).beneficiary_for_operator = new_beneficiary;\n        } else {\n            move_to(operator, BeneficiaryForOperator { beneficiary_for_operator: new_beneficiary });\n        };\n\n        emit(SetBeneficiaryForOperator {\n            operator: operator_addr,\n            old_beneficiary,\n            new_beneficiary,\n        });\n    }\n\n    /// Allow anyone to distribute already unlocked funds. This does not affect reward compounding and therefore does\n    /// not need to be restricted to just the staker or operator.\n    public entry fun distribute(staker: address, operator: address) acquires Store, BeneficiaryForOperator {\n        assert_staking_contract_exists(staker, operator);\n        let store = borrow_global_mut<Store>(staker);\n        let staking_contract = simple_map::borrow_mut(&mut store.staking_contracts, &operator);\n        distribute_internal(staker, operator, staking_contract, &mut store.distribute_events);\n    }\n\n    /// Distribute all unlocked (inactive) funds according to distribution shares.\n    fun distribute_internal(\n        staker: address,\n        operator: address,\n        staking_contract: &mut StakingContract,\n        distribute_events: &mut EventHandle<DistributeEvent>,\n    ) acquires BeneficiaryForOperator {\n        let pool_address = staking_contract.pool_address;\n        let (_, inactive, _, pending_inactive) = stake::get_stake(pool_address);\n        let total_potential_withdrawable = inactive + pending_inactive;\n        let coins = stake::withdraw_with_cap(&staking_contract.owner_cap, total_potential_withdrawable);\n        let distribution_amount = coin::value(&coins);\n        if (distribution_amount == 0) {\n            coin::destroy_zero(coins);\n            return\n        };\n\n        let distribution_pool = &mut staking_contract.distribution_pool;\n        update_distribution_pool(\n            distribution_pool, distribution_amount, operator, staking_contract.commission_percentage);\n\n        // Buy all recipients out of the distribution pool.\n        while (pool_u64::shareholders_count(distribution_pool) > 0) {\n            let recipients = pool_u64::shareholders(distribution_pool);\n            let recipient = *vector::borrow(&mut recipients, 0);\n            let current_shares = pool_u64::shares(distribution_pool, recipient);\n            let amount_to_distribute = pool_u64::redeem_shares(distribution_pool, recipient, current_shares);\n            // If the recipient is the operator, send the commission to the beneficiary instead.\n            if (recipient == operator) {\n                recipient = beneficiary_for_operator(operator);\n            };\n            aptos_account::deposit_coins(recipient, coin::extract(&mut coins, amount_to_distribute));\n\n            if (std::features::module_event_migration_enabled()) {\n                emit(Distribute { operator, pool_address, recipient, amount: amount_to_distribute });\n            };\n            emit_event(\n                distribute_events,\n                DistributeEvent { operator, pool_address, recipient, amount: amount_to_distribute }\n            );\n        };\n\n        // In case there's any dust left, send them all to the staker.\n        if (coin::value(&coins) > 0) {\n            aptos_account::deposit_coins(staker, coins);\n            pool_u64::update_total_coins(distribution_pool, 0);\n        } else {\n            coin::destroy_zero(coins);\n        }\n    }\n\n    /// Assert that a staking_contract exists for the staker/operator pair.\n    fun assert_staking_contract_exists(staker: address, operator: address) acquires Store {\n        assert!(exists<Store>(staker), error::not_found(ENO_STAKING_CONTRACT_FOUND_FOR_STAKER));\n        let staking_contracts = &mut borrow_global_mut<Store>(staker).staking_contracts;\n        assert!(\n            simple_map::contains_key(staking_contracts, &operator),\n            error::not_found(ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR),\n        );\n    }\n\n    /// Add a new distribution for `recipient` and `amount` to the staking contract's distributions list.\n    fun add_distribution(\n        operator: address,\n        staking_contract: &mut StakingContract,\n        recipient: address,\n        coins_amount: u64,\n        add_distribution_events: &mut EventHandle<AddDistributionEvent>\n    ) {\n        let distribution_pool = &mut staking_contract.distribution_pool;\n        let (_, _, _, total_distribution_amount) = stake::get_stake(staking_contract.pool_address);\n        update_distribution_pool(\n            distribution_pool, total_distribution_amount, operator, staking_contract.commission_percentage);\n\n        pool_u64::buy_in(distribution_pool, recipient, coins_amount);\n        let pool_address = staking_contract.pool_address;\n        if (std::features::module_event_migration_enabled()) {\n            emit(AddDistribution { operator, pool_address, amount: coins_amount });\n        };\n        emit_event(\n            add_distribution_events,\n            AddDistributionEvent { operator, pool_address, amount: coins_amount }\n        );\n    }\n\n    /// Calculate accumulated rewards and commissions since last update.\n    fun get_staking_contract_amounts_internal(staking_contract: &StakingContract): (u64, u64, u64) {\n        // Pending_inactive is not included in the calculation because pending_inactive can only come from:\n        // 1. Outgoing commissions. This means commission has already been extracted.\n        // 2. Stake withdrawals from stakers. This also means commission has already been extracted as\n        // request_commission_internal is called in unlock_stake\n        let (active, _, pending_active, _) = stake::get_stake(staking_contract.pool_address);\n        let total_active_stake = active + pending_active;\n        let accumulated_rewards = total_active_stake - staking_contract.principal;\n        let commission_amount = accumulated_rewards * staking_contract.commission_percentage / 100;\n\n        (total_active_stake, accumulated_rewards, commission_amount)\n    }\n\n    fun create_stake_pool(\n        staker: &signer,\n        operator: address,\n        voter: address,\n        contract_creation_seed: vector<u8>,\n    ): (signer, SignerCapability, OwnerCapability) {\n        // Generate a seed that will be used to create the resource account that hosts the staking contract.\n        let seed = create_resource_account_seed(\n            signer::address_of(staker), operator, contract_creation_seed);\n\n        let (stake_pool_signer, stake_pool_signer_cap) = account::create_resource_account(staker, seed);\n        stake::initialize_stake_owner(&stake_pool_signer, 0, operator, voter);\n\n        // Extract owner_cap from the StakePool, so we have control over it in the staking_contracts flow.\n        // This is stored as part of the staking_contract. Thus, the staker would not have direct control over it without\n        // going through well-defined functions in this module.\n        let owner_cap = stake::extract_owner_cap(&stake_pool_signer);\n\n        (stake_pool_signer, stake_pool_signer_cap, owner_cap)\n    }\n\n    fun update_distribution_pool(\n        distribution_pool: &mut Pool,\n        updated_total_coins: u64,\n        operator: address,\n        commission_percentage: u64,\n    ) {\n        // Short-circuit and do nothing if the pool's total value has not changed.\n        if (pool_u64::total_coins(distribution_pool) == updated_total_coins) {\n            return\n        };\n\n        // Charge all stakeholders (except for the operator themselves) commission on any rewards earnt relatively to the\n        // previous value of the distribution pool.\n        let shareholders = &pool_u64::shareholders(distribution_pool);\n        vector::for_each_ref(shareholders, |shareholder| {\n            let shareholder: address = *shareholder;\n            if (shareholder != operator) {\n                let shares = pool_u64::shares(distribution_pool, shareholder);\n                let previous_worth = pool_u64::balance(distribution_pool, shareholder);\n                let current_worth = pool_u64::shares_to_amount_with_total_coins(\n                    distribution_pool, shares, updated_total_coins);\n                let unpaid_commission = (current_worth - previous_worth) * commission_percentage / 100;\n                // Transfer shares from current shareholder to the operator as payment.\n                // The value of the shares should use the updated pool's total value.\n                let shares_to_transfer = pool_u64::amount_to_shares_with_total_coins(\n                    distribution_pool, unpaid_commission, updated_total_coins);\n                pool_u64::transfer_shares(distribution_pool, shareholder, operator, shares_to_transfer);\n            };\n        });\n\n        pool_u64::update_total_coins(distribution_pool, updated_total_coins);\n    }\n\n    /// Create the seed to derive the resource account address.\n    fun create_resource_account_seed(\n        staker: address,\n        operator: address,\n        contract_creation_seed: vector<u8>,\n    ): vector<u8> {\n        let seed = bcs::to_bytes(&staker);\n        vector::append(&mut seed, bcs::to_bytes(&operator));\n        // Include a salt to avoid conflicts with any other modules out there that might also generate\n        // deterministic resource accounts for the same staker + operator addresses.\n        vector::append(&mut seed, SALT);\n        // Add an extra salt given by the staker in case an account with the same address has already been created.\n        vector::append(&mut seed, contract_creation_seed);\n        seed\n    }\n\n    /// Create a new staking_contracts resource.\n    fun new_staking_contracts_holder(staker: &signer): Store {\n        Store {\n            staking_contracts: simple_map::create<address, StakingContract>(),\n            // Events.\n            create_staking_contract_events: account::new_event_handle<CreateStakingContractEvent>(staker),\n            update_voter_events: account::new_event_handle<UpdateVoterEvent>(staker),\n            reset_lockup_events: account::new_event_handle<ResetLockupEvent>(staker),\n            add_stake_events: account::new_event_handle<AddStakeEvent>(staker),\n            request_commission_events: account::new_event_handle<RequestCommissionEvent>(staker),\n            unlock_stake_events: account::new_event_handle<UnlockStakeEvent>(staker),\n            switch_operator_events: account::new_event_handle<SwitchOperatorEvent>(staker),\n            add_distribution_events: account::new_event_handle<AddDistributionEvent>(staker),\n            distribute_events: account::new_event_handle<DistributeEvent>(staker),\n        }\n    }\n\n    #[test_only]\n    const VALIDATOR_STATUS_ACTIVE: u64 = 2;\n    #[test_only]\n    const VALIDATOR_STATUS_INACTIVE: u64 = 4;\n\n    #[test_only]\n    use aptos_framework::stake::with_rewards;\n\n    #[test_only]\n    const INITIAL_BALANCE: u64 = 100000000000000; // 1M APT coins with 8 decimals.\n\n    #[test_only]\n    const MAXIMUM_STAKE: u64 = 100000000000000000; // 1B APT coins with 8 decimals.\n\n    #[test_only]\n    const MODULE_EVENT: u64 = 26;\n\n    #[test_only]\n    const OPERATOR_BENEFICIARY_CHANGE: u64 = 39;\n\n    #[test_only]\n    public fun setup(aptos_framework: &signer, staker: &signer, operator: &signer, initial_balance: u64) {\n        // Reward rate of 0.1% per epoch.\n        stake::initialize_for_test_custom(\n            aptos_framework,\n            INITIAL_BALANCE,\n            MAXIMUM_STAKE,\n            3600,\n            true,\n            10,\n            10000,\n            1000000\n        );\n\n        let staker_address = signer::address_of(staker);\n        if (!account::exists_at(staker_address)) {\n            account::create_account_for_test(staker_address);\n        };\n        let operator_address = signer::address_of(operator);\n        if (!account::exists_at(operator_address)) {\n            account::create_account_for_test(operator_address);\n        };\n        stake::mint(staker, initial_balance);\n        stake::mint(operator, initial_balance);\n    }\n\n    #[test_only]\n    public fun setup_staking_contract(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer,\n        amount: u64,\n        commission: u64,\n    ) acquires Store {\n        setup(aptos_framework, staker, operator, amount);\n        let operator_address = signer::address_of(operator);\n\n        // Voter is initially set to operator but then updated to be staker.\n        create_staking_contract(staker, operator_address, operator_address, amount, commission, vector::empty<u8>());\n        std::features::change_feature_flags_for_testing(aptos_framework, vector[MODULE_EVENT, OPERATOR_BENEFICIARY_CHANGE], vector[]);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_end_to_end(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer\n    ) acquires Store, BeneficiaryForOperator {\n        setup_staking_contract(aptos_framework, staker, operator, INITIAL_BALANCE, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        assert_staking_contract_exists(staker_address, operator_address);\n        assert_staking_contract(staker_address, operator_address, INITIAL_BALANCE, 10);\n\n        // Verify that the stake pool has been set up properly.\n        let pool_address = stake_pool_address(staker_address, operator_address);\n        stake::assert_stake_pool(pool_address, INITIAL_BALANCE, 0, 0, 0);\n        assert!(last_recorded_principal(staker_address, operator_address) == INITIAL_BALANCE, 0);\n\n        // Operator joins the validator set.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, pool_address, true);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Fast forward to generate rewards.\n        stake::end_epoch();\n        let new_balance = with_rewards(INITIAL_BALANCE);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n\n        // Operator claims 10% of rewards so far as commissions.\n        let expected_commission_1 = (new_balance - last_recorded_principal(staker_address, operator_address)) / 10;\n        new_balance = new_balance - expected_commission_1;\n        request_commission(operator, staker_address, operator_address);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, expected_commission_1);\n        assert!(last_recorded_principal(staker_address, operator_address) == new_balance, 0);\n        assert_distribution(staker_address, operator_address, operator_address, expected_commission_1);\n        stake::fast_forward_to_unlock(pool_address);\n\n        // Both original stake and operator commissions have received rewards.\n        expected_commission_1 = with_rewards(expected_commission_1);\n        new_balance = with_rewards(new_balance);\n        stake::assert_stake_pool(pool_address, new_balance, expected_commission_1, 0, 0);\n        distribute(staker_address, operator_address);\n        let operator_balance = coin::balance<AptosCoin>(operator_address);\n        let expected_operator_balance = INITIAL_BALANCE + expected_commission_1;\n        assert!(operator_balance == expected_operator_balance, operator_balance);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n        assert_no_pending_distributions(staker_address, operator_address);\n\n        // Staker adds more stake.\n        stake::mint(staker, INITIAL_BALANCE);\n        let previous_principal = last_recorded_principal(staker_address, operator_address);\n        add_stake(staker, operator_address, INITIAL_BALANCE);\n        stake::assert_stake_pool(pool_address, new_balance, 0, INITIAL_BALANCE, 0);\n        assert!(last_recorded_principal(staker_address, operator_address) == previous_principal + INITIAL_BALANCE, 0);\n\n        // The newly added stake didn't receive any rewards because it was only added in the new epoch.\n        stake::end_epoch();\n        new_balance = with_rewards(new_balance) + INITIAL_BALANCE;\n\n        // Second round of commission request/withdrawal.\n        let expected_commission_2 = (new_balance - last_recorded_principal(staker_address, operator_address)) / 10;\n        new_balance = new_balance - expected_commission_2;\n        request_commission(operator, staker_address, operator_address);\n        assert_distribution(staker_address, operator_address, operator_address, expected_commission_2);\n        assert!(last_recorded_principal(staker_address, operator_address) == new_balance, 0);\n        stake::fast_forward_to_unlock(pool_address);\n        expected_commission_2 = with_rewards(expected_commission_2);\n        distribute(staker_address, operator_address);\n        operator_balance = coin::balance<AptosCoin>(operator_address);\n        expected_operator_balance = expected_operator_balance + expected_commission_2;\n        assert!(operator_balance == expected_operator_balance, operator_balance);\n        assert_no_pending_distributions(staker_address, operator_address);\n        new_balance = with_rewards(new_balance);\n\n        // New rounds of rewards.\n        stake::fast_forward_to_unlock(pool_address);\n        new_balance = with_rewards(new_balance);\n\n        // Staker withdraws all stake, which should also request commission distribution.\n        let unpaid_commission = (new_balance - last_recorded_principal(staker_address, operator_address)) / 10;\n        unlock_stake(staker, operator_address, new_balance);\n        stake::assert_stake_pool(pool_address, 0, 0, 0, new_balance);\n        assert_distribution(staker_address, operator_address, operator_address, unpaid_commission);\n        let withdrawn_amount = new_balance - unpaid_commission;\n        assert_distribution(staker_address, operator_address, staker_address, withdrawn_amount);\n        assert!(last_recorded_principal(staker_address, operator_address) == 0, 0);\n\n        // End epoch. The stake pool should get kicked out of the validator set as it has 0 remaining active stake.\n        stake::fast_forward_to_unlock(pool_address);\n        // Operator should still earn 10% commission on the rewards on top of the staker's withdrawn_amount.\n        let commission_on_withdrawn_amount = (with_rewards(withdrawn_amount) - withdrawn_amount) / 10;\n        unpaid_commission = with_rewards(unpaid_commission) + commission_on_withdrawn_amount;\n        withdrawn_amount = with_rewards(withdrawn_amount) - commission_on_withdrawn_amount;\n        stake::assert_stake_pool(pool_address, 0, with_rewards(new_balance), 0, 0);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE, 0);\n\n        // Distribute and verify balances.\n        distribute(staker_address, operator_address);\n        assert_no_pending_distributions(staker_address, operator_address);\n        operator_balance = coin::balance<AptosCoin>(operator_address);\n        assert!(operator_balance == expected_operator_balance + unpaid_commission, operator_balance);\n        let staker_balance = coin::balance<AptosCoin>(staker_address);\n        // Staker receives the extra dust due to rounding error.\n        assert!(staker_balance == withdrawn_amount + 1, staker_balance);\n        assert_no_pending_distributions(staker_address, operator_address);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_operator_cannot_request_same_commission_multiple_times(\n        aptos_framework: &signer, staker: &signer, operator: &signer) acquires Store, BeneficiaryForOperator {\n        setup_staking_contract(aptos_framework, staker, operator, INITIAL_BALANCE, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        let pool_address = stake_pool_address(staker_address, operator_address);\n\n        // Operator joins the validator set.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, pool_address, true);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Fast forward to generate rewards.\n        stake::end_epoch();\n        let new_balance = with_rewards(INITIAL_BALANCE);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n\n        // Operator tries to request commission multiple times. But their distribution shouldn't change.\n        let expected_commission = (new_balance - last_recorded_principal(staker_address, operator_address)) / 10;\n        request_commission(operator, staker_address, operator_address);\n        assert_distribution(staker_address, operator_address, operator_address, expected_commission);\n        request_commission(operator, staker_address, operator_address);\n        assert_distribution(staker_address, operator_address, operator_address, expected_commission);\n        request_commission(operator, staker_address, operator_address);\n        assert_distribution(staker_address, operator_address, operator_address, expected_commission);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_unlock_rewards(\n        aptos_framework: &signer, staker: &signer, operator: &signer) acquires Store, BeneficiaryForOperator {\n        setup_staking_contract(aptos_framework, staker, operator, INITIAL_BALANCE, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        let pool_address = stake_pool_address(staker_address, operator_address);\n\n        // Operator joins the validator set.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, pool_address, true);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Fast forward to generate rewards.\n        stake::end_epoch();\n        let new_balance = with_rewards(INITIAL_BALANCE);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n\n        // Staker withdraws all accumulated rewards, which should pay commission first.\n        unlock_rewards(staker, operator_address);\n        let accumulated_rewards = new_balance - INITIAL_BALANCE;\n        let expected_commission = accumulated_rewards / 10;\n        let staker_rewards = accumulated_rewards - expected_commission;\n        assert_distribution(staker_address, operator_address, staker_address, staker_rewards);\n        assert_distribution(staker_address, operator_address, operator_address, expected_commission);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    #[expected_failure(abort_code = 0x80006, location = Self)]\n    public entry fun test_staker_cannot_create_same_staking_contract_multiple_times(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer,\n    ) acquires Store {\n        setup_staking_contract(aptos_framework, staker, operator, INITIAL_BALANCE, 10);\n        let operator_address = signer::address_of(operator);\n        stake::mint(staker, INITIAL_BALANCE);\n        create_staking_contract(staker, operator_address, operator_address, INITIAL_BALANCE, 10, vector::empty<u8>());\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    #[expected_failure(abort_code = 0x10002, location = Self)]\n    public entry fun test_staker_cannot_create_staking_contract_with_invalid_commission(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer,\n    ) acquires Store {\n        setup_staking_contract(aptos_framework, staker, operator, INITIAL_BALANCE, 101);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    #[expected_failure(abort_code = 0x10001, location = Self)]\n    public entry fun test_staker_cannot_create_staking_contract_with_less_than_min_stake_required(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer,\n    ) acquires Store {\n        setup_staking_contract(aptos_framework, staker, operator, 50, 100);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_update_voter(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer,\n    ) acquires Store {\n        setup_staking_contract(aptos_framework, staker, operator, INITIAL_BALANCE, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n\n        // Voter is initially set to operator but then updated to be staker.\n        let pool_address = stake_pool_address(staker_address, operator_address);\n        assert!(stake::get_delegated_voter(pool_address) == operator_address, 0);\n        update_voter(staker, operator_address, staker_address);\n        assert!(stake::get_delegated_voter(pool_address) == staker_address, 1);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_reset_lockup(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer,\n    ) acquires Store {\n        setup_staking_contract(aptos_framework, staker, operator, INITIAL_BALANCE, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        let pool_address = stake_pool_address(staker_address, operator_address);\n\n        let origin_lockup_expiration = stake::get_lockup_secs(pool_address);\n        reset_lockup(staker, operator_address);\n        assert!(origin_lockup_expiration < stake::get_lockup_secs(pool_address), 0);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator_1 = @0x234, operator_2 = @0x345)]\n    public entry fun test_staker_can_switch_operator(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator_1: &signer,\n        operator_2: &signer,\n    ) acquires Store, BeneficiaryForOperator {\n        setup_staking_contract(aptos_framework, staker, operator_1, INITIAL_BALANCE, 10);\n        account::create_account_for_test(signer::address_of(operator_2));\n        stake::mint(operator_2, INITIAL_BALANCE);\n        let staker_address = signer::address_of(staker);\n        let operator_1_address = signer::address_of(operator_1);\n        let operator_2_address = signer::address_of(operator_2);\n\n        // Join validator set and earn some rewards.\n        let pool_address = stake_pool_address(staker_address, operator_1_address);\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator_1, pool_address, true);\n        stake::end_epoch();\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 0);\n\n        // Switch operators.\n        switch_operator(staker, operator_1_address, operator_2_address, 20);\n        // The staking_contract is now associated with operator 2 but there should be a pending distribution of unpaid\n        // commission to operator 1.\n        let new_balance = with_rewards(INITIAL_BALANCE);\n        let commission_for_operator_1 = (new_balance - INITIAL_BALANCE) / 10;\n        assert_distribution(staker_address, operator_2_address, operator_1_address, commission_for_operator_1);\n        // Unpaid commission should be unlocked from the stake pool.\n        new_balance = new_balance - commission_for_operator_1;\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, commission_for_operator_1);\n        assert!(last_recorded_principal(staker_address, operator_2_address) == new_balance, 0);\n\n        // The stake pool's validator should not have left the validator set.\n        assert!(stake_pool_address(staker_address, operator_2_address) == pool_address, 1);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 2);\n\n        // End epoch to get more rewards.\n        stake::fast_forward_to_unlock(pool_address);\n        new_balance = with_rewards(new_balance);\n        // Rewards on the commission being paid to operator_1 should still be charged commission that will go to\n        // operator_2;\n        let commission_on_operator_1_distribution =\n            (with_rewards(commission_for_operator_1) - commission_for_operator_1) / 5;\n        commission_for_operator_1 = with_rewards(commission_for_operator_1) - commission_on_operator_1_distribution;\n\n        // Verify that when commissions are withdrawn, previous pending distribution to operator 1 also happens.\n        // Then new commission of 20% is paid to operator 2.\n        let commission_for_operator_2 =\n            (new_balance - last_recorded_principal(staker_address, operator_2_address)) / 5;\n        new_balance = new_balance - commission_for_operator_2;\n        request_commission(operator_2, staker_address, operator_2_address);\n        assert_distribution(staker_address, operator_2_address, operator_2_address, commission_for_operator_2);\n        let operator_1_balance = coin::balance<AptosCoin>(operator_1_address);\n        assert!(operator_1_balance == INITIAL_BALANCE + commission_for_operator_1, operator_1_balance);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, commission_for_operator_2);\n        assert!(last_recorded_principal(staker_address, operator_2_address) == new_balance, 0);\n        stake::fast_forward_to_unlock(pool_address);\n\n        // Operator 2's commission is distributed.\n        distribute(staker_address, operator_2_address);\n        let operator_2_balance = coin::balance<AptosCoin>(operator_2_address);\n        new_balance = with_rewards(new_balance);\n        commission_for_operator_2 = with_rewards(commission_for_operator_2);\n        assert!(\n            operator_2_balance == INITIAL_BALANCE + commission_for_operator_2 + commission_on_operator_1_distribution,\n            operator_2_balance,\n        );\n        stake::assert_stake_pool(\n            pool_address,\n            new_balance,\n            0,\n            0,\n            0,\n        );\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator_1 = @0x234, operator_2 = @0x345)]\n    public entry fun test_staker_can_switch_operator_with_same_commission(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator_1: &signer,\n        operator_2: &signer,\n    ) acquires Store, BeneficiaryForOperator {\n        setup_staking_contract(aptos_framework, staker, operator_1, INITIAL_BALANCE, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_1_address = signer::address_of(operator_1);\n        let operator_2_address = signer::address_of(operator_2);\n\n        // Switch operators.\n        switch_operator_with_same_commission(staker, operator_1_address, operator_2_address);\n        // The staking_contract should now be associated with operator 2 but with same commission rate.\n        assert!(staking_contract_exists(staker_address, operator_2_address), 0);\n        assert!(!staking_contract_exists(staker_address, operator_1_address), 1);\n        assert!(commission_percentage(staker_address, operator_2_address) == 10, 2);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator1 = @0x234, beneficiary = @0x345, operator2 = @0x456)]\n    public entry fun test_operator_can_set_beneficiary(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator1: &signer,\n        beneficiary: &signer,\n        operator2: &signer,\n    ) acquires Store, BeneficiaryForOperator {\n        setup_staking_contract(aptos_framework, staker, operator1, INITIAL_BALANCE, 10);\n        let staker_address = signer::address_of(staker);\n        let operator1_address = signer::address_of(operator1);\n        let operator2_address = signer::address_of(operator2);\n        let beneficiary_address = signer::address_of(beneficiary);\n\n        // account::create_account_for_test(beneficiary_address);\n        aptos_framework::aptos_account::create_account(beneficiary_address);\n        assert_staking_contract_exists(staker_address, operator1_address);\n        assert_staking_contract(staker_address, operator1_address, INITIAL_BALANCE, 10);\n\n        // Verify that the stake pool has been set up properly.\n        let pool_address = stake_pool_address(staker_address, operator1_address);\n        stake::assert_stake_pool(pool_address, INITIAL_BALANCE, 0, 0, 0);\n        assert!(last_recorded_principal(staker_address, operator1_address) == INITIAL_BALANCE, 0);\n        assert!(stake::get_operator(pool_address) == operator1_address, 0);\n        assert!(beneficiary_for_operator(operator1_address) == operator1_address, 0);\n\n        // Operator joins the validator set.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator1, pool_address, true);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Set beneficiary.\n        set_beneficiary_for_operator(operator1, beneficiary_address);\n        assert!(beneficiary_for_operator(operator1_address) == beneficiary_address, 0);\n\n        // Fast forward to generate rewards.\n        stake::end_epoch();\n        let new_balance = with_rewards(INITIAL_BALANCE);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n\n        // Operator claims 10% of rewards so far as commissions.\n        let expected_commission_1 = (new_balance - last_recorded_principal(staker_address, operator1_address)) / 10;\n        new_balance = new_balance - expected_commission_1;\n        request_commission(operator1, staker_address, operator1_address);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, expected_commission_1);\n        assert!(last_recorded_principal(staker_address, operator1_address) == new_balance, 0);\n        assert_distribution(staker_address, operator1_address, operator1_address, expected_commission_1);\n        stake::fast_forward_to_unlock(pool_address);\n\n        // Both original stake and operator commissions have received rewards.\n        expected_commission_1 = with_rewards(expected_commission_1);\n        new_balance = with_rewards(new_balance);\n        stake::assert_stake_pool(pool_address, new_balance, expected_commission_1, 0, 0);\n        distribute(staker_address, operator1_address);\n        let operator_balance = coin::balance<AptosCoin>(operator1_address);\n        let beneficiary_balance = coin::balance<AptosCoin>(beneficiary_address);\n        let expected_operator_balance = INITIAL_BALANCE;\n        let expected_beneficiary_balance = expected_commission_1;\n        assert!(operator_balance == expected_operator_balance, operator_balance);\n        assert!(beneficiary_balance == expected_beneficiary_balance, beneficiary_balance);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n        assert_no_pending_distributions(staker_address, operator1_address);\n\n        // switch operator to operator2. The rewards should go to operator2 not to the beneficiay of operator1.\n        let old_beneficiay_balance = beneficiary_balance;\n        switch_operator(staker, operator1_address, operator2_address, 10);\n\n        stake::end_epoch();\n        let (_, accumulated_rewards, _) = staking_contract_amounts(staker_address, operator2_address);\n\n        let expected_commission = accumulated_rewards / 10;\n\n        // Request commission.\n        request_commission(operator2, staker_address, operator2_address);\n        // Unlocks the commission.\n        stake::fast_forward_to_unlock(pool_address);\n        expected_commission = with_rewards(expected_commission);\n\n        // Distribute the commission to the operator.\n        distribute(staker_address, operator2_address);\n\n        // Assert that the rewards go to operator2, and the balance of the operator1's beneficiay remains the same.\n        assert!(coin::balance<AptosCoin>(operator2_address) >= expected_commission, 1);\n        assert!(coin::balance<AptosCoin>(beneficiary_address) == old_beneficiay_balance, 1);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_staker_can_withdraw_partial_stake(\n        aptos_framework: &signer, staker: &signer, operator: &signer) acquires Store, BeneficiaryForOperator {\n        let initial_balance = INITIAL_BALANCE * 2;\n        setup_staking_contract(aptos_framework, staker, operator, initial_balance, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        let pool_address = stake_pool_address(staker_address, operator_address);\n\n        // Operator joins the validator set so rewards are generated.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, pool_address, true);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Fast forward to generate rewards.\n        stake::end_epoch();\n        let new_balance = with_rewards(initial_balance);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n\n        // Staker withdraws 1/4 of the stake, which should also request commission distribution.\n        let withdrawn_stake = new_balance / 4;\n        let unpaid_commission = (new_balance - initial_balance) / 10;\n        let new_balance = new_balance - withdrawn_stake - unpaid_commission;\n        unlock_stake(staker, operator_address, withdrawn_stake);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, withdrawn_stake + unpaid_commission);\n        assert_distribution(staker_address, operator_address, operator_address, unpaid_commission);\n        assert_distribution(staker_address, operator_address, staker_address, withdrawn_stake);\n        assert!(last_recorded_principal(staker_address, operator_address) == new_balance, 0);\n\n        // The validator is still in the active set as its remaining stake is still above min required.\n        stake::fast_forward_to_unlock(pool_address);\n        new_balance = with_rewards(new_balance);\n        unpaid_commission = with_rewards(unpaid_commission);\n        // Commission should still be charged on the rewards on top of withdrawn_stake.\n        // So the operator should receive 10% of the rewards on top of withdrawn_stake.\n        let commission_on_withdrawn_stake = (with_rewards(withdrawn_stake) - withdrawn_stake) / 10;\n        unpaid_commission = unpaid_commission + commission_on_withdrawn_stake;\n        withdrawn_stake = with_rewards(withdrawn_stake) - commission_on_withdrawn_stake;\n        stake::assert_stake_pool(pool_address, new_balance, withdrawn_stake + unpaid_commission, 0, 0);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 0);\n\n        // Distribute and verify balances.\n        distribute(staker_address, operator_address);\n        assert_no_pending_distributions(staker_address, operator_address);\n        let operator_balance = coin::balance<AptosCoin>(operator_address);\n        assert!(operator_balance == initial_balance + unpaid_commission, operator_balance);\n        let staker_balance = coin::balance<AptosCoin>(staker_address);\n        assert!(staker_balance == withdrawn_stake, staker_balance);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_staker_can_withdraw_partial_stake_if_operator_never_joined_validator_set(\n        aptos_framework: &signer, staker: &signer, operator: &signer) acquires Store, BeneficiaryForOperator {\n        let initial_balance = INITIAL_BALANCE * 2;\n        setup_staking_contract(aptos_framework, staker, operator, initial_balance, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        let pool_address = stake_pool_address(staker_address, operator_address);\n\n        // Epoch ended, but since validator never joined the set, no rewards were minted.\n        stake::end_epoch();\n        stake::assert_stake_pool(pool_address, initial_balance, 0, 0, 0);\n\n        // Staker withdraws 1/4 of the stake, which doesn't create any commission distribution as there's no rewards.\n        let withdrawn_stake = initial_balance / 4;\n        let new_balance = initial_balance - withdrawn_stake;\n        unlock_stake(staker, operator_address, withdrawn_stake);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, withdrawn_stake);\n        assert_distribution(staker_address, operator_address, operator_address, 0);\n        assert_distribution(staker_address, operator_address, staker_address, withdrawn_stake);\n        assert!(last_recorded_principal(staker_address, operator_address) == new_balance, 0);\n\n        // Distribute and verify balances.\n        distribute(staker_address, operator_address);\n        assert_no_pending_distributions(staker_address, operator_address);\n        // Operator's balance shouldn't change as there are no rewards.\n        let operator_balance = coin::balance<AptosCoin>(operator_address);\n        assert!(operator_balance == initial_balance, operator_balance);\n        // Staker receives back the withdrawn amount (no rewards).\n        let staker_balance = coin::balance<AptosCoin>(staker_address);\n        assert!(staker_balance == withdrawn_stake, staker_balance);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_multiple_distributions_added_before_distribute(\n        aptos_framework: &signer, staker: &signer, operator: &signer) acquires Store, BeneficiaryForOperator {\n        let initial_balance = INITIAL_BALANCE * 2;\n        setup_staking_contract(aptos_framework, staker, operator, initial_balance, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        let pool_address = stake_pool_address(staker_address, operator_address);\n\n        // Operator joins the validator set so rewards are generated.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, pool_address, true);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Fast forward to generate rewards.\n        stake::end_epoch();\n        let new_balance = with_rewards(initial_balance);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, 0);\n\n        // Staker withdraws 1/4 of the stake, which should also request commission distribution.\n        let withdrawn_stake = new_balance / 4;\n        let unpaid_commission = (new_balance - initial_balance) / 10;\n        let new_balance = new_balance - withdrawn_stake - unpaid_commission;\n        unlock_stake(staker, operator_address, withdrawn_stake);\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, withdrawn_stake + unpaid_commission);\n        assert_distribution(staker_address, operator_address, operator_address, unpaid_commission);\n        assert_distribution(staker_address, operator_address, staker_address, withdrawn_stake);\n        assert!(last_recorded_principal(staker_address, operator_address) == new_balance, 0);\n\n        // End epoch to generate some rewards. Staker withdraws another 1/4 of the stake.\n        // Commission should be charged on the rewards earned on the previous 1/4 stake withdrawal.\n        stake::end_epoch();\n        let commission_on_withdrawn_stake = (with_rewards(withdrawn_stake) - withdrawn_stake) / 10;\n        let commission_on_new_balance = (with_rewards(new_balance) - new_balance) / 10;\n        unpaid_commission = with_rewards(unpaid_commission) + commission_on_withdrawn_stake + commission_on_new_balance;\n        new_balance = with_rewards(new_balance) - commission_on_new_balance;\n        let new_withdrawn_stake = new_balance / 4;\n        unlock_stake(staker, operator_address, new_withdrawn_stake);\n        new_balance = new_balance - new_withdrawn_stake;\n        withdrawn_stake = with_rewards(withdrawn_stake) - commission_on_withdrawn_stake + new_withdrawn_stake;\n        stake::assert_stake_pool(pool_address, new_balance, 0, 0, withdrawn_stake + unpaid_commission);\n        // There's some small rounding error here.\n        assert_distribution(staker_address, operator_address, operator_address, unpaid_commission - 1);\n        assert_distribution(staker_address, operator_address, staker_address, withdrawn_stake);\n        assert!(last_recorded_principal(staker_address, operator_address) == new_balance, 0);\n    }\n\n    #[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]\n    public entry fun test_update_commission(\n        aptos_framework: &signer,\n        staker: &signer,\n        operator: &signer\n    ) acquires Store, BeneficiaryForOperator, StakingGroupUpdateCommissionEvent {\n        let initial_balance = INITIAL_BALANCE * 2;\n        setup_staking_contract(aptos_framework, staker, operator, initial_balance, 10);\n        let staker_address = signer::address_of(staker);\n        let operator_address = signer::address_of(operator);\n        let pool_address = stake_pool_address(staker_address, operator_address);\n\n        // Operator joins the validator set so rewards are generated.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, pool_address, true);\n        assert!(stake::get_validator_state(pool_address) == VALIDATOR_STATUS_ACTIVE, 1);\n\n        // Fast forward to generate rewards.\n        stake::end_epoch();\n        let balance_1epoch = with_rewards(initial_balance);\n        let unpaid_commission = (balance_1epoch - initial_balance) / 10;\n        stake::assert_stake_pool(pool_address, balance_1epoch, 0, 0, 0);\n\n        update_commision(staker, operator_address, 5);\n        stake::end_epoch();\n        let balance_2epoch = with_rewards(balance_1epoch - unpaid_commission);\n        stake::assert_stake_pool(pool_address, balance_2epoch, 0, 0, with_rewards(unpaid_commission));\n    }\n\n    #[test(\n        staker = @0xe256f4f4e2986cada739e339895cf5585082ff247464cab8ec56eea726bd2263,\n        operator = @0x9f0a211d218b082987408f1e393afe1ba0c202c6d280f081399788d3360c7f09\n    )]\n    public entry fun test_get_expected_stake_pool_address(staker: address, operator: address) {\n        let pool_address = get_expected_stake_pool_address(staker, operator, vector[0x42, 0x42]);\n        assert!(pool_address == @0x9d9648031ada367c26f7878eb0b0406ae6a969b1a43090269e5cdfabe1b48f0f, 0);\n    }\n\n    #[test_only]\n    public fun assert_staking_contract(\n        staker: address, operator: address, principal: u64, commission_percentage: u64) acquires Store {\n        let staking_contract = simple_map::borrow(&borrow_global<Store>(staker).staking_contracts, &operator);\n        assert!(staking_contract.principal == principal, staking_contract.principal);\n        assert!(\n            staking_contract.commission_percentage == commission_percentage,\n            staking_contract.commission_percentage\n        );\n    }\n\n    #[test_only]\n    public fun assert_no_pending_distributions(staker: address, operator: address) acquires Store {\n        let staking_contract = simple_map::borrow(&borrow_global<Store>(staker).staking_contracts, &operator);\n        let distribution_pool = &staking_contract.distribution_pool;\n        let shareholders_count = pool_u64::shareholders_count(distribution_pool);\n        assert!(shareholders_count == 0, shareholders_count);\n        let total_coins_remaining = pool_u64::total_coins(distribution_pool);\n        assert!(total_coins_remaining == 0, total_coins_remaining);\n    }\n\n    #[test_only]\n    public fun assert_distribution(\n        staker: address, operator: address, recipient: address, coins_amount: u64) acquires Store {\n        let staking_contract = simple_map::borrow(&borrow_global<Store>(staker).staking_contracts, &operator);\n        let distribution_balance = pool_u64::balance(&staking_contract.distribution_pool, recipient);\n        assert!(distribution_balance == coins_amount, distribution_balance);\n    }\n}\n","name":"staking_contract.move"},{"content":"module aptos_framework::staking_proxy {\n    use std::signer;\n    use std::vector;\n\n    use aptos_framework::stake;\n    use aptos_framework::staking_contract;\n    use aptos_framework::vesting;\n\n    public entry fun set_operator(owner: &signer, old_operator: address, new_operator: address) {\n        set_vesting_contract_operator(owner, old_operator, new_operator);\n        set_staking_contract_operator(owner, old_operator, new_operator);\n        set_stake_pool_operator(owner, new_operator);\n    }\n\n    public entry fun set_voter(owner: &signer, operator: address, new_voter: address) {\n        set_vesting_contract_voter(owner, operator, new_voter);\n        set_staking_contract_voter(owner, operator, new_voter);\n        set_stake_pool_voter(owner, new_voter);\n    }\n\n    public entry fun set_vesting_contract_operator(owner: &signer, old_operator: address, new_operator: address) {\n        let owner_address = signer::address_of(owner);\n        let vesting_contracts = &vesting::vesting_contracts(owner_address);\n        vector::for_each_ref(vesting_contracts, |vesting_contract| {\n            let vesting_contract = *vesting_contract;\n            if (vesting::operator(vesting_contract) == old_operator) {\n                let current_commission_percentage = vesting::operator_commission_percentage(vesting_contract);\n                vesting::update_operator(owner, vesting_contract, new_operator, current_commission_percentage);\n            };\n        });\n    }\n\n    public entry fun set_staking_contract_operator(owner: &signer, old_operator: address, new_operator: address) {\n        let owner_address = signer::address_of(owner);\n        if (staking_contract::staking_contract_exists(owner_address, old_operator)) {\n            let current_commission_percentage = staking_contract::commission_percentage(owner_address, old_operator);\n            staking_contract::switch_operator(owner, old_operator, new_operator, current_commission_percentage);\n        };\n    }\n\n    public entry fun set_stake_pool_operator(owner: &signer, new_operator: address) {\n        let owner_address = signer::address_of(owner);\n        if (stake::stake_pool_exists(owner_address)) {\n            stake::set_operator(owner, new_operator);\n        };\n    }\n\n    public entry fun set_vesting_contract_voter(owner: &signer, operator: address, new_voter: address) {\n        let owner_address = signer::address_of(owner);\n        let vesting_contracts = &vesting::vesting_contracts(owner_address);\n        vector::for_each_ref(vesting_contracts, |vesting_contract| {\n            let vesting_contract = *vesting_contract;\n            if (vesting::operator(vesting_contract) == operator) {\n                vesting::update_voter(owner, vesting_contract, new_voter);\n            };\n        });\n    }\n\n    public entry fun set_staking_contract_voter(owner: &signer, operator: address, new_voter: address) {\n        let owner_address = signer::address_of(owner);\n        if (staking_contract::staking_contract_exists(owner_address, operator)) {\n            staking_contract::update_voter(owner, operator, new_voter);\n        };\n    }\n\n    public entry fun set_stake_pool_voter(owner: &signer, new_voter: address) {\n        if (stake::stake_pool_exists(signer::address_of(owner))) {\n            stake::set_delegated_voter(owner, new_voter);\n        };\n    }\n\n    #[test_only]\n    const INITIAL_BALANCE: u64 = 100000000000000; // 1M APT coins with 8 decimals.\n\n    #[test(\n        aptos_framework = @0x1,\n        owner = @0x123,\n        operator_1 = @0x234,\n        operator_2 = @0x345,\n        new_operator = @0x567,\n    )]\n    public entry fun test_set_operator(\n        aptos_framework: &signer,\n        owner: &signer,\n        operator_1: &signer,\n        operator_2: &signer,\n        new_operator: &signer,\n    ) {\n        let owner_address = signer::address_of(owner);\n        let operator_1_address = signer::address_of(operator_1);\n        let operator_2_address = signer::address_of(operator_2);\n        let new_operator_address = signer::address_of(new_operator);\n        vesting::setup(\n            aptos_framework, &vector[owner_address, operator_1_address, operator_2_address, new_operator_address]);\n        staking_contract::setup_staking_contract(aptos_framework, owner, operator_1, INITIAL_BALANCE, 0);\n        staking_contract::setup_staking_contract(aptos_framework, owner, operator_2, INITIAL_BALANCE, 0);\n\n        let vesting_contract_1 = vesting::setup_vesting_contract(owner, &vector[@11], &vector[INITIAL_BALANCE], owner_address, 0);\n        vesting::update_operator(owner, vesting_contract_1, operator_1_address, 0);\n        let vesting_contract_2 = vesting::setup_vesting_contract(owner, &vector[@12], &vector[INITIAL_BALANCE], owner_address, 0);\n        vesting::update_operator(owner, vesting_contract_2, operator_2_address, 0);\n\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::initialize_test_validator(&pk, &pop, owner, INITIAL_BALANCE, false, false);\n        stake::set_operator(owner, operator_1_address);\n\n        set_operator(owner, operator_1_address, new_operator_address);\n        // Stake pool's operator has been switched from operator 1 to new operator.\n        assert!(stake::get_operator(owner_address) == new_operator_address, 0);\n        // Staking contract has been switched from operator 1 to new operator.\n        // Staking contract with operator_2 should stay unchanged.\n        assert!(staking_contract::staking_contract_exists(owner_address, new_operator_address), 1);\n        assert!(!staking_contract::staking_contract_exists(owner_address, operator_1_address), 2);\n        assert!(staking_contract::staking_contract_exists(owner_address, operator_2_address), 3);\n        // Vesting contract 1 has been switched from operator 1 to new operator while vesting contract 2 stays unchanged\n        assert!(vesting::operator(vesting_contract_1) == new_operator_address, 4);\n        assert!(vesting::operator(vesting_contract_2) == operator_2_address, 5);\n    }\n\n    #[test(\n        aptos_framework = @0x1,\n        owner = @0x123,\n        operator_1 = @0x234,\n        operator_2 = @0x345,\n        new_operator = @0x567,\n    )]\n    public entry fun test_set_operator_nothing_to_change(\n        aptos_framework: &signer,\n        owner: &signer,\n        operator_1: &signer,\n        operator_2: &signer,\n        new_operator: &signer,\n    ) {\n        let owner_address = signer::address_of(owner);\n        let operator_1_address = signer::address_of(operator_1);\n        let operator_2_address = signer::address_of(operator_2);\n        let new_operator_address = signer::address_of(new_operator);\n        vesting::setup(\n            aptos_framework, &vector[owner_address, operator_1_address, operator_2_address, new_operator_address]);\n        staking_contract::setup_staking_contract(aptos_framework, owner, operator_2, INITIAL_BALANCE, 0);\n\n        let vesting_contract_2 = vesting::setup_vesting_contract(owner, &vector[@12], &vector[INITIAL_BALANCE], owner_address, 0);\n        vesting::update_operator(owner, vesting_contract_2, operator_2_address, 0);\n\n        set_operator(owner, operator_1_address, new_operator_address);\n        // No staking or vesting contracts changed.\n        assert!(!staking_contract::staking_contract_exists(owner_address, new_operator_address), 0);\n        assert!(staking_contract::staking_contract_exists(owner_address, operator_2_address), 1);\n        assert!(vesting::operator(vesting_contract_2) == operator_2_address, 2);\n    }\n\n    #[test(\n        aptos_framework = @0x1,\n        owner = @0x123,\n        operator_1 = @0x234,\n        operator_2 = @0x345,\n        new_voter = @0x567,\n    )]\n    public entry fun test_set_voter(\n        aptos_framework: &signer,\n        owner: &signer,\n        operator_1: &signer,\n        operator_2: &signer,\n        new_voter: &signer,\n    ) {\n        let owner_address = signer::address_of(owner);\n        let operator_1_address = signer::address_of(operator_1);\n        let operator_2_address = signer::address_of(operator_2);\n        let new_voter_address = signer::address_of(new_voter);\n        vesting::setup(\n            aptos_framework, &vector[owner_address, operator_1_address, operator_2_address, new_voter_address]);\n        staking_contract::setup_staking_contract(aptos_framework, owner, operator_1, INITIAL_BALANCE, 0);\n        staking_contract::setup_staking_contract(aptos_framework, owner, operator_2, INITIAL_BALANCE, 0);\n\n        let vesting_contract_1 = vesting::setup_vesting_contract(owner, &vector[@11], &vector[INITIAL_BALANCE], owner_address, 0);\n        vesting::update_operator(owner, vesting_contract_1, operator_1_address, 0);\n        let vesting_contract_2 = vesting::setup_vesting_contract(owner, &vector[@12], &vector[INITIAL_BALANCE], owner_address, 0);\n        vesting::update_operator(owner, vesting_contract_2, operator_2_address, 0);\n\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::initialize_test_validator(&pk, &pop, owner, INITIAL_BALANCE, false, false);\n\n        set_voter(owner, operator_1_address, new_voter_address);\n        // Stake pool's voter has been updated.\n        assert!(stake::get_delegated_voter(owner_address) == new_voter_address, 0);\n        // Staking contract with operator 1's voter has been updated.\n        // Staking contract with operator_2 should stay unchanged.\n        let stake_pool_address_1 = staking_contract::stake_pool_address(owner_address, operator_1_address);\n        let stake_pool_address_2 = staking_contract::stake_pool_address(owner_address, operator_2_address);\n        assert!(stake::get_delegated_voter(stake_pool_address_1) == new_voter_address, 1);\n        assert!(stake::get_delegated_voter(stake_pool_address_2) == operator_2_address, 2);\n        // Vesting contract 1's voter has been updated while vesting contract 2's stays unchanged.\n        assert!(vesting::voter(vesting_contract_1) == new_voter_address, 3);\n        assert!(vesting::voter(vesting_contract_2) == owner_address, 4);\n    }\n\n    #[test(\n        aptos_framework = @0x1,\n        owner = @0x123,\n        operator_1 = @0x234,\n        operator_2 = @0x345,\n        new_voter = @0x567,\n    )]\n    public entry fun test_set_voter_nothing_to_change(\n        aptos_framework: &signer,\n        owner: &signer,\n        operator_1: &signer,\n        operator_2: &signer,\n        new_voter: &signer,\n    ) {\n        let owner_address = signer::address_of(owner);\n        let operator_1_address = signer::address_of(operator_1);\n        let operator_2_address = signer::address_of(operator_2);\n        let new_voter_address = signer::address_of(new_voter);\n        vesting::setup(\n            aptos_framework, &vector[owner_address, operator_1_address, operator_2_address, new_voter_address]);\n        staking_contract::setup_staking_contract(aptos_framework, owner, operator_2, INITIAL_BALANCE, 0);\n\n        let vesting_contract_2 = vesting::setup_vesting_contract(owner, &vector[@12], &vector[INITIAL_BALANCE], owner_address, 0);\n        vesting::update_operator(owner, vesting_contract_2, operator_2_address, 0);\n\n        set_operator(owner, operator_1_address, new_voter_address);\n        // No staking or vesting contracts changed.\n        let stake_pool_address = staking_contract::stake_pool_address(owner_address, operator_2_address);\n        assert!(stake::get_delegated_voter(stake_pool_address) == operator_2_address, 0);\n        assert!(vesting::voter(vesting_contract_2) == owner_address, 1);\n    }\n}\n","name":"staking_proxy.move"},{"content":"module aptos_framework::state_storage {\n\n    use aptos_framework::system_addresses;\n    use std::error;\n\n    friend aptos_framework::block;\n    friend aptos_framework::genesis;\n    friend aptos_framework::storage_gas;\n\n    const ESTATE_STORAGE_USAGE: u64 = 0;\n\n    struct Usage has copy, drop, store {\n        items: u64,\n        bytes: u64,\n    }\n\n    /// This is updated at the beginning of each epoch, reflecting the storage\n    /// usage after the last txn of the previous epoch is committed.\n    struct StateStorageUsage has key, store {\n        epoch: u64,\n        usage: Usage,\n    }\n\n    public(friend) fun initialize(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(\n            !exists<StateStorageUsage>(@aptos_framework),\n            error::already_exists(ESTATE_STORAGE_USAGE)\n        );\n        move_to(aptos_framework, StateStorageUsage {\n            epoch: 0,\n            usage: Usage {\n                items: 0,\n                bytes: 0,\n            }\n        });\n    }\n\n    public(friend) fun on_new_block(epoch: u64) acquires StateStorageUsage {\n        assert!(\n            exists<StateStorageUsage>(@aptos_framework),\n            error::not_found(ESTATE_STORAGE_USAGE)\n        );\n        let usage = borrow_global_mut<StateStorageUsage>(@aptos_framework);\n        if (epoch != usage.epoch) {\n            usage.epoch = epoch;\n            usage.usage = get_state_storage_usage_only_at_epoch_beginning();\n        }\n    }\n\n    public(friend) fun current_items_and_bytes(): (u64, u64) acquires StateStorageUsage {\n        assert!(\n            exists<StateStorageUsage>(@aptos_framework),\n            error::not_found(ESTATE_STORAGE_USAGE)\n        );\n        let usage = borrow_global<StateStorageUsage>(@aptos_framework);\n        (usage.usage.items, usage.usage.bytes)\n    }\n\n    /// Warning: the result returned is based on the base state view held by the\n    /// VM for the entire block or chunk of transactions, it's only deterministic\n    /// if called from the first transaction of the block because the execution layer\n    /// guarantees a fresh state view then.\n    native fun get_state_storage_usage_only_at_epoch_beginning(): Usage;\n\n    #[test_only]\n    public fun set_for_test(epoch: u64, items: u64, bytes: u64) acquires StateStorageUsage {\n        assert!(\n            exists<StateStorageUsage>(@aptos_framework),\n            error::not_found(ESTATE_STORAGE_USAGE)\n        );\n        let usage = borrow_global_mut<StateStorageUsage>(@aptos_framework);\n        usage.epoch = epoch;\n        usage.usage = Usage {\n            items,\n            bytes\n        };\n    }\n\n    // ======================== deprecated ============================\n    friend aptos_framework::reconfiguration;\n\n    struct GasParameter has key, store {\n        usage: Usage,\n    }\n\n    public(friend) fun on_reconfig() {\n        abort 0\n    }\n}\n","name":"state_storage.move"},{"content":"/// Gas parameters for global storage.\n///\n/// # General overview sections\n///\n/// [Definitions](#definitions)\n///\n/// * [Utilization dimensions](#utilization-dimensions)\n/// * [Utilization ratios](#utilization-ratios)\n/// * [Gas curve lookup](#gas-curve-lookup)\n/// * [Item-wise operations](#item-wise-operations)\n/// * [Byte-wise operations](#byte-wise-operations)\n///\n/// [Function dependencies](#function-dependencies)\n///\n/// * [Initialization](#initialization)\n/// * [Reconfiguration](#reconfiguration)\n/// * [Setting configurations](#setting-configurations)\n///\n/// # Definitions\n///\n/// ## Utilization dimensions\n///\n/// Global storage gas fluctuates each epoch based on total utilization,\n/// which is defined across two dimensions:\n///\n/// 1. The number of \"items\" in global storage.\n/// 2. The number of bytes in global storage.\n///\n/// \"Items\" include:\n///\n/// 1. Resources having the `key` attribute, which have been moved into\n///    global storage via a `move_to()` operation.\n/// 2.  Table entries.\n///\n/// ## Utilization ratios\n///\n/// `initialize()` sets an arbitrary \"target\" utilization for both\n/// item-wise and byte-wise storage, then each epoch, gas parameters are\n/// reconfigured based on the \"utilization ratio\" for each of the two\n/// utilization dimensions. The utilization ratio for a given dimension,\n/// either item-wise or byte-wise, is taken as the quotient of actual\n/// utilization and target utilization. For example, given a 500 GB\n/// target and 250 GB actual utilization, the byte-wise utilization\n/// ratio is 50%.\n///\n/// See `base_8192_exponential_curve()` for mathematical definitions.\n///\n/// ## Gas curve lookup\n///\n/// The utilization ratio in a given epoch is used as a lookup value in\n/// a Eulerian approximation to an exponential curve, known as a\n/// `GasCurve`, which is defined in `base_8192_exponential_curve()`,\n/// based on a minimum gas charge and a maximum gas charge.\n///\n/// The minimum gas charge and maximum gas charge at the endpoints of\n/// the curve are set in `initialize()`, and correspond to the following\n/// operations defined in `StorageGas`:\n///\n/// 1. Per-item read\n/// 2. Per-item create\n/// 3. Per-item write\n/// 4. Per-byte read\n/// 5. Per-byte create\n/// 6. Per-byte write\n///\n/// For example, if the byte-wise utilization ratio is 50%, then\n/// per-byte reads will charge the minimum per-byte gas cost, plus\n/// 1.09% of the difference between the maximum and the minimum cost.\n/// See `base_8192_exponential_curve()` for a supporting calculation.\n///\n/// ## Item-wise operations\n///\n/// 1. Per-item read gas is assessed whenever an item is read from\n///    global storage via `borrow_global<T>()` or via a table entry read\n///    operation.\n/// 2. Per-item create gas is assessed whenever an item is created in\n///    global storage via `move_to<T>()` or via a table entry creation\n///    operation.\n/// 3. Per-item write gas is assessed whenever an item is overwritten in\n///    global storage via `borrow_global_mut<T>` or via a table entry\n///    mutation operation.\n///\n/// ## Byte-wise operations\n///\n/// Byte-wise operations are assessed in a manner similar to per-item\n/// operations, but account for the number of bytes affected by the\n/// given operation. Notably, this number denotes the total number of\n/// bytes in an *entire item*.\n///\n/// For example, if an operation mutates a `u8` field in a resource that\n/// has 5 other `u128` fields, the per-byte gas write cost will account\n/// for $(5 * 128) / 8 + 1 = 81$ bytes. Vectors are similarly treated\n/// as fields.\n///\n/// # Function dependencies\n///\n/// The below dependency chart uses `mermaid.js` syntax, which can be\n/// automatically rendered into a diagram (depending on the browser)\n/// when viewing the documentation file generated from source code. If\n/// a browser renders the diagrams with coloring that makes it difficult\n/// to read, try a different browser.\n///\n/// ## Initialization\n///\n/// ```mermaid\n///\n/// flowchart LR\n///\n/// initialize --> base_8192_exponential_curve\n/// base_8192_exponential_curve --> new_gas_curve\n/// base_8192_exponential_curve --> new_point\n/// new_gas_curve --> validate_points\n///\n/// ```\n///\n/// ## Reconfiguration\n///\n/// ```mermaid\n///\n/// flowchart LR\n///\n/// calculate_gas --> Interpolate %% capitalized\n/// calculate_read_gas --> calculate_gas\n/// calculate_create_gas --> calculate_gas\n/// calculate_write_gas --> calculate_gas\n/// on_reconfig --> calculate_read_gas\n/// on_reconfig --> calculate_create_gas\n/// on_reconfig --> calculate_write_gas\n/// reconfiguration::reconfigure --> on_reconfig\n///\n/// ```\n///\n/// Here, the function `interpolate()` is spelled `Interpolate` because\n/// `interpolate` is a reserved word in `mermaid.js`.\n///\n/// ## Setting configurations\n///\n/// ```mermaid\n///\n/// flowchart LR\n///\n/// gas_schedule::set_storage_gas_config --> set_config\n///\n/// ```\n///\n/// # Complete docgen index\n///\n/// The below index is automatically generated from source code:\nmodule aptos_framework::storage_gas {\n\n    use aptos_framework::system_addresses;\n    use std::error;\n    use aptos_framework::state_storage;\n    use std::vector;\n\n    friend aptos_framework::gas_schedule;\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration;\n\n    const ESTORAGE_GAS_CONFIG: u64 = 0;\n    const ESTORAGE_GAS: u64 = 1;\n    const EINVALID_GAS_RANGE: u64 = 2;\n    const EZERO_TARGET_USAGE: u64 = 3;\n    const ETARGET_USAGE_TOO_BIG: u64 = 4;\n    const EINVALID_MONOTONICALLY_NON_DECREASING_CURVE: u64 = 5;\n    const EINVALID_POINT_RANGE: u64 = 6;\n\n    const BASIS_POINT_DENOMINATION: u64 = 10000;\n\n    const MAX_U64: u64 = 18446744073709551615;\n\n    /// Storage parameters, reconfigured each epoch.\n    ///\n    /// Parameters are updated during reconfiguration via\n    /// `on_reconfig()`, based on storage utilization at the beginning\n    /// of the epoch in which the reconfiguration transaction is\n    /// executed. The gas schedule derived from these parameters will\n    /// then be used to calculate gas for the entirety of the\n    /// following epoch, such that the data is one epoch older than\n    /// ideal. Notably, however, per this approach, the virtual machine\n    /// does not need to reload gas parameters after the\n    /// first transaction of an epoch.\n    struct StorageGas has key {\n        /// Cost to read an item from global storage.\n        per_item_read: u64,\n        /// Cost to create an item in global storage.\n        per_item_create: u64,\n        /// Cost to overwrite an item in global storage.\n        per_item_write: u64,\n        /// Cost to read a byte from global storage.\n        per_byte_read: u64,\n        /// Cost to create a byte in global storage.\n        per_byte_create: u64,\n        /// Cost to overwrite a byte in global storage.\n        per_byte_write: u64,\n    }\n\n    /// A point in a Eulerian curve approximation, with each coordinate\n    /// given in basis points:\n    ///\n    /// | Field value | Percentage |\n    /// |-------------|------------|\n    /// | `1`         | 00.01 %    |\n    /// | `10`        | 00.10 %    |\n    /// | `100`       | 01.00 %    |\n    /// | `1000`      | 10.00 %    |\n    struct Point has copy, drop, store {\n        /// x-coordinate basis points, corresponding to utilization\n        /// ratio in `base_8192_exponential_curve()`.\n        x: u64,\n        /// y-coordinate basis points, corresponding to utilization\n        /// multiplier in `base_8192_exponential_curve()`.\n        y: u64\n    }\n\n    /// A gas configuration for either per-item or per-byte costs.\n    ///\n    /// Contains a target usage amount, as well as a Eulerian\n    /// approximation of an exponential curve for reads, creations, and\n    /// overwrites. See `StorageGasConfig`.\n    struct UsageGasConfig has copy, drop, store {\n        target_usage: u64,\n        read_curve: GasCurve,\n        create_curve: GasCurve,\n        write_curve: GasCurve,\n    }\n\n    /// Eulerian approximation of an exponential curve.\n    ///\n    /// Assumes the following endpoints:\n    ///\n    /// * $(x_0, y_0) = (0, 0)$\n    /// * $(x_f, y_f) = (10000, 10000)$\n    ///\n    /// Intermediate points must satisfy:\n    ///\n    /// 1. $x_i > x_{i - 1}$ ( $x$ is strictly increasing).\n    /// 2. $0 \\leq x_i \\leq 10000$ ( $x$ is between 0 and 10000).\n    /// 3. $y_i \\geq y_{i - 1}$ ( $y$ is non-decreasing).\n    /// 4. $0 \\leq y_i \\leq 10000$ ( $y$ is between 0 and 10000).\n    ///\n    /// Lookup between two successive points is calculated via linear\n    /// interpolation, e.g., as if there were a straight line between\n    /// them.\n    ///\n    /// See `base_8192_exponential_curve()`.\n    struct GasCurve has copy, drop, store {\n        min_gas: u64,\n        max_gas: u64,\n        points: vector<Point>,\n    }\n\n    /// Default exponential curve having base 8192.\n    ///\n    /// # Function definition\n    ///\n    /// Gas price as a function of utilization ratio is defined as:\n    ///\n    /// $$g(u_r) = g_{min} + \\frac{(b^{u_r} - 1)}{b - 1} \\Delta_g$$\n    ///\n    /// $$g(u_r) = g_{min} + u_m \\Delta_g$$\n    ///\n    /// | Variable                            | Description            |\n    /// |-------------------------------------|------------------------|\n    /// | $g_{min}$                           | `min_gas`              |\n    /// | $g_{max}$                           | `max_gas`              |\n    /// | $\\Delta_{g} = g_{max} - g_{min}$    | Gas delta              |\n    /// | $u$                                 | Utilization            |\n    /// | $u_t$                               | Target utilization     |\n    /// | $u_r = u / u_t$                     | Utilization ratio      |\n    /// | $u_m = \\frac{(b^{u_r} - 1)}{b - 1}$ | Utilization multiplier |\n    /// | $b = 8192$                          | Exponent base          |\n    ///\n    /// # Example\n    ///\n    /// Hence for a utilization ratio of 50% ( $u_r = 0.5$ ):\n    ///\n    /// $$g(0.5) = g_{min} + \\frac{8192^{0.5} - 1}{8192 - 1} \\Delta_g$$\n    ///\n    /// $$g(0.5) \\approx g_{min} + 0.0109 \\Delta_g$$\n    ///\n    /// Which means that the price above `min_gas` is approximately\n    /// 1.09% of the difference between `max_gas` and `min_gas`.\n    ///\n    /// # Utilization multipliers\n    ///\n    /// | $u_r$ | $u_m$ (approximate) |\n    /// |-------|---------------------|\n    /// | 10%   | 0.02%               |\n    /// | 20%   | 0.06%               |\n    /// | 30%   | 0.17%               |\n    /// | 40%   | 0.44%               |\n    /// | 50%   | 1.09%               |\n    /// | 60%   | 2.71%               |\n    /// | 70%   | 6.69%               |\n    /// | 80%   | 16.48%              |\n    /// | 90%   | 40.61%              |\n    /// | 95%   | 63.72%              |\n    /// | 99%   | 91.38%              |\n    public fun base_8192_exponential_curve(min_gas: u64, max_gas: u64): GasCurve {\n        new_gas_curve(min_gas, max_gas,\n            vector[\n                new_point(1000, 2),\n                new_point(2000, 6),\n                new_point(3000, 17),\n                new_point(4000, 44),\n                new_point(5000, 109),\n                new_point(6000, 271),\n                new_point(7000, 669),\n                new_point(8000, 1648),\n                new_point(9000, 4061),\n                new_point(9500, 6372),\n                new_point(9900, 9138),\n            ]\n        )\n    }\n\n    /// Gas configurations for per-item and per-byte prices.\n    struct StorageGasConfig has copy, drop, key {\n        /// Per-item gas configuration.\n        item_config: UsageGasConfig,\n        /// Per-byte gas configuration.\n        byte_config: UsageGasConfig,\n    }\n\n    public fun new_point(x: u64, y: u64): Point {\n        assert!(\n            x <= BASIS_POINT_DENOMINATION && y <= BASIS_POINT_DENOMINATION,\n            error::invalid_argument(EINVALID_POINT_RANGE)\n        );\n        Point { x, y }\n    }\n\n    public fun new_gas_curve(min_gas: u64, max_gas: u64, points: vector<Point>): GasCurve {\n        assert!(max_gas >= min_gas, error::invalid_argument(EINVALID_GAS_RANGE));\n        assert!(max_gas <= MAX_U64 / BASIS_POINT_DENOMINATION, error::invalid_argument(EINVALID_GAS_RANGE));\n        validate_points(&points);\n        GasCurve {\n            min_gas,\n            max_gas,\n            points\n        }\n    }\n\n    public fun new_usage_gas_config(target_usage: u64, read_curve: GasCurve, create_curve: GasCurve, write_curve: GasCurve): UsageGasConfig {\n        assert!(target_usage > 0, error::invalid_argument(EZERO_TARGET_USAGE));\n        assert!(target_usage <= MAX_U64 / BASIS_POINT_DENOMINATION, error::invalid_argument(ETARGET_USAGE_TOO_BIG));\n        UsageGasConfig {\n            target_usage,\n            read_curve,\n            create_curve,\n            write_curve,\n        }\n    }\n\n    public fun new_storage_gas_config(item_config: UsageGasConfig, byte_config: UsageGasConfig): StorageGasConfig {\n        StorageGasConfig {\n            item_config,\n            byte_config\n        }\n    }\n\n    public(friend) fun set_config(aptos_framework: &signer, config: StorageGasConfig) acquires StorageGasConfig {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        *borrow_global_mut<StorageGasConfig>(@aptos_framework) = config;\n    }\n\n    /// Initialize per-item and per-byte gas prices.\n    ///\n    /// Target utilization is set to 2 billion items and 1 TB.\n    ///\n    /// `GasCurve` endpoints are initialized as follows:\n    ///\n    /// | Data style | Operation | Minimum gas | Maximum gas |\n    /// |------------|-----------|-------------|-------------|\n    /// | Per item   | Read      | 300K        | 300K * 100  |\n    /// | Per item   | Create    | 300k        | 300k * 100    |\n    /// | Per item   | Write     | 300K        | 300K * 100  |\n    /// | Per byte   | Read      | 300         | 300 * 100   |\n    /// | Per byte   | Create    | 5K          | 5K * 100    |\n    /// | Per byte   | Write     | 5K          | 5K * 100    |\n    ///\n    /// `StorageGas` values are additionally initialized, but per\n    /// `on_reconfig()`, they will be reconfigured for each subsequent\n    /// epoch after initialization.\n    ///\n    /// See `base_8192_exponential_curve()` fore more information on\n    /// target utilization.\n    public fun initialize(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(\n            !exists<StorageGasConfig>(@aptos_framework),\n            error::already_exists(ESTORAGE_GAS_CONFIG)\n        );\n\n        let k: u64 = 1000;\n        let m: u64 = 1000 * 1000;\n\n        let item_config = UsageGasConfig {\n            target_usage: 2 * k * m, // 2 billion\n            read_curve: base_8192_exponential_curve(300 * k, 300 * k * 100),\n            create_curve: base_8192_exponential_curve(300 * k, 300 * k * 100),\n            write_curve: base_8192_exponential_curve(300 * k, 300 * k * 100),\n        };\n        let byte_config = UsageGasConfig {\n            target_usage: 1 * m * m, // 1TB\n            read_curve: base_8192_exponential_curve(300, 300 * 100),\n            create_curve: base_8192_exponential_curve(5 * k,  5 * k * 100),\n            write_curve: base_8192_exponential_curve(5 * k,  5 * k * 100),\n        };\n        move_to(aptos_framework, StorageGasConfig {\n            item_config,\n            byte_config,\n        });\n\n        assert!(\n            !exists<StorageGas>(@aptos_framework),\n            error::already_exists(ESTORAGE_GAS)\n        );\n        move_to(aptos_framework, StorageGas {\n            per_item_read: 300 * k,\n            per_item_create: 5 * m,\n            per_item_write: 300 * k,\n            per_byte_read: 300,\n            per_byte_create: 5 * k,\n            per_byte_write: 5 * k,\n        });\n    }\n\n    fun validate_points(points: &vector<Point>) {\n        let len = vector::length(points);\n        spec {\n            assume len < MAX_U64;\n        };\n        let i = 0;\n        while ({\n            spec {\n                invariant forall j in 0..i: {\n                    let cur = if (j == 0) { Point { x: 0, y: 0 } } else { points[j - 1] };\n                    let next = if (j == len) { Point { x: BASIS_POINT_DENOMINATION, y: BASIS_POINT_DENOMINATION } } else { points[j] };\n                    cur.x < next.x && cur.y <= next.y\n                };\n            };\n            i <= len\n        }) {\n            let cur = if (i == 0) { &Point { x: 0, y: 0 } } else { vector::borrow(points, i - 1) };\n            let next = if (i == len) { &Point { x: BASIS_POINT_DENOMINATION, y: BASIS_POINT_DENOMINATION } } else { vector::borrow(points, i) };\n            assert!(cur.x < next.x && cur.y <= next.y, error::invalid_argument(EINVALID_MONOTONICALLY_NON_DECREASING_CURVE));\n            i = i + 1;\n        }\n    }\n\n    fun calculate_gas(max_usage: u64, current_usage: u64, curve: &GasCurve): u64 {\n        let capped_current_usage = if (current_usage > max_usage) max_usage else current_usage;\n        let points = &curve.points;\n        let num_points = vector::length(points);\n        let current_usage_bps = capped_current_usage * BASIS_POINT_DENOMINATION / max_usage;\n\n        // Check the corner case that current_usage_bps drops before the first point.\n        let (left, right) = if (num_points == 0) {\n            (&Point { x: 0, y: 0 }, &Point { x: BASIS_POINT_DENOMINATION, y: BASIS_POINT_DENOMINATION })\n        } else if (current_usage_bps < vector::borrow(points, 0).x) {\n            (&Point { x: 0, y: 0 }, vector::borrow(points, 0))\n        } else if (vector::borrow(points, num_points - 1).x <= current_usage_bps) {\n            (vector::borrow(points, num_points - 1), &Point { x: BASIS_POINT_DENOMINATION, y: BASIS_POINT_DENOMINATION })\n        } else {\n            let (i, j) = (0, num_points - 2);\n            while ({\n                spec {\n                    invariant i <= j;\n                    invariant j < num_points - 1;\n                    invariant points[i].x <= current_usage_bps;\n                    invariant current_usage_bps < points[j + 1].x;\n                };\n                i < j\n            }) {\n                let mid = j - (j - i) / 2;\n                if (current_usage_bps < vector::borrow(points, mid).x) {\n                    spec {\n                        // j is strictly decreasing.\n                        assert mid - 1 < j;\n                    };\n                    j = mid - 1;\n                } else {\n                    spec {\n                        // i is strictly increasing.\n                        assert i < mid;\n                    };\n                    i = mid;\n                };\n            };\n            (vector::borrow(points, i), vector::borrow(points, i + 1))\n        };\n        let y_interpolated = interpolate(left.x, right.x, left.y, right.y, current_usage_bps);\n        interpolate(0, BASIS_POINT_DENOMINATION, curve.min_gas, curve.max_gas, y_interpolated)\n    }\n\n    // Interpolates y for x on the line between (x0, y0) and (x1, y1).\n    fun interpolate(x0: u64, x1: u64, y0: u64, y1: u64, x: u64): u64 {\n        y0 + (x - x0) * (y1 - y0) / (x1 - x0)\n    }\n\n    fun calculate_read_gas(config: &UsageGasConfig, usage: u64): u64 {\n        calculate_gas(config.target_usage, usage, &config.read_curve)\n    }\n\n    fun calculate_create_gas(config: &UsageGasConfig, usage: u64): u64 {\n        calculate_gas(config.target_usage, usage, &config.create_curve)\n    }\n\n    fun calculate_write_gas(config: &UsageGasConfig, usage: u64): u64 {\n        calculate_gas(config.target_usage, usage, &config.write_curve)\n    }\n\n    public(friend) fun on_reconfig() acquires StorageGas, StorageGasConfig {\n        assert!(\n            exists<StorageGasConfig>(@aptos_framework),\n            error::not_found(ESTORAGE_GAS_CONFIG)\n        );\n        assert!(\n            exists<StorageGas>(@aptos_framework),\n            error::not_found(ESTORAGE_GAS)\n        );\n        let (items, bytes) = state_storage::current_items_and_bytes();\n        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);\n        let gas = borrow_global_mut<StorageGas>(@aptos_framework);\n        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);\n        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);\n        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);\n        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);\n        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);\n        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);\n    }\n\n    // TODO: reactivate this test after fixing assertions\n    //#[test(framework = @aptos_framework)]\n    #[test_only]\n    fun test_initialize_and_reconfig(framework: signer) acquires StorageGas, StorageGasConfig {\n        state_storage::initialize(&framework);\n        initialize(&framework);\n        on_reconfig();\n        let gas_parameter = borrow_global<StorageGas>(@aptos_framework);\n        assert!(gas_parameter.per_item_read == 10, 0);\n        assert!(gas_parameter.per_item_create == 10, 0);\n        assert!(gas_parameter.per_item_write == 10, 0);\n        assert!(gas_parameter.per_byte_read == 1, 0);\n        assert!(gas_parameter.per_byte_create == 1, 0);\n        assert!(gas_parameter.per_byte_write == 1, 0);\n    }\n\n    #[test]\n    fun test_curve() {\n        let constant_curve = new_gas_curve(5, 5, vector[]);\n        let linear_curve = new_gas_curve(1, 1000, vector[]);\n        let standard_curve = base_8192_exponential_curve(1, 1000);\n        let target = BASIS_POINT_DENOMINATION / 2;\n        while (target < 2 * BASIS_POINT_DENOMINATION) {\n            let i = 0;\n            let old_standard_curve_gas = 1;\n            while (i <= target + 7) {\n                assert!(calculate_gas(target, i, &constant_curve) == 5, 0);\n                assert!(calculate_gas(target, i, &linear_curve) == (if (i < target) { 1 + 999 * (i * BASIS_POINT_DENOMINATION / target) / BASIS_POINT_DENOMINATION } else { 1000 }), 0);\n                let new_standard_curve_gas = calculate_gas(target, i, &standard_curve);\n                assert!(new_standard_curve_gas >= old_standard_curve_gas, 0);\n                old_standard_curve_gas = new_standard_curve_gas;\n                i = i + 3;\n            };\n            assert!(old_standard_curve_gas == 1000, 0);\n            target = target + BASIS_POINT_DENOMINATION;\n        }\n    }\n\n    #[test(framework = @aptos_framework)]\n    fun test_set_storage_gas_config(framework: signer) acquires StorageGas, StorageGasConfig {\n        state_storage::initialize(&framework);\n        initialize(&framework);\n        let item_curve = new_gas_curve(1000, 2000,\n            vector[new_point(3000, 0), new_point(5000, 5000), new_point(8000, 5000)]\n        );\n        let byte_curve = new_gas_curve(0, 1000, vector::singleton<Point>(new_point(5000, 3000)));\n        let item_usage_config = new_usage_gas_config(100, copy item_curve, copy item_curve, copy item_curve);\n        let byte_usage_config = new_usage_gas_config(2000, copy byte_curve, copy byte_curve, copy byte_curve);\n        let storage_gas_config = new_storage_gas_config(item_usage_config, byte_usage_config);\n        set_config(&framework, storage_gas_config);\n        {\n            state_storage::set_for_test(0, 20, 100);\n            on_reconfig();\n            let gas_parameter = borrow_global<StorageGas>(@aptos_framework);\n            assert!(gas_parameter.per_item_read == 1000, 0);\n            assert!(gas_parameter.per_byte_read == 30, 0);\n        };\n        {\n            state_storage::set_for_test(0, 40, 800);\n            on_reconfig();\n            let gas_parameter = borrow_global<StorageGas>(@aptos_framework);\n            assert!(gas_parameter.per_item_create == 1250, 0);\n            assert!(gas_parameter.per_byte_create == 240, 0);\n        };\n        {\n            state_storage::set_for_test(0, 60, 1200);\n            on_reconfig();\n            let gas_parameter = borrow_global<StorageGas>(@aptos_framework);\n            assert!(gas_parameter.per_item_write == 1500, 0);\n            assert!(gas_parameter.per_byte_write == 440, 0);\n        };\n        {\n            state_storage::set_for_test(0, 90, 1800);\n            on_reconfig();\n            let gas_parameter = borrow_global<StorageGas>(@aptos_framework);\n            assert!(gas_parameter.per_item_create == 1750, 0);\n            assert!(gas_parameter.per_byte_create == 860, 0);\n        };\n        {\n            // usage overflow case\n            state_storage::set_for_test(0, 110, 2200);\n            on_reconfig();\n            let gas_parameter = borrow_global<StorageGas>(@aptos_framework);\n            assert!(gas_parameter.per_item_read == 2000, 0);\n            assert!(gas_parameter.per_byte_read == 1000, 0);\n        };\n    }\n}\n","name":"storage_gas.move"},{"content":"module aptos_framework::system_addresses {\n    use std::error;\n    use std::signer;\n\n    /// The address/account did not correspond to the core resource address\n    const ENOT_CORE_RESOURCE_ADDRESS: u64 = 1;\n    /// The operation can only be performed by the VM\n    const EVM: u64 = 2;\n    /// The address/account did not correspond to the core framework address\n    const ENOT_APTOS_FRAMEWORK_ADDRESS: u64 = 3;\n    /// The address is not framework reserved address\n    const ENOT_FRAMEWORK_RESERVED_ADDRESS: u64 = 4;\n\n    public fun assert_core_resource(account: &signer) {\n        assert_core_resource_address(signer::address_of(account))\n    }\n\n    public fun assert_core_resource_address(addr: address) {\n        assert!(is_core_resource_address(addr), error::permission_denied(ENOT_CORE_RESOURCE_ADDRESS))\n    }\n\n    public fun is_core_resource_address(addr: address): bool {\n        addr == @core_resources\n    }\n\n    public fun assert_aptos_framework(account: &signer) {\n        assert!(\n            is_aptos_framework_address(signer::address_of(account)),\n            error::permission_denied(ENOT_APTOS_FRAMEWORK_ADDRESS),\n        )\n    }\n\n    public fun assert_framework_reserved_address(account: &signer) {\n        assert_framework_reserved(signer::address_of(account));\n    }\n\n    public fun assert_framework_reserved(addr: address) {\n        assert!(\n            is_framework_reserved_address(addr),\n            error::permission_denied(ENOT_FRAMEWORK_RESERVED_ADDRESS),\n        )\n    }\n\n    /// Return true if `addr` is 0x0 or under the on chain governance's control.\n    public fun is_framework_reserved_address(addr: address): bool {\n        is_aptos_framework_address(addr) ||\n            addr == @0x2 ||\n            addr == @0x3 ||\n            addr == @0x4 ||\n            addr == @0x5 ||\n            addr == @0x6 ||\n            addr == @0x7 ||\n            addr == @0x8 ||\n            addr == @0x9 ||\n            addr == @0xa\n    }\n\n    /// Return true if `addr` is 0x1.\n    public fun is_aptos_framework_address(addr: address): bool {\n        addr == @aptos_framework\n    }\n\n    /// Assert that the signer has the VM reserved address.\n    public fun assert_vm(account: &signer) {\n        assert!(is_vm(account), error::permission_denied(EVM))\n    }\n\n    /// Return true if `addr` is a reserved address for the VM to call system modules.\n    public fun is_vm(account: &signer): bool {\n        is_vm_address(signer::address_of(account))\n    }\n\n    /// Return true if `addr` is a reserved address for the VM to call system modules.\n    public fun is_vm_address(addr: address): bool {\n        addr == @vm_reserved\n    }\n\n    /// Return true if `addr` is either the VM address or an Aptos Framework address.\n    public fun is_reserved_address(addr: address): bool {\n        is_aptos_framework_address(addr) || is_vm_address(addr)\n    }\n}\n","name":"system_addresses.move"},{"content":"/// This module keeps a global wall clock that stores the current Unix time in microseconds.\n/// It interacts with the other modules in the following ways:\n/// * genesis: to initialize the timestamp\n/// * block: to reach consensus on the global wall clock time\nmodule aptos_framework::timestamp {\n    use aptos_framework::system_addresses;\n    use std::error;\n\n    friend aptos_framework::genesis;\n\n    /// A singleton resource holding the current Unix time in microseconds\n    struct CurrentTimeMicroseconds has key {\n        microseconds: u64,\n    }\n\n    /// Conversion factor between seconds and microseconds\n    const MICRO_CONVERSION_FACTOR: u64 = 1000000;\n\n    /// The blockchain is not in an operating state yet\n    const ENOT_OPERATING: u64 = 1;\n    /// An invalid timestamp was provided\n    const EINVALID_TIMESTAMP: u64 = 2;\n\n    /// Marks that time has started. This can only be called from genesis and with the aptos framework account.\n    public(friend) fun set_time_has_started(aptos_framework: &signer) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        let timer = CurrentTimeMicroseconds { microseconds: 0 };\n        move_to(aptos_framework, timer);\n    }\n\n    /// Updates the wall clock time by consensus. Requires VM privilege and will be invoked during block prologue.\n    public fun update_global_time(\n        account: &signer,\n        proposer: address,\n        timestamp: u64\n    ) acquires CurrentTimeMicroseconds {\n        // Can only be invoked by AptosVM signer.\n        system_addresses::assert_vm(account);\n\n        let global_timer = borrow_global_mut<CurrentTimeMicroseconds>(@aptos_framework);\n        let now = global_timer.microseconds;\n        if (proposer == @vm_reserved) {\n            // NIL block with null address as proposer. Timestamp must be equal.\n            assert!(now == timestamp, error::invalid_argument(EINVALID_TIMESTAMP));\n        } else {\n            // Normal block. Time must advance\n            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));\n            global_timer.microseconds = timestamp;\n        };\n    }\n\n    #[test_only]\n    public fun set_time_has_started_for_testing(account: &signer) {\n        if (!exists<CurrentTimeMicroseconds>(@aptos_framework)) {\n            set_time_has_started(account);\n        };\n    }\n\n    #[view]\n    /// Gets the current time in microseconds.\n    public fun now_microseconds(): u64 acquires CurrentTimeMicroseconds {\n        borrow_global<CurrentTimeMicroseconds>(@aptos_framework).microseconds\n    }\n\n    #[view]\n    /// Gets the current time in seconds.\n    public fun now_seconds(): u64 acquires CurrentTimeMicroseconds {\n        now_microseconds() / MICRO_CONVERSION_FACTOR\n    }\n\n    #[test_only]\n    public fun update_global_time_for_test(timestamp_microsecs: u64) acquires CurrentTimeMicroseconds {\n        let global_timer = borrow_global_mut<CurrentTimeMicroseconds>(@aptos_framework);\n        let now = global_timer.microseconds;\n        assert!(now < timestamp_microsecs, error::invalid_argument(EINVALID_TIMESTAMP));\n        global_timer.microseconds = timestamp_microsecs;\n    }\n\n    #[test_only]\n    public fun update_global_time_for_test_secs(timestamp_seconds: u64) acquires CurrentTimeMicroseconds {\n        update_global_time_for_test(timestamp_seconds * MICRO_CONVERSION_FACTOR);\n    }\n\n    #[test_only]\n    public fun fast_forward_seconds(timestamp_seconds: u64) acquires CurrentTimeMicroseconds {\n        update_global_time_for_test_secs(now_seconds() + timestamp_seconds);\n    }\n}\n","name":"timestamp.move"},{"content":"module aptos_framework::transaction_context {\n    use std::error;\n    use std::features;\n    use std::option::Option;\n    use std::string::String;\n\n    /// Transaction context is only available in the user transaction prologue, execution, or epilogue phases.\n    const ETRANSACTION_CONTEXT_NOT_AVAILABLE: u64 = 1;\n\n    /// The transaction context extension feature is not enabled.\n    const ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED: u64 = 2;\n\n    /// A wrapper denoting aptos unique identifer (AUID)\n    /// for storing an address\n    struct AUID has drop, store {\n        unique_address: address\n    }\n\n    /// Represents the entry function payload.\n    struct EntryFunctionPayload has copy, drop {\n        account_address: address,\n        module_name: String,\n        function_name: String,\n        ty_args_names: vector<String>,\n        args: vector<vector<u8>>,\n    }\n\n    /// Represents the multisig payload.\n    struct MultisigPayload has copy, drop {\n        multisig_address: address,\n        entry_function_payload: Option<EntryFunctionPayload>,\n    }\n\n    /// Returns the transaction hash of the current transaction.\n    native fun get_txn_hash(): vector<u8>;\n\n    /// Returns the transaction hash of the current transaction.\n    /// Internally calls the private function `get_txn_hash`.\n    /// This function is created for to feature gate the `get_txn_hash` function.\n    public fun get_transaction_hash(): vector<u8> {\n        get_txn_hash()\n    }\n\n    /// Returns a universally unique identifier (of type address) generated\n    /// by hashing the transaction hash of this transaction and a sequence number\n    /// specific to this transaction. This function can be called any\n    /// number of times inside a single transaction. Each such call increments\n    /// the sequence number and generates a new unique address.\n    /// Uses Scheme in types/src/transaction/authenticator.rs for domain separation\n    /// from other ways of generating unique addresses.\n    native fun generate_unique_address(): address;\n\n    /// Returns a aptos unique identifier. Internally calls\n    /// the private function `generate_unique_address`. This function is\n    /// created for to feature gate the `generate_unique_address` function.\n    public fun generate_auid_address(): address {\n        generate_unique_address()\n    }\n\n    /// Returns the script hash of the current entry function.\n    public native fun get_script_hash(): vector<u8>;\n\n    /// This method runs `generate_unique_address` native function and returns\n    /// the generated unique address wrapped in the AUID class.\n    public fun generate_auid(): AUID {\n        return AUID {\n            unique_address: generate_unique_address()\n        }\n    }\n\n    /// Returns the unique address wrapped in the given AUID struct.\n    public fun auid_address(auid: &AUID): address {\n        auid.unique_address\n    }\n\n    /// Returns the sender's address for the current transaction.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun sender(): address {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        sender_internal()\n    }\n    native fun sender_internal(): address;\n\n    /// Returns the list of the secondary signers for the current transaction.\n    /// If the current transaction has no secondary signers, this function returns an empty vector.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun secondary_signers(): vector<address> {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        secondary_signers_internal()\n    }\n    native fun secondary_signers_internal(): vector<address>;\n\n    /// Returns the gas payer address for the current transaction.\n    /// It is either the sender's address if no separate gas fee payer is specified for the current transaction,\n    /// or the address of the separate gas fee payer if one is specified.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun gas_payer(): address {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        gas_payer_internal()\n    }\n    native fun gas_payer_internal(): address;\n\n    /// Returns the max gas amount in units which is specified for the current transaction.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun max_gas_amount(): u64 {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        max_gas_amount_internal()\n    }\n    native fun max_gas_amount_internal(): u64;\n\n    /// Returns the gas unit price in Octas which is specified for the current transaction.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun gas_unit_price(): u64 {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        gas_unit_price_internal()\n    }\n    native fun gas_unit_price_internal(): u64;\n\n    /// Returns the chain ID specified for the current transaction.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun chain_id(): u8 {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        chain_id_internal()\n    }\n    native fun chain_id_internal(): u8;\n\n    /// Returns the entry function payload if the current transaction has such a payload. Otherwise, return `None`.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun entry_function_payload(): Option<EntryFunctionPayload> {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        entry_function_payload_internal()\n    }\n    native fun entry_function_payload_internal(): Option<EntryFunctionPayload>;\n\n    /// Returns the account address of the entry function payload.\n    public fun account_address(payload: &EntryFunctionPayload): address {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        payload.account_address\n    }\n\n    /// Returns the module name of the entry function payload.\n    public fun module_name(payload: &EntryFunctionPayload): String {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        payload.module_name\n    }\n\n    /// Returns the function name of the entry function payload.\n    public fun function_name(payload: &EntryFunctionPayload): String {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        payload.function_name\n    }\n\n    /// Returns the type arguments names of the entry function payload.\n    public fun type_arg_names(payload: &EntryFunctionPayload): vector<String> {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        payload.ty_args_names\n    }\n\n    /// Returns the arguments of the entry function payload.\n    public fun args(payload: &EntryFunctionPayload): vector<vector<u8>> {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        payload.args\n    }\n\n    /// Returns the multisig payload if the current transaction has such a payload. Otherwise, return `None`.\n    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.\n    public fun multisig_payload(): Option<MultisigPayload> {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        multisig_payload_internal()\n    }\n    native fun multisig_payload_internal(): Option<MultisigPayload>;\n\n    /// Returns the multisig account address of the multisig payload.\n    public fun multisig_address(payload: &MultisigPayload): address {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        payload.multisig_address\n    }\n\n    /// Returns the inner entry function payload of the multisig payload.\n    public fun inner_entry_function_payload(payload: &MultisigPayload): Option<EntryFunctionPayload> {\n        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));\n        payload.entry_function_payload\n    }\n\n    #[test(fx = @std)]\n    fun test_auid_uniquess(fx: signer) {\n        use std::features;\n        use std::vector;\n\n        let feature = features::get_auids();\n        features::change_feature_flags_for_testing(&fx, vector[feature], vector[]);\n\n        let auids: vector<address> = vector<address>[];\n        let i: u64 = 0;\n        let count: u64 = 50;\n        while (i < count) {\n            i = i + 1;\n            vector::push_back(&mut auids, generate_auid_address());\n        };\n        i = 0;\n        while (i < count - 1) {\n            let j: u64 = i + 1;\n            while (j < count) {\n                assert!(*vector::borrow(&auids, i) != *vector::borrow(&auids, j), 0);\n                j = j + 1;\n            };\n            i = i + 1;\n        };\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_sender() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _sender = sender();\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_secondary_signers() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _secondary_signers = secondary_signers();\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_gas_payer() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _gas_payer = gas_payer();\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_max_gas_amount() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _max_gas_amount = max_gas_amount();\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_gas_unit_price() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _gas_unit_price = gas_unit_price();\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_chain_id() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _chain_id = chain_id();\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_entry_function_payload() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _entry_fun = entry_function_payload();\n    }\n\n    #[test]\n    #[expected_failure(abort_code=196609, location = Self)]\n    fun test_call_multisig_payload() {\n        // expected to fail with the error code of `invalid_state(E_TRANSACTION_CONTEXT_NOT_AVAILABLE)`\n        let _multisig = multisig_payload();\n    }\n}\n","name":"transaction_context.move"},{"content":"/// This module provides an interface to burn or collect and redistribute transaction fees.\nmodule aptos_framework::transaction_fee {\n    use aptos_framework::coin::{Self, AggregatableCoin, BurnCapability, Coin, MintCapability};\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::stake;\n    use aptos_framework::system_addresses;\n    use std::error;\n    use std::option::{Self, Option};\n    use aptos_framework::event;\n\n    friend aptos_framework::block;\n    friend aptos_framework::genesis;\n    friend aptos_framework::reconfiguration;\n    friend aptos_framework::transaction_validation;\n\n    /// Gas fees are already being collected and the struct holding\n    /// information about collected amounts is already published.\n    const EALREADY_COLLECTING_FEES: u64 = 1;\n\n    /// The burn percentage is out of range [0, 100].\n    const EINVALID_BURN_PERCENTAGE: u64 = 3;\n\n    /// No longer supported.\n    const ENO_LONGER_SUPPORTED: u64 = 4;\n\n    /// Stores burn capability to burn the gas fees.\n    struct AptosCoinCapabilities has key {\n        burn_cap: BurnCapability<AptosCoin>,\n    }\n\n    /// Stores mint capability to mint the refunds.\n    struct AptosCoinMintCapability has key {\n        mint_cap: MintCapability<AptosCoin>,\n    }\n\n    /// Stores information about the block proposer and the amount of fees\n    /// collected when executing the block.\n    struct CollectedFeesPerBlock has key {\n        amount: AggregatableCoin<AptosCoin>,\n        proposer: Option<address>,\n        burn_percentage: u8,\n    }\n\n    #[event]\n    /// Breakdown of fee charge and refund for a transaction.\n    /// The structure is:\n    ///\n    /// - Net charge or refund (not in the statement)\n    ///    - total charge: total_charge_gas_units, matches `gas_used` in the on-chain `TransactionInfo`.\n    ///      This is the sum of the sub-items below. Notice that there's potential precision loss when\n    ///      the conversion between internal and external gas units and between native token and gas\n    ///      units, so it's possible that the numbers don't add up exactly. -- This number is the final\n    ///      charge, while the break down is merely informational.\n    ///        - gas charge for execution (CPU time): `execution_gas_units`\n    ///        - gas charge for IO (storage random access): `io_gas_units`\n    ///        - storage fee charge (storage space): `storage_fee_octas`, to be included in\n    ///          `total_charge_gas_unit`, this number is converted to gas units according to the user\n    ///          specified `gas_unit_price` on the transaction.\n    ///    - storage deletion refund: `storage_fee_refund_octas`, this is not included in `gas_used` or\n    ///      `total_charge_gas_units`, the net charge / refund is calculated by\n    ///      `total_charge_gas_units` * `gas_unit_price` - `storage_fee_refund_octas`.\n    ///\n    /// This is meant to emitted as a module event.\n    struct FeeStatement has drop, store {\n        /// Total gas charge.\n        total_charge_gas_units: u64,\n        /// Execution gas charge.\n        execution_gas_units: u64,\n        /// IO gas charge.\n        io_gas_units: u64,\n        /// Storage fee charge.\n        storage_fee_octas: u64,\n        /// Storage fee refund.\n        storage_fee_refund_octas: u64,\n    }\n\n    /// Initializes the resource storing information about gas fees collection and\n    /// distribution. Should be called by on-chain governance.\n    public fun initialize_fee_collection_and_distribution(aptos_framework: &signer, burn_percentage: u8) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(\n            !exists<CollectedFeesPerBlock>(@aptos_framework),\n            error::already_exists(EALREADY_COLLECTING_FEES)\n        );\n        assert!(burn_percentage <= 100, error::out_of_range(EINVALID_BURN_PERCENTAGE));\n\n        // Make sure stakng module is aware of transaction fees collection.\n        stake::initialize_validator_fees(aptos_framework);\n\n        // Initially, no fees are collected and the block proposer is not set.\n        let collected_fees = CollectedFeesPerBlock {\n            amount: coin::initialize_aggregatable_coin(aptos_framework),\n            proposer: option::none(),\n            burn_percentage,\n        };\n        move_to(aptos_framework, collected_fees);\n    }\n\n    fun is_fees_collection_enabled(): bool {\n        exists<CollectedFeesPerBlock>(@aptos_framework)\n    }\n\n    /// Sets the burn percentage for collected fees to a new value. Should be called by on-chain governance.\n    public fun upgrade_burn_percentage(\n        aptos_framework: &signer,\n        new_burn_percentage: u8\n    ) acquires AptosCoinCapabilities, CollectedFeesPerBlock {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        assert!(new_burn_percentage <= 100, error::out_of_range(EINVALID_BURN_PERCENTAGE));\n\n        // Prior to upgrading the burn percentage, make sure to process collected\n        // fees. Otherwise we would use the new (incorrect) burn_percentage when\n        // processing fees later!\n        process_collected_fees();\n\n        if (is_fees_collection_enabled()) {\n            // Upgrade has no effect unless fees are being collected.\n            let burn_percentage = &mut borrow_global_mut<CollectedFeesPerBlock>(@aptos_framework).burn_percentage;\n            *burn_percentage = new_burn_percentage\n        }\n    }\n\n    /// Registers the proposer of the block for gas fees collection. This function\n    /// can only be called at the beginning of the block.\n    public(friend) fun register_proposer_for_fee_collection(proposer_addr: address) acquires CollectedFeesPerBlock {\n        if (is_fees_collection_enabled()) {\n            let collected_fees = borrow_global_mut<CollectedFeesPerBlock>(@aptos_framework);\n            let _ = option::swap_or_fill(&mut collected_fees.proposer, proposer_addr);\n        }\n    }\n\n    /// Burns a specified fraction of the coin.\n    fun burn_coin_fraction(coin: &mut Coin<AptosCoin>, burn_percentage: u8) acquires AptosCoinCapabilities {\n        assert!(burn_percentage <= 100, error::out_of_range(EINVALID_BURN_PERCENTAGE));\n\n        let collected_amount = coin::value(coin);\n        spec {\n            // We assume that `burn_percentage * collected_amount` does not overflow.\n            assume burn_percentage * collected_amount <= MAX_U64;\n        };\n        let amount_to_burn = (burn_percentage as u64) * collected_amount / 100;\n        if (amount_to_burn > 0) {\n            let coin_to_burn = coin::extract(coin, amount_to_burn);\n            coin::burn(\n                coin_to_burn,\n                &borrow_global<AptosCoinCapabilities>(@aptos_framework).burn_cap,\n            );\n        }\n    }\n\n    /// Calculates the fee which should be distributed to the block proposer at the\n    /// end of an epoch, and records it in the system. This function can only be called\n    /// at the beginning of the block or during reconfiguration.\n    public(friend) fun process_collected_fees() acquires AptosCoinCapabilities, CollectedFeesPerBlock {\n        if (!is_fees_collection_enabled()) {\n            return\n        };\n        let collected_fees = borrow_global_mut<CollectedFeesPerBlock>(@aptos_framework);\n\n        // If there are no collected fees, only unset the proposer. See the rationale for\n        // setting proposer to option::none() below.\n        if (coin::is_aggregatable_coin_zero(&collected_fees.amount)) {\n            if (option::is_some(&collected_fees.proposer)) {\n                let _ = option::extract(&mut collected_fees.proposer);\n            };\n            return\n        };\n\n        // Otherwise get the collected fee, and check if it can distributed later.\n        let coin = coin::drain_aggregatable_coin(&mut collected_fees.amount);\n        if (option::is_some(&collected_fees.proposer)) {\n            // Extract the address of proposer here and reset it to option::none(). This\n            // is particularly useful to avoid any undesired side-effects where coins are\n            // collected but never distributed or distributed to the wrong account.\n            // With this design, processing collected fees enforces that all fees will be burnt\n            // unless the proposer is specified in the block prologue. When we have a governance\n            // proposal that triggers reconfiguration, we distribute pending fees and burn the\n            // fee for the proposal. Otherwise, that fee would be leaked to the next block.\n            let proposer = option::extract(&mut collected_fees.proposer);\n\n            // Since the block can be produced by the VM itself, we have to make sure we catch\n            // this case.\n            if (proposer == @vm_reserved) {\n                burn_coin_fraction(&mut coin, 100);\n                coin::destroy_zero(coin);\n                return\n            };\n\n            burn_coin_fraction(&mut coin, collected_fees.burn_percentage);\n            stake::add_transaction_fee(proposer, coin);\n            return\n        };\n\n        // If checks did not pass, simply burn all collected coins and return none.\n        burn_coin_fraction(&mut coin, 100);\n        coin::destroy_zero(coin)\n    }\n\n    /// Burn transaction fees in epilogue.\n    public(friend) fun burn_fee(account: address, fee: u64) acquires AptosCoinCapabilities {\n        coin::burn_from<AptosCoin>(\n            account,\n            fee,\n            &borrow_global<AptosCoinCapabilities>(@aptos_framework).burn_cap,\n        );\n    }\n\n    /// Mint refund in epilogue.\n    public(friend) fun mint_and_refund(account: address, refund: u64) acquires AptosCoinMintCapability {\n        let mint_cap = &borrow_global<AptosCoinMintCapability>(@aptos_framework).mint_cap;\n        let refund_coin = coin::mint(refund, mint_cap);\n        coin::force_deposit(account, refund_coin);\n    }\n\n    /// Collect transaction fees in epilogue.\n    public(friend) fun collect_fee(account: address, fee: u64) acquires CollectedFeesPerBlock {\n        let collected_fees = borrow_global_mut<CollectedFeesPerBlock>(@aptos_framework);\n\n        // Here, we are always optimistic and always collect fees. If the proposer is not set,\n        // or we cannot redistribute fees later for some reason (e.g. account cannot receive AptoCoin)\n        // we burn them all at once. This way we avoid having a check for every transaction epilogue.\n        let collected_amount = &mut collected_fees.amount;\n        coin::collect_into_aggregatable_coin<AptosCoin>(account, fee, collected_amount);\n    }\n\n    /// Only called during genesis.\n    public(friend) fun store_aptos_coin_burn_cap(aptos_framework: &signer, burn_cap: BurnCapability<AptosCoin>) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        move_to(aptos_framework, AptosCoinCapabilities { burn_cap })\n    }\n\n    /// Only called during genesis.\n    public(friend) fun store_aptos_coin_mint_cap(aptos_framework: &signer, mint_cap: MintCapability<AptosCoin>) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n        move_to(aptos_framework, AptosCoinMintCapability { mint_cap })\n    }\n\n    #[deprecated]\n    public fun initialize_storage_refund(_: &signer) {\n        abort error::not_implemented(ENO_LONGER_SUPPORTED)\n    }\n\n    // Called by the VM after epilogue.\n    fun emit_fee_statement(fee_statement: FeeStatement) {\n        event::emit(fee_statement)\n    }\n\n    #[test_only]\n    use aptos_framework::aggregator_factory;\n    #[test_only]\n    use aptos_framework::object;\n\n    #[test(aptos_framework = @aptos_framework)]\n    fun test_initialize_fee_collection_and_distribution(aptos_framework: signer) acquires CollectedFeesPerBlock {\n        aggregator_factory::initialize_aggregator_factory_for_test(&aptos_framework);\n        initialize_fee_collection_and_distribution(&aptos_framework, 25);\n\n        // Check struct has been published.\n        assert!(exists<CollectedFeesPerBlock>(@aptos_framework), 0);\n\n        // Check that initial balance is 0 and there is no proposer set.\n        let collected_fees = borrow_global<CollectedFeesPerBlock>(@aptos_framework);\n        assert!(coin::is_aggregatable_coin_zero(&collected_fees.amount), 0);\n        assert!(option::is_none(&collected_fees.proposer), 0);\n        assert!(collected_fees.burn_percentage == 25, 0);\n    }\n\n    #[test(aptos_framework = @aptos_framework)]\n    fun test_burn_fraction_calculation(aptos_framework: signer) acquires AptosCoinCapabilities {\n        use aptos_framework::aptos_coin;\n        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(&aptos_framework);\n        store_aptos_coin_burn_cap(&aptos_framework, burn_cap);\n\n        let c1 = coin::mint<AptosCoin>(100, &mint_cap);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 100, 0);\n\n        // Burning 25%.\n        burn_coin_fraction(&mut c1, 25);\n        assert!(coin::value(&c1) == 75, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 75, 0);\n\n        // Burning 0%.\n        burn_coin_fraction(&mut c1, 0);\n        assert!(coin::value(&c1) == 75, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 75, 0);\n\n        // Burning remaining 100%.\n        burn_coin_fraction(&mut c1, 100);\n        assert!(coin::value(&c1) == 0, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 0, 0);\n\n        coin::destroy_zero(c1);\n        let c2 = coin::mint<AptosCoin>(10, &mint_cap);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 10, 0);\n\n        burn_coin_fraction(&mut c2, 5);\n        assert!(coin::value(&c2) == 10, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 10, 0);\n\n        burn_coin_fraction(&mut c2, 100);\n        coin::destroy_zero(c2);\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n    }\n\n    #[test(aptos_framework = @aptos_framework, alice = @0xa11ce, bob = @0xb0b, carol = @0xca101)]\n    fun test_fees_distribution(\n        aptos_framework: signer,\n        alice: signer,\n        bob: signer,\n        carol: signer,\n    ) acquires AptosCoinCapabilities, CollectedFeesPerBlock {\n        use std::signer;\n        use aptos_framework::aptos_account;\n        use aptos_framework::aptos_coin;\n\n        // Initialization.\n        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(&aptos_framework);\n        store_aptos_coin_burn_cap(&aptos_framework, burn_cap);\n        initialize_fee_collection_and_distribution(&aptos_framework, 10);\n\n        // Create dummy accounts.\n        let alice_addr = signer::address_of(&alice);\n        let bob_addr = signer::address_of(&bob);\n        let carol_addr = signer::address_of(&carol);\n        aptos_account::create_account(alice_addr);\n        aptos_account::create_account(bob_addr);\n        aptos_account::create_account(carol_addr);\n        assert!(object::object_address(&coin::ensure_paired_metadata<AptosCoin>()) == @aptos_fungible_asset, 0);\n        coin::deposit(alice_addr, coin::mint(10000, &mint_cap));\n        coin::deposit(bob_addr, coin::mint(10000, &mint_cap));\n        coin::deposit(carol_addr, coin::mint(10000, &mint_cap));\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 30000, 0);\n\n        // Block 1 starts.\n        process_collected_fees();\n        register_proposer_for_fee_collection(alice_addr);\n\n        // Check that there was no fees distribution in the first block.\n        let collected_fees = borrow_global<CollectedFeesPerBlock>(@aptos_framework);\n        assert!(coin::is_aggregatable_coin_zero(&collected_fees.amount), 0);\n        assert!(*option::borrow(&collected_fees.proposer) == alice_addr, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 30000, 0);\n\n        // Simulate transaction fee collection - here we simply collect some fees from Bob.\n        collect_fee(bob_addr, 100);\n        collect_fee(bob_addr, 500);\n        collect_fee(bob_addr, 400);\n\n        // Now Bob must have 1000 less in his account. Alice and Carol have the same amounts.\n        assert!(coin::balance<AptosCoin>(alice_addr) == 10000, 0);\n        assert!(coin::balance<AptosCoin>(bob_addr) == 9000, 0);\n        assert!(coin::balance<AptosCoin>(carol_addr) == 10000, 0);\n\n        // Block 2 starts.\n        process_collected_fees();\n        register_proposer_for_fee_collection(bob_addr);\n\n        // Collected fees from Bob must have been assigned to Alice.\n        assert!(stake::get_validator_fee(alice_addr) == 900, 0);\n        assert!(coin::balance<AptosCoin>(alice_addr) == 10000, 0);\n        assert!(coin::balance<AptosCoin>(bob_addr) == 9000, 0);\n        assert!(coin::balance<AptosCoin>(carol_addr) == 10000, 0);\n\n        // Also, aggregator coin is drained and total supply is slightly changed (10% of 1000 is burnt).\n        let collected_fees = borrow_global<CollectedFeesPerBlock>(@aptos_framework);\n        assert!(coin::is_aggregatable_coin_zero(&collected_fees.amount), 0);\n        assert!(*option::borrow(&collected_fees.proposer) == bob_addr, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 29900, 0);\n\n        // Simulate transaction fee collection one more time.\n        collect_fee(bob_addr, 5000);\n        collect_fee(bob_addr, 4000);\n\n        assert!(coin::balance<AptosCoin>(alice_addr) == 10000, 0);\n        assert!(coin::balance<AptosCoin>(bob_addr) == 0, 0);\n        assert!(coin::balance<AptosCoin>(carol_addr) == 10000, 0);\n\n        // Block 3 starts.\n        process_collected_fees();\n        register_proposer_for_fee_collection(carol_addr);\n\n        // Collected fees should have been assigned to Bob because he was the peoposer.\n        assert!(stake::get_validator_fee(alice_addr) == 900, 0);\n        assert!(coin::balance<AptosCoin>(alice_addr) == 10000, 0);\n        assert!(stake::get_validator_fee(bob_addr) == 8100, 0);\n        assert!(coin::balance<AptosCoin>(bob_addr) == 0, 0);\n        assert!(coin::balance<AptosCoin>(carol_addr) == 10000, 0);\n\n        // Again, aggregator coin is drained and total supply is changed by 10% of 9000.\n        let collected_fees = borrow_global<CollectedFeesPerBlock>(@aptos_framework);\n        assert!(coin::is_aggregatable_coin_zero(&collected_fees.amount), 0);\n        assert!(*option::borrow(&collected_fees.proposer) == carol_addr, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 29000, 0);\n\n        // Simulate transaction fee collection one last time.\n        collect_fee(alice_addr, 1000);\n        collect_fee(alice_addr, 1000);\n\n        // Block 4 starts.\n        process_collected_fees();\n        register_proposer_for_fee_collection(alice_addr);\n\n        // Check that 2000 was collected from Alice.\n        assert!(coin::balance<AptosCoin>(alice_addr) == 8000, 0);\n        assert!(coin::balance<AptosCoin>(bob_addr) == 0, 0);\n\n        // Carol must have some fees assigned now.\n        let collected_fees = borrow_global<CollectedFeesPerBlock>(@aptos_framework);\n        assert!(stake::get_validator_fee(carol_addr) == 1800, 0);\n        assert!(coin::is_aggregatable_coin_zero(&collected_fees.amount), 0);\n        assert!(*option::borrow(&collected_fees.proposer) == alice_addr, 0);\n        assert!(*option::borrow(&coin::supply<AptosCoin>()) == 28800, 0);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n    }\n}\n","name":"transaction_fee.move"},{"content":"module aptos_framework::transaction_validation {\n    use std::bcs;\n    use std::error;\n    use std::features;\n    use std::option;\n    use std::option::Option;\n    use std::signer;\n    use std::vector;\n\n    use aptos_framework::account;\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::chain_id;\n    use aptos_framework::coin;\n    use aptos_framework::system_addresses;\n    use aptos_framework::timestamp;\n    use aptos_framework::transaction_fee;\n\n    friend aptos_framework::genesis;\n\n    /// This holds information that will be picked up by the VM to call the\n    /// correct chain-specific prologue and epilogue functions\n    struct TransactionValidation has key {\n        module_addr: address,\n        module_name: vector<u8>,\n        script_prologue_name: vector<u8>,\n        // module_prologue_name is deprecated and not used.\n        module_prologue_name: vector<u8>,\n        multi_agent_prologue_name: vector<u8>,\n        user_epilogue_name: vector<u8>,\n    }\n\n    /// MSB is used to indicate a gas payer tx\n    const MAX_U64: u128 = 18446744073709551615;\n\n    /// Transaction exceeded its allocated max gas\n    const EOUT_OF_GAS: u64 = 6;\n\n    /// Prologue errors. These are separated out from the other errors in this\n    /// module since they are mapped separately to major VM statuses, and are\n    /// important to the semantics of the system.\n    const PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY: u64 = 1001;\n    const PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD: u64 = 1002;\n    const PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW: u64 = 1003;\n    const PROLOGUE_EACCOUNT_DOES_NOT_EXIST: u64 = 1004;\n    const PROLOGUE_ECANT_PAY_GAS_DEPOSIT: u64 = 1005;\n    const PROLOGUE_ETRANSACTION_EXPIRED: u64 = 1006;\n    const PROLOGUE_EBAD_CHAIN_ID: u64 = 1007;\n    const PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG: u64 = 1008;\n    const PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH: u64 = 1009;\n    const PROLOGUE_EFEE_PAYER_NOT_ENABLED: u64 = 1010;\n    const PROLOGUE_EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT: u64 = 1011;\n\n    /// Only called during genesis to initialize system resources for this module.\n    public(friend) fun initialize(\n        aptos_framework: &signer,\n        script_prologue_name: vector<u8>,\n        // module_prologue_name is deprecated and not used.\n        module_prologue_name: vector<u8>,\n        multi_agent_prologue_name: vector<u8>,\n        user_epilogue_name: vector<u8>,\n    ) {\n        system_addresses::assert_aptos_framework(aptos_framework);\n\n        move_to(aptos_framework, TransactionValidation {\n            module_addr: @aptos_framework,\n            module_name: b\"transaction_validation\",\n            script_prologue_name,\n            // module_prologue_name is deprecated and not used.\n            module_prologue_name,\n            multi_agent_prologue_name,\n            user_epilogue_name,\n        });\n    }\n\n    /// Called in prologue to optionally hold some amount for special txns (e.g. randomness txns).\n    /// `return_deposit()` should be invoked in the corresponding epilogue with the same arguments.\n    fun collect_deposit(gas_payer: address, amount: Option<u64>) {\n        if (option::is_some(&amount)) {\n            let amount = option::extract(&mut amount);\n            let balance = coin::balance<AptosCoin>(gas_payer);\n            assert!(balance >= amount, error::invalid_state(PROLOGUE_EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT));\n            transaction_fee::burn_fee(gas_payer, amount);\n        }\n    }\n\n    /// Called in epilogue to optionally released the amount held in prologue for special txns (e.g. randomness txns).\n    fun return_deposit(gas_payer: address, amount: Option<u64>) {\n        if (option::is_some(&amount)) {\n            let amount = option::extract(&mut amount);\n            transaction_fee::mint_and_refund(gas_payer, amount);\n        }\n    }\n\n    fun prologue_common(\n        sender: signer,\n        gas_payer: address,\n        txn_sequence_number: u64,\n        txn_authentication_key: vector<u8>,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        txn_expiration_time: u64,\n        chain_id: u8,\n    ) {\n        assert!(\n            timestamp::now_seconds() < txn_expiration_time,\n            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),\n        );\n        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));\n\n        let transaction_sender = signer::address_of(&sender);\n\n        if (\n            transaction_sender == gas_payer\n            || account::exists_at(transaction_sender)\n            || !features::sponsored_automatic_account_creation_enabled()\n            || txn_sequence_number > 0\n        ) {\n            assert!(account::exists_at(transaction_sender), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));\n            assert!(\n                txn_authentication_key == account::get_authentication_key(transaction_sender),\n                error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),\n            );\n\n            let account_sequence_number = account::get_sequence_number(transaction_sender);\n            assert!(\n                txn_sequence_number < (1u64 << 63),\n                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)\n            );\n\n            assert!(\n                txn_sequence_number >= account_sequence_number,\n                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)\n            );\n\n            assert!(\n                txn_sequence_number == account_sequence_number,\n                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)\n            );\n        } else {\n            // In this case, the transaction is sponsored and the account does not exist, so ensure\n            // the default values match.\n            assert!(\n                txn_sequence_number == 0,\n                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)\n            );\n\n            assert!(\n                txn_authentication_key == bcs::to_bytes(&transaction_sender),\n                error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),\n            );\n        };\n\n        let max_transaction_fee = txn_gas_price * txn_max_gas_units;\n        assert!(\n            coin::is_account_registered<AptosCoin>(gas_payer),\n            error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),\n        );\n        assert!(\n            coin::is_balance_at_least<AptosCoin>(gas_payer, max_transaction_fee),\n            error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)\n        );\n    }\n\n    fun script_prologue(\n        sender: signer,\n        txn_sequence_number: u64,\n        txn_public_key: vector<u8>,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        txn_expiration_time: u64,\n        chain_id: u8,\n        _script_hash: vector<u8>,\n    ) {\n        let gas_payer = signer::address_of(&sender);\n        prologue_common(sender, gas_payer, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id)\n    }\n\n    /// `script_prologue()` then collect an optional deposit depending on the txn.\n    ///\n    /// Deposit collection goes last so `script_prologue()` doesn't have to be aware of the deposit logic.\n    fun script_prologue_collect_deposit(\n        sender: signer,\n        txn_sequence_number: u64,\n        txn_public_key: vector<u8>,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        txn_expiration_time: u64,\n        chain_id: u8,\n        script_hash: vector<u8>,\n        required_deposit: Option<u64>,\n    ) {\n        let gas_payer = signer::address_of(&sender);\n        script_prologue(sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id, script_hash);\n        collect_deposit(gas_payer, required_deposit);\n    }\n\n    fun multi_agent_script_prologue(\n        sender: signer,\n        txn_sequence_number: u64,\n        txn_sender_public_key: vector<u8>,\n        secondary_signer_addresses: vector<address>,\n        secondary_signer_public_key_hashes: vector<vector<u8>>,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        txn_expiration_time: u64,\n        chain_id: u8,\n    ) {\n        let sender_addr = signer::address_of(&sender);\n        prologue_common(\n            sender,\n            sender_addr,\n            txn_sequence_number,\n            txn_sender_public_key,\n            txn_gas_price,\n            txn_max_gas_units,\n            txn_expiration_time,\n            chain_id,\n        );\n        multi_agent_common_prologue(secondary_signer_addresses, secondary_signer_public_key_hashes);\n    }\n\n    fun multi_agent_common_prologue(\n        secondary_signer_addresses: vector<address>,\n        secondary_signer_public_key_hashes: vector<vector<u8>>,\n    ) {\n        let num_secondary_signers = vector::length(&secondary_signer_addresses);\n        assert!(\n            vector::length(&secondary_signer_public_key_hashes) == num_secondary_signers,\n            error::invalid_argument(PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH),\n        );\n\n        let i = 0;\n        while ({\n            spec {\n                invariant i <= num_secondary_signers;\n                invariant forall j in 0..i:\n                    account::exists_at(secondary_signer_addresses[j])\n                    && secondary_signer_public_key_hashes[j]\n                       == account::get_authentication_key(secondary_signer_addresses[j]);\n            };\n            (i < num_secondary_signers)\n        }) {\n            let secondary_address = *vector::borrow(&secondary_signer_addresses, i);\n            assert!(account::exists_at(secondary_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));\n\n            let signer_public_key_hash = *vector::borrow(&secondary_signer_public_key_hashes, i);\n            assert!(\n                signer_public_key_hash == account::get_authentication_key(secondary_address),\n                error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),\n            );\n            i = i + 1;\n        }\n    }\n\n    fun fee_payer_script_prologue(\n        sender: signer,\n        txn_sequence_number: u64,\n        txn_sender_public_key: vector<u8>,\n        secondary_signer_addresses: vector<address>,\n        secondary_signer_public_key_hashes: vector<vector<u8>>,\n        fee_payer_address: address,\n        fee_payer_public_key_hash: vector<u8>,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        txn_expiration_time: u64,\n        chain_id: u8,\n    ) {\n        assert!(features::fee_payer_enabled(), error::invalid_state(PROLOGUE_EFEE_PAYER_NOT_ENABLED));\n        prologue_common(\n            sender,\n            fee_payer_address,\n            txn_sequence_number,\n            txn_sender_public_key,\n            txn_gas_price,\n            txn_max_gas_units,\n            txn_expiration_time,\n            chain_id,\n        );\n        multi_agent_common_prologue(secondary_signer_addresses, secondary_signer_public_key_hashes);\n        assert!(\n            fee_payer_public_key_hash == account::get_authentication_key(fee_payer_address),\n            error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),\n        );\n    }\n\n    /// `fee_payer_script_prologue()` then collect an optional deposit depending on the txn.\n    ///\n    /// Deposit collection goes last so `fee_payer_script_prologue()` doesn't have to be aware of the deposit logic.\n    fun fee_payer_script_prologue_collect_deposit(\n        sender: signer,\n        txn_sequence_number: u64,\n        txn_sender_public_key: vector<u8>,\n        secondary_signer_addresses: vector<address>,\n        secondary_signer_public_key_hashes: vector<vector<u8>>,\n        fee_payer_address: address,\n        fee_payer_public_key_hash: vector<u8>,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        txn_expiration_time: u64,\n        chain_id: u8,\n        required_deposit: Option<u64>,\n    ) {\n        fee_payer_script_prologue(\n            sender,\n            txn_sequence_number,\n            txn_sender_public_key,\n            secondary_signer_addresses,\n            secondary_signer_public_key_hashes,\n            fee_payer_address,\n            fee_payer_public_key_hash,\n            txn_gas_price,\n            txn_max_gas_units,\n            txn_expiration_time,\n            chain_id,\n        );\n        collect_deposit(fee_payer_address, required_deposit);\n    }\n\n    /// Epilogue function is run after a transaction is successfully executed.\n    /// Called by the Adapter\n    fun epilogue(\n        account: signer,\n        storage_fee_refunded: u64,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        gas_units_remaining: u64\n    ) {\n        let addr = signer::address_of(&account);\n        epilogue_gas_payer(account, addr, storage_fee_refunded, txn_gas_price, txn_max_gas_units, gas_units_remaining);\n    }\n\n    /// Return the deposit held in prologue, then `epilogue()`.\n    ///\n    /// Deposit return goes first so `epilogue()` doesn't have to be aware of this change.\n    fun epilogue_return_deposit(\n        account: signer,\n        storage_fee_refunded: u64,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        gas_units_remaining: u64,\n        required_deposit: Option<u64>,\n    ) {\n        let gas_payer = signer::address_of(&account);\n        return_deposit(gas_payer, required_deposit);\n        epilogue(\n            account,\n            storage_fee_refunded,\n            txn_gas_price,\n            txn_max_gas_units,\n            gas_units_remaining,\n        );\n    }\n\n    /// Epilogue function with explicit gas payer specified, is run after a transaction is successfully executed.\n    /// Called by the Adapter\n    fun epilogue_gas_payer(\n        account: signer,\n        gas_payer: address,\n        storage_fee_refunded: u64,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        gas_units_remaining: u64\n    ) {\n        assert!(txn_max_gas_units >= gas_units_remaining, error::invalid_argument(EOUT_OF_GAS));\n        let gas_used = txn_max_gas_units - gas_units_remaining;\n\n        assert!(\n            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,\n            error::out_of_range(EOUT_OF_GAS)\n        );\n        let transaction_fee_amount = txn_gas_price * gas_used;\n        // it's important to maintain the error code consistent with vm\n        // to do failed transaction cleanup.\n        assert!(\n            coin::is_balance_at_least<AptosCoin>(gas_payer, transaction_fee_amount),\n            error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),\n        );\n\n        let amount_to_burn = if (features::collect_and_distribute_gas_fees()) {\n            // TODO(gas): We might want to distinguish the refundable part of the charge and burn it or track\n            // it separately, so that we don't increase the total supply by refunding.\n\n            // If transaction fees are redistributed to validators, collect them here for\n            // later redistribution.\n            transaction_fee::collect_fee(gas_payer, transaction_fee_amount);\n            0\n        } else {\n            // Otherwise, just burn the fee.\n            // TODO: this branch should be removed completely when transaction fee collection\n            // is tested and is fully proven to work well.\n            transaction_fee_amount\n        };\n\n        if (amount_to_burn > storage_fee_refunded) {\n            let burn_amount = amount_to_burn - storage_fee_refunded;\n            transaction_fee::burn_fee(gas_payer, burn_amount);\n        } else if (amount_to_burn < storage_fee_refunded) {\n            let mint_amount = storage_fee_refunded - amount_to_burn;\n            transaction_fee::mint_and_refund(gas_payer, mint_amount)\n        };\n\n        // Increment sequence number\n        let addr = signer::address_of(&account);\n        account::increment_sequence_number(addr);\n    }\n\n    /// Return the deposit held in prologue to the gas payer, then `epilogue_gas_payer()`.\n    ///\n    /// Deposit return should go first so `epilogue_gas_payer()` doesn't have to be aware of this change.\n    fun epilogue_gas_payer_return_deposit(\n        account: signer,\n        gas_payer: address,\n        storage_fee_refunded: u64,\n        txn_gas_price: u64,\n        txn_max_gas_units: u64,\n        gas_units_remaining: u64,\n        required_deposit: Option<u64>,\n    ) {\n        return_deposit(gas_payer, required_deposit);\n        epilogue_gas_payer(\n            account,\n            gas_payer,\n            storage_fee_refunded,\n            txn_gas_price,\n            txn_max_gas_units,\n            gas_units_remaining,\n        );\n    }\n}\n","name":"transaction_validation.move"},{"content":"/// Utility functions used by the framework modules.\nmodule aptos_framework::util {\n    friend aptos_framework::code;\n    friend aptos_framework::gas_schedule;\n\n    /// Native function to deserialize a type T.\n    ///\n    /// Note that this function does not put any constraint on `T`. If code uses this function to\n    /// deserialized a linear value, its their responsibility that the data they deserialize is\n    /// owned.\n    public(friend) native fun from_bytes<T>(bytes: vector<u8>): T;\n\n    public fun address_from_bytes(bytes: vector<u8>): address {\n        from_bytes(bytes)\n    }\n}\n","name":"util.move"},{"content":"/// Common type: `ValidatorConsensusInfo`.\nmodule aptos_framework::validator_consensus_info {\n    /// Information about a validator that participates consensus.\n    struct ValidatorConsensusInfo has copy, drop, store {\n        addr: address,\n        pk_bytes: vector<u8>,\n        voting_power: u64,\n    }\n\n    /// Create a default `ValidatorConsensusInfo` object. Value may be invalid. Only for place holding prupose.\n    public fun default(): ValidatorConsensusInfo {\n        ValidatorConsensusInfo {\n            addr: @vm,\n            pk_bytes: vector[],\n            voting_power: 0,\n        }\n    }\n\n    /// Create a `ValidatorConsensusInfo` object.\n    public fun new(addr: address, pk_bytes: vector<u8>, voting_power: u64): ValidatorConsensusInfo {\n        ValidatorConsensusInfo {\n            addr,\n            pk_bytes,\n            voting_power,\n        }\n    }\n\n    /// Get `ValidatorConsensusInfo.addr`.\n    public fun get_addr(vci: &ValidatorConsensusInfo): address {\n        vci.addr\n    }\n\n    /// Get `ValidatorConsensusInfo.pk_bytes`.\n    public fun get_pk_bytes(vci: &ValidatorConsensusInfo): vector<u8> {\n        vci.pk_bytes\n    }\n\n    /// Get `ValidatorConsensusInfo.voting_power`.\n    public fun get_voting_power(vci: &ValidatorConsensusInfo): u64 {\n        vci.voting_power\n    }\n}\n","name":"validator_consensus_info.move"},{"content":"///\n/// Simple vesting contract that allows specifying how much APT coins should be vesting in each fixed-size period. The\n/// vesting contract also comes with staking and allows shareholders to withdraw rewards anytime.\n///\n/// Vesting schedule is represented as a vector of distributions. For example, a vesting schedule of\n/// [3/48, 3/48, 1/48] means that after the vesting starts:\n/// 1. The first and second periods will vest 3/48 of the total original grant.\n/// 2. The third period will vest 1/48.\n/// 3. All subsequent periods will also vest 1/48 (last distribution in the schedule) until the original grant runs out.\n///\n/// Shareholder flow:\n/// 1. Admin calls create_vesting_contract with a schedule of [3/48, 3/48, 1/48] with a vesting cliff of 1 year and\n/// vesting period of 1 month.\n/// 2. After a month, a shareholder calls unlock_rewards to request rewards. They can also call vest() which would also\n/// unlocks rewards but since the 1 year cliff has not passed (vesting has not started), vest() would not release any of\n/// the original grant.\n/// 3. After the unlocked rewards become fully withdrawable (as it's subject to staking lockup), shareholders can call\n/// distribute() to send all withdrawable funds to all shareholders based on the original grant's shares structure.\n/// 4. After 1 year and 1 month, the vesting schedule now starts. Shareholders call vest() to unlock vested coins. vest()\n/// checks the schedule and unlocks 3/48 of the original grant in addition to any accumulated rewards since last\n/// unlock_rewards(). Once the unlocked coins become withdrawable, shareholders can call distribute().\n/// 5. Assuming the shareholders forgot to call vest() for 2 months, when they call vest() again, they will unlock vested\n/// tokens for the next period since last vest. This would be for the first month they missed. They can call vest() a\n/// second time to unlock for the second month they missed.\n///\n/// Admin flow:\n/// 1. After creating the vesting contract, admin cannot change the vesting schedule.\n/// 2. Admin can call update_voter, update_operator, or reset_lockup at any time to update the underlying staking\n/// contract.\n/// 3. Admin can also call update_beneficiary for any shareholder. This would send all distributions (rewards, vested\n/// coins) of that shareholder to the beneficiary account. By defalt, if a beneficiary is not set, the distributions are\n/// send directly to the shareholder account.\n/// 4. Admin can call terminate_vesting_contract to terminate the vesting. This would first finish any distribution but\n/// will prevent any further rewards or vesting distributions from being created. Once the locked up stake becomes\n/// withdrawable, admin can call admin_withdraw to withdraw all funds to the vesting contract's withdrawal address.\nmodule aptos_framework::vesting {\n    use std::bcs;\n    use std::error;\n    use std::fixed_point32::{Self, FixedPoint32};\n    use std::signer;\n    use std::string::{utf8, String};\n    use std::vector;\n\n    use aptos_std::pool_u64::{Self, Pool};\n    use aptos_std::simple_map::{Self, SimpleMap};\n\n    use aptos_framework::account::{Self, SignerCapability, new_event_handle};\n    use aptos_framework::aptos_account::{Self, assert_account_is_registered_for_apt};\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::coin::{Self, Coin};\n    use aptos_framework::event::{EventHandle, emit, emit_event};\n    use aptos_framework::stake;\n    use aptos_framework::staking_contract;\n    use aptos_framework::system_addresses;\n    use aptos_framework::timestamp;\n\n    friend aptos_framework::genesis;\n\n    const VESTING_POOL_SALT: vector<u8> = b\"aptos_framework::vesting\";\n\n    /// Withdrawal address is invalid.\n    const EINVALID_WITHDRAWAL_ADDRESS: u64 = 1;\n    /// Vesting schedule cannot be empty.\n    const EEMPTY_VESTING_SCHEDULE: u64 = 2;\n    /// Vesting period cannot be 0.\n    const EZERO_VESTING_SCHEDULE_PERIOD: u64 = 3;\n    /// Shareholders list cannot be empty.\n    const ENO_SHAREHOLDERS: u64 = 4;\n    /// The length of shareholders and shares lists don't match.\n    const ESHARES_LENGTH_MISMATCH: u64 = 5;\n    /// Vesting cannot start before or at the current block timestamp. Has to be in the future.\n    const EVESTING_START_TOO_SOON: u64 = 6;\n    /// The signer is not the admin of the vesting contract.\n    const ENOT_ADMIN: u64 = 7;\n    /// Vesting contract needs to be in active state.\n    const EVESTING_CONTRACT_NOT_ACTIVE: u64 = 8;\n    /// Admin can only withdraw from an inactive (paused or terminated) vesting contract.\n    const EVESTING_CONTRACT_STILL_ACTIVE: u64 = 9;\n    /// No vesting contract found at provided address.\n    const EVESTING_CONTRACT_NOT_FOUND: u64 = 10;\n    /// Cannot terminate the vesting contract with pending active stake. Need to wait until next epoch.\n    const EPENDING_STAKE_FOUND: u64 = 11;\n    /// Grant amount cannot be 0.\n    const EZERO_GRANT: u64 = 12;\n    /// Vesting account has no other management roles beside admin.\n    const EVESTING_ACCOUNT_HAS_NO_ROLES: u64 = 13;\n    /// The vesting account has no such management role.\n    const EROLE_NOT_FOUND: u64 = 14;\n    /// Account is not admin or does not have the required role to take this action.\n    const EPERMISSION_DENIED: u64 = 15;\n    /// Zero items were provided to a *_many function.\n    const EVEC_EMPTY_FOR_MANY_FUNCTION: u64 = 16;\n\n    /// Maximum number of shareholders a vesting pool can support.\n    const MAXIMUM_SHAREHOLDERS: u64 = 30;\n\n    /// Vesting contract states.\n    /// Vesting contract is active and distributions can be made.\n    const VESTING_POOL_ACTIVE: u64 = 1;\n    /// Vesting contract has been terminated and all funds have been released back to the withdrawal address.\n    const VESTING_POOL_TERMINATED: u64 = 2;\n\n    /// Roles that can manage certain aspects of the vesting account beyond the main admin.\n    const ROLE_BENEFICIARY_RESETTER: vector<u8> = b\"ROLE_BENEFICIARY_RESETTER\";\n\n    struct VestingSchedule has copy, drop, store {\n        // The vesting schedule as a list of fractions that vest for each period. The last number is repeated until the\n        // vesting amount runs out.\n        // For example [1/24, 1/24, 1/48] with a period of 1 month means that after vesting starts, the first two months\n        // will vest 1/24 of the original total amount. From the third month only, 1/48 will vest until the vesting fund\n        // runs out.\n        // u32/u32 should be sufficient to support vesting schedule fractions.\n        schedule: vector<FixedPoint32>,\n        // When the vesting should start.\n        start_timestamp_secs: u64,\n        // In seconds. How long each vesting period is. For example 1 month.\n        period_duration: u64,\n        // Last vesting period, 1-indexed. For example if 2 months have passed, the last vesting period, if distribution\n        // was requested, would be 2. Default value is 0 which means there have been no vesting periods yet.\n        last_vested_period: u64,\n    }\n\n    struct StakingInfo has store {\n        // Where the vesting's stake pool is located at. Included for convenience.\n        pool_address: address,\n        // The currently assigned operator.\n        operator: address,\n        // The currently assigned voter.\n        voter: address,\n        // Commission paid to the operator of the stake pool.\n        commission_percentage: u64,\n    }\n\n    struct VestingContract has key {\n        state: u64,\n        admin: address,\n        grant_pool: Pool,\n        beneficiaries: SimpleMap<address, address>,\n        vesting_schedule: VestingSchedule,\n        // Withdrawal address where all funds would be released back to if the admin ends the vesting for a specific\n        // account or terminates the entire vesting contract.\n        withdrawal_address: address,\n        staking: StakingInfo,\n        // Remaining amount in the grant. For calculating accumulated rewards.\n        remaining_grant: u64,\n        // Used to control staking.\n        signer_cap: SignerCapability,\n\n        // Events.\n        update_operator_events: EventHandle<UpdateOperatorEvent>,\n        update_voter_events: EventHandle<UpdateVoterEvent>,\n        reset_lockup_events: EventHandle<ResetLockupEvent>,\n        set_beneficiary_events: EventHandle<SetBeneficiaryEvent>,\n        unlock_rewards_events: EventHandle<UnlockRewardsEvent>,\n        vest_events: EventHandle<VestEvent>,\n        distribute_events: EventHandle<DistributeEvent>,\n        terminate_events: EventHandle<TerminateEvent>,\n        admin_withdraw_events: EventHandle<AdminWithdrawEvent>,\n    }\n\n    struct VestingAccountManagement has key {\n        roles: SimpleMap<String, address>,\n    }\n\n    struct AdminStore has key {\n        vesting_contracts: vector<address>,\n        // Used to create resource accounts for new vesting contracts so there's no address collision.\n        nonce: u64,\n\n        create_events: EventHandle<CreateVestingContractEvent>,\n    }\n\n    #[event]\n    struct CreateVestingContract has drop, store {\n        operator: address,\n        voter: address,\n        grant_amount: u64,\n        withdrawal_address: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        commission_percentage: u64,\n    }\n\n    #[event]\n    struct UpdateOperator has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        old_operator: address,\n        new_operator: address,\n        commission_percentage: u64,\n    }\n\n    #[event]\n    struct UpdateVoter has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        old_voter: address,\n        new_voter: address,\n    }\n\n    #[event]\n    struct ResetLockup has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        new_lockup_expiration_secs: u64,\n    }\n\n    #[event]\n    struct SetBeneficiary has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        shareholder: address,\n        old_beneficiary: address,\n        new_beneficiary: address,\n    }\n\n    #[event]\n    struct UnlockRewards has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        amount: u64,\n    }\n\n    #[event]\n    struct Vest has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        period_vested: u64,\n        amount: u64,\n    }\n\n    #[event]\n    struct Distribute has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        amount: u64,\n    }\n\n    #[event]\n    struct Terminate has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n    }\n\n    #[event]\n    struct AdminWithdraw has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        amount: u64,\n    }\n\n    struct CreateVestingContractEvent has drop, store {\n        operator: address,\n        voter: address,\n        grant_amount: u64,\n        withdrawal_address: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        commission_percentage: u64,\n    }\n\n    struct UpdateOperatorEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        old_operator: address,\n        new_operator: address,\n        commission_percentage: u64,\n    }\n\n    struct UpdateVoterEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        old_voter: address,\n        new_voter: address,\n    }\n\n    struct ResetLockupEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        new_lockup_expiration_secs: u64,\n    }\n\n    struct SetBeneficiaryEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        shareholder: address,\n        old_beneficiary: address,\n        new_beneficiary: address,\n    }\n\n    struct UnlockRewardsEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        amount: u64,\n    }\n\n    struct VestEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        staking_pool_address: address,\n        period_vested: u64,\n        amount: u64,\n    }\n\n    struct DistributeEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        amount: u64,\n    }\n\n    struct TerminateEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n    }\n\n    struct AdminWithdrawEvent has drop, store {\n        admin: address,\n        vesting_contract_address: address,\n        amount: u64,\n    }\n\n    #[view]\n    /// Return the address of the underlying stake pool (separate resource account) of the vesting contract.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun stake_pool_address(vesting_contract_address: address): address acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).staking.pool_address\n    }\n\n    #[view]\n    /// Return the vesting start timestamp (in seconds) of the vesting contract.\n    /// Vesting will start at this time, and once a full period has passed, the first vest will become unlocked.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun vesting_start_secs(vesting_contract_address: address): u64 acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).vesting_schedule.start_timestamp_secs\n    }\n\n    #[view]\n    /// Return the duration of one vesting period (in seconds).\n    /// Each vest is released after one full period has started, starting from the specified start_timestamp_secs.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun period_duration_secs(vesting_contract_address: address): u64 acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).vesting_schedule.period_duration\n    }\n\n    #[view]\n    /// Return the remaining grant, consisting of unvested coins that have not been distributed to shareholders.\n    /// Prior to start_timestamp_secs, the remaining grant will always be equal to the original grant.\n    /// Once vesting has started, and vested tokens are distributed, the remaining grant will decrease over time,\n    /// according to the vesting schedule.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun remaining_grant(vesting_contract_address: address): u64 acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).remaining_grant\n    }\n\n    #[view]\n    /// Return the beneficiary account of the specified shareholder in a vesting contract.\n    /// This is the same as the shareholder address by default and only different if it's been explicitly set.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun beneficiary(vesting_contract_address: address, shareholder: address): address acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        get_beneficiary(borrow_global<VestingContract>(vesting_contract_address), shareholder)\n    }\n\n    #[view]\n    /// Return the percentage of accumulated rewards that is paid to the operator as commission.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun operator_commission_percentage(vesting_contract_address: address): u64 acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).staking.commission_percentage\n    }\n\n    #[view]\n    /// Return all the vesting contracts a given address is an admin of.\n    public fun vesting_contracts(admin: address): vector<address> acquires AdminStore {\n        if (!exists<AdminStore>(admin)) {\n            vector::empty<address>()\n        } else {\n            borrow_global<AdminStore>(admin).vesting_contracts\n        }\n    }\n\n    #[view]\n    /// Return the operator who runs the validator for the vesting contract.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun operator(vesting_contract_address: address): address acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).staking.operator\n    }\n\n    #[view]\n    /// Return the voter who will be voting on on-chain governance proposals on behalf of the vesting contract's stake\n    /// pool.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun voter(vesting_contract_address: address): address acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).staking.voter\n    }\n\n    #[view]\n    /// Return the vesting contract's vesting schedule. The core schedule is represented as a list of u64-based\n    /// fractions, where the rightmmost 32 bits can be divided by 2^32 to get the fraction, and anything else is the\n    /// whole number.\n    ///\n    /// For example 3/48, or 0.0625, will be represented as 268435456. The fractional portion would be\n    /// 268435456 / 2^32 = 0.0625. Since there are fewer than 32 bits, the whole number portion is effectively 0.\n    /// So 268435456 = 0.0625.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun vesting_schedule(vesting_contract_address: address): VestingSchedule acquires VestingContract {\n        assert_vesting_contract_exists(vesting_contract_address);\n        borrow_global<VestingContract>(vesting_contract_address).vesting_schedule\n    }\n\n    #[view]\n    /// Return the total accumulated rewards that have not been distributed to shareholders of the vesting contract.\n    /// This excludes any unpaid commission that the operator has not collected.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun total_accumulated_rewards(vesting_contract_address: address): u64 acquires VestingContract {\n        assert_active_vesting_contract(vesting_contract_address);\n\n        let vesting_contract = borrow_global<VestingContract>(vesting_contract_address);\n        let (total_active_stake, _, commission_amount) =\n            staking_contract::staking_contract_amounts(vesting_contract_address, vesting_contract.staking.operator);\n        total_active_stake - vesting_contract.remaining_grant - commission_amount\n    }\n\n    #[view]\n    /// Return the accumulated rewards that have not been distributed to the provided shareholder. Caller can also pass\n    /// the beneficiary address instead of shareholder address.\n    ///\n    /// This errors out if the vesting contract with the provided address doesn't exist.\n    public fun accumulated_rewards(\n        vesting_contract_address: address, shareholder_or_beneficiary: address): u64 acquires VestingContract {\n        assert_active_vesting_contract(vesting_contract_address);\n\n        let total_accumulated_rewards = total_accumulated_rewards(vesting_contract_address);\n        let shareholder = shareholder(vesting_contract_address, shareholder_or_beneficiary);\n        let vesting_contract = borrow_global<VestingContract>(vesting_contract_address);\n        let shares = pool_u64::shares(&vesting_contract.grant_pool, shareholder);\n        pool_u64::shares_to_amount_with_total_coins(&vesting_contract.grant_pool, shares, total_accumulated_rewards)\n    }\n\n    #[view]\n    /// Return the list of all shareholders in the vesting contract.\n    public fun shareholders(vesting_contract_address: address): vector<address> acquires VestingContract {\n        assert_active_vesting_contract(vesting_contract_address);\n\n        let vesting_contract = borrow_global<VestingContract>(vesting_contract_address);\n        pool_u64::shareholders(&vesting_contract.grant_pool)\n    }\n\n    #[view]\n    /// Return the shareholder address given the beneficiary address in a given vesting contract. If there are multiple\n    /// shareholders with the same beneficiary address, only the first shareholder is returned. If the given beneficiary\n    /// address is actually a shareholder address, just return the address back.\n    ///\n    /// This returns 0x0 if no shareholder is found for the given beneficiary / the address is not a shareholder itself.\n    public fun shareholder(\n        vesting_contract_address: address,\n        shareholder_or_beneficiary: address\n    ): address acquires VestingContract {\n        assert_active_vesting_contract(vesting_contract_address);\n\n        let shareholders = &shareholders(vesting_contract_address);\n        if (vector::contains(shareholders, &shareholder_or_beneficiary)) {\n            return shareholder_or_beneficiary\n        };\n        let vesting_contract = borrow_global<VestingContract>(vesting_contract_address);\n        let result = @0x0;\n        vector::any(shareholders, |shareholder| {\n            if (shareholder_or_beneficiary == get_beneficiary(vesting_contract, *shareholder)) {\n                result = *shareholder;\n                true\n            } else {\n                false\n            }\n        });\n\n        result\n    }\n\n    /// Create a vesting schedule with the given schedule of distributions, a vesting start time and period duration.\n    public fun create_vesting_schedule(\n        schedule: vector<FixedPoint32>,\n        start_timestamp_secs: u64,\n        period_duration: u64,\n    ): VestingSchedule {\n        assert!(vector::length(&schedule) > 0, error::invalid_argument(EEMPTY_VESTING_SCHEDULE));\n        assert!(period_duration > 0, error::invalid_argument(EZERO_VESTING_SCHEDULE_PERIOD));\n        assert!(\n            start_timestamp_secs >= timestamp::now_seconds(),\n            error::invalid_argument(EVESTING_START_TOO_SOON),\n        );\n\n        VestingSchedule {\n            schedule,\n            start_timestamp_secs,\n            period_duration,\n            last_vested_period: 0,\n        }\n    }\n\n    /// Create a vesting contract with a given configurations.\n    public fun create_vesting_contract(\n        admin: &signer,\n        shareholders: &vector<address>,\n        buy_ins: SimpleMap<address, Coin<AptosCoin>>,\n        vesting_schedule: VestingSchedule,\n        withdrawal_address: address,\n        operator: address,\n        voter: address,\n        commission_percentage: u64,\n        // Optional seed used when creating the staking contract account.\n        contract_creation_seed: vector<u8>,\n    ): address acquires AdminStore {\n        assert!(\n            !system_addresses::is_reserved_address(withdrawal_address),\n            error::invalid_argument(EINVALID_WITHDRAWAL_ADDRESS),\n        );\n        assert_account_is_registered_for_apt(withdrawal_address);\n        assert!(vector::length(shareholders) > 0, error::invalid_argument(ENO_SHAREHOLDERS));\n        assert!(\n            simple_map::length(&buy_ins) == vector::length(shareholders),\n            error::invalid_argument(ESHARES_LENGTH_MISMATCH),\n        );\n\n        // Create a coins pool to track shareholders and shares of the grant.\n        let grant = coin::zero<AptosCoin>();\n        let grant_amount = 0;\n        let grant_pool = pool_u64::create(MAXIMUM_SHAREHOLDERS);\n        vector::for_each_ref(shareholders, |shareholder| {\n            let shareholder: address = *shareholder;\n            let (_, buy_in) = simple_map::remove(&mut buy_ins, &shareholder);\n            let buy_in_amount = coin::value(&buy_in);\n            coin::merge(&mut grant, buy_in);\n            pool_u64::buy_in(\n                &mut grant_pool,\n                shareholder,\n                buy_in_amount,\n            );\n            grant_amount = grant_amount + buy_in_amount;\n        });\n        assert!(grant_amount > 0, error::invalid_argument(EZERO_GRANT));\n\n        // If this is the first time this admin account has created a vesting contract, initialize the admin store.\n        let admin_address = signer::address_of(admin);\n        if (!exists<AdminStore>(admin_address)) {\n            move_to(admin, AdminStore {\n                vesting_contracts: vector::empty<address>(),\n                nonce: 0,\n                create_events: new_event_handle<CreateVestingContractEvent>(admin),\n            });\n        };\n\n        // Initialize the vesting contract in a new resource account. This allows the same admin to create multiple\n        // pools.\n        let (contract_signer, contract_signer_cap) = create_vesting_contract_account(admin, contract_creation_seed);\n        let pool_address = staking_contract::create_staking_contract_with_coins(\n            &contract_signer, operator, voter, grant, commission_percentage, contract_creation_seed);\n\n        // Add the newly created vesting contract's address to the admin store.\n        let contract_address = signer::address_of(&contract_signer);\n        let admin_store = borrow_global_mut<AdminStore>(admin_address);\n        vector::push_back(&mut admin_store.vesting_contracts, contract_address);\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                CreateVestingContract {\n                    operator,\n                    voter,\n                    withdrawal_address,\n                    grant_amount,\n                    vesting_contract_address: contract_address,\n                    staking_pool_address: pool_address,\n                    commission_percentage,\n                },\n            );\n        };\n        emit_event(\n            &mut admin_store.create_events,\n            CreateVestingContractEvent {\n                operator,\n                voter,\n                withdrawal_address,\n                grant_amount,\n                vesting_contract_address: contract_address,\n                staking_pool_address: pool_address,\n                commission_percentage,\n            },\n        );\n\n        move_to(&contract_signer, VestingContract {\n            state: VESTING_POOL_ACTIVE,\n            admin: admin_address,\n            grant_pool,\n            beneficiaries: simple_map::create<address, address>(),\n            vesting_schedule,\n            withdrawal_address,\n            staking: StakingInfo { pool_address, operator, voter, commission_percentage },\n            remaining_grant: grant_amount,\n            signer_cap: contract_signer_cap,\n            update_operator_events: new_event_handle<UpdateOperatorEvent>(&contract_signer),\n            update_voter_events: new_event_handle<UpdateVoterEvent>(&contract_signer),\n            reset_lockup_events: new_event_handle<ResetLockupEvent>(&contract_signer),\n            set_beneficiary_events: new_event_handle<SetBeneficiaryEvent>(&contract_signer),\n            unlock_rewards_events: new_event_handle<UnlockRewardsEvent>(&contract_signer),\n            vest_events: new_event_handle<VestEvent>(&contract_signer),\n            distribute_events: new_event_handle<DistributeEvent>(&contract_signer),\n            terminate_events: new_event_handle<TerminateEvent>(&contract_signer),\n            admin_withdraw_events: new_event_handle<AdminWithdrawEvent>(&contract_signer),\n        });\n\n        simple_map::destroy_empty(buy_ins);\n        contract_address\n    }\n\n    /// Unlock any accumulated rewards.\n    public entry fun unlock_rewards(contract_address: address) acquires VestingContract {\n        let accumulated_rewards = total_accumulated_rewards(contract_address);\n        let vesting_contract = borrow_global<VestingContract>(contract_address);\n        unlock_stake(vesting_contract, accumulated_rewards);\n    }\n\n    /// Call `unlock_rewards` for many vesting contracts.\n    public entry fun unlock_rewards_many(contract_addresses: vector<address>) acquires VestingContract {\n        let len = vector::length(&contract_addresses);\n\n        assert!(len != 0, error::invalid_argument(EVEC_EMPTY_FOR_MANY_FUNCTION));\n\n        vector::for_each_ref(&contract_addresses, |contract_address| {\n            let contract_address: address = *contract_address;\n            unlock_rewards(contract_address);\n        });\n    }\n\n    /// Unlock any vested portion of the grant.\n    public entry fun vest(contract_address: address) acquires VestingContract {\n        // Unlock all rewards first, if any.\n        unlock_rewards(contract_address);\n\n        // Unlock the vested amount. This amount will become withdrawable when the underlying stake pool's lockup\n        // expires.\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        // Short-circuit if vesting hasn't started yet.\n        if (vesting_contract.vesting_schedule.start_timestamp_secs > timestamp::now_seconds()) {\n            return\n        };\n\n        // Check if the next vested period has already passed. If not, short-circuit since there's nothing to vest.\n        let vesting_schedule = &mut vesting_contract.vesting_schedule;\n        let last_vested_period = vesting_schedule.last_vested_period;\n        let next_period_to_vest = last_vested_period + 1;\n        let last_completed_period =\n            (timestamp::now_seconds() - vesting_schedule.start_timestamp_secs) / vesting_schedule.period_duration;\n        if (last_completed_period < next_period_to_vest) {\n            return\n        };\n\n        // Calculate how much has vested, excluding rewards.\n        // Index is 0-based while period is 1-based so we need to subtract 1.\n        let schedule = &vesting_schedule.schedule;\n        let schedule_index = next_period_to_vest - 1;\n        let vesting_fraction = if (schedule_index < vector::length(schedule)) {\n            *vector::borrow(schedule, schedule_index)\n        } else {\n            // Last vesting schedule fraction will repeat until the grant runs out.\n            *vector::borrow(schedule, vector::length(schedule) - 1)\n        };\n        let total_grant = pool_u64::total_coins(&vesting_contract.grant_pool);\n        let vested_amount = fixed_point32::multiply_u64(total_grant, vesting_fraction);\n        // Cap vested amount by the remaining grant amount so we don't try to distribute more than what's remaining.\n        vested_amount = min(vested_amount, vesting_contract.remaining_grant);\n        vesting_contract.remaining_grant = vesting_contract.remaining_grant - vested_amount;\n        vesting_schedule.last_vested_period = next_period_to_vest;\n        unlock_stake(vesting_contract, vested_amount);\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                Vest {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                    staking_pool_address: vesting_contract.staking.pool_address,\n                    period_vested: next_period_to_vest,\n                    amount: vested_amount,\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.vest_events,\n            VestEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n                staking_pool_address: vesting_contract.staking.pool_address,\n                period_vested: next_period_to_vest,\n                amount: vested_amount,\n            },\n        );\n    }\n\n    /// Call `vest` for many vesting contracts.\n    public entry fun vest_many(contract_addresses: vector<address>) acquires VestingContract {\n        let len = vector::length(&contract_addresses);\n\n        assert!(len != 0, error::invalid_argument(EVEC_EMPTY_FOR_MANY_FUNCTION));\n\n        vector::for_each_ref(&contract_addresses, |contract_address| {\n            let contract_address = *contract_address;\n            vest(contract_address);\n        });\n    }\n\n    /// Distribute any withdrawable stake from the stake pool.\n    public entry fun distribute(contract_address: address) acquires VestingContract {\n        assert_active_vesting_contract(contract_address);\n\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        let coins = withdraw_stake(vesting_contract, contract_address);\n        let total_distribution_amount = coin::value(&coins);\n        if (total_distribution_amount == 0) {\n            coin::destroy_zero(coins);\n            return\n        };\n\n        // Distribute coins to all shareholders in the vesting contract.\n        let grant_pool = &vesting_contract.grant_pool;\n        let shareholders = &pool_u64::shareholders(grant_pool);\n        vector::for_each_ref(shareholders, |shareholder| {\n            let shareholder = *shareholder;\n            let shares = pool_u64::shares(grant_pool, shareholder);\n            let amount = pool_u64::shares_to_amount_with_total_coins(grant_pool, shares, total_distribution_amount);\n            let share_of_coins = coin::extract(&mut coins, amount);\n            let recipient_address = get_beneficiary(vesting_contract, shareholder);\n            aptos_account::deposit_coins(recipient_address, share_of_coins);\n        });\n\n        // Send any remaining \"dust\" (leftover due to rounding error) to the withdrawal address.\n        if (coin::value(&coins) > 0) {\n            aptos_account::deposit_coins(vesting_contract.withdrawal_address, coins);\n        } else {\n            coin::destroy_zero(coins);\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                Distribute {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                    amount: total_distribution_amount,\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.distribute_events,\n            DistributeEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n                amount: total_distribution_amount,\n            },\n        );\n    }\n\n    /// Call `distribute` for many vesting contracts.\n    public entry fun distribute_many(contract_addresses: vector<address>) acquires VestingContract {\n        let len = vector::length(&contract_addresses);\n\n        assert!(len != 0, error::invalid_argument(EVEC_EMPTY_FOR_MANY_FUNCTION));\n\n        vector::for_each_ref(&contract_addresses, |contract_address| {\n            let contract_address = *contract_address;\n            distribute(contract_address);\n        });\n    }\n\n    /// Terminate the vesting contract and send all funds back to the withdrawal address.\n    public entry fun terminate_vesting_contract(admin: &signer, contract_address: address) acquires VestingContract {\n        assert_active_vesting_contract(contract_address);\n\n        // Distribute all withdrawable coins, which should have been from previous rewards withdrawal or vest.\n        distribute(contract_address);\n\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n        let (active_stake, _, pending_active_stake, _) = stake::get_stake(vesting_contract.staking.pool_address);\n        assert!(pending_active_stake == 0, error::invalid_state(EPENDING_STAKE_FOUND));\n\n        // Unlock all remaining active stake.\n        vesting_contract.state = VESTING_POOL_TERMINATED;\n        vesting_contract.remaining_grant = 0;\n        unlock_stake(vesting_contract, active_stake);\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                Terminate {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.terminate_events,\n            TerminateEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n            },\n        );\n    }\n\n    /// Withdraw all funds to the preset vesting contract's withdrawal address. This can only be called if the contract\n    /// has already been terminated.\n    public entry fun admin_withdraw(admin: &signer, contract_address: address) acquires VestingContract {\n        let vesting_contract = borrow_global<VestingContract>(contract_address);\n        assert!(\n            vesting_contract.state == VESTING_POOL_TERMINATED,\n            error::invalid_state(EVESTING_CONTRACT_STILL_ACTIVE)\n        );\n\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n        let coins = withdraw_stake(vesting_contract, contract_address);\n        let amount = coin::value(&coins);\n        if (amount == 0) {\n            coin::destroy_zero(coins);\n            return\n        };\n        aptos_account::deposit_coins(vesting_contract.withdrawal_address, coins);\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                AdminWithdraw {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                    amount,\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.admin_withdraw_events,\n            AdminWithdrawEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n                amount,\n            },\n        );\n    }\n\n    public entry fun update_operator(\n        admin: &signer,\n        contract_address: address,\n        new_operator: address,\n        commission_percentage: u64,\n    ) acquires VestingContract {\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);\n        let old_operator = vesting_contract.staking.operator;\n        staking_contract::switch_operator(contract_signer, old_operator, new_operator, commission_percentage);\n        vesting_contract.staking.operator = new_operator;\n        vesting_contract.staking.commission_percentage = commission_percentage;\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                UpdateOperator {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                    staking_pool_address: vesting_contract.staking.pool_address,\n                    old_operator,\n                    new_operator,\n                    commission_percentage,\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.update_operator_events,\n            UpdateOperatorEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n                staking_pool_address: vesting_contract.staking.pool_address,\n                old_operator,\n                new_operator,\n                commission_percentage,\n            },\n        );\n    }\n\n    public entry fun update_operator_with_same_commission(\n        admin: &signer,\n        contract_address: address,\n        new_operator: address,\n    ) acquires VestingContract {\n        let commission_percentage = operator_commission_percentage(contract_address);\n        update_operator(admin, contract_address, new_operator, commission_percentage);\n    }\n\n    public entry fun update_commission_percentage(\n        admin: &signer,\n        contract_address: address,\n        new_commission_percentage: u64,\n    ) acquires VestingContract {\n        let operator = operator(contract_address);\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);\n        staking_contract::update_commision(contract_signer, operator, new_commission_percentage);\n        vesting_contract.staking.commission_percentage = new_commission_percentage;\n        // This function does not emit an event. Instead, `staking_contract::update_commission_percentage`\n        // emits the event for this commission percentage update.\n    }\n\n    public entry fun update_voter(\n        admin: &signer,\n        contract_address: address,\n        new_voter: address,\n    ) acquires VestingContract {\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);\n        let old_voter = vesting_contract.staking.voter;\n        staking_contract::update_voter(contract_signer, vesting_contract.staking.operator, new_voter);\n        vesting_contract.staking.voter = new_voter;\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                UpdateVoter {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                    staking_pool_address: vesting_contract.staking.pool_address,\n                    old_voter,\n                    new_voter,\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.update_voter_events,\n            UpdateVoterEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n                staking_pool_address: vesting_contract.staking.pool_address,\n                old_voter,\n                new_voter,\n            },\n        );\n    }\n\n    public entry fun reset_lockup(\n        admin: &signer,\n        contract_address: address,\n    ) acquires VestingContract {\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);\n        staking_contract::reset_lockup(contract_signer, vesting_contract.staking.operator);\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                ResetLockup {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                    staking_pool_address: vesting_contract.staking.pool_address,\n                    new_lockup_expiration_secs: stake::get_lockup_secs(vesting_contract.staking.pool_address),\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.reset_lockup_events,\n            ResetLockupEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n                staking_pool_address: vesting_contract.staking.pool_address,\n                new_lockup_expiration_secs: stake::get_lockup_secs(vesting_contract.staking.pool_address),\n            },\n        );\n    }\n\n    public entry fun set_beneficiary(\n        admin: &signer,\n        contract_address: address,\n        shareholder: address,\n        new_beneficiary: address,\n    ) acquires VestingContract {\n        // Verify that the beneficiary account is set up to receive APT. This is a requirement so distribute() wouldn't\n        // fail and block all other accounts from receiving APT if one beneficiary is not registered.\n        assert_account_is_registered_for_apt(new_beneficiary);\n\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n\n        let old_beneficiary = get_beneficiary(vesting_contract, shareholder);\n        let beneficiaries = &mut vesting_contract.beneficiaries;\n        if (simple_map::contains_key(beneficiaries, &shareholder)) {\n            let beneficiary = simple_map::borrow_mut(beneficiaries, &shareholder);\n            *beneficiary = new_beneficiary;\n        } else {\n            simple_map::add(beneficiaries, shareholder, new_beneficiary);\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            emit(\n                SetBeneficiary {\n                    admin: vesting_contract.admin,\n                    vesting_contract_address: contract_address,\n                    shareholder,\n                    old_beneficiary,\n                    new_beneficiary,\n                },\n            );\n        };\n        emit_event(\n            &mut vesting_contract.set_beneficiary_events,\n            SetBeneficiaryEvent {\n                admin: vesting_contract.admin,\n                vesting_contract_address: contract_address,\n                shareholder,\n                old_beneficiary,\n                new_beneficiary,\n            },\n        );\n    }\n\n    /// Remove the beneficiary for the given shareholder. All distributions will sent directly to the shareholder\n    /// account.\n    public entry fun reset_beneficiary(\n        account: &signer,\n        contract_address: address,\n        shareholder: address,\n    ) acquires VestingAccountManagement, VestingContract {\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        let addr = signer::address_of(account);\n        assert!(\n            addr == vesting_contract.admin ||\n                addr == get_role_holder(contract_address, utf8(ROLE_BENEFICIARY_RESETTER)),\n            error::permission_denied(EPERMISSION_DENIED),\n        );\n\n        let beneficiaries = &mut vesting_contract.beneficiaries;\n        if (simple_map::contains_key(beneficiaries, &shareholder)) {\n            simple_map::remove(beneficiaries, &shareholder);\n        };\n    }\n\n    public entry fun set_management_role(\n        admin: &signer,\n        contract_address: address,\n        role: String,\n        role_holder: address,\n    ) acquires VestingAccountManagement, VestingContract {\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n\n        if (!exists<VestingAccountManagement>(contract_address)) {\n            let contract_signer = &get_vesting_account_signer_internal(vesting_contract);\n            move_to(contract_signer, VestingAccountManagement {\n                roles: simple_map::create<String, address>(),\n            })\n        };\n        let roles = &mut borrow_global_mut<VestingAccountManagement>(contract_address).roles;\n        if (simple_map::contains_key(roles, &role)) {\n            *simple_map::borrow_mut(roles, &role) = role_holder;\n        } else {\n            simple_map::add(roles, role, role_holder);\n        };\n    }\n\n    public entry fun set_beneficiary_resetter(\n        admin: &signer,\n        contract_address: address,\n        beneficiary_resetter: address,\n    ) acquires VestingAccountManagement, VestingContract {\n        set_management_role(admin, contract_address, utf8(ROLE_BENEFICIARY_RESETTER), beneficiary_resetter);\n    }\n\n    /// Set the beneficiary for the operator.\n    public entry fun set_beneficiary_for_operator(\n        operator: &signer,\n        new_beneficiary: address,\n    ) {\n        staking_contract::set_beneficiary_for_operator(operator, new_beneficiary);\n    }\n\n    public fun get_role_holder(contract_address: address, role: String): address acquires VestingAccountManagement {\n        assert!(exists<VestingAccountManagement>(contract_address), error::not_found(EVESTING_ACCOUNT_HAS_NO_ROLES));\n        let roles = &borrow_global<VestingAccountManagement>(contract_address).roles;\n        assert!(simple_map::contains_key(roles, &role), error::not_found(EROLE_NOT_FOUND));\n        *simple_map::borrow(roles, &role)\n    }\n\n    /// For emergency use in case the admin needs emergency control of vesting contract account.\n    /// This doesn't give the admin total power as the admin would still need to follow the rules set by\n    /// staking_contract and stake modules.\n    public fun get_vesting_account_signer(admin: &signer, contract_address: address): signer acquires VestingContract {\n        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);\n        verify_admin(admin, vesting_contract);\n        get_vesting_account_signer_internal(vesting_contract)\n    }\n\n    fun get_vesting_account_signer_internal(vesting_contract: &VestingContract): signer {\n        account::create_signer_with_capability(&vesting_contract.signer_cap)\n    }\n\n    /// Create a salt for generating the resource accounts that will be holding the VestingContract.\n    /// This address should be deterministic for the same admin and vesting contract creation nonce.\n    fun create_vesting_contract_account(\n        admin: &signer,\n        contract_creation_seed: vector<u8>,\n    ): (signer, SignerCapability) acquires AdminStore {\n        let admin_store = borrow_global_mut<AdminStore>(signer::address_of(admin));\n        let seed = bcs::to_bytes(&signer::address_of(admin));\n        vector::append(&mut seed, bcs::to_bytes(&admin_store.nonce));\n        admin_store.nonce = admin_store.nonce + 1;\n\n        // Include a salt to avoid conflicts with any other modules out there that might also generate\n        // deterministic resource accounts for the same admin address + nonce.\n        vector::append(&mut seed, VESTING_POOL_SALT);\n        vector::append(&mut seed, contract_creation_seed);\n\n        let (account_signer, signer_cap) = account::create_resource_account(admin, seed);\n        // Register the vesting contract account to receive APT as it'll be sent to it when claiming unlocked stake from\n        // the underlying staking contract.\n        coin::register<AptosCoin>(&account_signer);\n\n        (account_signer, signer_cap)\n    }\n\n    fun verify_admin(admin: &signer, vesting_contract: &VestingContract) {\n        assert!(signer::address_of(admin) == vesting_contract.admin, error::unauthenticated(ENOT_ADMIN));\n    }\n\n    fun assert_vesting_contract_exists(contract_address: address) {\n        assert!(exists<VestingContract>(contract_address), error::not_found(EVESTING_CONTRACT_NOT_FOUND));\n    }\n\n    fun assert_active_vesting_contract(contract_address: address) acquires VestingContract {\n        assert_vesting_contract_exists(contract_address);\n        let vesting_contract = borrow_global<VestingContract>(contract_address);\n        assert!(vesting_contract.state == VESTING_POOL_ACTIVE, error::invalid_state(EVESTING_CONTRACT_NOT_ACTIVE));\n    }\n\n    fun unlock_stake(vesting_contract: &VestingContract, amount: u64) {\n        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);\n        staking_contract::unlock_stake(contract_signer, vesting_contract.staking.operator, amount);\n    }\n\n    fun withdraw_stake(vesting_contract: &VestingContract, contract_address: address): Coin<AptosCoin> {\n        // Claim any withdrawable distribution from the staking contract. The withdrawn coins will be sent directly to\n        // the vesting contract's account.\n        staking_contract::distribute(contract_address, vesting_contract.staking.operator);\n        let withdrawn_coins = coin::balance<AptosCoin>(contract_address);\n        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);\n        coin::withdraw<AptosCoin>(contract_signer, withdrawn_coins)\n    }\n\n    fun get_beneficiary(contract: &VestingContract, shareholder: address): address {\n        if (simple_map::contains_key(&contract.beneficiaries, &shareholder)) {\n            *simple_map::borrow(&contract.beneficiaries, &shareholder)\n        } else {\n            shareholder\n        }\n    }\n\n    #[test_only]\n    use aptos_framework::stake::with_rewards;\n\n    #[test_only]\n    use aptos_framework::account::create_account_for_test;\n    use aptos_std::math64::min;\n\n    #[test_only]\n    const MIN_STAKE: u64 = 100000000000000; // 1M APT coins with 8 decimals.\n\n    #[test_only]\n    const GRANT_AMOUNT: u64 = 20000000000000000; // 200M APT coins with 8 decimals.\n\n    #[test_only]\n    const VESTING_SCHEDULE_CLIFF: u64 = 31536000; // 1 year\n\n    #[test_only]\n    const VESTING_PERIOD: u64 = 2592000; // 30 days\n\n    #[test_only]\n    const VALIDATOR_STATUS_PENDING_ACTIVE: u64 = 1;\n    #[test_only]\n    const VALIDATOR_STATUS_ACTIVE: u64 = 2;\n    #[test_only]\n    const VALIDATOR_STATUS_INACTIVE: u64 = 4;\n\n    #[test_only]\n    const MODULE_EVENT: u64 = 26;\n\n    #[test_only]\n    const OPERATOR_BENEFICIARY_CHANGE: u64 = 39;\n\n    #[test_only]\n    public fun setup(aptos_framework: &signer, accounts: &vector<address>) {\n        use aptos_framework::aptos_account::create_account;\n\n        stake::initialize_for_test_custom(\n            aptos_framework,\n            MIN_STAKE,\n            GRANT_AMOUNT * 10,\n            3600,\n            true,\n            10,\n            10000,\n            1000000\n        );\n\n        vector::for_each_ref(accounts, |addr| {\n            let addr: address = *addr;\n            if (!account::exists_at(addr)) {\n                create_account(addr);\n            };\n        });\n\n        std::features::change_feature_flags_for_testing(aptos_framework, vector[MODULE_EVENT, OPERATOR_BENEFICIARY_CHANGE], vector[]);\n    }\n\n    #[test_only]\n    public fun setup_vesting_contract(\n        admin: &signer,\n        shareholders: &vector<address>,\n        shares: &vector<u64>,\n        withdrawal_address: address,\n        commission_percentage: u64,\n    ): address acquires AdminStore {\n        setup_vesting_contract_with_schedule(\n            admin,\n            shareholders,\n            shares,\n            withdrawal_address,\n            commission_percentage,\n            &vector[3, 2, 1],\n            48,\n        )\n    }\n\n    #[test_only]\n    public fun setup_vesting_contract_with_schedule(\n        admin: &signer,\n        shareholders: &vector<address>,\n        shares: &vector<u64>,\n        withdrawal_address: address,\n        commission_percentage: u64,\n        vesting_numerators: &vector<u64>,\n        vesting_denominator: u64,\n    ): address acquires AdminStore {\n        let schedule = vector::empty<FixedPoint32>();\n        vector::for_each_ref(vesting_numerators, |num| {\n            vector::push_back(&mut schedule, fixed_point32::create_from_rational(*num, vesting_denominator));\n        });\n        let vesting_schedule = create_vesting_schedule(\n            schedule,\n            timestamp::now_seconds() + VESTING_SCHEDULE_CLIFF,\n            VESTING_PERIOD,\n        );\n\n        let admin_address = signer::address_of(admin);\n        let buy_ins = simple_map::create<address, Coin<AptosCoin>>();\n        vector::enumerate_ref(shares, |i, share| {\n            let shareholder = *vector::borrow(shareholders, i);\n            simple_map::add(&mut buy_ins, shareholder, stake::mint_coins(*share));\n        });\n\n        create_vesting_contract(\n            admin,\n            shareholders,\n            buy_ins,\n            vesting_schedule,\n            withdrawal_address,\n            admin_address,\n            admin_address,\n            commission_percentage,\n            vector[],\n        )\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder_1 = @0x234, shareholder_2 = @0x345, withdrawal = @111)]\n    public entry fun test_end_to_end(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder_1: &signer,\n        shareholder_2: &signer,\n        withdrawal: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let withdrawal_address = signer::address_of(withdrawal);\n        let shareholder_1_address = signer::address_of(shareholder_1);\n        let shareholder_2_address = signer::address_of(shareholder_2);\n        let shareholders = &vector[shareholder_1_address, shareholder_2_address];\n        let shareholder_1_share = GRANT_AMOUNT / 4;\n        let shareholder_2_share = GRANT_AMOUNT * 3 / 4;\n        let shares = &vector[shareholder_1_share, shareholder_2_share];\n\n        // Create the vesting contract.\n        setup(\n            aptos_framework, &vector[admin_address, withdrawal_address, shareholder_1_address, shareholder_2_address]);\n        let contract_address = setup_vesting_contract(admin, shareholders, shares, withdrawal_address, 0);\n        assert!(vector::length(&borrow_global<AdminStore>(admin_address).vesting_contracts) == 1, 0);\n        let stake_pool_address = stake_pool_address(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, 0);\n\n        // The stake pool is still in pending active stake, so unlock_rewards and vest shouldn't do anything.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, admin, stake_pool_address, false);\n        assert!(stake::get_validator_state(stake_pool_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 1);\n        unlock_rewards(contract_address);\n        vest(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, 0);\n\n        // Wait for the validator to join the validator set. No rewards are earnt yet so unlock_rewards and vest should\n        // still do nothing.\n        stake::end_epoch();\n        assert!(stake::get_validator_state(stake_pool_address) == VALIDATOR_STATUS_ACTIVE, 2);\n        unlock_rewards(contract_address);\n        vest(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, 0);\n\n        // Stake pool earns some rewards. unlock_rewards should unlock the right amount.\n        stake::end_epoch();\n        let rewards = get_accumulated_rewards(contract_address);\n        unlock_rewards(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, rewards);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Stake pool earns more rewards. vest should unlock the rewards but no vested tokens as vesting hasn't started.\n        stake::end_epoch();\n        rewards = with_rewards(rewards); // Pending inactive stake still earns rewards.\n        rewards = rewards + get_accumulated_rewards(contract_address);\n        vest(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, rewards);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Fast forward to stake lockup expiration so rewards are fully unlocked.\n        // In the mean time, rewards still earn rewards.\n        // Calling distribute() should send rewards to the shareholders.\n        stake::fast_forward_to_unlock(stake_pool_address);\n        rewards = with_rewards(rewards);\n        distribute(contract_address);\n        let shareholder_1_bal = coin::balance<AptosCoin>(shareholder_1_address);\n        let shareholder_2_bal = coin::balance<AptosCoin>(shareholder_2_address);\n        // Distribution goes by the shares of the vesting contract.\n        assert!(shareholder_1_bal == rewards / 4, shareholder_1_bal);\n        assert!(shareholder_2_bal == rewards * 3 / 4, shareholder_2_bal);\n\n        // Fast forward time to the vesting start.\n        timestamp::update_global_time_for_test_secs(vesting_start_secs(contract_address));\n        // Calling vest only unlocks rewards but not any vested token as the first vesting period hasn't passed yet.\n        rewards = get_accumulated_rewards(contract_address);\n        vest(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, rewards);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Fast forward to the end of the first period. vest() should now unlock 3/48 of the tokens.\n        timestamp::fast_forward_seconds(VESTING_PERIOD);\n        vest(contract_address);\n        let vested_amount = fraction(GRANT_AMOUNT, 3, 48);\n        let remaining_grant = GRANT_AMOUNT - vested_amount;\n        let pending_distribution = rewards + vested_amount;\n        assert!(remaining_grant(contract_address) == remaining_grant, remaining_grant(contract_address));\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, pending_distribution);\n\n        // Fast forward to the end of the fourth period. We can call vest() 3 times to vest the last 3 periods.\n        timestamp::fast_forward_seconds(VESTING_PERIOD * 3);\n        vest(contract_address);\n        vested_amount = fraction(GRANT_AMOUNT, 2, 48);\n        remaining_grant = remaining_grant - vested_amount;\n        pending_distribution = pending_distribution + vested_amount;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, pending_distribution);\n        vest(contract_address);\n        vested_amount = fraction(GRANT_AMOUNT, 1, 48);\n        remaining_grant = remaining_grant - vested_amount;\n        pending_distribution = pending_distribution + vested_amount;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, pending_distribution);\n        // The last vesting fraction (1/48) is repeated beyond the first 3 periods.\n        vest(contract_address);\n        remaining_grant = remaining_grant - vested_amount;\n        pending_distribution = pending_distribution + vested_amount;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, pending_distribution);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n\n        stake::end_epoch();\n        let total_active = with_rewards(remaining_grant);\n        pending_distribution = with_rewards(pending_distribution);\n        distribute(contract_address);\n        stake::assert_stake_pool(stake_pool_address, total_active, 0, 0, 0);\n        assert!(coin::balance<AptosCoin>(shareholder_1_address) == shareholder_1_bal + pending_distribution / 4, 0);\n        assert!(coin::balance<AptosCoin>(shareholder_2_address) == shareholder_2_bal + pending_distribution * 3 / 4, 1);\n        // Withdrawal address receives the left-over dust of 1 coin due to rounding error.\n        assert!(coin::balance<AptosCoin>(withdrawal_address) == 1, 0);\n\n        // Admin terminates the vesting contract.\n        terminate_vesting_contract(admin, contract_address);\n        stake::assert_stake_pool(stake_pool_address, 0, 0, 0, total_active);\n        assert!(remaining_grant(contract_address) == 0, 0);\n        stake::fast_forward_to_unlock(stake_pool_address);\n        let withdrawn_amount = with_rewards(total_active);\n        stake::assert_stake_pool(stake_pool_address, 0, withdrawn_amount, 0, 0);\n        let previous_bal = coin::balance<AptosCoin>(withdrawal_address);\n        admin_withdraw(admin, contract_address);\n        assert!(coin::balance<AptosCoin>(withdrawal_address) == previous_bal + withdrawn_amount, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x1000C, location = Self)]\n    public entry fun test_create_vesting_contract_with_zero_grant_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        setup_vesting_contract(admin, &vector[@1], &vector[0], admin_address, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x10004, location = Self)]\n    public entry fun test_create_vesting_contract_with_no_shareholders_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        setup_vesting_contract(admin, &vector[], &vector[], admin_address, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x10005, location = Self)]\n    public entry fun test_create_vesting_contract_with_mistmaching_shareholders_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        setup_vesting_contract(admin, &vector[@1, @2], &vector[1], admin_address, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x60001, location = aptos_framework::aptos_account)]\n    public entry fun test_create_vesting_contract_with_invalid_withdrawal_address_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        setup_vesting_contract(admin, &vector[@1, @2], &vector[1], @5, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x60001, location = aptos_framework::aptos_account)]\n    public entry fun test_create_vesting_contract_with_missing_withdrawal_account_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        setup_vesting_contract(admin, &vector[@1, @2], &vector[1], @11, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x60002, location = aptos_framework::aptos_account)]\n    public entry fun test_create_vesting_contract_with_unregistered_withdrawal_account_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        create_account_for_test(@11);\n        setup_vesting_contract(admin, &vector[@1, @2], &vector[1], @11, 0);\n    }\n\n    #[test(aptos_framework = @0x1)]\n    #[expected_failure(abort_code = 0x10002, location = Self)]\n    public entry fun test_create_empty_vesting_schedule_should_fail(aptos_framework: &signer) {\n        setup(aptos_framework, &vector[]);\n        create_vesting_schedule(vector[], 1, 1);\n    }\n\n    #[test(aptos_framework = @0x1)]\n    #[expected_failure(abort_code = 0x10003, location = Self)]\n    public entry fun test_create_vesting_schedule_with_zero_period_duration_should_fail(aptos_framework: &signer) {\n        setup(aptos_framework, &vector[]);\n        create_vesting_schedule(vector[fixed_point32::create_from_rational(1, 1)], 1, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x10006, location = Self)]\n    public entry fun test_create_vesting_schedule_with_invalid_vesting_start_should_fail(aptos_framework: &signer) {\n        setup(aptos_framework, &vector[]);\n        timestamp::update_global_time_for_test_secs(1000);\n        create_vesting_schedule(\n            vector[fixed_point32::create_from_rational(1, 1)],\n            900,\n            1);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    public entry fun test_vest_twice_should_not_double_count(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Operator needs to join the validator set for the stake pool to earn rewards.\n        let stake_pool_address = stake_pool_address(contract_address);\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, admin, stake_pool_address, true);\n\n        // Fast forward to the end of the first period. vest() should now unlock 3/48 of the tokens.\n        timestamp::update_global_time_for_test_secs(vesting_start_secs(contract_address) + VESTING_PERIOD);\n        vest(contract_address);\n        let vested_amount = fraction(GRANT_AMOUNT, 3, 48);\n        let remaining_grant = GRANT_AMOUNT - vested_amount;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, vested_amount);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n\n        // Calling vest() a second time shouldn't change anything.\n        vest(contract_address);\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, vested_amount);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    public entry fun test_unlock_rewards_twice_should_not_double_count(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Operator needs to join the validator set for the stake pool to earn rewards.\n        let stake_pool_address = stake_pool_address(contract_address);\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, admin, stake_pool_address, true);\n\n        // Stake pool earns some rewards. unlock_rewards should unlock the right amount.\n        stake::end_epoch();\n        let rewards = get_accumulated_rewards(contract_address);\n        unlock_rewards(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, rewards);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Calling unlock_rewards a second time shouldn't change anything as no new rewards has accumulated.\n        unlock_rewards(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, rewards);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234, operator = @0x345)]\n    public entry fun test_unlock_rewards_should_pay_commission_first(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n        operator: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let operator_address = signer::address_of(operator);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address, operator_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n        assert!(operator_commission_percentage(contract_address) == 0, 0);\n\n        // 10% commission will be paid to the operator.\n        update_operator(admin, contract_address, operator_address, 10);\n        assert!(operator_commission_percentage(contract_address) == 10, 0);\n\n        // Operator needs to join the validator set for the stake pool to earn rewards.\n        let stake_pool_address = stake_pool_address(contract_address);\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, stake_pool_address, true);\n\n        // Stake pool earns some rewards. unlock_rewards should unlock the right amount.\n        stake::end_epoch();\n        let accumulated_rewards = get_accumulated_rewards(contract_address);\n        let commission = accumulated_rewards / 10; // 10%.\n        let staker_rewards = accumulated_rewards - commission;\n        unlock_rewards(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, accumulated_rewards);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Distribution should pay commission to operator first and remaining amount to shareholders.\n        stake::fast_forward_to_unlock(stake_pool_address);\n        stake::assert_stake_pool(\n            stake_pool_address,\n            with_rewards(GRANT_AMOUNT),\n            with_rewards(accumulated_rewards),\n            0,\n            0\n        );\n        // Operator also earns more commission from the rewards earnt on the withdrawn rewards.\n        let commission_on_staker_rewards = (with_rewards(staker_rewards) - staker_rewards) / 10;\n        staker_rewards = with_rewards(staker_rewards) - commission_on_staker_rewards;\n        commission = with_rewards(commission) + commission_on_staker_rewards;\n        distribute(contract_address);\n        // Rounding error leads to a dust amount of 1 transferred to the staker.\n        assert!(coin::balance<AptosCoin>(shareholder_address) == staker_rewards + 1, 0);\n        assert!(coin::balance<AptosCoin>(operator_address) == commission - 1, 1);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234, operator = @0x345)]\n    public entry fun test_request_commission_should_not_lock_rewards_for_shareholders(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n        operator: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let operator_address = signer::address_of(operator);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address, operator_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n        assert!(operator_commission_percentage(contract_address) == 0, 0);\n\n        // 10% commission will be paid to the operator.\n        update_operator(admin, contract_address, operator_address, 10);\n        assert!(operator_commission_percentage(contract_address) == 10, 0);\n\n        // Operator needs to join the validator set for the stake pool to earn rewards.\n        let stake_pool_address = stake_pool_address(contract_address);\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, stake_pool_address, true);\n\n        // Stake pool earns some rewards.\n        stake::end_epoch();\n\n        // Operator requests commission directly with staking_contract first.\n        let accumulated_rewards = get_accumulated_rewards(contract_address);\n        let commission = accumulated_rewards / 10; // 10%.\n        let staker_rewards = accumulated_rewards - commission;\n        staking_contract::request_commission(operator, contract_address, operator_address);\n\n        // Unlock vesting rewards. This should still pay out the accumulated rewards to shareholders.\n        unlock_rewards(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, accumulated_rewards);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Distribution should pay commission to operator first and remaining amount to shareholders.\n        stake::fast_forward_to_unlock(stake_pool_address);\n        stake::assert_stake_pool(\n            stake_pool_address,\n            with_rewards(GRANT_AMOUNT),\n            with_rewards(accumulated_rewards),\n            0,\n            0\n        );\n        // Operator also earns more commission from the rewards earnt on the withdrawn rewards.\n        let commission_on_staker_rewards = (with_rewards(staker_rewards) - staker_rewards) / 10;\n        staker_rewards = with_rewards(staker_rewards) - commission_on_staker_rewards;\n        commission = with_rewards(commission) + commission_on_staker_rewards;\n        distribute(contract_address);\n        // Rounding error leads to a dust amount of 1 transferred to the staker.\n        assert!(coin::balance<AptosCoin>(shareholder_address) == staker_rewards + 1, 0);\n        assert!(coin::balance<AptosCoin>(operator_address) == commission - 1, 1);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, operator = @0x345)]\n    public entry fun test_update_operator_with_same_commission(\n        aptos_framework: &signer,\n        admin: &signer,\n        operator: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let operator_address = signer::address_of(operator);\n        setup(aptos_framework, &vector[admin_address, @11, operator_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@11], &vector[GRANT_AMOUNT], admin_address, 10);\n\n        update_operator_with_same_commission(admin, contract_address, operator_address);\n        assert!(operator_commission_percentage(contract_address) == 10, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234, operator = @0x345)]\n    public entry fun test_commission_percentage_change(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n        operator: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let operator_address = signer::address_of(operator);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address, operator_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n        assert!(operator_commission_percentage(contract_address) == 0, 0);\n        let stake_pool_address = stake_pool_address(contract_address);\n\n        // 10% commission will be paid to the operator.\n        update_operator(admin, contract_address, operator_address, 10);\n\n        // Operator needs to join the validator set for the stake pool to earn rewards.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator, stake_pool_address, true);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, 0);\n        assert!(get_accumulated_rewards(contract_address) == 0, 0);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Stake pool earns some rewards.\n        stake::end_epoch();\n        let (_, accumulated_rewards, _) = staking_contract::staking_contract_amounts(\n            contract_address,\n            operator_address\n        );\n\n        // Update commission percentage to 20%. This also immediately requests commission.\n        update_commission_percentage(admin, contract_address, 20);\n        // Assert that the operator is still the same, and the commission percentage is updated to 20%.\n        assert!(operator(contract_address) == operator_address, 0);\n        assert!(operator_commission_percentage(contract_address) == 20, 0);\n\n        // Commission is calculated using the previous commission percentage which is 10%.\n        let expected_commission = accumulated_rewards / 10;\n\n        // Stake pool earns some more rewards.\n        stake::end_epoch();\n        let (_, accumulated_rewards, _) = staking_contract::staking_contract_amounts(\n            contract_address,\n            operator_address\n        );\n\n        // Request commission again.\n        staking_contract::request_commission(operator, contract_address, operator_address);\n        // The commission is calculated using the current commission percentage which is 20%.\n        expected_commission = with_rewards(expected_commission) + (accumulated_rewards / 5);\n\n        // Unlocks the commission.\n        stake::fast_forward_to_unlock(stake_pool_address);\n        expected_commission = with_rewards(expected_commission);\n\n        // Distribute the commission to the operator.\n        distribute(contract_address);\n\n        // Assert that the operator receives the expected commission.\n        assert!(coin::balance<AptosCoin>(operator_address) == expected_commission, 1);\n    }\n\n    #[test(\n        aptos_framework = @0x1,\n        admin = @0x123,\n        shareholder = @0x234,\n        operator1 = @0x345,\n        beneficiary = @0x456,\n        operator2 = @0x567\n    )]\n    public entry fun test_set_beneficiary_for_operator(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n        operator1: &signer,\n        beneficiary: &signer,\n        operator2: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let operator_address1 = signer::address_of(operator1);\n        let operator_address2 = signer::address_of(operator2);\n        let shareholder_address = signer::address_of(shareholder);\n        let beneficiary_address = signer::address_of(beneficiary);\n        setup(aptos_framework, &vector[admin_address, shareholder_address, operator_address1, beneficiary_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n        assert!(operator_commission_percentage(contract_address) == 0, 0);\n        let stake_pool_address = stake_pool_address(contract_address);\n        // 10% commission will be paid to the operator.\n        update_operator(admin, contract_address, operator_address1, 10);\n        assert!(staking_contract::beneficiary_for_operator(operator_address1) == operator_address1, 0);\n        set_beneficiary_for_operator(operator1, beneficiary_address);\n        assert!(staking_contract::beneficiary_for_operator(operator_address1) == beneficiary_address, 0);\n\n        // Operator needs to join the validator set for the stake pool to earn rewards.\n        let (_sk, pk, pop) = stake::generate_identity();\n        stake::join_validator_set_for_test(&pk, &pop, operator1, stake_pool_address, true);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, 0);\n        assert!(get_accumulated_rewards(contract_address) == 0, 0);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Stake pool earns some rewards.\n        stake::end_epoch();\n        let (_, accumulated_rewards, _) = staking_contract::staking_contract_amounts(contract_address,\n            operator_address1\n        );\n        // Commission is calculated using the previous commission percentage which is 10%.\n        let expected_commission = accumulated_rewards / 10;\n\n        // Request commission.\n        staking_contract::request_commission(operator1, contract_address, operator_address1);\n        // Unlocks the commission.\n        stake::fast_forward_to_unlock(stake_pool_address);\n        expected_commission = with_rewards(expected_commission);\n\n        // Distribute the commission to the operator.\n        distribute(contract_address);\n\n        // Assert that the beneficiary receives the expected commission.\n        assert!(coin::balance<AptosCoin>(operator_address1) == 0, 1);\n        assert!(coin::balance<AptosCoin>(beneficiary_address) == expected_commission, 1);\n        let old_beneficiay_balance = coin::balance<AptosCoin>(beneficiary_address);\n\n        // switch operator to operator2. The rewards should go to operator2 not to the beneficiay of operator1.\n        update_operator(admin, contract_address, operator_address2, 10);\n\n        stake::end_epoch();\n        let (_, accumulated_rewards, _) = staking_contract::staking_contract_amounts(contract_address,\n            operator_address2\n        );\n\n        let expected_commission = accumulated_rewards / 10;\n\n        // Request commission.\n        staking_contract::request_commission(operator2, contract_address, operator_address2);\n        // Unlocks the commission.\n        stake::fast_forward_to_unlock(stake_pool_address);\n        expected_commission = with_rewards(expected_commission);\n\n        // Distribute the commission to the operator.\n        distribute(contract_address);\n\n        // Assert that the rewards go to operator2, and the balance of the operator1's beneficiay remains the same.\n        assert!(coin::balance<AptosCoin>(operator_address2) >= expected_commission, 1);\n        assert!(coin::balance<AptosCoin>(beneficiary_address) == old_beneficiay_balance, 1);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    #[expected_failure(abort_code = 0x30008, location = Self)]\n    public entry fun test_cannot_unlock_rewards_after_contract_is_terminated(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Immediately terminate. Calling unlock_rewards should now fail.\n        terminate_vesting_contract(admin, contract_address);\n        unlock_rewards(contract_address);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    public entry fun test_vesting_contract_with_zero_vestings(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract_with_schedule(\n            admin,\n            &vector[shareholder_address],\n            &vector[GRANT_AMOUNT],\n            admin_address,\n            0,\n            &vector[0, 3, 0, 2],\n            48,\n        );\n        let stake_pool_address = stake_pool_address(contract_address);\n\n        // First vest() should unlock 0 according to schedule.\n        timestamp::update_global_time_for_test_secs(vesting_start_secs(contract_address) + VESTING_PERIOD);\n        vest(contract_address);\n        stake::assert_stake_pool(stake_pool_address, GRANT_AMOUNT, 0, 0, 0);\n        assert!(remaining_grant(contract_address) == GRANT_AMOUNT, 0);\n\n        // Next period should vest 3/48.\n        timestamp::fast_forward_seconds(VESTING_PERIOD);\n        vest(contract_address);\n        let vested_amount = fraction(GRANT_AMOUNT, 3, 48);\n        let remaining_grant = GRANT_AMOUNT - vested_amount;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, vested_amount);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n\n        timestamp::fast_forward_seconds(VESTING_PERIOD);\n        // Distribute the previous vested amount.\n        distribute(contract_address);\n        // Next period should vest 0 again.\n        vest(contract_address);\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, 0);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n\n        // Next period should vest 2/48.\n        timestamp::fast_forward_seconds(VESTING_PERIOD);\n        vest(contract_address);\n        let vested_amount = fraction(GRANT_AMOUNT, 2, 48);\n        remaining_grant = remaining_grant - vested_amount;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, vested_amount);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    public entry fun test_last_vest_should_distribute_remaining_amount(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract_with_schedule(\n            admin,\n            &vector[shareholder_address],\n            &vector[GRANT_AMOUNT],\n            admin_address,\n            0,\n            // First vest = 3/4 but last vest should only be for the remaining 1/4.\n            &vector[3],\n            4,\n        );\n        let stake_pool_address = stake_pool_address(contract_address);\n\n        // First vest is 3/48\n        timestamp::update_global_time_for_test_secs(vesting_start_secs(contract_address) + VESTING_PERIOD);\n        vest(contract_address);\n        let vested_amount = fraction(GRANT_AMOUNT, 3, 4);\n        let remaining_grant = GRANT_AMOUNT - vested_amount;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, vested_amount);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n\n        timestamp::fast_forward_seconds(VESTING_PERIOD);\n        // Distribute the previous vested amount.\n        distribute(contract_address);\n        // Last vest should be the remaining amount (1/4).\n        vest(contract_address);\n        let vested_amount = remaining_grant;\n        remaining_grant = 0;\n        stake::assert_stake_pool(stake_pool_address, remaining_grant, 0, 0, vested_amount);\n        assert!(remaining_grant(contract_address) == remaining_grant, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    #[expected_failure(abort_code = 0x30008, location = Self)]\n    public entry fun test_cannot_vest_after_contract_is_terminated(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Immediately terminate. Calling vest should now fail.\n        terminate_vesting_contract(admin, contract_address);\n        vest(contract_address);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    #[expected_failure(abort_code = 0x30008, location = Self)]\n    public entry fun test_cannot_terminate_twice(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Call terminate_vesting_contract twice should fail.\n        terminate_vesting_contract(admin, contract_address);\n        terminate_vesting_contract(admin, contract_address);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234)]\n    #[expected_failure(abort_code = 0x30009, location = Self)]\n    public entry fun test_cannot_call_admin_withdraw_if_contract_is_not_terminated(\n        aptos_framework: &signer,\n        admin: &signer,\n        shareholder: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        let shareholder_address = signer::address_of(shareholder);\n        setup(aptos_framework, &vector[admin_address, shareholder_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[shareholder_address], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Calling admin_withdraw should fail as contract has not been terminated.\n        admin_withdraw(admin, contract_address);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x60001, location = aptos_framework::aptos_account)]\n    public entry fun test_set_beneficiary_with_missing_account_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@1, @2], &vector[GRANT_AMOUNT, GRANT_AMOUNT], admin_address, 0);\n        set_beneficiary(admin, contract_address, @1, @11);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    #[expected_failure(abort_code = 0x60002, location = aptos_framework::aptos_account)]\n    public entry fun test_set_beneficiary_with_unregistered_account_should_fail(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@1, @2], &vector[GRANT_AMOUNT, GRANT_AMOUNT], admin_address, 0);\n        create_account_for_test(@11);\n        set_beneficiary(admin, contract_address, @1, @11);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    public entry fun test_set_beneficiary_should_send_distribution(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address, @11]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@1], &vector[GRANT_AMOUNT], admin_address, 0);\n        set_beneficiary(admin, contract_address, @1, @11);\n        assert!(beneficiary(contract_address, @1) == @11, 0);\n\n        // Fast forward to the end of the first period. vest() should now unlock 3/48 of the tokens.\n        timestamp::update_global_time_for_test_secs(vesting_start_secs(contract_address) + VESTING_PERIOD);\n        vest(contract_address);\n\n        // Distribution should go to the beneficiary account.\n        stake::end_epoch();\n        // No rewards as validator never joined the validator set.\n        let vested_amount = fraction(GRANT_AMOUNT, 3, 48);\n        distribute(contract_address);\n        let balance = coin::balance<AptosCoin>(@11);\n        assert!(balance == vested_amount, balance);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    public entry fun test_set_management_role(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore, VestingAccountManagement, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@11], &vector[GRANT_AMOUNT], admin_address, 0);\n        let role = utf8(b\"RANDOM\");\n        set_management_role(admin, contract_address, role, @12);\n        assert!(get_role_holder(contract_address, role) == @12, 0);\n        set_management_role(admin, contract_address, role, @13);\n        assert!(get_role_holder(contract_address, role) == @13, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123)]\n    public entry fun test_reset_beneficiary(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore, VestingAccountManagement, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address, @11, @12]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@11], &vector[GRANT_AMOUNT], admin_address, 0);\n        set_beneficiary(admin, contract_address, @11, @12);\n        assert!(beneficiary(contract_address, @11) == @12, 0);\n\n        // Fast forward to the end of the first period. vest() should now unlock 3/48 of the tokens.\n        timestamp::update_global_time_for_test_secs(vesting_start_secs(contract_address) + VESTING_PERIOD);\n        vest(contract_address);\n\n        // Reset the beneficiary.\n        reset_beneficiary(admin, contract_address, @11);\n\n        // Distribution should go to the original account.\n        stake::end_epoch();\n        // No rewards as validator never joined the validator set.\n        let vested_amount = fraction(GRANT_AMOUNT, 3, 48);\n        distribute(contract_address);\n        assert!(coin::balance<AptosCoin>(@11) == vested_amount, 0);\n        assert!(coin::balance<AptosCoin>(@12) == 0, 1);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, resetter = @0x234)]\n    public entry fun test_reset_beneficiary_with_resetter_role(\n        aptos_framework: &signer,\n        admin: &signer,\n        resetter: &signer,\n    ) acquires AdminStore, VestingAccountManagement, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address, @11, @12]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@11], &vector[GRANT_AMOUNT], admin_address, 0);\n        set_beneficiary(admin, contract_address, @11, @12);\n        assert!(beneficiary(contract_address, @11) == @12, 0);\n\n        // Reset the beneficiary with the resetter role.\n        let resetter_address = signer::address_of(resetter);\n        set_beneficiary_resetter(admin, contract_address, resetter_address);\n        assert!(simple_map::length(&borrow_global<VestingAccountManagement>(contract_address).roles) == 1, 0);\n        reset_beneficiary(resetter, contract_address, @11);\n        assert!(beneficiary(contract_address, @11) == @11, 0);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, resetter = @0x234, random = @0x345)]\n    #[expected_failure(abort_code = 0x5000F, location = Self)]\n    public entry fun test_reset_beneficiary_with_unauthorized(\n        aptos_framework: &signer,\n        admin: &signer,\n        resetter: &signer,\n        random: &signer,\n    ) acquires AdminStore, VestingAccountManagement, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address, @11]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@11], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Reset the beneficiary with a random account. This should failed.\n        set_beneficiary_resetter(admin, contract_address, signer::address_of(resetter));\n        reset_beneficiary(random, contract_address, @11);\n    }\n\n    #[test(aptos_framework = @0x1, admin = @0x123, resetter = @0x234, random = @0x345)]\n    public entry fun test_shareholder(\n        aptos_framework: &signer,\n        admin: &signer,\n    ) acquires AdminStore, VestingContract {\n        let admin_address = signer::address_of(admin);\n        setup(aptos_framework, &vector[admin_address, @11, @12]);\n        let contract_address = setup_vesting_contract(\n            admin, &vector[@11], &vector[GRANT_AMOUNT], admin_address, 0);\n\n        // Confirm that the lookup returns the same address when a shareholder is\n        // passed for which there is no beneficiary.\n        assert!(shareholder(contract_address, @11) == @11, 0);\n\n        // Set a beneficiary for @11.\n        set_beneficiary(admin, contract_address, @11, @12);\n        assert!(beneficiary(contract_address, @11) == @12, 0);\n\n        // Confirm that lookup from beneficiary to shareholder works when a beneficiary\n        // is set.\n        assert!(shareholder(contract_address, @12) == @11, 0);\n\n        // Confirm that it returns 0x0 when the address is not in the map.\n        assert!(shareholder(contract_address, @33) == @0x0, 0);\n    }\n\n    #[test_only]\n    fun get_accumulated_rewards(contract_address: address): u64 acquires VestingContract {\n        let vesting_contract = borrow_global<VestingContract>(contract_address);\n        let (active_stake, _, _, _) = stake::get_stake(vesting_contract.staking.pool_address);\n        active_stake - vesting_contract.remaining_grant\n    }\n\n    #[test_only]\n    fun fraction(total: u64, numerator: u64, denominator: u64): u64 {\n        fixed_point32::multiply_u64(total, fixed_point32::create_from_rational(numerator, denominator))\n    }\n}\n","name":"vesting.move"},{"content":"///\n/// This is the general Voting module that can be used as part of a DAO Governance. Voting is designed to be used by\n/// standalone governance modules, who has full control over the voting flow and is responsible for voting power\n/// calculation and including proper capabilities when creating the proposal so resolution can go through.\n/// On-chain governance of the Aptos network also uses Voting.\n///\n/// The voting flow:\n/// 1. The Voting module can be deployed at a known address (e.g. 0x1 for Aptos on-chain governance)\n/// 2. The governance module, e.g. AptosGovernance, can be deployed later and define a GovernanceProposal resource type\n/// that can also contain other information such as Capability resource for authorization.\n/// 3. The governance module's owner can then register the ProposalType with Voting. This also hosts the proposal list\n/// (forum) on the calling account.\n/// 4. A proposer, through the governance module, can call Voting::create_proposal to create a proposal. create_proposal\n/// cannot be called directly not through the governance module. A script hash of the resolution script that can later\n/// be called to execute the proposal is required.\n/// 5. A voter, through the governance module, can call Voting::vote on a proposal. vote requires passing a &ProposalType\n/// and thus only the governance module that registers ProposalType can call vote.\n/// 6. Once the proposal's expiration time has passed and more than the defined threshold has voted yes on the proposal,\n/// anyone can call resolve which returns the content of the proposal (of type ProposalType) that can be used to execute.\n/// 7. Only the resolution script with the same script hash specified in the proposal can call Voting::resolve as part of\n/// the resolution process.\nmodule aptos_framework::voting {\n    use std::bcs::to_bytes;\n    use std::error;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::string::{String, utf8};\n    use std::vector;\n\n    use aptos_std::from_bcs::to_u64;\n    use aptos_std::simple_map::{Self, SimpleMap};\n    use aptos_std::table::{Self, Table};\n    use aptos_std::type_info::{Self, TypeInfo};\n\n    use aptos_framework::account;\n    use aptos_framework::event::{Self, EventHandle};\n    use aptos_framework::timestamp;\n    use aptos_framework::transaction_context;\n    use aptos_std::from_bcs;\n\n    /// Current script's execution hash does not match the specified proposal's\n    const EPROPOSAL_EXECUTION_HASH_NOT_MATCHING: u64 = 1;\n    /// Proposal cannot be resolved. Either voting duration has not passed, not enough votes, or fewer yes than no votes\n    const EPROPOSAL_CANNOT_BE_RESOLVED: u64 = 2;\n    /// Proposal cannot be resolved more than once\n    const EPROPOSAL_ALREADY_RESOLVED: u64 = 3;\n    /// Proposal cannot contain an empty execution script hash\n    const EPROPOSAL_EMPTY_EXECUTION_HASH: u64 = 4;\n    /// Proposal's voting period has already ended.\n    const EPROPOSAL_VOTING_ALREADY_ENDED: u64 = 5;\n    /// Voting forum has already been registered.\n    const EVOTING_FORUM_ALREADY_REGISTERED: u64 = 6;\n    /// Minimum vote threshold cannot be higher than early resolution threshold.\n    const EINVALID_MIN_VOTE_THRESHOLD: u64 = 7;\n    /// Resolution of a proposal cannot happen atomically in the same transaction as the last vote.\n    const ERESOLUTION_CANNOT_BE_ATOMIC: u64 = 8;\n    /// Cannot vote if the specified multi-step proposal is in execution.\n    const EMULTI_STEP_PROPOSAL_IN_EXECUTION: u64 = 9;\n    /// If a proposal is multi-step, we need to use `resolve_proposal_v2()` to resolve it.\n    /// If we use `resolve()` to resolve a multi-step proposal, it will fail with EMULTI_STEP_PROPOSAL_CANNOT_USE_SINGLE_STEP_RESOLVE_FUNCTION.\n    const EMULTI_STEP_PROPOSAL_CANNOT_USE_SINGLE_STEP_RESOLVE_FUNCTION: u64 = 10;\n    /// If we call `resolve_proposal_v2()` to resolve a single-step proposal, the `next_execution_hash` parameter should be an empty vector.\n    const ESINGLE_STEP_PROPOSAL_CANNOT_HAVE_NEXT_EXECUTION_HASH: u64 = 11;\n    /// Cannot call `is_multi_step_proposal_in_execution()` on single-step proposals.\n    const EPROPOSAL_IS_SINGLE_STEP: u64 = 12;\n\n    /// ProposalStateEnum representing proposal state.\n    const PROPOSAL_STATE_PENDING: u64 = 0;\n    const PROPOSAL_STATE_SUCCEEDED: u64 = 1;\n    /// Proposal has failed because either the min vote threshold is not met or majority voted no.\n    const PROPOSAL_STATE_FAILED: u64 = 3;\n\n    /// Key used to track the resolvable time in the proposal's metadata.\n    const RESOLVABLE_TIME_METADATA_KEY: vector<u8> = b\"RESOLVABLE_TIME_METADATA_KEY\";\n    /// Key used to track if the proposal is multi-step\n    const IS_MULTI_STEP_PROPOSAL_KEY: vector<u8> = b\"IS_MULTI_STEP_PROPOSAL_KEY\";\n    /// Key used to track if the multi-step proposal is in execution / resolving in progress.\n    const IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY: vector<u8> = b\"IS_MULTI_STEP_PROPOSAL_IN_EXECUTION\";\n\n    /// Extra metadata (e.g. description, code url) can be part of the ProposalType struct.\n    struct Proposal<ProposalType: store> has store {\n        /// Required. The address of the proposer.\n        proposer: address,\n\n        /// Required. Should contain enough information to execute later, for example the required capability.\n        /// This is stored as an option so we can return it to governance when the proposal is resolved.\n        execution_content: Option<ProposalType>,\n\n        /// Optional. Value is serialized value of an attribute.\n        /// Currently, we have three attributes that are used by the voting flow.\n        /// 1. RESOLVABLE_TIME_METADATA_KEY: this is uesed to record the resolvable time to ensure that resolution has to be done non-atomically.\n        /// 2. IS_MULTI_STEP_PROPOSAL_KEY: this is used to track if a proposal is single-step or multi-step.\n        /// 3. IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY: this attribute only applies to multi-step proposals. A single-step proposal will not have\n        /// this field in its metadata map. The value is used to indicate if a multi-step proposal is in execution. If yes, we will disable further\n        /// voting for this multi-step proposal.\n        metadata: SimpleMap<String, vector<u8>>,\n\n        /// Timestamp when the proposal was created.\n        creation_time_secs: u64,\n\n        /// Required. The hash for the execution script module. Only the same exact script module can resolve this\n        /// proposal.\n        execution_hash: vector<u8>,\n\n        /// A proposal is only resolved if expiration has passed and the number of votes is above threshold.\n        min_vote_threshold: u128,\n        expiration_secs: u64,\n\n        /// Optional. Early resolution threshold. If specified, the proposal can be resolved early if the total\n        /// number of yes or no votes passes this threshold.\n        /// For example, this can be set to 50% of the total supply of the voting token, so if > 50% vote yes or no,\n        /// the proposal can be resolved before expiration.\n        early_resolution_vote_threshold: Option<u128>,\n\n        /// Number of votes for each outcome.\n        /// u128 since the voting power is already u64 and can add up to more than u64 can hold.\n        yes_votes: u128,\n        no_votes: u128,\n\n        /// Whether the proposal has been resolved.\n        is_resolved: bool,\n        /// Resolution timestamp if the proposal has been resolved. 0 otherwise.\n        resolution_time_secs: u64,\n    }\n\n    struct VotingForum<ProposalType: store> has key {\n        /// Use Table for execution optimization instead of Vector for gas cost since Vector is read entirely into memory\n        /// during execution while only relevant Table entries are.\n        proposals: Table<u64, Proposal<ProposalType>>,\n        events: VotingEvents,\n        /// Unique identifier for a proposal. This allows for 2 * 10**19 proposals.\n        next_proposal_id: u64,\n    }\n\n    struct VotingEvents has store {\n        create_proposal_events: EventHandle<CreateProposalEvent>,\n        register_forum_events: EventHandle<RegisterForumEvent>,\n        resolve_proposal_events: EventHandle<ResolveProposal>,\n        vote_events: EventHandle<VoteEvent>,\n    }\n\n    #[event]\n    struct CreateProposal has drop, store {\n        proposal_id: u64,\n        early_resolution_vote_threshold: Option<u128>,\n        execution_hash: vector<u8>,\n        expiration_secs: u64,\n        metadata: SimpleMap<String, vector<u8>>,\n        min_vote_threshold: u128,\n    }\n\n    #[event]\n    struct RegisterForum has drop, store {\n        hosting_account: address,\n        proposal_type_info: TypeInfo,\n    }\n\n    #[event]\n    struct Vote has drop, store {\n        proposal_id: u64,\n        num_votes: u64,\n    }\n\n    #[event]\n    struct ResolveProposal has drop, store {\n        proposal_id: u64,\n        yes_votes: u128,\n        no_votes: u128,\n        resolved_early: bool\n    }\n\n    struct CreateProposalEvent has drop, store {\n        proposal_id: u64,\n        early_resolution_vote_threshold: Option<u128>,\n        execution_hash: vector<u8>,\n        expiration_secs: u64,\n        metadata: SimpleMap<String, vector<u8>>,\n        min_vote_threshold: u128,\n    }\n\n    struct RegisterForumEvent has drop, store {\n        hosting_account: address,\n        proposal_type_info: TypeInfo,\n    }\n\n    struct VoteEvent has drop, store {\n        proposal_id: u64,\n        num_votes: u64,\n    }\n\n    public fun register<ProposalType: store>(account: &signer) {\n        let addr = signer::address_of(account);\n        assert!(!exists<VotingForum<ProposalType>>(addr), error::already_exists(EVOTING_FORUM_ALREADY_REGISTERED));\n\n        let voting_forum = VotingForum<ProposalType> {\n            next_proposal_id: 0,\n            proposals: table::new<u64, Proposal<ProposalType>>(),\n            events: VotingEvents {\n                create_proposal_events: account::new_event_handle<CreateProposalEvent>(account),\n                register_forum_events: account::new_event_handle<RegisterForumEvent>(account),\n                resolve_proposal_events: account::new_event_handle<ResolveProposal>(account),\n                vote_events: account::new_event_handle<VoteEvent>(account),\n            }\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                RegisterForum {\n                    hosting_account: addr,\n                    proposal_type_info: type_info::type_of<ProposalType>(),\n                },\n            );\n        };\n        event::emit_event<RegisterForumEvent>(\n            &mut voting_forum.events.register_forum_events,\n            RegisterForumEvent {\n                hosting_account: addr,\n                proposal_type_info: type_info::type_of<ProposalType>(),\n            },\n        );\n\n        move_to(account, voting_forum);\n    }\n\n    /// Create a single-step proposal with the given parameters\n    ///\n    /// @param voting_forum_address The forum's address where the proposal will be stored.\n    /// @param execution_content The execution content that will be given back at resolution time. This can contain\n    /// data such as a capability resource used to scope the execution.\n    /// @param execution_hash The hash for the execution script module. Only the same exact script module can resolve\n    /// this proposal.\n    /// @param min_vote_threshold The minimum number of votes needed to consider this proposal successful.\n    /// @param expiration_secs The time in seconds at which the proposal expires and can potentially be resolved.\n    /// @param early_resolution_vote_threshold The vote threshold for early resolution of this proposal.\n    /// @param metadata A simple_map that stores information about this proposal.\n    /// @return The proposal id.\n    public fun create_proposal<ProposalType: store>(\n        proposer: address,\n        voting_forum_address: address,\n        execution_content: ProposalType,\n        execution_hash: vector<u8>,\n        min_vote_threshold: u128,\n        expiration_secs: u64,\n        early_resolution_vote_threshold: Option<u128>,\n        metadata: SimpleMap<String, vector<u8>>,\n    ): u64 acquires VotingForum {\n        create_proposal_v2(\n            proposer,\n            voting_forum_address,\n            execution_content,\n            execution_hash,\n            min_vote_threshold,\n            expiration_secs,\n            early_resolution_vote_threshold,\n            metadata,\n            false\n        )\n    }\n\n    /// Create a single-step or a multi-step proposal with the given parameters\n    ///\n    /// @param voting_forum_address The forum's address where the proposal will be stored.\n    /// @param execution_content The execution content that will be given back at resolution time. This can contain\n    /// data such as a capability resource used to scope the execution.\n    /// @param execution_hash The sha-256 hash for the execution script module. Only the same exact script module can\n    /// resolve this proposal.\n    /// @param min_vote_threshold The minimum number of votes needed to consider this proposal successful.\n    /// @param expiration_secs The time in seconds at which the proposal expires and can potentially be resolved.\n    /// @param early_resolution_vote_threshold The vote threshold for early resolution of this proposal.\n    /// @param metadata A simple_map that stores information about this proposal.\n    /// @param is_multi_step_proposal A bool value that indicates if the proposal is single-step or multi-step.\n    /// @return The proposal id.\n    public fun create_proposal_v2<ProposalType: store>(\n        proposer: address,\n        voting_forum_address: address,\n        execution_content: ProposalType,\n        execution_hash: vector<u8>,\n        min_vote_threshold: u128,\n        expiration_secs: u64,\n        early_resolution_vote_threshold: Option<u128>,\n        metadata: SimpleMap<String, vector<u8>>,\n        is_multi_step_proposal: bool,\n    ): u64 acquires VotingForum {\n        if (option::is_some(&early_resolution_vote_threshold)) {\n            assert!(\n                min_vote_threshold <= *option::borrow(&early_resolution_vote_threshold),\n                error::invalid_argument(EINVALID_MIN_VOTE_THRESHOLD),\n            );\n        };\n        // Make sure the execution script's hash is not empty.\n        assert!(vector::length(&execution_hash) > 0, error::invalid_argument(EPROPOSAL_EMPTY_EXECUTION_HASH));\n\n        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);\n        let proposal_id = voting_forum.next_proposal_id;\n        voting_forum.next_proposal_id = voting_forum.next_proposal_id + 1;\n\n        // Add a flag to indicate if this proposal is single-step or multi-step.\n        simple_map::add(&mut metadata, utf8(IS_MULTI_STEP_PROPOSAL_KEY), to_bytes(&is_multi_step_proposal));\n\n        let is_multi_step_in_execution_key = utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY);\n        if (is_multi_step_proposal) {\n            // If the given proposal is a multi-step proposal, we will add a flag to indicate if this multi-step proposal is in execution.\n            // This value is by default false. We turn this value to true when we start executing the multi-step proposal. This value\n            // will be used to disable further voting after we started executing the multi-step proposal.\n            simple_map::add(&mut metadata, is_multi_step_in_execution_key, to_bytes(&false));\n            // If the proposal is a single-step proposal, we check if the metadata passed by the client has the IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY key.\n            // If they have the key, we will remove it, because a single-step proposal that doesn't need this key.\n        } else if (simple_map::contains_key(&mut metadata, &is_multi_step_in_execution_key)) {\n            simple_map::remove(&mut metadata, &is_multi_step_in_execution_key);\n        };\n\n        table::add(&mut voting_forum.proposals, proposal_id, Proposal {\n            proposer,\n            creation_time_secs: timestamp::now_seconds(),\n            execution_content: option::some<ProposalType>(execution_content),\n            execution_hash,\n            metadata,\n            min_vote_threshold,\n            expiration_secs,\n            early_resolution_vote_threshold,\n            yes_votes: 0,\n            no_votes: 0,\n            is_resolved: false,\n            resolution_time_secs: 0,\n        });\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                CreateProposal {\n                    proposal_id,\n                    early_resolution_vote_threshold,\n                    execution_hash,\n                    expiration_secs,\n                    metadata,\n                    min_vote_threshold,\n                },\n            );\n        };\n        event::emit_event<CreateProposalEvent>(\n            &mut voting_forum.events.create_proposal_events,\n            CreateProposalEvent {\n                proposal_id,\n                early_resolution_vote_threshold,\n                execution_hash,\n                expiration_secs,\n                metadata,\n                min_vote_threshold,\n            },\n        );\n\n        proposal_id\n    }\n\n    /// Vote on the given proposal.\n    ///\n    /// @param _proof Required so only the governance module that defines ProposalType can initiate voting.\n    ///               This guarantees that voting eligibility and voting power are controlled by the right governance.\n    /// @param voting_forum_address The address of the forum where the proposals are stored.\n    /// @param proposal_id The proposal id.\n    /// @param num_votes Number of votes. Voting power should be calculated by governance.\n    /// @param should_pass Whether the votes are for yes or no.\n    public fun vote<ProposalType: store>(\n        _proof: &ProposalType,\n        voting_forum_address: address,\n        proposal_id: u64,\n        num_votes: u64,\n        should_pass: bool,\n    ) acquires VotingForum {\n        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);\n        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);\n        // Voting might still be possible after the proposal has enough yes votes to be resolved early. This would only\n        // lead to possible proposal resolution failure if the resolve early threshold is not definitive (e.g. < 50% + 1\n        // of the total voting token's supply). In this case, more voting might actually still be desirable.\n        // Governance mechanisms built on this voting module can apply additional rules on when voting is closed as\n        // appropriate.\n        assert!(!is_voting_period_over(proposal), error::invalid_state(EPROPOSAL_VOTING_ALREADY_ENDED));\n        assert!(!proposal.is_resolved, error::invalid_state(EPROPOSAL_ALREADY_RESOLVED));\n        // Assert this proposal is single-step, or if the proposal is multi-step, it is not in execution yet.\n        assert!(!simple_map::contains_key(&proposal.metadata, &utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY))\n            || *simple_map::borrow(&proposal.metadata, &utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY)) == to_bytes(\n            &false\n        ),\n            error::invalid_state(EMULTI_STEP_PROPOSAL_IN_EXECUTION));\n\n        if (should_pass) {\n            proposal.yes_votes = proposal.yes_votes + (num_votes as u128);\n        } else {\n            proposal.no_votes = proposal.no_votes + (num_votes as u128);\n        };\n\n        // Record the resolvable time to ensure that resolution has to be done non-atomically.\n        let timestamp_secs_bytes = to_bytes(&timestamp::now_seconds());\n        let key = utf8(RESOLVABLE_TIME_METADATA_KEY);\n        if (simple_map::contains_key(&proposal.metadata, &key)) {\n            *simple_map::borrow_mut(&mut proposal.metadata, &key) = timestamp_secs_bytes;\n        } else {\n            simple_map::add(&mut proposal.metadata, key, timestamp_secs_bytes);\n        };\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(Vote { proposal_id, num_votes });\n        };\n        event::emit_event<VoteEvent>(\n            &mut voting_forum.events.vote_events,\n            VoteEvent { proposal_id, num_votes },\n        );\n    }\n\n    /// Common checks on if a proposal is resolvable, regardless if the proposal is single-step or multi-step.\n    fun is_proposal_resolvable<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ) acquires VotingForum {\n        let proposal_state = get_proposal_state<ProposalType>(voting_forum_address, proposal_id);\n        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_state(EPROPOSAL_CANNOT_BE_RESOLVED));\n\n        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);\n        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);\n        assert!(!proposal.is_resolved, error::invalid_state(EPROPOSAL_ALREADY_RESOLVED));\n\n        // We need to make sure that the resolution is happening in\n        // a separate transaction from the last vote to guard against any potential flashloan attacks.\n        let resolvable_time = to_u64(*simple_map::borrow(&proposal.metadata, &utf8(RESOLVABLE_TIME_METADATA_KEY)));\n        assert!(timestamp::now_seconds() > resolvable_time, error::invalid_state(ERESOLUTION_CANNOT_BE_ATOMIC));\n\n        assert!(\n            transaction_context::get_script_hash() == proposal.execution_hash,\n            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),\n        );\n    }\n\n    /// Resolve a single-step proposal with given id. Can only be done if there are at least as many votes as min required and\n    /// there are more yes votes than no. If either of these conditions is not met, this will revert.\n    ///\n    /// @param voting_forum_address The address of the forum where the proposals are stored.\n    /// @param proposal_id The proposal id.\n    public fun resolve<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): ProposalType acquires VotingForum {\n        is_proposal_resolvable<ProposalType>(voting_forum_address, proposal_id);\n\n        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);\n        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);\n\n        // Assert that the specified proposal is not a multi-step proposal.\n        let multi_step_key = utf8(IS_MULTI_STEP_PROPOSAL_KEY);\n        let has_multi_step_key = simple_map::contains_key(&proposal.metadata, &multi_step_key);\n        if (has_multi_step_key) {\n            let is_multi_step_proposal = from_bcs::to_bool(*simple_map::borrow(&proposal.metadata, &multi_step_key));\n            assert!(\n                !is_multi_step_proposal,\n                error::permission_denied(EMULTI_STEP_PROPOSAL_CANNOT_USE_SINGLE_STEP_RESOLVE_FUNCTION)\n            );\n        };\n\n        let resolved_early = can_be_resolved_early(proposal);\n        proposal.is_resolved = true;\n        proposal.resolution_time_secs = timestamp::now_seconds();\n\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                ResolveProposal {\n                    proposal_id,\n                    yes_votes: proposal.yes_votes,\n                    no_votes: proposal.no_votes,\n                    resolved_early,\n                },\n            );\n        };\n        event::emit_event<ResolveProposal>(\n            &mut voting_forum.events.resolve_proposal_events,\n            ResolveProposal {\n                proposal_id,\n                yes_votes: proposal.yes_votes,\n                no_votes: proposal.no_votes,\n                resolved_early,\n            },\n        );\n\n        option::extract(&mut proposal.execution_content)\n    }\n\n    /// Resolve a single-step or a multi-step proposal with the given id.\n    /// Can only be done if there are at least as many votes as min required and\n    /// there are more yes votes than no. If either of these conditions is not met, this will revert.\n    ///\n    ///\n    /// @param voting_forum_address The address of the forum where the proposals are stored.\n    /// @param proposal_id The proposal id.\n    /// @param next_execution_hash The next execution hash if the given proposal is multi-step.\n    public fun resolve_proposal_v2<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n        next_execution_hash: vector<u8>,\n    ) acquires VotingForum {\n        is_proposal_resolvable<ProposalType>(voting_forum_address, proposal_id);\n\n        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);\n        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);\n\n        // Update the IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY key to indicate that the multi-step proposal is in execution.\n        let multi_step_in_execution_key = utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY);\n        if (simple_map::contains_key(&proposal.metadata, &multi_step_in_execution_key)) {\n            let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(\n                &mut proposal.metadata,\n                &multi_step_in_execution_key\n            );\n            *is_multi_step_proposal_in_execution_value = to_bytes(&true);\n        };\n\n        let multi_step_key = utf8(IS_MULTI_STEP_PROPOSAL_KEY);\n        let is_multi_step = simple_map::contains_key(&proposal.metadata, &multi_step_key) && from_bcs::to_bool(\n            *simple_map::borrow(&proposal.metadata, &multi_step_key)\n        );\n        let next_execution_hash_is_empty = vector::length(&next_execution_hash) == 0;\n\n        // Assert that if this proposal is single-step, the `next_execution_hash` parameter is empty.\n        assert!(\n            is_multi_step || next_execution_hash_is_empty,\n            error::invalid_argument(ESINGLE_STEP_PROPOSAL_CANNOT_HAVE_NEXT_EXECUTION_HASH)\n        );\n\n        // If the `next_execution_hash` parameter is empty, it means that either\n        // - this proposal is a single-step proposal, or\n        // - this proposal is multi-step and we're currently resolving the last step in the multi-step proposal.\n        // We can mark that this proposal is resolved.\n        if (next_execution_hash_is_empty) {\n            proposal.is_resolved = true;\n            proposal.resolution_time_secs = timestamp::now_seconds();\n\n            // Set the `IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY` value to false upon successful resolution of the last step of a multi-step proposal.\n            if (is_multi_step) {\n                let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(\n                    &mut proposal.metadata,\n                    &multi_step_in_execution_key\n                );\n                *is_multi_step_proposal_in_execution_value = to_bytes(&false);\n            };\n        } else {\n            // If the current step is not the last step,\n            // update the proposal's execution hash on-chain to the execution hash of the next step.\n            proposal.execution_hash = next_execution_hash;\n        };\n\n        // For single-step proposals, we emit one `ResolveProposal` event per proposal.\n        // For multi-step proposals, we emit one `ResolveProposal` event per step in the multi-step proposal. This means\n        // that we emit multiple `ResolveProposal` events for the same multi-step proposal.\n        let resolved_early = can_be_resolved_early(proposal);\n        if (std::features::module_event_migration_enabled()) {\n            event::emit(\n                ResolveProposal {\n                    proposal_id,\n                    yes_votes: proposal.yes_votes,\n                    no_votes: proposal.no_votes,\n                    resolved_early,\n                },\n            );\n        };\n        event::emit_event(\n            &mut voting_forum.events.resolve_proposal_events,\n            ResolveProposal {\n                proposal_id,\n                yes_votes: proposal.yes_votes,\n                no_votes: proposal.no_votes,\n                resolved_early,\n            },\n        );\n\n    }\n\n    #[view]\n    /// Return the next unassigned proposal id\n    public fun next_proposal_id<ProposalType: store>(voting_forum_address: address, ): u64 acquires VotingForum {\n        let voting_forum = borrow_global<VotingForum<ProposalType>>(voting_forum_address);\n        voting_forum.next_proposal_id\n    }\n\n    #[view]\n    public fun get_proposer<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64\n    ): address acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.proposer\n    }\n\n    #[view]\n    public fun is_voting_closed<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64\n    ): bool acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        can_be_resolved_early(proposal) || is_voting_period_over(proposal)\n    }\n\n    /// Return true if the proposal has reached early resolution threshold (if specified).\n    public fun can_be_resolved_early<ProposalType: store>(proposal: &Proposal<ProposalType>): bool {\n        if (option::is_some(&proposal.early_resolution_vote_threshold)) {\n            let early_resolution_threshold = *option::borrow(&proposal.early_resolution_vote_threshold);\n            if (proposal.yes_votes >= early_resolution_threshold || proposal.no_votes >= early_resolution_threshold) {\n                return true\n            };\n        };\n        false\n    }\n\n    #[view]\n    public fun get_proposal_metadata<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): SimpleMap<String, vector<u8>> acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.metadata\n    }\n\n    #[view]\n    public fun get_proposal_metadata_value<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n        metadata_key: String,\n    ): vector<u8> acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        *simple_map::borrow(&proposal.metadata, &metadata_key)\n    }\n\n    #[view]\n    /// Return the state of the proposal with given id.\n    ///\n    /// @param voting_forum_address The address of the forum where the proposals are stored.\n    /// @param proposal_id The proposal id.\n    /// @return Proposal state as an enum value.\n    public fun get_proposal_state<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): u64 acquires VotingForum {\n        if (is_voting_closed<ProposalType>(voting_forum_address, proposal_id)) {\n            let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n            let yes_votes = proposal.yes_votes;\n            let no_votes = proposal.no_votes;\n\n            if (yes_votes > no_votes && yes_votes + no_votes >= proposal.min_vote_threshold) {\n                PROPOSAL_STATE_SUCCEEDED\n            } else {\n                PROPOSAL_STATE_FAILED\n            }\n        } else {\n            PROPOSAL_STATE_PENDING\n        }\n    }\n\n    #[view]\n    /// Return the proposal's creation time.\n    public fun get_proposal_creation_secs<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): u64 acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.creation_time_secs\n    }\n\n    #[view]\n    /// Return the proposal's expiration time.\n    public fun get_proposal_expiration_secs<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): u64 acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.expiration_secs\n    }\n\n    #[view]\n    /// Return the proposal's execution hash.\n    public fun get_execution_hash<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): vector<u8> acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.execution_hash\n    }\n\n    #[view]\n    /// Return the proposal's minimum vote threshold\n    public fun get_min_vote_threshold<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): u128 acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.min_vote_threshold\n    }\n\n    #[view]\n    /// Return the proposal's early resolution minimum vote threshold (optionally set)\n    public fun get_early_resolution_vote_threshold<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): Option<u128> acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.early_resolution_vote_threshold\n    }\n\n    #[view]\n    /// Return the proposal's current vote count (yes_votes, no_votes)\n    public fun get_votes<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): (u128, u128) acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        (proposal.yes_votes, proposal.no_votes)\n    }\n\n    #[view]\n    /// Return true if the governance proposal has already been resolved.\n    public fun is_resolved<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): bool acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.is_resolved\n    }\n\n    #[view]\n    public fun get_resolution_time_secs<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): u64 acquires VotingForum {\n        let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);\n        proposal.resolution_time_secs\n    }\n\n    #[view]\n    /// Return true if the multi-step governance proposal is in execution.\n    public fun is_multi_step_proposal_in_execution<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): bool acquires VotingForum {\n        let voting_forum = borrow_global<VotingForum<ProposalType>>(voting_forum_address);\n        let proposal = table::borrow(&voting_forum.proposals, proposal_id);\n        let is_multi_step_in_execution_key = utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY);\n        assert!(\n            simple_map::contains_key(&proposal.metadata, &is_multi_step_in_execution_key),\n            error::invalid_argument(EPROPOSAL_IS_SINGLE_STEP)\n        );\n        from_bcs::to_bool(*simple_map::borrow(&proposal.metadata, &is_multi_step_in_execution_key))\n    }\n\n    /// Return true if the voting period of the given proposal has already ended.\n    fun is_voting_period_over<ProposalType: store>(proposal: &Proposal<ProposalType>): bool {\n        timestamp::now_seconds() > proposal.expiration_secs\n    }\n\n    inline fun get_proposal<ProposalType: store>(\n        voting_forum_address: address,\n        proposal_id: u64,\n    ): &Proposal<ProposalType> acquires VotingForum {\n        let voting_forum = borrow_global<VotingForum<ProposalType>>(voting_forum_address);\n        table::borrow(&voting_forum.proposals, proposal_id)\n    }\n\n    #[test_only]\n    struct TestProposal has store {}\n\n    #[test_only]\n    const VOTING_DURATION_SECS: u64 = 100000;\n\n    #[test_only]\n    public fun create_test_proposal_generic(\n        governance: &signer,\n        early_resolution_threshold: Option<u128>,\n        use_generic_create_proposal_function: bool,\n    ): u64 acquires VotingForum {\n        // Register voting forum and create a proposal.\n        register<TestProposal>(governance);\n        let governance_address = signer::address_of(governance);\n        let proposal = TestProposal {};\n\n        // This works because our Move unit test extensions mock out the execution hash to be [1].\n        let execution_hash = vector::empty<u8>();\n        vector::push_back(&mut execution_hash, 1);\n        let metadata = simple_map::create<String, vector<u8>>();\n\n        if (use_generic_create_proposal_function) {\n            create_proposal_v2<TestProposal>(\n                governance_address,\n                governance_address,\n                proposal,\n                execution_hash,\n                10,\n                timestamp::now_seconds() + VOTING_DURATION_SECS,\n                early_resolution_threshold,\n                metadata,\n                use_generic_create_proposal_function\n            )\n        } else {\n            create_proposal<TestProposal>(\n                governance_address,\n                governance_address,\n                proposal,\n                execution_hash,\n                10,\n                timestamp::now_seconds() + VOTING_DURATION_SECS,\n                early_resolution_threshold,\n                metadata,\n            )\n        }\n    }\n\n    #[test_only]\n    public fun resolve_proposal_for_test<ProposalType>(\n        voting_forum_address: address,\n        proposal_id: u64,\n        is_multi_step: bool,\n        finish_multi_step_execution: bool\n    ) acquires VotingForum {\n        if (is_multi_step) {\n            let execution_hash = vector::empty<u8>();\n            vector::push_back(&mut execution_hash, 1);\n            resolve_proposal_v2<TestProposal>(voting_forum_address, proposal_id, execution_hash);\n\n            if (finish_multi_step_execution) {\n                resolve_proposal_v2<TestProposal>(voting_forum_address, proposal_id, vector::empty<u8>());\n            };\n        } else {\n            let proposal = resolve<TestProposal>(voting_forum_address, proposal_id);\n            let TestProposal {} = proposal;\n        };\n    }\n\n    #[test_only]\n    public fun create_test_proposal(\n        governance: &signer,\n        early_resolution_threshold: Option<u128>,\n    ): u64 acquires VotingForum {\n        create_test_proposal_generic(governance, early_resolution_threshold, false)\n    }\n\n    #[test_only]\n    public fun create_proposal_with_empty_execution_hash_should_fail_generic(\n        governance: &signer,\n        is_multi_step: bool\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        register<TestProposal>(governance);\n        let proposal = TestProposal {};\n\n        // This should fail because execution hash is empty.\n        if (is_multi_step) {\n            create_proposal_v2<TestProposal>(\n                governance_address,\n                governance_address,\n                proposal,\n                b\"\",\n                10,\n                100000,\n                option::none<u128>(),\n                simple_map::create<String, vector<u8>>(),\n                is_multi_step\n            );\n        } else {\n            create_proposal<TestProposal>(\n                governance_address,\n                governance_address,\n                proposal,\n                b\"\",\n                10,\n                100000,\n                option::none<u128>(),\n                simple_map::create<String, vector<u8>>(),\n            );\n        };\n    }\n\n    #[test(governance = @0x123)]\n    #[expected_failure(abort_code = 0x10004, location = Self)]\n    public fun create_proposal_with_empty_execution_hash_should_fail(governance: &signer) acquires VotingForum {\n        create_proposal_with_empty_execution_hash_should_fail_generic(governance, false);\n    }\n\n    #[test(governance = @0x123)]\n    #[expected_failure(abort_code = 0x10004, location = Self)]\n    public fun create_proposal_with_empty_execution_hash_should_fail_multi_step(\n        governance: &signer\n    ) acquires VotingForum {\n        create_proposal_with_empty_execution_hash_should_fail_generic(governance, true);\n    }\n\n    #[test_only]\n    public entry fun test_voting_passed_generic(\n        aptos_framework: &signer,\n        governance: &signer,\n        use_create_multi_step: bool,\n        use_resolve_multi_step: bool\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n\n        // Register voting forum and create a proposal.\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(governance, option::none<u128>(), use_create_multi_step);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_PENDING, 0);\n\n        // Vote.\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 10, true);\n        let TestProposal {} = proof;\n\n        // Resolve.\n        timestamp::fast_forward_seconds(VOTING_DURATION_SECS + 1);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_SUCCEEDED, 1);\n\n        // This if statement is specifically for the test `test_voting_passed_single_step_can_use_generic_function()`.\n        // It's testing when we have a single-step proposal that was created by the single-step `create_proposal()`,\n        // we should be able to successfully resolve it using the generic `resolve_proposal_v2` function.\n        if (!use_create_multi_step && use_resolve_multi_step) {\n            resolve_proposal_v2<TestProposal>(governance_address, proposal_id, vector::empty<u8>());\n        } else {\n            resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, use_resolve_multi_step, true);\n        };\n        let voting_forum = borrow_global<VotingForum<TestProposal>>(governance_address);\n        assert!(table::borrow(&voting_forum.proposals, proposal_id).is_resolved, 2);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    public entry fun test_voting_passed(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        test_voting_passed_generic(aptos_framework, governance, false, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    public entry fun test_voting_passed_multi_step(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        test_voting_passed_generic(aptos_framework, governance, true, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x5000a, location = Self)]\n    public entry fun test_voting_passed_multi_step_cannot_use_single_step_resolve_function(\n        aptos_framework: &signer,\n        governance: &signer\n    ) acquires VotingForum {\n        test_voting_passed_generic(aptos_framework, governance, true, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    public entry fun test_voting_passed_single_step_can_use_generic_function(\n        aptos_framework: &signer,\n        governance: &signer\n    ) acquires VotingForum {\n        test_voting_passed_generic(aptos_framework, governance, false, true);\n    }\n\n    #[test_only]\n    public entry fun test_cannot_resolve_twice_generic(\n        aptos_framework: &signer,\n        governance: &signer,\n        is_multi_step: bool\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n\n        // Register voting forum and create a proposal.\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(governance, option::none<u128>(), is_multi_step);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_PENDING, 0);\n\n        // Vote.\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 10, true);\n        let TestProposal {} = proof;\n\n        // Resolve.\n        timestamp::fast_forward_seconds(VOTING_DURATION_SECS + 1);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_SUCCEEDED, 1);\n        resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, is_multi_step, true);\n        resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, is_multi_step, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30003, location = Self)]\n    public entry fun test_cannot_resolve_twice(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        test_cannot_resolve_twice_generic(aptos_framework, governance, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30003, location = Self)]\n    public entry fun test_cannot_resolve_twice_multi_step(\n        aptos_framework: &signer,\n        governance: &signer\n    ) acquires VotingForum {\n        test_cannot_resolve_twice_generic(aptos_framework, governance, true);\n    }\n\n    #[test_only]\n    public entry fun test_voting_passed_early_generic(\n        aptos_framework: &signer,\n        governance: &signer,\n        is_multi_step: bool\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n\n        // Register voting forum and create a proposal.\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(governance, option::some(100), is_multi_step);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_PENDING, 0);\n\n        // Assert that IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY has value `false` in proposal.metadata.\n        if (is_multi_step) {\n            assert!(!is_multi_step_proposal_in_execution<TestProposal>(governance_address, 0), 1);\n        };\n\n        // Vote.\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 100, true);\n        vote<TestProposal>(&proof, governance_address, proposal_id, 10, false);\n        let TestProposal {} = proof;\n\n        // Resolve early. Need to increase timestamp as resolution cannot happen in the same tx.\n        timestamp::fast_forward_seconds(1);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_SUCCEEDED, 2);\n\n        if (is_multi_step) {\n            // Assert that IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY still has value `false` in proposal.metadata before execution.\n            assert!(!is_multi_step_proposal_in_execution<TestProposal>(governance_address, 0), 3);\n            resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, is_multi_step, false);\n\n            // Assert that the multi-step proposal is in execution but not resolved yet.\n            assert!(is_multi_step_proposal_in_execution<TestProposal>(governance_address, 0), 4);\n            let voting_forum = borrow_global_mut<VotingForum<TestProposal>>(governance_address);\n            let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);\n            assert!(!proposal.is_resolved, 5);\n        };\n\n        resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, is_multi_step, true);\n        let voting_forum = borrow_global_mut<VotingForum<TestProposal>>(governance_address);\n        assert!(table::borrow(&voting_forum.proposals, proposal_id).is_resolved, 6);\n\n        // Assert that the IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY value is set back to `false` upon successful resolution of this multi-step proposal.\n        if (is_multi_step) {\n            assert!(!is_multi_step_proposal_in_execution<TestProposal>(governance_address, 0), 7);\n        };\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    public entry fun test_voting_passed_early(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        test_voting_passed_early_generic(aptos_framework, governance, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    public entry fun test_voting_passed_early_multi_step(\n        aptos_framework: &signer,\n        governance: &signer\n    ) acquires VotingForum {\n        test_voting_passed_early_generic(aptos_framework, governance, true);\n    }\n\n    #[test_only]\n    public entry fun test_voting_passed_early_in_same_tx_should_fail_generic(\n        aptos_framework: &signer,\n        governance: &signer,\n        is_multi_step: bool\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(governance, option::some(100), is_multi_step);\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 40, true);\n        vote<TestProposal>(&proof, governance_address, proposal_id, 60, true);\n        let TestProposal {} = proof;\n\n        // Resolving early should fail since timestamp hasn't changed since the last vote.\n        resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, is_multi_step, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30008, location = Self)]\n    public entry fun test_voting_passed_early_in_same_tx_should_fail(\n        aptos_framework: &signer,\n        governance: &signer\n    ) acquires VotingForum {\n        test_voting_passed_early_in_same_tx_should_fail_generic(aptos_framework, governance, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30008, location = Self)]\n    public entry fun test_voting_passed_early_in_same_tx_should_fail_multi_step(\n        aptos_framework: &signer,\n        governance: &signer\n    ) acquires VotingForum {\n        test_voting_passed_early_in_same_tx_should_fail_generic(aptos_framework, governance, true);\n    }\n\n    #[test_only]\n    public entry fun test_voting_failed_generic(\n        aptos_framework: &signer,\n        governance: &signer,\n        is_multi_step: bool\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n\n        // Register voting forum and create a proposal.\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(governance, option::none<u128>(), is_multi_step);\n\n        // Vote.\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 10, true);\n        vote<TestProposal>(&proof, governance_address, proposal_id, 100, false);\n        let TestProposal {} = proof;\n\n        // Resolve.\n        timestamp::fast_forward_seconds(VOTING_DURATION_SECS + 1);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_FAILED, 1);\n        resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, is_multi_step, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30002, location = Self)]\n    public entry fun test_voting_failed(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        test_voting_failed_generic(aptos_framework, governance, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30002, location = Self)]\n    public entry fun test_voting_failed_multi_step(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        test_voting_failed_generic(aptos_framework, governance, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30005, location = Self)]\n    public entry fun test_cannot_vote_after_voting_period_is_over(\n        aptos_framework: signer,\n        governance: signer\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(&aptos_framework);\n        let governance_address = signer::address_of(&governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal(&governance, option::none<u128>());\n        // Voting period is over. Voting should now fail.\n        timestamp::fast_forward_seconds(VOTING_DURATION_SECS + 1);\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 10, true);\n        let TestProposal {} = proof;\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30009, location = Self)]\n    public entry fun test_cannot_vote_after_multi_step_proposal_starts_executing(\n        aptos_framework: signer,\n        governance: signer\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(&aptos_framework);\n\n        // Register voting forum and create a proposal.\n        let governance_address = signer::address_of(&governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(&governance, option::some(100), true);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_PENDING, 0);\n\n        // Vote.\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 100, true);\n\n        // Resolve early.\n        timestamp::fast_forward_seconds(1);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_SUCCEEDED, 1);\n        resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, true, false);\n        vote<TestProposal>(&proof, governance_address, proposal_id, 100, false);\n        let TestProposal {} = proof;\n    }\n\n    #[test_only]\n    public entry fun test_voting_failed_early_generic(\n        aptos_framework: &signer,\n        governance: &signer,\n        is_multi_step: bool\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n\n        // Register voting forum and create a proposal.\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(governance, option::some(100), is_multi_step);\n\n        // Vote.\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 100, true);\n        vote<TestProposal>(&proof, governance_address, proposal_id, 100, false);\n        let TestProposal {} = proof;\n\n        // Resolve.\n        timestamp::fast_forward_seconds(VOTING_DURATION_SECS + 1);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_FAILED, 1);\n        resolve_proposal_for_test<TestProposal>(governance_address, proposal_id, is_multi_step, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30002, location = Self)]\n    public entry fun test_voting_failed_early(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        test_voting_failed_early_generic(aptos_framework, governance, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x30002, location = Self)]\n    public entry fun test_voting_failed_early_multi_step(\n        aptos_framework: &signer,\n        governance: &signer\n    ) acquires VotingForum {\n        test_voting_failed_early_generic(aptos_framework, governance, false);\n    }\n\n    #[test_only]\n    public entry fun test_cannot_set_min_threshold_higher_than_early_resolution_generic(\n        aptos_framework: &signer,\n        governance: &signer,\n        is_multi_step: bool,\n    ) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n        account::create_account_for_test(signer::address_of(governance));\n        // This should fail.\n        create_test_proposal_generic(governance, option::some(5), is_multi_step);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_cannot_set_min_threshold_higher_than_early_resolution(\n        aptos_framework: &signer,\n        governance: &signer,\n    ) acquires VotingForum {\n        test_cannot_set_min_threshold_higher_than_early_resolution_generic(aptos_framework, governance, false);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    #[expected_failure(abort_code = 0x10007, location = Self)]\n    public entry fun test_cannot_set_min_threshold_higher_than_early_resolution_multi_step(\n        aptos_framework: &signer,\n        governance: &signer,\n    ) acquires VotingForum {\n        test_cannot_set_min_threshold_higher_than_early_resolution_generic(aptos_framework, governance, true);\n    }\n\n    #[test(aptos_framework = @aptos_framework, governance = @0x123)]\n    public entry fun test_replace_execution_hash(aptos_framework: &signer, governance: &signer) acquires VotingForum {\n        account::create_account_for_test(@aptos_framework);\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n\n        // Register voting forum and create a proposal.\n        let governance_address = signer::address_of(governance);\n        account::create_account_for_test(governance_address);\n        let proposal_id = create_test_proposal_generic(governance, option::none<u128>(), true);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_PENDING, 0);\n\n        // Vote.\n        let proof = TestProposal {};\n        vote<TestProposal>(&proof, governance_address, proposal_id, 10, true);\n        let TestProposal {} = proof;\n\n        // Resolve.\n        timestamp::fast_forward_seconds(VOTING_DURATION_SECS + 1);\n        assert!(get_proposal_state<TestProposal>(governance_address, proposal_id) == PROPOSAL_STATE_SUCCEEDED, 1);\n\n        resolve_proposal_v2<TestProposal>(governance_address, proposal_id, vector[10u8]);\n        let voting_forum = borrow_global<VotingForum<TestProposal>>(governance_address);\n        let proposal = table::borrow(&voting_forum.proposals, 0);\n        assert!(proposal.execution_hash == vector[10u8], 2);\n        assert!(!table::borrow(&voting_forum.proposals, proposal_id).is_resolved, 3);\n    }\n}\n","name":"voting.move"}]