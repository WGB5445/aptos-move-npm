"use strict";
(() => {
  // index.ts
  var aptos_stdlib_default = [{ "content": "module aptos_std::any {\n    use aptos_std::type_info;\n    use aptos_std::from_bcs::from_bytes;\n    use std::bcs::to_bytes;\n    use std::error;\n    use std::string::String;\n\n    friend aptos_std::copyable_any;\n\n    /// The type provided for `unpack` is not the same as was given for `pack`.\n    const ETYPE_MISMATCH: u64 = 1;\n\n    /// A type which can represent a value of any type. This allows for representation of 'unknown' future\n    /// values. For example, to define a resource such that it can be later be extended without breaking\n    /// changes one can do\n    ///\n    /// ```move\n    ///   struct Resource {\n    ///      field: Type,\n    ///      ...\n    ///      extension: Option<Any>\n    ///   }\n    /// ```\n    struct Any has drop, store {\n        type_name: String,\n        data: vector<u8>\n    }\n\n    /// Pack a value into the `Any` representation. Because Any can be stored and dropped, this is\n    /// also required from `T`.\n    public fun pack<T: drop + store>(x: T): Any {\n        Any {\n            type_name: type_info::type_name<T>(),\n            data: to_bytes(&x)\n        }\n    }\n\n    /// Unpack a value from the `Any` representation. This aborts if the value has not the expected type `T`.\n    public fun unpack<T>(x: Any): T {\n        assert!(type_info::type_name<T>() == x.type_name, error::invalid_argument(ETYPE_MISMATCH));\n        from_bytes<T>(x.data)\n    }\n\n    /// Returns the type name of this Any\n    public fun type_name(x: &Any): &String {\n        &x.type_name\n    }\n\n    #[test_only]\n    struct S has store, drop { x: u64 }\n\n    #[test]\n    fun test_any() {\n        assert!(unpack<u64>(pack(22)) == 22, 1);\n        assert!(unpack<S>(pack(S { x: 22 })) == S { x: 22 }, 2);\n    }\n}\n", "name": "any.move" }, { "content": "/// A module which defines the basic concept of\n/// [*capabilities*](https://en.wikipedia.org/wiki/Capability-based_security) for managing access control.\n///\n/// EXPERIMENTAL\n///\n/// # Overview\n///\n/// A capability is a unforgeable token which testifies that a signer has authorized a certain operation.\n/// The token is valid during the transaction where it is obtained. Since the type `capability::Cap` has\n/// no ability to be stored in global memory, capabilities cannot leak out of a transaction. For every function\n/// called within a transaction which has a capability as a parameter, it is guaranteed that the capability\n/// has been obtained via a proper signer-based authorization step previously in the transaction's execution.\n///\n/// ## Usage\n///\n/// Initializing and acquiring capabilities is usually encapsulated in a module with a type\n/// tag which can only be constructed by this module.\n///\n/// ```\n/// module Pkg::Feature {\n///   use std::capability::Cap;\n///\n///   /// A type tag used in Cap<Feature>. Only this module can create an instance,\n///   /// and there is no public function other than Self::acquire which returns a value of this type.\n///   /// This way, this module has full control how Cap<Feature> is given out.\n///   struct Feature has drop {}\n///\n///   /// Initializes this module.\n///   public fun initialize(s: &signer) {\n///     // Create capability. This happens once at module initialization time.\n///     // One needs to provide a witness for being the owner of Feature\n///     // in the 2nd parameter.\n///     <<additional conditions allowing to initialize this capability>>\n///     capability::create<Feature>(s, &Feature{});\n///   }\n///\n///   /// Acquires the capability to work with this feature.\n///   public fun acquire(s: &signer): Cap<Feature> {\n///     <<additional conditions allowing to acquire this capability>>\n///     capability::acquire<Feature>(s, &Feature{});\n///   }\n///\n///   /// Does something related to the feature. The caller must pass a Cap<Feature>.\n///   public fun do_something(_cap: Cap<Feature>) { ... }\n/// }\n/// ```\n///\n/// ## Delegation\n///\n/// Capabilities come with the optional feature of *delegation*. Via `Self::delegate`, an owner of a capability\n/// can designate another signer to be also capable of acquiring the capability. Like the original creator,\n/// the delegate needs to present his signer to obtain the capability in his transactions. Delegation can\n/// be revoked via `Self::revoke`, removing this access right from the delegate.\n///\n/// While the basic authorization mechanism for delegates is the same as with core capabilities, the\n/// target of delegation might be subject of restrictions which need to be specified and verified. This can\n/// be done via global invariants in the specification language. For example, in order to prevent delegation\n/// all together for a capability, one can use the following invariant:\n///\n/// ```\n///   invariant forall a: address where capability::spec_has_cap<Feature>(a):\n///               len(capability::spec_delegates<Feature>(a)) == 0;\n/// ```\n///\n/// Similarly, the following invariant would enforce that delegates, if existent, must satisfy a certain\n/// predicate:\n///\n/// ```\n///   invariant forall a: address where capability::spec_has_cap<Feature>(a):\n///               forall d in capability::spec_delegates<Feature>(a):\n///                  is_valid_delegate_for_feature(d);\n/// ```\n///\nmodule aptos_std::capability {\n    use std::error;\n    use std::signer;\n    use std::vector;\n\n    /// Capability resource already exists on the specified account\n    const ECAPABILITY_ALREADY_EXISTS: u64 = 1;\n    /// Capability resource not found\n    const ECAPABILITY_NOT_FOUND: u64 = 2;\n    /// Account does not have delegated permissions\n    const EDELEGATE: u64 = 3;\n\n    /// The token representing an acquired capability. Cannot be stored in memory, but copied and dropped freely.\n    struct Cap<phantom Feature> has copy, drop {\n        root: address\n    }\n\n    /// A linear version of a capability token. This can be used if an acquired capability should be enforced\n    /// to be used only once for an authorization.\n    struct LinearCap<phantom Feature> has drop {\n        root: address\n    }\n\n    /// An internal data structure for representing a configured capability.\n    struct CapState<phantom Feature> has key {\n        delegates: vector<address>\n    }\n\n    /// An internal data structure for representing a configured delegated capability.\n    struct CapDelegateState<phantom Feature> has key {\n        root: address\n    }\n\n    /// Creates a new capability class, owned by the passed signer. A caller must pass a witness that\n    /// they own the `Feature` type parameter.\n    public fun create<Feature>(owner: &signer, _feature_witness: &Feature) {\n        let addr = signer::address_of(owner);\n        assert!(!exists<CapState<Feature>>(addr), error::already_exists(ECAPABILITY_ALREADY_EXISTS));\n        move_to<CapState<Feature>>(owner, CapState { delegates: vector::empty() });\n    }\n\n    /// Acquires a capability token. Only the owner of the capability class, or an authorized delegate,\n    /// can succeed with this operation. A caller must pass a witness that they own the `Feature` type\n    /// parameter.\n    public fun acquire<Feature>(requester: &signer, _feature_witness: &Feature): Cap<Feature>\n    acquires CapState, CapDelegateState {\n        Cap<Feature> { root: validate_acquire<Feature>(requester) }\n    }\n\n    /// Acquires a linear capability token. It is up to the module which owns `Feature` to decide\n    /// whether to expose a linear or non-linear capability.\n    public fun acquire_linear<Feature>(requester: &signer, _feature_witness: &Feature): LinearCap<Feature>\n    acquires CapState, CapDelegateState {\n        LinearCap<Feature> { root: validate_acquire<Feature>(requester) }\n    }\n\n    /// Helper to validate an acquire. Returns the root address of the capability.\n    fun validate_acquire<Feature>(requester: &signer): address\n    acquires CapState, CapDelegateState {\n        let addr = signer::address_of(requester);\n        if (exists<CapDelegateState<Feature>>(addr)) {\n            let root_addr = borrow_global<CapDelegateState<Feature>>(addr).root;\n            // double check that requester is actually registered as a delegate\n            assert!(exists<CapState<Feature>>(root_addr), error::invalid_state(EDELEGATE));\n            assert!(vector::contains(&borrow_global<CapState<Feature>>(root_addr).delegates, &addr),\n                error::invalid_state(EDELEGATE));\n            root_addr\n        } else {\n            assert!(exists<CapState<Feature>>(addr), error::not_found(ECAPABILITY_NOT_FOUND));\n            addr\n        }\n    }\n\n    /// Returns the root address associated with the given capability token. Only the owner\n    /// of the feature can do this.\n    public fun root_addr<Feature>(cap: Cap<Feature>, _feature_witness: &Feature): address {\n        cap.root\n    }\n\n    /// Returns the root address associated with the given linear capability token.\n    public fun linear_root_addr<Feature>(cap: LinearCap<Feature>, _feature_witness: &Feature): address {\n        cap.root\n    }\n\n    /// Registers a delegation relation. If the relation already exists, this function does\n    /// nothing.\n    // TODO: explore whether this should be idempotent like now or abort\n    public fun delegate<Feature>(cap: Cap<Feature>, _feature_witness: &Feature, to: &signer)\n    acquires CapState {\n        let addr = signer::address_of(to);\n        if (exists<CapDelegateState<Feature>>(addr)) return;\n        move_to(to, CapDelegateState<Feature> { root: cap.root });\n        add_element(&mut borrow_global_mut<CapState<Feature>>(cap.root).delegates, addr);\n    }\n\n    /// Revokes a delegation relation. If no relation exists, this function does nothing.\n    // TODO: explore whether this should be idempotent like now or abort\n    public fun revoke<Feature>(cap: Cap<Feature>, _feature_witness: &Feature, from: address)\n    acquires CapState, CapDelegateState\n    {\n        if (!exists<CapDelegateState<Feature>>(from)) return;\n        let CapDelegateState { root: _root } = move_from<CapDelegateState<Feature>>(from);\n        remove_element(&mut borrow_global_mut<CapState<Feature>>(cap.root).delegates, &from);\n    }\n\n    /// Helper to remove an element from a vector.\n    fun remove_element<E: drop>(v: &mut vector<E>, x: &E) {\n        let (found, index) = vector::index_of(v, x);\n        if (found) {\n            vector::remove(v, index);\n        }\n    }\n\n    /// Helper to add an element to a vector.\n    fun add_element<E: drop>(v: &mut vector<E>, x: E) {\n        if (!vector::contains(v, &x)) {\n            vector::push_back(v, x)\n        }\n    }\n}\n", "name": "capability.move" }, { "content": '/// Provides a framework for comparing two elements\nmodule aptos_std::comparator {\n    use std::bcs;\n    use std::vector;\n\n    const EQUAL: u8 = 0;\n    const SMALLER: u8 = 1;\n    const GREATER: u8 = 2;\n\n    struct Result has drop {\n        inner: u8,\n    }\n\n    public fun is_equal(result: &Result): bool {\n        result.inner == EQUAL\n    }\n\n    public fun is_smaller_than(result: &Result): bool {\n        result.inner == SMALLER\n    }\n\n    public fun is_greater_than(result: &Result): bool {\n        result.inner == GREATER\n    }\n\n    // Performs a comparison of two types after BCS serialization.\n    // BCS uses little endian encoding for all integer types,\n    // so comparison between primitive integer types will not behave as expected.\n    // For example, 1(0x1) will be larger than 256(0x100) after BCS serialization.\n    public fun compare<T>(left: &T, right: &T): Result {\n        let left_bytes = bcs::to_bytes(left);\n        let right_bytes = bcs::to_bytes(right);\n\n        compare_u8_vector(left_bytes, right_bytes)\n    }\n\n    // Performs a comparison of two vector<u8>s or byte vectors\n    public fun compare_u8_vector(left: vector<u8>, right: vector<u8>): Result {\n        let left_length = vector::length(&left);\n        let right_length = vector::length(&right);\n\n        let idx = 0;\n\n        while (idx < left_length && idx < right_length) {\n            let left_byte = *vector::borrow(&left, idx);\n            let right_byte = *vector::borrow(&right, idx);\n\n            if (left_byte < right_byte) {\n                return Result { inner: SMALLER }\n            } else if (left_byte > right_byte) {\n                return Result { inner: GREATER }\n            };\n            idx = idx + 1;\n        };\n\n        if (left_length < right_length) {\n            Result { inner: SMALLER }\n        } else if (left_length > right_length) {\n            Result { inner: GREATER }\n        } else {\n            Result { inner: EQUAL }\n        }\n    }\n\n    #[test]\n    public fun test_strings() {\n        use std::string;\n\n        let value0 = string::utf8(b"alpha");\n        let value1 = string::utf8(b"beta");\n        let value2 = string::utf8(b"betaa");\n\n        assert!(is_equal(&compare(&value0, &value0)), 0);\n        assert!(is_equal(&compare(&value1, &value1)), 1);\n        assert!(is_equal(&compare(&value2, &value2)), 2);\n\n        assert!(is_greater_than(&compare(&value0, &value1)), 3);\n        assert!(is_smaller_than(&compare(&value1, &value0)), 4);\n\n        assert!(is_smaller_than(&compare(&value0, &value2)), 5);\n        assert!(is_greater_than(&compare(&value2, &value0)), 6);\n\n        assert!(is_smaller_than(&compare(&value1, &value2)), 7);\n        assert!(is_greater_than(&compare(&value2, &value1)), 8);\n    }\n\n    #[test]\n    #[expected_failure]\n    public fun test_integer() {\n        // 1(0x1) will be larger than 256(0x100) after BCS serialization.\n        let value0: u128 = 1;\n        let value1: u128 = 256;\n\n        assert!(is_equal(&compare(&value0, &value0)), 0);\n        assert!(is_equal(&compare(&value1, &value1)), 1);\n\n        assert!(is_smaller_than(&compare(&value0, &value1)), 2);\n        assert!(is_greater_than(&compare(&value1, &value0)), 3);\n    }\n\n    #[test]\n    public fun test_u128() {\n        let value0: u128 = 5;\n        let value1: u128 = 152;\n        let value2: u128 = 511; // 0x1ff\n\n        assert!(is_equal(&compare(&value0, &value0)), 0);\n        assert!(is_equal(&compare(&value1, &value1)), 1);\n        assert!(is_equal(&compare(&value2, &value2)), 2);\n\n        assert!(is_smaller_than(&compare(&value0, &value1)), 2);\n        assert!(is_greater_than(&compare(&value1, &value0)), 3);\n\n        assert!(is_smaller_than(&compare(&value0, &value2)), 3);\n        assert!(is_greater_than(&compare(&value2, &value0)), 4);\n\n        assert!(is_smaller_than(&compare(&value1, &value2)), 5);\n        assert!(is_greater_than(&compare(&value2, &value1)), 6);\n    }\n\n    #[test_only]\n    struct Complex has drop {\n        value0: vector<u128>,\n        value1: u8,\n        value2: u64,\n    }\n\n    #[test]\n    public fun test_complex() {\n        let value0_0 = vector::empty();\n        vector::push_back(&mut value0_0, 10);\n        vector::push_back(&mut value0_0, 9);\n        vector::push_back(&mut value0_0, 5);\n\n        let value0_1 = vector::empty();\n        vector::push_back(&mut value0_1, 10);\n        vector::push_back(&mut value0_1, 9);\n        vector::push_back(&mut value0_1, 5);\n        vector::push_back(&mut value0_1, 1);\n\n        let base = Complex {\n            value0: value0_0,\n            value1: 13,\n            value2: 41,\n        };\n\n        let other_0 = Complex {\n            value0: value0_1,\n            value1: 13,\n            value2: 41,\n        };\n\n        let other_1 = Complex {\n            value0: copy value0_0,\n            value1: 14,\n            value2: 41,\n        };\n\n        let other_2 = Complex {\n            value0: value0_0,\n            value1: 13,\n            value2: 42,\n        };\n\n        assert!(is_equal(&compare(&base, &base)), 0);\n        assert!(is_smaller_than(&compare(&base, &other_0)), 1);\n        assert!(is_greater_than(&compare(&other_0, &base)), 2);\n        assert!(is_smaller_than(&compare(&base, &other_1)), 3);\n        assert!(is_greater_than(&compare(&other_1, &base)), 4);\n        assert!(is_smaller_than(&compare(&base, &other_2)), 5);\n        assert!(is_greater_than(&compare(&other_2, &base)), 6);\n    }\n}\n', "name": "comparator.move" }, { "content": "module aptos_std::copyable_any {\n    use aptos_std::type_info;\n    use aptos_std::from_bcs::from_bytes;\n    use std::bcs;\n    use std::error;\n    use std::string::String;\n\n    /// The type provided for `unpack` is not the same as was given for `pack`.\n    const ETYPE_MISMATCH: u64 = 0;\n\n    /// The same as `any::Any` but with the copy ability.\n    struct Any has drop, store, copy {\n        type_name: String,\n        data: vector<u8>\n    }\n\n    /// Pack a value into the `Any` representation. Because Any can be stored, dropped, and copied this is\n    /// also required from `T`.\n    public fun pack<T: drop + store + copy>(x: T): Any {\n        Any {\n            type_name: type_info::type_name<T>(),\n            data: bcs::to_bytes(&x)\n        }\n    }\n\n    /// Unpack a value from the `Any` representation. This aborts if the value has not the expected type `T`.\n    public fun unpack<T>(x: Any): T {\n        assert!(type_info::type_name<T>() == x.type_name, error::invalid_argument(ETYPE_MISMATCH));\n        from_bytes<T>(x.data)\n    }\n\n    /// Returns the type name of this Any\n    public fun type_name(x: &Any): &String {\n        &x.type_name\n    }\n\n    #[test_only]\n    struct S has store, drop, copy { x: u64 }\n\n    #[test]\n    fun test_any() {\n        assert!(unpack<u64>(pack(22)) == 22, 1);\n        assert!(unpack<S>(pack(S { x: 22 })) == S { x: 22 }, 2);\n    }\n}\n", "name": "copyable_any.move" }, { "content": '/// Contains functions for:\n///\n///     The minimum-pubkey-size variant of [Boneh-Lynn-Shacham (BLS) signatures](https://en.wikipedia.org/wiki/BLS_digital_signature),\n///     where public keys are BLS12-381 elliptic-curve points in $\\mathbb{G}_1$ and signatures are in $\\mathbb{G}_2$,\n///     as per the [IETF BLS draft standard](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature#section-2.1).\n\nmodule aptos_std::bls12381 {\n    use std::option::{Self, Option};\n    #[test_only]\n    use std::error::invalid_argument;\n\n    /// The signature size, in bytes\n    const SIGNATURE_SIZE: u64 = 96;\n\n    /// The public key size, in bytes\n    const PUBLIC_KEY_NUM_BYTES: u64 = 48;\n\n    /// The caller was supposed to input one or more public keys.\n    const EZERO_PUBKEYS: u64 = 1;\n\n    /// One of the given inputs has the wrong size.s\n    const EWRONG_SIZE: u64 = 2;\n\n    /// The number of signers does not match the number of messages to be signed.\n    const E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES: u64 = 3;\n\n    // TODO: Performance would increase if structs in this module are implemented natively via handles (similar to Table and\n    // RistrettoPoint). This will avoid unnecessary (de)serialization. We would need to allow storage of these structs too.\n\n    #[test_only]\n    struct SecretKey has copy, drop {\n        bytes: vector<u8>,\n    }\n\n    /// A *validated* public key that:\n    ///   (1) is a point in the prime-order subgroup of the BLS12-381 elliptic curve, and\n    ///   (2) is not the identity point\n    ///\n    /// This struct can be used to verify a normal (non-aggregated) signature.\n    ///\n    /// This struct can be combined with a ProofOfPossession struct in order to create a PublicKeyWithPop struct, which\n    /// can be used to verify a multisignature.\n    struct PublicKey has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A proof-of-possession (PoP).\n    /// Given such a struct and a PublicKey struct, one can construct a PublicKeyWithPoP (see below).\n    struct ProofOfPossession has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A *validated* public key that had a successfully-verified proof-of-possession (PoP).\n    ///\n    /// A vector of these structs can be either:\n    ///   (1) used to verify an aggregate signature\n    ///   (2) aggregated with other PublicKeyWithPoP structs into an AggrPublicKeysWithPoP, which in turn can be used\n    ///       to verify a multisignature\n    struct PublicKeyWithPoP has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// An aggregation of public keys with verified PoPs, which can be used to verify multisignatures.\n    struct AggrPublicKeysWithPoP has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A BLS signature. This can be either a:\n    ///   (1) normal (non-aggregated) signature\n    ///   (2) signature share (for a multisignature or aggregate signature)\n    struct Signature has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// An aggregation of BLS signatures. This can be either a:\n    ///   (4) aggregated signature (i.e., an aggregation of signatures s_i, each on a message m_i)\n    ///   (3) multisignature (i.e., an aggregation of signatures s_i, each on the same message m)\n    ///\n    /// We distinguish between a Signature type and a AggrOrMultiSignature type to prevent developers from interchangeably\n    /// calling `verify_multisignature` and `verify_signature_share` to verify both multisignatures and signature shares,\n    /// which could create problems down the line.\n    struct AggrOrMultiSignature has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// Creates a new public key from a sequence of bytes.\n    public fun public_key_from_bytes(bytes: vector<u8>): Option<PublicKey> {\n        if (validate_pubkey_internal(bytes)) {\n            option::some(PublicKey {\n                bytes\n            })\n        } else {\n            option::none<PublicKey>()\n        }\n    }\n\n    /// Serializes a public key into 48 bytes.\n    public fun public_key_to_bytes(pk: &PublicKey): vector<u8> {\n        pk.bytes\n    }\n\n    /// Creates a new proof-of-possession (PoP) which can be later used to create a PublicKeyWithPoP struct,\n    public fun proof_of_possession_from_bytes(bytes: vector<u8>): ProofOfPossession {\n        ProofOfPossession {\n            bytes\n        }\n    }\n\n    /// Serializes the signature into 96 bytes.\n    public fun proof_of_possession_to_bytes(pop: &ProofOfPossession): vector<u8> {\n        pop.bytes\n    }\n\n    /// Creates a PoP\'d public key from a normal public key and a corresponding proof-of-possession.\n    public fun public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: &ProofOfPossession): Option<PublicKeyWithPoP> {\n        if (verify_proof_of_possession_internal(pk_bytes, pop.bytes)) {\n            option::some(PublicKeyWithPoP {\n                bytes: pk_bytes\n            })\n        } else {\n            option::none<PublicKeyWithPoP>()\n        }\n    }\n\n    /// Creates a normal public key from a PoP\'d public key.\n    public fun public_key_with_pop_to_normal(pkpop: &PublicKeyWithPoP): PublicKey {\n        PublicKey {\n            bytes: pkpop.bytes\n        }\n    }\n\n    /// Serializes a PoP\'d public key into 48 bytes.\n    public fun public_key_with_pop_to_bytes(pk: &PublicKeyWithPoP): vector<u8> {\n        pk.bytes\n    }\n\n    /// Creates a new signature from a sequence of bytes. Does not check the signature for prime-order subgroup\n    /// membership since that is done implicitly during verification.\n    public fun signature_from_bytes(bytes: vector<u8>): Signature {\n        Signature {\n            bytes\n        }\n    }\n\n    /// Serializes the signature into 96 bytes.\n    public fun signature_to_bytes(sig: &Signature): vector<u8> {\n        sig.bytes\n    }\n\n    /// Checks that the group element that defines a signature is in the prime-order subgroup.\n    /// This check is implicitly performed when verifying any signature via this module, but we expose this functionality\n    /// in case it might be useful for applications to easily dismiss invalid signatures early on.\n    public fun signature_subgroup_check(signature: &Signature): bool {\n        signature_subgroup_check_internal(signature.bytes)\n    }\n\n    /// Given a vector of public keys with verified PoPs, combines them into an *aggregated* public key which can be used\n    /// to verify multisignatures using `verify_multisignature` and aggregate signatures using `verify_aggregate_signature`.\n    /// Aborts if no public keys are given as input.\n    public fun aggregate_pubkeys(public_keys: vector<PublicKeyWithPoP>): AggrPublicKeysWithPoP {\n        let (bytes, success) = aggregate_pubkeys_internal(public_keys);\n        assert!(success, std::error::invalid_argument(EZERO_PUBKEYS));\n\n        AggrPublicKeysWithPoP {\n            bytes\n        }\n    }\n\n    /// Serializes an aggregate public key into 48 bytes.\n    public fun aggregate_pubkey_to_bytes(apk: &AggrPublicKeysWithPoP): vector<u8> {\n        apk.bytes\n    }\n\n    /// Aggregates the input signatures into an aggregate-or-multi-signature structure, which can be later verified via\n    /// `verify_aggregate_signature` or `verify_multisignature`. Returns `None` if zero signatures are given as input\n    /// or if some of the signatures are not valid group elements.\n    public fun aggregate_signatures(signatures: vector<Signature>): Option<AggrOrMultiSignature> {\n        let (bytes, success) = aggregate_signatures_internal(signatures);\n        if (success) {\n            option::some(\n                AggrOrMultiSignature {\n                    bytes\n                }\n            )\n        } else {\n            option::none<AggrOrMultiSignature>()\n        }\n    }\n\n    /// Serializes an aggregate-or-multi-signature into 96 bytes.\n    public fun aggr_or_multi_signature_to_bytes(sig: &AggrOrMultiSignature): vector<u8> {\n        sig.bytes\n    }\n\n    /// Deserializes an aggregate-or-multi-signature from 96 bytes.\n    public fun aggr_or_multi_signature_from_bytes(bytes: vector<u8>): AggrOrMultiSignature {\n        assert!(std::vector::length(&bytes) == SIGNATURE_SIZE, std::error::invalid_argument(EWRONG_SIZE));\n\n        AggrOrMultiSignature {\n            bytes\n        }\n    }\n\n\n    /// Checks that the group element that defines an aggregate-or-multi-signature is in the prime-order subgroup.\n    public fun aggr_or_multi_signature_subgroup_check(signature: &AggrOrMultiSignature): bool {\n        signature_subgroup_check_internal(signature.bytes)\n    }\n\n    /// Verifies an aggregate signature, an aggregation of many signatures `s_i`, each on a different message `m_i`.\n    public fun verify_aggregate_signature(\n        aggr_sig: &AggrOrMultiSignature,\n        public_keys: vector<PublicKeyWithPoP>,\n        messages: vector<vector<u8>>,\n    ): bool {\n        verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages)\n    }\n\n    /// Verifies a multisignature: an aggregation of many signatures, each on the same message `m`.\n    public fun verify_multisignature(\n        multisig: &AggrOrMultiSignature,\n        aggr_public_key: &AggrPublicKeysWithPoP,\n        message: vector<u8>\n    ): bool {\n        verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message)\n    }\n\n    /// Verifies a normal, non-aggregated signature.\n    public fun verify_normal_signature(\n        signature: &Signature,\n        public_key: &PublicKey,\n        message: vector<u8>\n    ): bool {\n        verify_normal_signature_internal(signature.bytes, public_key.bytes, message)\n    }\n\n    /// Verifies a signature share in the multisignature share or an aggregate signature share.\n    public fun verify_signature_share(\n        signature_share: &Signature,\n        public_key: &PublicKeyWithPoP,\n        message: vector<u8>\n    ): bool {\n        verify_signature_share_internal(signature_share.bytes, public_key.bytes, message)\n    }\n\n    #[test_only]\n    /// Generates a BLS key-pair: a secret key with its corresponding public key.\n    public fun generate_keys(): (SecretKey, PublicKeyWithPoP) {\n        let (sk_bytes, pk_bytes) = generate_keys_internal();\n        let sk = SecretKey {\n            bytes: sk_bytes\n        };\n        let pkpop = PublicKeyWithPoP {\n            bytes: pk_bytes\n        };\n        (sk, pkpop)\n    }\n\n    #[test_only]\n    /// Generates a BLS signature for a message with a signing key.\n    public fun sign_arbitrary_bytes(signing_key: &SecretKey, message: vector<u8>): Signature {\n        Signature {\n            bytes: sign_internal(signing_key.bytes, message)\n        }\n    }\n\n    #[test_only]\n    /// Generates a multi-signature for a message with multiple signing keys.\n    public fun multi_sign_arbitrary_bytes(signing_keys: &vector<SecretKey>, message: vector<u8>): AggrOrMultiSignature {\n        let n = std::vector::length(signing_keys);\n        let sigs = vector[];\n        let i: u64 = 0;\n        while (i < n) {\n            let sig = sign_arbitrary_bytes(std::vector::borrow(signing_keys, i), message);\n            std::vector::push_back(&mut sigs, sig);\n            i = i + 1;\n        };\n        let multisig = aggregate_signatures(sigs);\n        option::extract(&mut multisig)\n    }\n\n    #[test_only]\n    /// Generates an aggregated signature over all messages in messages, where signing_keys[i] signs messages[i].\n    public fun aggr_sign_arbitrary_bytes(signing_keys: &vector<SecretKey>, messages: &vector<vector<u8>>): AggrOrMultiSignature {\n        let signing_key_count = std::vector::length(signing_keys);\n        let message_count = std::vector::length(messages);\n        assert!(signing_key_count == message_count, invalid_argument(E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES));\n        let sigs = vector[];\n        let i: u64 = 0;\n        while (i < signing_key_count) {\n            let sig = sign_arbitrary_bytes(std::vector::borrow(signing_keys, i), *std::vector::borrow(messages, i));\n            std::vector::push_back(&mut sigs, sig);\n            i = i + 1;\n        };\n        let aggr_sig = aggregate_signatures(sigs);\n        option::extract(&mut aggr_sig)\n    }\n\n    #[test_only]\n    /// Returns a mauled copy of a byte array.\n    public fun maul_bytes(bytes: &vector<u8>): vector<u8> {\n        let new_bytes = *bytes;\n        let first_byte = std::vector::borrow_mut(&mut new_bytes, 0);\n        *first_byte = *first_byte ^ 0xff;\n        new_bytes\n    }\n\n    #[test_only]\n    /// Returns a mauled copy of a normal signature.\n    public fun maul_signature(sig: &Signature): Signature {\n        Signature {\n            bytes: maul_bytes(&signature_to_bytes(sig))\n        }\n    }\n\n    #[test_only]\n    /// Returns a mauled copy of an aggregated signature or a multi-signature.\n    public fun maul_aggr_or_multi_signature(sig: &AggrOrMultiSignature): AggrOrMultiSignature {\n        AggrOrMultiSignature {\n            bytes: maul_bytes(&aggr_or_multi_signature_to_bytes(sig))\n        }\n    }\n\n    #[test_only]\n    /// Returns a mauled copy of a normal public key.\n    public fun maul_public_key(pk: &PublicKey): PublicKey {\n        PublicKey {\n            bytes: maul_bytes(&public_key_to_bytes(pk))\n        }\n    }\n\n    #[test_only]\n    /// Returns a mauled copy of a PoP\'d public key.\n    public fun maul_public_key_with_pop(pk: &PublicKeyWithPoP): PublicKeyWithPoP {\n        PublicKeyWithPoP {\n            bytes: maul_bytes(&public_key_with_pop_to_bytes(pk))\n        }\n    }\n\n    #[test_only]\n    /// Returns a mauled copy of an aggregated public key.\n    public fun maul_aggregated_public_key(pk: &AggrPublicKeysWithPoP): AggrPublicKeysWithPoP {\n        AggrPublicKeysWithPoP {\n            bytes: maul_bytes(&aggregate_pubkey_to_bytes(pk))\n        }\n    }\n\n    #[test_only]\n    /// Returns a mauled copy of a proof-of-possession.\n    public fun maul_proof_of_possession(pop: &ProofOfPossession): ProofOfPossession {\n        ProofOfPossession {\n            bytes: maul_bytes(&proof_of_possession_to_bytes(pop))\n        }\n    }\n\n\n    #[test_only]\n    /// Generates a proof-of-possession (PoP) for the public key associated with the secret key `sk`.\n    public fun generate_proof_of_possession(sk: &SecretKey): ProofOfPossession {\n        ProofOfPossession {\n            bytes: generate_proof_of_possession_internal(sk.bytes)\n        }\n    }\n\n    //\n    // Native functions\n    //\n\n    /// CRYPTOGRAPHY WARNING: This function assumes that the caller verified all public keys have a valid\n    /// proof-of-possesion (PoP) using `verify_proof_of_possession`.\n    ///\n    /// Given a vector of serialized public keys, combines them into an aggregated public key, returning `(bytes, true)`,\n    /// where `bytes` store the serialized public key.\n    /// Aborts if no public keys are given as input.\n    native fun aggregate_pubkeys_internal(public_keys: vector<PublicKeyWithPoP>): (vector<u8>, bool);\n\n\n    /// CRYPTOGRAPHY WARNING: This function can be safely called without verifying that the input signatures are elements\n    /// of the prime-order subgroup of the BLS12-381 curve.\n    ///\n    /// Given a vector of serialized signatures, combines them into an aggregate signature, returning `(bytes, true)`,\n    /// where `bytes` store the serialized signature.\n    /// Does not check the input signatures nor the final aggregated signatures for prime-order subgroup membership.\n    /// Returns `(_, false)` if no signatures are given as input.\n    /// Does not abort.\n    native fun aggregate_signatures_internal(signatures: vector<Signature>): (vector<u8>, bool);\n\n    /// Return `true` if the bytes in `public_key` are a valid BLS12-381 public key:\n    ///  (1) it is NOT the identity point, and\n    ///  (2) it is a BLS12-381 elliptic curve point, and\n    ///  (3) it is a prime-order point\n    /// Return `false` otherwise.\n    /// Does not abort.\n    native fun validate_pubkey_internal(public_key: vector<u8>): bool;\n\n    /// Return `true` if the elliptic curve point serialized in `signature`:\n    ///  (1) is NOT the identity point, and\n    ///  (2) is a BLS12-381 elliptic curve point, and\n    ///  (3) is a prime-order point\n    /// Return `false` otherwise.\n    /// Does not abort.\n    native fun signature_subgroup_check_internal(signature: vector<u8>): bool;\n\n    /// CRYPTOGRAPHY WARNING: First, this function assumes all public keys have a valid proof-of-possesion (PoP).\n    /// This prevents both small-subgroup attacks and rogue-key attacks. Second, this function can be safely called\n    /// without verifying that the aggregate signature is in the prime-order subgroup of the BLS12-381 curve.\n    ///\n    /// Returns `true` if the aggregate signature `aggsig` on `messages` under `public_keys` verifies (where `messages[i]`\n    /// should be signed by `public_keys[i]`).\n    ///\n    /// Returns `false` if either:\n    /// - no public keys or messages are given as input,\n    /// - number of messages does not equal number of public keys\n    /// - `aggsig` (1) is the identity point, or (2) is NOT a BLS12-381 elliptic curve point, or (3) is NOT a\n    ///   prime-order point\n    /// Does not abort.\n    native fun verify_aggregate_signature_internal(\n        aggsig: vector<u8>,\n        public_keys: vector<PublicKeyWithPoP>,\n        messages: vector<vector<u8>>,\n    ): bool;\n\n    /// CRYPTOGRAPHY WARNING: This function assumes verified proofs-of-possesion (PoP) for the public keys used in\n    /// computing the aggregate public key. This prevents small-subgroup attacks and rogue-key attacks.\n    ///\n    /// Return `true` if the BLS `multisignature` on `message` verifies against the BLS aggregate public key `agg_public_key`.\n    /// Returns `false` otherwise.\n    /// Does not abort.\n    native fun verify_multisignature_internal(\n        multisignature: vector<u8>,\n        agg_public_key: vector<u8>,\n        message: vector<u8>\n    ): bool;\n\n    /// CRYPTOGRAPHY WARNING: This function WILL check that the public key is a prime-order point, in order to prevent\n    /// library users from misusing the library by forgetting to validate public keys before giving them as arguments to\n    /// this function.\n    ///\n    /// Returns `true` if the `signature` on `message` verifies under `public key`.\n    /// Returns `false` otherwise.\n    /// Does not abort.\n    native fun verify_normal_signature_internal(\n        signature: vector<u8>,\n        public_key: vector<u8>,\n        message: vector<u8>\n    ): bool;\n\n    /// Return `true` if the bytes in `public_key` are a valid bls12381 public key (as per `validate_pubkey`)\n    /// *and* this public key has a valid proof-of-possesion (PoP).\n    /// Return `false` otherwise.\n    /// Does not abort.\n    native fun verify_proof_of_possession_internal(\n        public_key: vector<u8>,\n        proof_of_possesion: vector<u8>\n    ): bool;\n\n    /// CRYPTOGRAPHY WARNING: Assumes the public key has a valid proof-of-possesion (PoP). This prevents rogue-key\n    /// attacks later on during signature aggregation.\n    ///\n    /// Returns `true` if the `signature_share` on `message` verifies under `public key`.\n    /// Returns `false` otherwise, similar to `verify_multisignature`.\n    /// Does not abort.\n    native fun verify_signature_share_internal(\n        signature_share: vector<u8>,\n        public_key: vector<u8>,\n        message: vector<u8>\n    ): bool;\n\n    #[test_only]\n    native fun generate_keys_internal(): (vector<u8>, vector<u8>);\n\n    #[test_only]\n    native fun sign_internal(sk: vector<u8>, msg: vector<u8>): vector<u8>;\n\n    #[test_only]\n    native fun generate_proof_of_possession_internal(sk: vector<u8>): vector<u8>;\n\n    //\n    // Constants and helpers for tests\n    //\n\n    /// Random signature generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in `crates/aptos-crypto`.\n    /// The message signed is "Hello Aptos!" and the associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.\n    const RANDOM_SIGNATURE: vector<u8> = x"a01a65854f987d3434149b7f08f70730e30b241984e8712bc2aca885d632aafced4c3f661209debb6b1c8601326623cc16ca2f6c9edc53b7b88b7435fb6b05ddece418d2c34dc6aca2f5a11a79e67774582c14084a01dcb7820e4cb4bad0ea8d";\n\n    /// Random signature generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in `crates/aptos-crypto`.\n    /// The associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.\n    const RANDOM_PK: vector<u8> = x"8a53e7ae5270e3e765cd8a4032c2e77c6f7e87a44ebb85bf28a4d7865565698f975346714262f9e47c6f3e0d5d951660";\n\n    //\n    // Tests\n    //\n\n    #[test_only]\n    fun get_random_aggsig(): AggrOrMultiSignature {\n        assert!(signature_subgroup_check_internal(RANDOM_SIGNATURE), 1);\n\n        AggrOrMultiSignature { bytes: RANDOM_SIGNATURE }\n    }\n\n    #[test_only]\n    fun get_random_pk_with_pop(): PublicKeyWithPoP {\n        assert!(validate_pubkey_internal(RANDOM_PK), 1);\n\n        PublicKeyWithPoP {\n            bytes: RANDOM_PK\n        }\n    }\n\n    #[test]\n    fun test_pubkey_validation() {\n        // test low order points (in group for PK)\n        assert!(option::is_none(&public_key_from_bytes(x"ae3cd9403b69c20a0d455fd860e977fe6ee7140a7f091f26c860f2caccd3e0a7a7365798ac10df776675b3a67db8faa0")), 1);\n        assert!(option::is_none(&public_key_from_bytes(x"928d4862a40439a67fd76a9c7560e2ff159e770dcf688ff7b2dd165792541c88ee76c82eb77dd6e9e72c89cbf1a56a68")), 1);\n        assert!(option::is_some(&public_key_from_bytes(x"b3e4921277221e01ed71284be5e3045292b26c7f465a6fcdba53ee47edd39ec5160da3b229a73c75671024dcb36de091")), 1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 65537, location = Self)]\n    fun test_empty_pubkey_aggregation() {\n        // First, make sure if no inputs are given, the function returns None\n        // assert!(aggregate_pop_verified_pubkeys(vector::empty()) == option::none(), 1);\n        aggregate_pubkeys(std::vector::empty());\n    }\n\n    #[test]\n    fun test_pubkey_aggregation() {\n        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:\n        //  $ cargo test -- sample_aggregate_pk_and_multisig --nocapture --include-ignored\n        let pks = vector[\n            PublicKeyWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },\n            PublicKeyWithPoP { bytes: x"ab9df801c6f96ade1c0490c938c87d5bcc2e52ccb8768e1b5d14197c5e8bfa562783b96711b702dda411a1a9f08ebbfa" },\n            PublicKeyWithPoP { bytes: x"b698c932cf7097d99c17bd6e9c9dc4eeba84278c621700a8f80ec726b1daa11e3ab55fc045b4dbadefbeef05c4182494" },\n            PublicKeyWithPoP { bytes: x"934706a8b876d47a996d427e1526ce52c952d5ec0858d49cd262efb785b62b1972d06270b0a7adda1addc98433ad1843" },\n            PublicKeyWithPoP { bytes: x"a4cd352daad3a0651c1998dfbaa7a748e08d248a54347544bfedd51a197e016bb6008e9b8e45a744e1a030cc3b27d2da" },\n        ];\n\n        // agg_pks[i] = \\sum_{j <= i}  pk[j]\n        let agg_pks = vector[\n            AggrPublicKeysWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },\n            AggrPublicKeysWithPoP { bytes: x"b79ad47abb441d7eda9b220a626df2e4e4910738c5f777947f0213398ecafae044ec0c20d552d1348347e9abfcf3eca1" },\n            AggrPublicKeysWithPoP { bytes: x"b5f5eb6153ab5388a1a76343d714e4a2dcf224c5d0722d1e8e90c6bcead05c573fffe986460bd4000645a655bf52bc60" },\n            AggrPublicKeysWithPoP { bytes: x"b922006ec14c183572a8864c31dc6632dccffa9f9c86411796f8b1b5a93a2457762c8e2f5ef0a2303506c4bca9a4e0bf" },\n            AggrPublicKeysWithPoP { bytes: x"b53df1cfee2168f59e5792e710bf22928dc0553e6531dae5c7656c0a66fc12cb82fbb04863938c953dc901a5a79cc0f3" },\n        ];\n\n        let i = 0;\n        let accum_pk = std::vector::empty<PublicKeyWithPoP>();\n        while (i < std::vector::length(&pks)) {\n            std::vector::push_back(&mut accum_pk, *std::vector::borrow(&pks, i));\n\n            let apk = aggregate_pubkeys(accum_pk);\n\n            // Make sure PKs were aggregated correctly\n            assert!(apk == *std::vector::borrow(&agg_pks, i), 1);\n            assert!(validate_pubkey_internal(apk.bytes), 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test]\n    fun test_pubkey_validation_against_invalid_keys() {\n        let (_sk, pk) = generate_keys();\n        let pk_bytes = public_key_with_pop_to_bytes(&pk);\n        assert!(option::is_some(&public_key_from_bytes(pk_bytes)), 1);\n        assert!(option::is_none(&public_key_from_bytes(maul_bytes(&pk_bytes))), 1);\n    }\n\n    #[test]\n    fun test_signature_aggregation() {\n        // First, test empty aggregation\n        assert!(option::is_none(&mut aggregate_signatures(vector[])), 1);\n\n        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:\n        //  $ cargo test -- sample_aggregate_sigs --nocapture --include-ignored\n\n        // Signatures of each signer i\n        let sigs = vector[\n            signature_from_bytes(x"a55ac2d64b4c1d141b15d876d3e54ad1eea07ee488e8287cce7cdf3eec551458ab5795ab196f8c112590346f7bc7c97e0053cd5be0f9bd74b93a87cd44458e98d125d6d5c6950ea5e62666beb34422ead79121f8cb0815dae41a986688d03eaf"),\n            signature_from_bytes(x"90a639a44491191c46379a843266c293de3a46197714ead2ad3886233dd5c2b608b6437fa32fbf9d218b20f1cbfa7970182663beb9c148e2e9412b148e16abf283ffa51b8a536c0e55d61b2e5c849edc49f636c0ef07cb99f125cbcf602e22bb"),\n            signature_from_bytes(x"9527d81aa15863ef3a3bf96bea6d58157d5063a93a6d0eb9d8b4f4bbda3b31142ec4586cb519da2cd7600941283d1bad061b5439703fd584295b44037a969876962ae1897dcc7cadf909d06faae213c4fef8e015dfb33ec109af02ab0c3f6833"),\n            signature_from_bytes(x"a54d264f5cab9654b1744232c4650c42b29adf2b19bd00bbdaf4a4d792ee4dfd40a1fe1b067f298bcfd8ae4fdc8250660a2848bd4a80d96585afccec5c6cfa617033dd7913c9acfdf98a72467e8a5155d4cad589a72d6665be7cb410aebc0068"),\n            signature_from_bytes(x"8d22876bdf73e6ad36ed98546018f6258cd47e45904b87c071e774a6ef4b07cac323258cb920b2fe2b07cca1f2b24bcb0a3194ec76f32edb92391ed2c39e1ada8919f8ea755c5e39873d33ff3a8f4fba21b1261c1ddb9d1688c2b40b77e355d1"),\n        ];\n\n        // multisigs[i] is a signature on "Hello, Aptoverse!" from signers 1 through i (inclusive)\n        let multisigs = vector[\n            AggrOrMultiSignature { bytes: x"a55ac2d64b4c1d141b15d876d3e54ad1eea07ee488e8287cce7cdf3eec551458ab5795ab196f8c112590346f7bc7c97e0053cd5be0f9bd74b93a87cd44458e98d125d6d5c6950ea5e62666beb34422ead79121f8cb0815dae41a986688d03eaf" },\n            AggrOrMultiSignature { bytes: x"8f1949a06b95c3cb62898d861f889350c0d2cb740da513bfa195aa0ab8fa006ea2efe004a7bbbd9bb363637a279aed20132efd0846f520e7ee0e8ed847a1c6969bb986ad2239bcc9af561b6c2aa6d3016e1c722146471f1e28313de189fe7ebc" },\n            AggrOrMultiSignature { bytes: x"ab5ad42bb8f350f8a6b4ae897946a05dbe8f2b22db4f6c37eff6ff737aebd6c5d75bd1abdfc99345ac8ec38b9a449700026f98647752e1c99f69bb132340f063b8a989728e0a3d82a753740bf63e5d8f51e413ebd9a36f6acbe1407a00c4b3e7" },\n            AggrOrMultiSignature { bytes: x"ae307a0d055d3ba55ad6ec7094adef27ed821bdcf735fb509ab2c20b80952732394bc67ea1fd8c26ea963540df7448f8102509f7b8c694e4d75f30a43c455f251b6b3fd8b580b9228ffeeb9039834927aacefccd3069bef4b847180d036971cf" },\n            AggrOrMultiSignature { bytes: x"8284e4e3983f29cb45020c3e2d89066df2eae533a01cb6ca2c4d466b5e02dd22467f59640aa120db2b9cc49e931415c3097e3d54ff977fd9067b5bc6cfa1c885d9d8821aef20c028999a1d97e783ae049d8fa3d0bbac36ce4ca8e10e551d3461" },\n        ];\n\n        let i = 0;\n        let accum_sigs = std::vector::empty<Signature>();\n        while (i < std::vector::length(&sigs)) {\n            std::vector::push_back(&mut accum_sigs, *std::vector::borrow(&sigs, i));\n\n            let multisig = option::extract(&mut aggregate_signatures(accum_sigs));\n\n            // Make sure sigs were aggregated correctly\n            assert!(multisig == *std::vector::borrow(&multisigs, i), 1);\n            assert!(signature_subgroup_check_internal(multisig.bytes), 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test]\n    fun test_empty_signature_aggregation() {\n        assert!(option::is_none(&mut aggregate_signatures(vector[])), 1);\n    }\n\n    #[test]\n    fun test_verify_multisig() {\n        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:\n        //  $ cargo test -- sample_aggregate_pk_and_multisig --nocapture --include-ignored\n        let pks = vector[\n            PublicKeyWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },\n            PublicKeyWithPoP { bytes: x"ab9df801c6f96ade1c0490c938c87d5bcc2e52ccb8768e1b5d14197c5e8bfa562783b96711b702dda411a1a9f08ebbfa" },\n            PublicKeyWithPoP { bytes: x"b698c932cf7097d99c17bd6e9c9dc4eeba84278c621700a8f80ec726b1daa11e3ab55fc045b4dbadefbeef05c4182494" },\n            PublicKeyWithPoP { bytes: x"934706a8b876d47a996d427e1526ce52c952d5ec0858d49cd262efb785b62b1972d06270b0a7adda1addc98433ad1843" },\n            PublicKeyWithPoP { bytes: x"a4cd352daad3a0651c1998dfbaa7a748e08d248a54347544bfedd51a197e016bb6008e9b8e45a744e1a030cc3b27d2da" },\n        ];\n\n        // agg_pks[i] = \\sum_{j <= i}  pk[j]\n        let agg_pks = vector[\n            AggrPublicKeysWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },\n            AggrPublicKeysWithPoP { bytes: x"b79ad47abb441d7eda9b220a626df2e4e4910738c5f777947f0213398ecafae044ec0c20d552d1348347e9abfcf3eca1" },\n            AggrPublicKeysWithPoP { bytes: x"b5f5eb6153ab5388a1a76343d714e4a2dcf224c5d0722d1e8e90c6bcead05c573fffe986460bd4000645a655bf52bc60" },\n            AggrPublicKeysWithPoP { bytes: x"b922006ec14c183572a8864c31dc6632dccffa9f9c86411796f8b1b5a93a2457762c8e2f5ef0a2303506c4bca9a4e0bf" },\n            AggrPublicKeysWithPoP { bytes: x"b53df1cfee2168f59e5792e710bf22928dc0553e6531dae5c7656c0a66fc12cb82fbb04863938c953dc901a5a79cc0f3" },\n        ];\n\n        // multisigs[i] is a signature on "Hello, Aptoverse!" under agg_pks[i]\n        let multisigs = vector[\n            AggrOrMultiSignature { bytes: x"ade45c67bff09ae57e0575feb0be870f2d351ce078e8033d847615099366da1299c69497027b77badb226ff1708543cd062597030c3f1553e0aef6c17e7af5dd0de63c1e4f1f9da68c966ea6c1dcade2cdc646bd5e8bcd4773931021ec5be3fd" },\n            AggrOrMultiSignature { bytes: x"964af3d83436f6a9a382f34590c0c14e4454dc1de536af205319ce1ed417b87a2374863d5df7b7d5ed900cf91dffa7a105d3f308831d698c0d74fb2259d4813434fb86425db0ded664ae8f85d02ec1d31734910317d4155cbf69017735900d4d" },\n            AggrOrMultiSignature { bytes: x"b523a31813e771e55aa0fc99a48db716ecc1085f9899ccadb64e759ecb481a2fb1cdcc0b266f036695f941361de773081729311f6a1bca9d47393f5359c8c87dc34a91f5dae335590aacbff974076ad1f910dd81750553a72ccbcad3c8cc0f07" },\n            AggrOrMultiSignature { bytes: x"a945f61699df58617d37530a85e67bd1181349678b89293951ed29d1fb7588b5c12ebb7917dfc9d674f3f4fde4d062740b85a5f4927f5a4f0091e46e1ac6e41bbd650a74dd49e91445339d741e3b10bdeb9bc8bba46833e0011ff91fa5c77bd2" },\n            AggrOrMultiSignature { bytes: x"b627b2cfd8ae59dcf5e58cc6c230ae369985fd096e1bc3be38da5deafcbed7d939f07cccc75383539940c56c6b6453db193f563f5b6e4fe54915afd9e1baea40a297fa7eda74abbdcd4cc5c667d6db3b9bd265782f7693798894400f2beb4637" },\n        ];\n\n        let i = 0;\n        let accum_pk = std::vector::empty<PublicKeyWithPoP>();\n        while (i < std::vector::length(&pks)) {\n            std::vector::push_back(&mut accum_pk, *std::vector::borrow(&pks, i));\n\n            let apk = aggregate_pubkeys(accum_pk);\n\n            assert!(apk == *std::vector::borrow(&agg_pks, i), 1);\n\n            assert!(verify_multisignature(std::vector::borrow(&multisigs, i), &apk, b"Hello, Aptoverse!"), 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test]\n    fun test_verify_multisignature_randomized() {\n        let signer_count = 1;\n        let max_signer_count = 5;\n        let msg = b"hello world";\n        while (signer_count <= max_signer_count) {\n            // Generate key pairs.\n            let signing_keys = vector[];\n            let public_keys = vector[];\n            let i = 0;\n            while (i < signer_count) {\n                let (sk, pk) = generate_keys();\n                std::vector::push_back(&mut signing_keys, sk);\n                std::vector::push_back(&mut public_keys, pk);\n                i = i + 1;\n            };\n\n            // Generate multi-signature.\n            let aggr_pk = aggregate_pubkeys(public_keys);\n            let multisig = multi_sign_arbitrary_bytes(&signing_keys, msg);\n\n            // Test signature verification.\n            assert!(verify_multisignature(&multisig, &aggr_pk, msg), 1);\n            assert!(!verify_multisignature(&maul_aggr_or_multi_signature(&multisig), &aggr_pk, msg), 1);\n            assert!(!verify_multisignature(&multisig, &maul_aggregated_public_key(&aggr_pk), msg), 1);\n            assert!(!verify_multisignature(&multisig, &aggr_pk, maul_bytes(&msg)), 1);\n\n            // Also test signature aggregation.\n            let signatures = vector[];\n            let i = 0;\n            while (i < signer_count) {\n                let sk = std::vector::borrow(&signing_keys, i);\n                let sig = sign_arbitrary_bytes(sk, msg);\n                std::vector::push_back(&mut signatures, sig);\n                i = i + 1;\n            };\n            let aggregated_signature = option::extract(&mut aggregate_signatures(signatures));\n            assert!(aggr_or_multi_signature_subgroup_check(&aggregated_signature), 1);\n            assert!(aggr_or_multi_signature_to_bytes(&aggregated_signature) == aggr_or_multi_signature_to_bytes(&multisig), 1);\n\n            signer_count = signer_count + 1;\n        }\n    }\n\n    #[test]\n    fun test_verify_aggsig() {\n        assert!(aggr_or_multi_signature_to_bytes(&aggr_or_multi_signature_from_bytes(RANDOM_SIGNATURE)) == RANDOM_SIGNATURE, 1);\n\n        // First, make sure verification returns None when no inputs are given or |pks| != |msgs|\n        assert!(verify_aggregate_signature(&get_random_aggsig(), vector[], vector[]) == false, 1);\n\n        assert!(verify_aggregate_signature(\n            &get_random_aggsig(),\n            vector[ get_random_pk_with_pop() ],\n            vector[]) == false, 1);\n\n        assert!(verify_aggregate_signature(\n            &get_random_aggsig(),\n            vector[],\n            vector[ x"ab" ]) == false, 1);\n\n        assert!(verify_aggregate_signature(\n            &get_random_aggsig(),\n            vector[ get_random_pk_with_pop() ],\n            vector[\n                x"cd", x"ef"\n            ]) == false, 1);\n\n        assert!(verify_aggregate_signature(\n            &get_random_aggsig(),\n            vector[\n                get_random_pk_with_pop(),\n                get_random_pk_with_pop(),\n                get_random_pk_with_pop(),\n            ],\n            vector[\n                x"cd", x"ef"\n            ]) == false, 1);\n\n        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:\n        //  $ cargo test -- bls12381_sample_aggregate_pk_and_aggsig --nocapture --ignored\n\n        // The signed messages are "Hello, Aptos <i>!", where <i> \\in {1, ..., 5}\n        let msgs = vector[\n            x"48656c6c6f2c204170746f73203121",\n            x"48656c6c6f2c204170746f73203221",\n            x"48656c6c6f2c204170746f73203321",\n            x"48656c6c6f2c204170746f73203421",\n            x"48656c6c6f2c204170746f73203521",\n        ];\n\n        // Public key of signer i\n        let pks = vector[\n            PublicKeyWithPoP { bytes: x"b93d6aabb2b83e52f4b8bda43c24ea920bbced87a03ffc80f8f70c814a8b3f5d69fbb4e579ca76ee008d61365747dbc6" },\n            PublicKeyWithPoP { bytes: x"b45648ceae3a983bcb816a96db599b5aef3b688c5753fa20ce36ac7a4f2c9ed792ab20af6604e85e42dab746398bb82c" },\n            PublicKeyWithPoP { bytes: x"b3e4921277221e01ed71284be5e3045292b26c7f465a6fcdba53ee47edd39ec5160da3b229a73c75671024dcb36de091" },\n            PublicKeyWithPoP { bytes: x"8463b8671c9775a7dbd98bf76d3deba90b5a90535fc87dc8c13506bb5c7bbd99be4d257e60c548140e1e30b107ff5822" },\n            PublicKeyWithPoP { bytes: x"a79e3d0e9d04587a3b27d05efe5717da05fd93485dc47978c866dc70a01695c2efd247d1dd843a011a4b6b24079d7384" },\n        ];\n\n        // aggsigs[i] = \\sum_{j <= i}  sigs[j], where sigs[j] is a signature on msgs[j] under pks[j]\n        let aggsigs = vector[\n            AggrOrMultiSignature { bytes: x"a2bc8bdebe6215ba74b5b53c5ed2aa0c68221a4adf868989ccdcfb62bb0eecc6537def9ee686a7960169c5917d25e5220177ed1c5e95ecfd68c09694062e76efcb00759beac874e4f9a715fd144210883bf9bb272f156b0a1fa15d0e9460f01f" },\n            AggrOrMultiSignature { bytes: x"a523aa3c3f1f1074d968ffecf017c7b93ae5243006bf0abd2e45c036ddbec99302984b650ebe5ba306cda4071d281ba50a99ef0e66c3957fab94163296f9d673fc58a36de4276f82bfb1d9180b591df93b5c2804d40dd68cf0f72cd92f86442e" },\n            AggrOrMultiSignature { bytes: x"abed10f464de74769121fc09715e59a3ac96a5054a43a9d43cc890a2d4d332614c74c7fb4cceef6d25f85c65dee337330f062f89f23fec9ecf7ce3193fbba2c886630d753be6a4513a4634428904b767af2f230c5cadbcb53a451dd9c7d977f6" },\n            AggrOrMultiSignature { bytes: x"8362871631ba822742a31209fa4abce6dc94b741ac4725995459da2951324b51efbbf6bc3ab4681e547ebfbadd80e0360dc078c04188198f0acea26c12645ace9107a4a23cf8db46abc7a402637f16a0477c72569fc9966fe804ef4dc0e5e758" },\n            AggrOrMultiSignature { bytes: x"a44d967935fbe63a763ce2dd2b16981f967ecd31e20d3266eef5517530cdc233c8a18273b6d9fd7f61dd39178826e3f115df4e7b304f2de17373a95ea0c9a14293dcfd6f0ef416e06fa23f6a3c850d638e4d8f97ab4562ef55d49a96a50baa13" },\n        ];\n\n        let i = 0;\n        let msg_subset = std::vector::empty<vector<u8>>();\n        let pk_subset = std::vector::empty<PublicKeyWithPoP>();\n        while (i < std::vector::length(&pks)) {\n            let aggsig = *std::vector::borrow(&aggsigs, i);\n\n            std::vector::push_back(&mut pk_subset, *std::vector::borrow(&pks, i));\n            std::vector::push_back(&mut msg_subset, *std::vector::borrow(&msgs, i));\n\n            assert!(verify_aggregate_signature(&aggsig, pk_subset, msg_subset), 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test]\n    fun test_verify_aggregated_signature_randomized() {\n        let signer_count = 1;\n        let max_signer_count = 5;\n        while (signer_count <= max_signer_count) {\n            // Generate key pairs and messages.\n            let signing_keys = vector[];\n            let public_keys = vector[];\n            let messages: vector<vector<u8>> = vector[];\n            let i = 0;\n            while (i < signer_count) {\n                let (sk, pk) = generate_keys();\n                std::vector::push_back(&mut signing_keys, sk);\n                std::vector::push_back(&mut public_keys, pk);\n                let msg: vector<u8> = vector[104, 101, 108, 108, 111, 32, 97, 112, 116, 111, 115, 32, 117, 115, 101, 114, 32, 48+(i as u8)]; //"hello aptos user {i}"\n                std::vector::push_back(&mut messages, msg);\n                i = i + 1;\n            };\n\n            // Maul messages and public keys.\n            let mauled_public_keys = vector[maul_public_key_with_pop(std::vector::borrow(&public_keys, 0))];\n            let mauled_messages = vector[maul_bytes(std::vector::borrow(&messages, 0))];\n            let i = 1;\n            while (i < signer_count) {\n                let pk = std::vector::borrow(&public_keys, i);\n                let msg = std::vector::borrow(&messages, i);\n                std::vector::push_back(&mut mauled_public_keys, *pk);\n                std::vector::push_back(&mut mauled_messages, *msg);\n                i = i + 1;\n            };\n\n            // Generate aggregated signature.\n            let aggrsig = aggr_sign_arbitrary_bytes(&signing_keys, &messages);\n\n            // Test signature verification.\n            assert!(verify_aggregate_signature(&aggrsig, public_keys, messages), 1);\n            assert!(!verify_aggregate_signature(&maul_aggr_or_multi_signature(&aggrsig), public_keys, messages), 1);\n            assert!(!verify_aggregate_signature(&aggrsig, mauled_public_keys, messages), 1);\n            assert!(!verify_aggregate_signature(&aggrsig, public_keys, mauled_messages), 1);\n\n            // Also test signature aggregation.\n            let signatures = vector[];\n            let i = 0;\n            while (i < signer_count) {\n                let sk = std::vector::borrow(&signing_keys, i);\n                let msg = std::vector::borrow(&messages, i);\n                let sig = sign_arbitrary_bytes(sk, *msg);\n                std::vector::push_back(&mut signatures, sig);\n                i = i + 1;\n            };\n            let aggrsig_another = option::extract(&mut aggregate_signatures(signatures));\n            assert!(aggr_or_multi_signature_to_bytes(&aggrsig_another) == aggr_or_multi_signature_to_bytes(&aggrsig), 1);\n\n            signer_count = signer_count + 1;\n        }\n    }\n\n    #[test]\n    /// Tests verification of a random BLS signature created using sk = x""\n    fun test_verify_normal_and_verify_sigshare() {\n        // Test case generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in\n        // `crates/aptos-crypto`\n        // =============================================================================================================\n        // SK:        077c8a56f26259215a4a245373ab6ddf328ac6e00e5ea38d8700efa361bdc58d\n\n        let message = b"Hello Aptos!";\n\n        // First, test signatures that verify\n        let ok = verify_normal_signature(\n            &signature_from_bytes(x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7"),\n            &option::extract(&mut public_key_from_bytes(x"94209a296b739577cb076d3bfb1ca8ee936f29b69b7dae436118c4dd1cc26fd43dcd16249476a006b8b949bf022a7858")),\n            message,\n        );\n        assert!(ok == true, 1);\n\n        let pk = option::extract(&mut public_key_from_bytes(x"94209a296b739577cb076d3bfb1ca8ee936f29b69b7dae436118c4dd1cc26fd43dcd16249476a006b8b949bf022a7858"));\n        let pk_with_pop = PublicKeyWithPoP { bytes: pk.bytes };\n\n        let ok = verify_signature_share(\n            &signature_from_bytes(x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7"),\n            &pk_with_pop,\n            message,\n        );\n        assert!(ok == true, 1);\n\n        // Second, test signatures that do NOT verify\n        let sigs = vector[\n            Signature { bytes: x"a01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7" },\n            Signature { bytes: x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7" },\n            Signature { bytes: x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7" },\n        ];\n        let pks = vector[\n            x"94209a296b739577cb076d3bfb1ca8ee936f29b69b7dae436118c4dd1cc26fd43dcd16249476a006b8b949bf022a7858",\n            x"ae4851bb9e7782027437ed0e2c026dd63b77a972ddf4bd9f72bcc218e327986568317e3aa9f679c697a2cb7cebf992f3",\n            x"82ed7bb5528303a2e306775040a7309e0bd597b70d9949d8c6198a01a7be0b00079320ebfeaf7bbd5bfe86809940d252",\n        ];\n        let messages = vector[\n            b"Hello Aptos!",\n            b"Hello Aptos!",\n            b"Bello Aptos!",\n        ];\n\n        let i = 0;\n        while (i < std::vector::length(&pks)) {\n            let sig = std::vector::borrow(&sigs, i);\n            let pk = *std::vector::borrow(&pks, i);\n            let msg = *std::vector::borrow(&messages, i);\n\n            let pk = option::extract(&mut public_key_from_bytes(pk));\n\n            let notok = verify_normal_signature(\n                sig,\n                &pk,\n                msg,\n            );\n            assert!(notok == false, 1);\n\n            let notok = verify_signature_share(\n                sig,\n                &PublicKeyWithPoP { bytes: pk.bytes },\n                msg,\n            );\n            assert!(notok == false, 1);\n\n            i = i + 1;\n        }\n    }\n\n    #[test]\n    fun test_verify_normal_signature_or_signature_share_randomized() {\n        let (sk, pkpop) = generate_keys();\n        let pk = public_key_with_pop_to_normal(&pkpop);\n\n        let msg = b"hello world";\n        let sig = sign_arbitrary_bytes(&sk, msg);\n        assert!(verify_normal_signature(&sig, &pk, msg), 1);\n        assert!(!verify_normal_signature(&maul_signature(&sig), &pk, msg), 1);\n        assert!(!verify_normal_signature(&sig, &maul_public_key(&pk), msg), 1);\n        assert!(!verify_normal_signature(&sig, &pk, maul_bytes(&msg)), 1);\n\n        assert!(verify_signature_share(&sig, &pkpop, msg), 1);\n        assert!(!verify_signature_share(&maul_signature(&sig), &pkpop, msg), 1);\n        assert!(!verify_signature_share(&sig, &maul_public_key_with_pop(&pkpop), msg), 1);\n        assert!(!verify_signature_share(&sig, &pkpop, maul_bytes(&msg)), 1);\n    }\n\n    #[test]\n    /// Tests verification of random BLS proofs-of-possession (PoPs)\n    fun test_verify_pop() {\n        // Test case generated by running `cargo test -- sample_pop --nocapture --include-ignored` in `crates/aptos-crypto`\n        // =============================================================================================================\n\n        let pks = vector[\n            x"808864c91ae7a9998b3f5ee71f447840864e56d79838e4785ff5126c51480198df3d972e1e0348c6da80d396983e42d7",\n            x"8843843c76d167c02842a214c21277bad0bfd83da467cb5cf2d3ee67b2dcc7221b9fafa6d430400164012580e0c34d27",\n            x"a23b524d4308d46e43ee8cbbf57f3e1c20c47061ad9c3f915212334ea6532451dd5c01d3d3ada6bea10fe180b2c3b450",\n            x"a2aaa3eae1df3fc36365491afa1da5181acbb03801afd1430f04bb3b3eb18036f8b756b3508e4caee04beff50d455d1c",\n            x"84985b7e983dbdaddfca1f0b7dad9660bb39fff660e329acec15f69ac48c75dfa5d2df9f0dc320e4e7b7658166e0ac1c",\n        ];\n\n        let pops = vector[\n            proof_of_possession_from_bytes(x"ab42afff92510034bf1232a37a0d31bc8abfc17e7ead9170d2d100f6cf6c75ccdcfedbd31699a112b4464a06fd636f3f190595863677d660b4c5d922268ace421f9e86e3a054946ee34ce29e1f88c1a10f27587cf5ec528d65ba7c0dc4863364"),\n            proof_of_possession_from_bytes(x"a6da5f2bc17df70ce664cff3e3a3e09d17162e47e652032b9fedc0c772fd5a533583242cba12095602e422e579c5284b1735009332dbdd23430bbcf61cc506ae37e41ff9a1fc78f0bc0d99b6bc7bf74c8f567dfb59079a035842bdc5fa3a0464"),\n            proof_of_possession_from_bytes(x"b8eef236595e2eab34d3c1abdab65971f5cfa1988c731ef62bd63c9a9ad3dfc9259f4f183bfffbc8375a38ba62e1c41a11173209705996ce889859bcbb3ddd7faa3c4ea3d8778f30a9ff814fdcfea1fb163d745c54dfb4dcc5a8cee092ee0070"),\n            proof_of_possession_from_bytes(x"a03a12fab68ad59d85c15dd1528560eff2c89250070ad0654ba260fda4334da179811d2ecdaca57693f80e9ce977d62011e3b1ee7bb4f7e0eb9b349468dd758f10fc35d54e0d0b8536ca713a77a301944392a5c192b6adf2a79ae2b38912dc98"),\n            proof_of_possession_from_bytes(x"8899b294f3c066e6dfb59bc0843265a1ccd6afc8f0f38a074d45ded8799c39d25ee0376cd6d6153b0d4d2ff8655e578b140254f1287b9e9df4e2aecc5b049d8556a4ab07f574df68e46348fd78e5298b7913377cf5bb3cf4796bfc755902bfdd"),\n        ];\n\n        assert!(std::vector::length(&pks) == std::vector::length(&pops), 1);\n\n        let i = 0;\n        while (i < std::vector::length(&pks)) {\n            let opt_pk = public_key_from_bytes_with_pop(*std::vector::borrow(&pks, i), std::vector::borrow(&pops, i));\n            assert!(option::is_some(&opt_pk), 1);\n\n            i = i + 1;\n        };\n\n        // assert first PK\'s PoP does not verify against modifed PK\' = 0xa0 | PK[1:]\n        let opt_pk = public_key_from_bytes_with_pop(\n            x"a08864c91ae7a9998b3f5ee71f447840864e56d79838e4785ff5126c51480198df3d972e1e0348c6da80d396983e42d7",\n            &proof_of_possession_from_bytes(x"ab42afff92510034bf1232a37a0d31bc8abfc17e7ead9170d2d100f6cf6c75ccdcfedbd31699a112b4464a06fd636f3f190595863677d660b4c5d922268ace421f9e86e3a054946ee34ce29e1f88c1a10f27587cf5ec528d65ba7c0dc4863364"));\n        assert!(option::is_none(&opt_pk), 1);\n\n        // assert first PK\'s PoP does not verify if modifed as pop\' = 0xb0 | pop[1:]\n        let opt_pk = public_key_from_bytes_with_pop(\n            x"808864c91ae7a9998b3f5ee71f447840864e56d79838e4785ff5126c51480198df3d972e1e0348c6da80d396983e42d7",\n            &proof_of_possession_from_bytes(x"bb42afff92510034bf1232a37a0d31bc8abfc17e7ead9170d2d100f6cf6c75ccdcfedbd31699a112b4464a06fd636f3f190595863677d660b4c5d922268ace421f9e86e3a054946ee34ce29e1f88c1a10f27587cf5ec528d65ba7c0dc4863364"));\n        assert!(option::is_none(&opt_pk), 1);\n    }\n\n    #[test]\n    fun test_verify_pop_randomized() {\n        let (sk, pk) = generate_keys();\n        let pk_bytes = public_key_with_pop_to_bytes(&pk);\n        let pop = generate_proof_of_possession(&sk);\n        assert!(option::is_some(&public_key_from_bytes_with_pop(pk_bytes, &pop)), 1);\n        assert!(option::is_none(&public_key_from_bytes_with_pop(pk_bytes, &maul_proof_of_possession(&pop))), 1);\n        assert!(option::is_none(&public_key_from_bytes_with_pop(maul_bytes(&pk_bytes), &pop)), 1);\n    }\n}\n', "name": "bls12381.move" }, { "content": '/// This module defines marker types, constants and test cases for working with BLS12-381 curves\n/// using the generic API defined in `algebra.move`.\n/// See https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-\n/// for the full specification of BLS12-381 curves.\n///\n/// Currently-supported BLS12-381 structures include `Fq12`, `Fr`, `G1`, `G2` and `Gt`,\n/// along with their widely-used serialization formats,\n/// the pairing between `G1`, `G2` and `Gt`,\n/// and the hash-to-curve operations for `G1` and `G2` defined in https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16.\n///\n/// Other unimplemented BLS12-381 structures and serialization formats are also listed here,\n/// as they help define some of the currently supported structures.\n/// Their implementation may also be added in the future.\n///\n/// `Fq`: the finite field $F_q$ used in BLS12-381 curves with a prime order $q$ equal to\n/// 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab.\n///\n/// `FormatFqLsb`: a serialization format for `Fq` elements,\n/// where an element is represented by a byte array `b[]` of size 48 with the least significant byte (LSB) coming first.\n///\n/// `FormatFqMsb`: a serialization format for `Fq` elements,\n/// where an element is represented by a byte array `b[]` of size 48 with the most significant byte (MSB) coming first.\n///\n/// `Fq2`: the finite field $F_{q^2}$ used in BLS12-381 curves,\n/// which is an extension field of `Fq`, constructed as $F_{q^2}=F_q[u]/(u^2+1)$.\n///\n/// `FormatFq2LscLsb`: a serialization format for `Fq2` elements,\n/// where an element in the form $(c_0+c_1\\cdot u)$ is represented by a byte array `b[]` of size 96,\n/// which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first:\n/// - `b[0..48]` is $c_0$ serialized using `FormatFqLsb`.\n/// - `b[48..96]` is $c_1$ serialized using `FormatFqLsb`.\n///\n/// `FormatFq2MscMsb`: a serialization format for `Fq2` elements,\n/// where an element in the form $(c_0+c_1\\cdot u)$ is represented by a byte array `b[]` of size 96,\n/// which is a concatenation of its coefficients serialized, with the most significant coefficient (MSC) coming first:\n/// - `b[0..48]` is $c_1$ serialized using `FormatFqLsb`.\n/// - `b[48..96]` is $c_0$ serialized using `FormatFqLsb`.\n///\n/// `Fq6`: the finite field $F_{q^6}$ used in BLS12-381 curves,\n/// which is an extension field of `Fq2`, constructed as $F_{q^6}=F_{q^2}[v]/(v^3-u-1)$.\n///\n/// `FormatFq6LscLsb`: a serialization scheme for `Fq6` elements,\n/// where an element in the form $(c_0+c_1\\cdot v+c_2\\cdot v^2)$ is represented by a byte array `b[]` of size 288,\n/// which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first:\n/// - `b[0..96]` is $c_0$ serialized using `FormatFq2LscLsb`.\n/// - `b[96..192]` is $c_1$ serialized using `FormatFq2LscLsb`.\n/// - `b[192..288]` is $c_2$ serialized using `FormatFq2LscLsb`.\n///\n/// `G1Full`: a group constructed by the points on the BLS12-381 curve $E(F_q): y^2=x^3+4$ and the point at infinity,\n/// under the elliptic curve point addition.\n/// It contains the prime-order subgroup $G_1$ used in pairing.\n///\n/// `G2Full`: a group constructed by the points on a curve $E\'(F_{q^2}): y^2=x^3+4(u+1)$ and the point at infinity,\n/// under the elliptic curve point addition.\n/// It contains the prime-order subgroup $G_2$ used in pairing.\nmodule aptos_std::bls12381_algebra {\n    //\n    // Marker types + serialization formats begin.\n    //\n\n    /// The finite field $F_{q^12}$ used in BLS12-381 curves,\n    /// which is an extension field of `Fq6` (defined in the module documentation), constructed as $F_{q^12}=F_{q^6}[w]/(w^2-v)$.\n    struct Fq12 {}\n\n    /// A serialization scheme for `Fq12` elements,\n    /// where an element $(c_0+c_1\\cdot w)$ is represented by a byte array `b[]` of size 576,\n    /// which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first.\n    /// - `b[0..288]` is $c_0$ serialized using `FormatFq6LscLsb` (defined in the module documentation).\n    /// - `b[288..576]` is $c_1$ serialized using `FormatFq6LscLsb`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.\n    struct FormatFq12LscLsb {}\n\n    /// The group $G_1$ in BLS12-381-based pairing $G_1 \\times G_2 \\rightarrow G_t$.\n    /// It is a subgroup of `G1Full` (defined in the module documentation) with a prime order $r$\n    /// equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.\n    /// (so `Fr` is the associated scalar field).\n    struct G1 {}\n\n    /// A serialization scheme for `G1` elements derived from\n    /// https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.\n    ///\n    /// Below is the serialization procedure that takes a `G1` element `p` and outputs a byte array of size 96.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` and `y` into `b_x[]` and `b_y[]` respectively using `FormatFqMsb` (defined in the module documentation).\n    /// 1. Concatenate `b_x[]` and `b_y[]` into `b[]`.\n    /// 1. If `p` is the point at infinity, set the infinity bit: `b[0]: = b[0] | 0x40`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G1` element or none.\n    /// 1. If the size of `b[]` is not 96, return none.\n    /// 1. Compute the compression flag as `b[0] & 0x80 != 0`.\n    /// 1. If the compression flag is true, return none.\n    /// 1. Compute the infinity flag as `b[0] & 0x40 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Deserialize `[b[0] & 0x1f, b[1], ..., b[47]]` to `x` using `FormatFqMsb`. If `x` is none, return none.\n    /// 1. Deserialize `[b[48], ..., b[95]]` to `y` using `FormatFqMsb`. If `y` is none, return none.\n    /// 1. Check if `(x,y)` is on curve `E`. If not, return none.\n    /// 1. Check if `(x,y)` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y)`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.\n    struct FormatG1Uncompr {}\n\n    /// A serialization scheme for `G1` elements derived from\n    /// https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.\n    ///\n    /// Below is the serialization procedure that takes a `G1` element `p` and outputs a byte array of size 48.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` into `b[]` using `FormatFqMsb` (defined in the module documentation).\n    /// 1. Set the compression bit: `b[0] := b[0] | 0x80`.\n    /// 1. If `p` is the point at infinity, set the infinity bit: `b[0]: = b[0] | 0x40`.\n    /// 1. If `y > -y`, set the lexicographical flag: `b[0] := b[0] | 0x20`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G1` element or none.\n    /// 1. If the size of `b[]` is not 48, return none.\n    /// 1. Compute the compression flag as `b[0] & 0x80 != 0`.\n    /// 1. If the compression flag is false, return none.\n    /// 1. Compute the infinity flag as `b[0] & 0x40 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Compute the lexicographical flag as `b[0] & 0x20 != 0`.\n    /// 1. Deserialize `[b[0] & 0x1f, b[1], ..., b[47]]` to `x` using `FormatFqMsb`. If `x` is none, return none.\n    /// 1. Solve the curve equation with `x` for `y`. If no such `y` exists, return none.\n    /// 1. Let `y\'` be `max(y,-y)` if the lexicographical flag is set, or `min(y,-y)` otherwise.\n    /// 1. Check if `(x,y\')` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y\')`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.\n    struct FormatG1Compr {}\n\n    /// The group $G_2$ in BLS12-381-based pairing $G_1 \\times G_2 \\rightarrow G_t$.\n    /// It is a subgroup of `G2Full` (defined in the module documentation) with a prime order $r$ equal to\n    /// 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.\n    /// (so `Fr` is the scalar field).\n    struct G2 {}\n\n    /// A serialization scheme for `G2` elements derived from\n    /// https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.\n    ///\n    /// Below is the serialization procedure that takes a `G2` element `p` and outputs a byte array of size 192.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` and `y` into `b_x[]` and `b_y[]` respectively using `FormatFq2MscMsb` (defined in the module documentation).\n    /// 1. Concatenate `b_x[]` and `b_y[]` into `b[]`.\n    /// 1. If `p` is the point at infinity, set the infinity bit in `b[]`: `b[0]: = b[0] | 0x40`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G2` element or none.\n    /// 1. If the size of `b[]` is not 192, return none.\n    /// 1. Compute the compression flag as `b[0] & 0x80 != 0`.\n    /// 1. If the compression flag is true, return none.\n    /// 1. Compute the infinity flag as `b[0] & 0x40 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Deserialize `[b[0] & 0x1f, ..., b[95]]` to `x` using `FormatFq2MscMsb`. If `x` is none, return none.\n    /// 1. Deserialize `[b[96], ..., b[191]]` to `y` using `FormatFq2MscMsb`. If `y` is none, return none.\n    /// 1. Check if `(x,y)` is on the curve `E\'`. If not, return none.\n    /// 1. Check if `(x,y)` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y)`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.\n    struct FormatG2Uncompr {}\n\n    /// A serialization scheme for `G2` elements derived from\n    /// https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.\n    ///\n    /// Below is the serialization procedure that takes a `G2` element `p` and outputs a byte array of size 96.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` into `b[]` using `FormatFq2MscMsb` (defined in the module documentation).\n    /// 1. Set the compression bit: `b[0] := b[0] | 0x80`.\n    /// 1. If `p` is the point at infinity, set the infinity bit: `b[0]: = b[0] | 0x40`.\n    /// 1. If `y > -y`, set the lexicographical flag: `b[0] := b[0] | 0x20`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G2` element or none.\n    /// 1. If the size of `b[]` is not 96, return none.\n    /// 1. Compute the compression flag as `b[0] & 0x80 != 0`.\n    /// 1. If the compression flag is false, return none.\n    /// 1. Compute the infinity flag as `b[0] & 0x40 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Compute the lexicographical flag as `b[0] & 0x20 != 0`.\n    /// 1. Deserialize `[b[0] & 0x1f, b[1], ..., b[95]]` to `x` using `FormatFq2MscMsb`. If `x` is none, return none.\n    /// 1. Solve the curve equation with `x` for `y`. If no such `y` exists, return none.\n    /// 1. Let `y\'` be `max(y,-y)` if the lexicographical flag is set, or `min(y,-y)` otherwise.\n    /// 1. Check if `(x,y\')` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y\')`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.\n    struct FormatG2Compr {}\n\n    /// The group $G_t$ in BLS12-381-based pairing $G_1 \\times G_2 \\rightarrow G_t$.\n    /// It is a multiplicative subgroup of `Fq12`,\n    /// with a prime order $r$ equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.\n    /// (so `Fr` is the scalar field).\n    /// The identity of `Gt` is 1.\n    struct Gt {}\n\n    /// A serialization scheme for `Gt` elements.\n    ///\n    /// To serialize, it treats a `Gt` element `p` as an `Fq12` element and serialize it using `FormatFq12LscLsb`.\n    ///\n    /// To deserialize, it uses `FormatFq12LscLsb` to try deserializing to an `Fq12` element then test the membership in `Gt`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.\n    struct FormatGt {}\n\n    /// The finite field $F_r$ that can be used as the scalar fields\n    /// associated with the groups $G_1$, $G_2$, $G_t$ in BLS12-381-based pairing.\n    struct Fr {}\n\n    /// A serialization format for `Fr` elements,\n    /// where an element is represented by a byte array `b[]` of size 32 with the least significant byte (LSB) coming first.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0, blst-0.3.7.\n    struct FormatFrLsb {}\n\n    /// A serialization scheme for `Fr` elements,\n    /// where an element is represented by a byte array `b[]` of size 32 with the most significant byte (MSB) coming first.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0, blst-0.3.7.\n    struct FormatFrMsb {}\n\n    //\n    // (Marker types + serialization formats end here.)\n    // Hash-to-structure suites begin.\n    //\n\n    /// The hash-to-curve suite `BLS12381G1_XMD:SHA-256_SSWU_RO_` that hashes a byte array into `G1` elements.\n    ///\n    /// Full specification is defined in https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#name-bls12-381-g1.\n    struct HashG1XmdSha256SswuRo {}\n\n    /// The hash-to-curve suite `BLS12381G2_XMD:SHA-256_SSWU_RO_` that hashes a byte array into `G2` elements.\n    ///\n    /// Full specification is defined in https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#name-bls12-381-g2.\n    struct HashG2XmdSha256SswuRo {}\n\n    //\n    // (Hash-to-structure suites end here.)\n    // Tests begin.\n    //\n\n    #[test_only]\n    const FQ12_VAL_0_SERIALIZED: vector<u8> = x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ12_VAL_1_SERIALIZED: vector<u8> = x"010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ12_VAL_7_SERIALIZED: vector<u8> = x"070000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ12_VAL_7_NEG_SERIALIZED: vector<u8> = x"a4aafffffffffeb9ffff53b1feffab1e24f6b0f6a0d23067bf1285f3844b7764d7ac4b43b6a71b4b9ae67f39ea11011a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const Q12_SERIALIZED: vector<u8> = x"1175f55da544c7625f8ccb1360e2b1d3ca40747811c8f5ed04440afe232b476c0215676aec05f2a44ac2da6b6d1b7cff075e7b2a587e0aab601a8d3db4f0d29906e5e4d0d78119f396d5a59f0f8d1ca8bca62540be6ab9c12d0ca00de1f311f106278d000e55a393c9766a74e0d08a298450f60d7e666575e3354bf14b8731f4e721c0c180a5ed55c2f8f51f815baecbf96b5fc717eb58ac161a27d1d5f2bdc1a079609b9d6449165b2466b32a01eac7992a1ea0cac2f223cde1d56f9bbccc67afe44621daf858df3fc0eb837818f3e42ab3e131ce4e492efa63c108e6ef91c29ed63b3045baebcb0ab8d203c7f558beaffccba31b12aca7f54b58d0c28340e4fdb3c7c94fe9c4fef9d640ff2fcff02f1748416cbed0981fbff49f0e39eaf8a30273e67ed851944d33d6a593ef5ddcd62da84568822a6045b633bf6a513b3cfe8f9de13e76f8dcbd915980dec205eab6a5c0c72dcebd9afff1d25509ddbf33f8e24131fbd74cda93336514340cf8036b66b09ed9e6a6ac37e22fb3ac407e321beae8cd9fe74c8aaeb4edaa9a7272848fc623f6fe835a2e647379f547fc5ec6371318a85bfa60009cb20ccbb8a467492988a87633c14c0324ba0d0c3e1798ed29c8494cea35023746da05e35d184b4a301d5b2238d665495c6318b5af8653758008952d06cb9e62487b196d64383c73c06d6e1cccdf9b3ce8f95679e7050d949004a55f4ccf95b2552880ae36d1f7e09504d2338316d87d14a064511a295d768113e301bdf9d4383a8be32192d3f2f3b2de14181c73839a7cb4af5301";\n\n    #[test_only]\n    fun rand_vector<S>(num: u64): vector<Element<S>> {\n        let elements = vector[];\n        while (num > 0) {\n            std::vector::push_back(&mut elements, rand_insecure<S>());\n            num = num - 1;\n        };\n        elements\n    }\n\n    #[test(fx = @std)]\n    fun test_fq12(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Constants.\n        assert!(Q12_SERIALIZED == order<Fq12>(), 1);\n\n        // Serialization/deserialization.\n        let val_0 = zero<Fq12>();\n        let val_1 = one<Fq12>();\n        assert!(FQ12_VAL_0_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_0), 1);\n        assert!(FQ12_VAL_1_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_1), 1);\n        let val_7 = from_u64<Fq12>(7);\n        let val_7_another = std::option::extract(&mut deserialize<Fq12, FormatFq12LscLsb>(&FQ12_VAL_7_SERIALIZED));\n        assert!(eq(&val_7, &val_7_another), 1);\n        assert!(FQ12_VAL_7_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_7), 1);\n        assert!(std::option::is_none(&deserialize<Fq12, FormatFq12LscLsb>(&x"ffff")), 1);\n\n        // Negation.\n        let val_minus_7 = neg(&val_7);\n        assert!(FQ12_VAL_7_NEG_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_minus_7), 1);\n\n        // Addition.\n        let val_9 = from_u64<Fq12>(9);\n        let val_2 = from_u64<Fq12>(2);\n        assert!(eq(&val_2, &add(&val_minus_7, &val_9)), 1);\n\n        // Subtraction.\n        assert!(eq(&val_9, &sub(&val_2, &val_minus_7)), 1);\n\n        // Multiplication.\n        let val_63 = from_u64<Fq12>(63);\n        assert!(eq(&val_63, &mul(&val_7, &val_9)), 1);\n\n        // division.\n        let val_0 = from_u64<Fq12>(0);\n        assert!(eq(&val_7, &std::option::extract(&mut div(&val_63, &val_9))), 1);\n        assert!(std::option::is_none(&div(&val_63, &val_0)), 1);\n\n        // Inversion.\n        assert!(eq(&val_minus_7, &neg(&val_7)), 1);\n        assert!(std::option::is_none(&inv(&val_0)), 1);\n\n        // Squaring.\n        let val_x = rand_insecure<Fq12>();\n        assert!(eq(&mul(&val_x, &val_x), &sqr(&val_x)), 1);\n\n        // Downcasting.\n        assert!(eq(&zero<Gt>(), &std::option::extract(&mut downcast<Fq12, Gt>(&val_1))), 1);\n    }\n\n    #[test_only]\n    const R_SERIALIZED: vector<u8> = x"01000000fffffffffe5bfeff02a4bd5305d8a10908d83933487d9d2953a7ed73";\n    #[test_only]\n    const G1_INF_SERIALIZED_COMP: vector<u8> = x"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const G1_INF_SERIALIZED_UNCOMP: vector<u8> = x"400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const G1_GENERATOR_SERIALIZED_COMP: vector<u8> = x"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb";\n    #[test_only]\n    const G1_GENERATOR_SERIALIZED_UNCOMP: vector<u8> = x"17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_SERIALIZED_COMP: vector<u8> = x"b928f3beb93519eecf0145da903b40a4c97dca00b21f12ac0df3be9116ef2ef27b2ae6bcd4c5bc2d54ef5a70627efcb7";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP: vector<u8> = x"1928f3beb93519eecf0145da903b40a4c97dca00b21f12ac0df3be9116ef2ef27b2ae6bcd4c5bc2d54ef5a70627efcb7108dadbaa4b636445639d5ae3089b3c43a8a1d47818edd1839d7383959a41c10fdc66849cfa1b08c5a11ec7e28981a1c";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP: vector<u8> = x"9928f3beb93519eecf0145da903b40a4c97dca00b21f12ac0df3be9116ef2ef27b2ae6bcd4c5bc2d54ef5a70627efcb7";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP: vector<u8> = x"1928f3beb93519eecf0145da903b40a4c97dca00b21f12ac0df3be9116ef2ef27b2ae6bcd4c5bc2d54ef5a70627efcb70973642f94c9b055f4e1d20812c1f91329ed2e3d71f635a72d599a679d0cda1320e597b4e1b24f735fed1381d767908f";\n\n    #[test(fx = @std)]\n    fun test_g1affine(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Constants.\n        assert!(R_SERIALIZED == order<G1>(), 1);\n        let point_at_infinity = zero<G1>();\n        let generator = one<G1>();\n\n        // Serialization/deserialization.\n        assert!(G1_GENERATOR_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&generator), 1);\n        assert!(G1_GENERATOR_SERIALIZED_COMP == serialize<G1, FormatG1Compr>(&generator), 1);\n        let generator_from_comp = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&G1_GENERATOR_SERIALIZED_COMP\n        ));\n        let generator_from_uncomp = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&G1_GENERATOR_SERIALIZED_UNCOMP\n        ));\n        assert!(eq(&generator, &generator_from_comp), 1);\n        assert!(eq(&generator, &generator_from_uncomp), 1);\n\n        // Deserialization should fail if given a byte array of correct size but the value is not a member.\n        assert!(std::option::is_none(&deserialize<Fq12, FormatFq12LscLsb>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<Fq12, FormatFq12LscLsb>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        assert!(\n            G1_INF_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&point_at_infinity), 1);\n        assert!(G1_INF_SERIALIZED_COMP == serialize<G1, FormatG1Compr>(&point_at_infinity), 1);\n        let inf_from_uncomp = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&G1_INF_SERIALIZED_UNCOMP\n        ));\n        let inf_from_comp = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&G1_INF_SERIALIZED_COMP\n        ));\n        assert!(eq(&point_at_infinity, &inf_from_comp), 1);\n        assert!(eq(&point_at_infinity, &inf_from_uncomp), 1);\n\n        let point_7g_from_uncomp = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&G1_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP\n        ));\n        let point_7g_from_comp = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&G1_GENERATOR_MUL_BY_7_SERIALIZED_COMP\n        ));\n        assert!(eq(&point_7g_from_comp, &point_7g_from_uncomp), 1);\n\n        // Deserialization should fail if given a point on the curve but off its prime-order subgroup, e.g., `(0,2)`.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given a valid point in (Fq,Fq) but not on the curve.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"8959e137e0719bf872abb08411010f437a8955bd42f5ba20fca64361af58ce188b1adb96ef229698bb7860b79e24ba12000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given an invalid point (x not in Fq).\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa76e9853b35f5c9b2002d9e5833fd8f9ab4cd3934a4722a06f6055bfca720c91629811e2ecae7f0cf301b6d07898a90f")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"9fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n\n        // Scalar multiplication.\n        let scalar_7 = from_u64<Fr>(7);\n        let point_7g_calc = scalar_mul(&generator, &scalar_7);\n        assert!(eq(&point_7g_calc, &point_7g_from_comp), 1);\n        assert!(G1_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&point_7g_calc), 1);\n        assert!(G1_GENERATOR_MUL_BY_7_SERIALIZED_COMP == serialize<G1, FormatG1Compr>( &point_7g_calc), 1);\n\n        // Multi-scalar multiplication.\n        let num_entries = 1;\n        while (num_entries < 10) {\n            let scalars = rand_vector<Fr>(num_entries);\n            let elements = rand_vector<G1>(num_entries);\n\n            let expected = zero<G1>();\n            let i = 0;\n            while (i < num_entries) {\n                let element = std::vector::borrow(&elements, i);\n                let scalar = std::vector::borrow(&scalars, i);\n                expected = add(&expected, &scalar_mul(element, scalar));\n                i = i + 1;\n            };\n\n            let actual = multi_scalar_mul(&elements, &scalars);\n            assert!(eq(&expected, &actual), 1);\n\n            num_entries = num_entries + 1;\n        };\n\n        // Doubling.\n        let scalar_2 = from_u64<Fr>(2);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_double_g = double(&generator);\n        assert!(eq(&point_2g, &point_double_g), 1);\n\n        // Negation.\n        let point_minus_7g_calc = neg(&point_7g_calc);\n        assert!(G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP == serialize<G1, FormatG1Compr>(&point_minus_7g_calc), 1);\n        assert!(G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&point_minus_7g_calc), 1);\n\n        // Addition.\n        let scalar_9 = from_u64<Fr>(9);\n        let point_9g = scalar_mul(&generator, &scalar_9);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_2g_calc = add(&point_minus_7g_calc, &point_9g);\n        assert!(eq(&point_2g, &point_2g_calc), 1);\n\n        // Subtraction.\n        assert!(eq(&point_9g, &sub(&point_2g, &point_minus_7g_calc)), 1);\n\n        // Hash-to-group using suite `BLS12381G1_XMD:SHA-256_SSWU_RO_`.\n        // Test vectors source: https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#name-bls12381g1_xmdsha-256_sswu_\n        let actual = hash_to<G1, HashG1XmdSha256SswuRo>(&b"QUUX-V01-CS02-with-BLS12381G1_XMD:SHA-256_SSWU_RO_", &b"");\n        let expected = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&x"052926add2207b76ca4fa57a8734416c8dc95e24501772c814278700eed6d1e4e8cf62d9c09db0fac349612b759e79a108ba738453bfed09cb546dbb0783dbb3a5f1f566ed67bb6be0e8c67e2e81a4cc68ee29813bb7994998f3eae0c9c6a265"));\n        assert!(eq(&expected, &actual), 1);\n        let actual = hash_to<G1, HashG1XmdSha256SswuRo>(&b"QUUX-V01-CS02-with-BLS12381G1_XMD:SHA-256_SSWU_RO_", &b"abcdef0123456789");\n        let expected = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&x"11e0b079dea29a68f0383ee94fed1b940995272407e3bb916bbf268c263ddd57a6a27200a784cbc248e84f357ce82d9803a87ae2caf14e8ee52e51fa2ed8eefe80f02457004ba4d486d6aa1f517c0889501dc7413753f9599b099ebcbbd2d709"));\n        assert!(eq(&expected, &actual), 1);\n    }\n\n    #[test_only]\n    const G2_INF_SERIALIZED_UNCOMP: vector<u8> = x"400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const G2_INF_SERIALIZED_COMP: vector<u8> = x"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const G2_GENERATOR_SERIALIZED_UNCOMP: vector<u8> = x"13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb80606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801";\n    #[test_only]\n    const G2_GENERATOR_SERIALIZED_COMP: vector<u8> = x"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP: vector<u8> = x"0d0273f6bf31ed37c3b8d68083ec3d8e20b5f2cc170fa24b9b5be35b34ed013f9a921f1cad1644d4bdb14674247234c8049cd1dbb2d2c3581e54c088135fef36505a6823d61b859437bfc79b617030dc8b40e32bad1fa85b9c0f368af6d38d3c05ecf93654b7a1885695aaeeb7caf41b0239dc45e1022be55d37111af2aecef87799638bec572de86a7437898efa702008b7ae4dbf802c17a6648842922c9467e460a71c88d393ee7af356da123a2f3619e80c3bdcc8e2b1da52f8cd9913ccdd";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_SERIALIZED_COMP: vector<u8> = x"8d0273f6bf31ed37c3b8d68083ec3d8e20b5f2cc170fa24b9b5be35b34ed013f9a921f1cad1644d4bdb14674247234c8049cd1dbb2d2c3581e54c088135fef36505a6823d61b859437bfc79b617030dc8b40e32bad1fa85b9c0f368af6d38d3c";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP: vector<u8> = x"0d0273f6bf31ed37c3b8d68083ec3d8e20b5f2cc170fa24b9b5be35b34ed013f9a921f1cad1644d4bdb14674247234c8049cd1dbb2d2c3581e54c088135fef36505a6823d61b859437bfc79b617030dc8b40e32bad1fa85b9c0f368af6d38d3c141418b3e4c84511f485fcc78b80b8bc623d6f3f1282e6da09f9c1860402272ba7129c72c4fcd2174f8ac87671053a8b1149639c79ffba82a4b71f73b11f186f8016a4686ab17ed0ec3d7bc6e476c6ee04c3f3c2d48b1d4ddfac073266ebddce";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP: vector<u8> = x"ad0273f6bf31ed37c3b8d68083ec3d8e20b5f2cc170fa24b9b5be35b34ed013f9a921f1cad1644d4bdb14674247234c8049cd1dbb2d2c3581e54c088135fef36505a6823d61b859437bfc79b617030dc8b40e32bad1fa85b9c0f368af6d38d3c";\n\n    #[test(fx = @std)]\n    fun test_g2affine(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Special constants.\n        assert!(R_SERIALIZED == order<G2>(), 1);\n        let point_at_infinity = zero<G2>();\n        let generator = one<G2>();\n\n        // Serialization/deserialization.\n        assert!(G2_GENERATOR_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&generator), 1);\n        assert!(G2_GENERATOR_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&generator), 1);\n        let generator_from_uncomp = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&G2_GENERATOR_SERIALIZED_UNCOMP\n        ));\n        let generator_from_comp = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&G2_GENERATOR_SERIALIZED_COMP\n        ));\n        assert!(eq(&generator, &generator_from_comp), 1);\n        assert!(eq(&generator, &generator_from_uncomp), 1);\n        assert!(G2_INF_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&point_at_infinity), 1);\n        assert!(G2_INF_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&point_at_infinity), 1);\n        let inf_from_uncomp = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&G2_INF_SERIALIZED_UNCOMP));\n        let inf_from_comp = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&G2_INF_SERIALIZED_COMP));\n        assert!(eq(&point_at_infinity, &inf_from_comp), 1);\n        assert!(eq(&point_at_infinity, &inf_from_uncomp), 1);\n        let point_7g_from_uncomp = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&G2_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP\n        ));\n        let point_7g_from_comp = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&G2_GENERATOR_MUL_BY_7_SERIALIZED_COMP\n        ));\n        assert!(eq(&point_7g_from_comp, &point_7g_from_uncomp), 1);\n\n        // Deserialization should fail if given a point on the curve but not in the prime-order subgroup.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890ddd862a6308796bf47e2265073c1f7d81afd69f9497fc1403e2e97a866129b43b672295229c21116d4a99f3e5c2ae720a31f181dbed8a93e15f909c20cf69d11a8879adbbe6890740def19814e6d4ed23fb0dcbd79291655caf48b466ac9cae04")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890d")), 1);\n\n        // Deserialization should fail if given a valid point in (Fq2,Fq2) but not on the curve.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given an invalid point (x not in Fq2).\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdd862a6308796bf47e2265073c1f7d81afd69f9497fc1403e2e97a866129b43b672295229c21116d4a99f3e5c2ae720a31f181dbed8a93e15f909c20cf69d11a8879adbbe6890740def19814e6d4ed23fb0dcbd79291655caf48b466ac9cae04")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n\n        // Scalar multiplication.\n        let scalar_7 = from_u64<Fr>(7);\n        let point_7g_calc = scalar_mul(&generator, &scalar_7);\n        assert!(eq(&point_7g_calc, &point_7g_from_comp), 1);\n        assert!(G2_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&point_7g_calc), 1);\n        assert!(G2_GENERATOR_MUL_BY_7_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&point_7g_calc), 1);\n\n        // Multi-scalar multiplication.\n        let num_entries = 1;\n        while (num_entries < 10) {\n            let scalars = rand_vector<Fr>(num_entries);\n            let elements = rand_vector<G2>(num_entries);\n\n            let expected = zero<G2>();\n            let i = 0;\n            while (i < num_entries) {\n                let element = std::vector::borrow(&elements, i);\n                let scalar = std::vector::borrow(&scalars, i);\n                expected = add(&expected, &scalar_mul(element, scalar));\n                i = i + 1;\n            };\n\n            let actual = multi_scalar_mul(&elements, &scalars);\n            assert!(eq(&expected, &actual), 1);\n\n            num_entries = num_entries + 1;\n        };\n\n        // Doubling.\n        let scalar_2 = from_u64<Fr>(2);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_double_g = double(&generator);\n        assert!(eq(&point_2g, &point_double_g), 1);\n\n        // Negation.\n        let point_minus_7g_calc = neg(&point_7g_calc);\n        assert!(G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&point_minus_7g_calc), 1);\n        assert!(G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&point_minus_7g_calc), 1);\n\n        // Addition.\n        let scalar_9 = from_u64<Fr>(9);\n        let point_9g = scalar_mul(&generator, &scalar_9);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_2g_calc = add(&point_minus_7g_calc, &point_9g);\n        assert!(eq(&point_2g, &point_2g_calc), 1);\n\n        // Subtraction.\n        assert!(eq(&point_9g, &sub(&point_2g, &point_minus_7g_calc)), 1);\n\n        // Hash-to-group using suite `BLS12381G2_XMD:SHA-256_SSWU_RO_`.\n        // Test vectors source: https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#name-bls12381g2_xmdsha-256_sswu_\n        let actual = hash_to<G2, HashG2XmdSha256SswuRo>(&b"QUUX-V01-CS02-with-BLS12381G2_XMD:SHA-256_SSWU_RO_", &b"");\n        let expected = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&x"05cb8437535e20ecffaef7752baddf98034139c38452458baeefab379ba13dff5bf5dd71b72418717047f5b0f37da03d0141ebfbdca40eb85b87142e130ab689c673cf60f1a3e98d69335266f30d9b8d4ac44c1038e9dcdd5393faf5c41fb78a12424ac32561493f3fe3c260708a12b7c620e7be00099a974e259ddc7d1f6395c3c811cdd19f1e8dbf3e9ecfdcbab8d60503921d7f6a12805e72940b963c0cf3471c7b2a524950ca195d11062ee75ec076daf2d4bc358c4b190c0c98064fdd92"));\n        assert!(eq(&expected, &actual), 1);\n        let actual = hash_to<G2, HashG2XmdSha256SswuRo>(&b"QUUX-V01-CS02-with-BLS12381G2_XMD:SHA-256_SSWU_RO_", &b"abcdef0123456789");\n        let expected = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&x"190d119345b94fbd15497bcba94ecf7db2cbfd1e1fe7da034d26cbba169fb3968288b3fafb265f9ebd380512a71c3f2c121982811d2491fde9ba7ed31ef9ca474f0e1501297f68c298e9f4c0028add35aea8bb83d53c08cfc007c1e005723cd00bb5e7572275c567462d91807de765611490205a941a5a6af3b1691bfe596c31225d3aabdf15faff860cb4ef17c7c3be05571a0f8d3c08d094576981f4a3b8eda0a8e771fcdcc8ecceaf1356a6acf17574518acb506e435b639353c2e14827c8"));\n        assert!(eq(&expected, &actual), 1);\n    }\n\n    #[test_only]\n    const FQ12_ONE_SERIALIZED: vector<u8> = x"010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const GT_GENERATOR_SERIALIZED: vector<u8> = x"b68917caaa0543a808c53908f694d1b6e7b38de90ce9d83d505ca1ef1b442d2727d7d06831d8b2a7920afc71d8eb50120f17a0ea982a88591d9f43503e94a8f1abaf2e4589f65aafb7923c484540a868883432a5c60e75860b11e5465b1c9a08873ec29e844c1c888cb396933057ffdd541b03a5220eda16b2b3a6728ea678034ce39c6839f20397202d7c5c44bb68134f93193cec215031b17399577a1de5ff1f5b0666bdd8907c61a7651e4e79e0372951505a07fa73c25788db6eb8023519a5aa97b51f1cad1d43d8aabbff4dc319c79a58cafc035218747c2f75daf8f2fb7c00c44da85b129113173d4722f5b201b6b4454062e9ea8ba78c5ca3cadaf7238b47bace5ce561804ae16b8f4b63da4645b8457a93793cbd64a7254f150781019de87ee42682940f3e70a88683d512bb2c3fb7b2434da5dedbb2d0b3fb8487c84da0d5c315bdd69c46fb05d23763f2191aabd5d5c2e12a10b8f002ff681bfd1b2ee0bf619d80d2a795eb22f2aa7b85d5ffb671a70c94809f0dafc5b73ea2fb0657bae23373b4931bc9fa321e8848ef78894e987bff150d7d671aee30b3931ac8c50e0b3b0868effc38bf48cd24b4b811a2995ac2a09122bed9fd9fa0c510a87b10290836ad06c8203397b56a78e9a0c61c77e56ccb4f1bc3d3fcaea7550f3503efe30f2d24f00891cb45620605fcfaa4292687b3a7db7c1c0554a93579e889a121fd8f72649b2402996a084d2381c5043166673b3849e4fd1e7ee4af24aa8ed443f56dfd6b68ffde4435a92cd7a4ac3bc77e1ad0cb728606cf08bf6386e5410f";\n    #[test_only]\n    const GT_GENERATOR_MUL_BY_7_SERIALIZED: vector<u8> = x"2041ea7b66c19680e2c0bb23245a71918753220b31f88a925aa9b1e192e7c188a0b365cb994b3ec5e809206117c6411242b940b10caa37ce734496b3b7c63578a0e3c076f9b31a7ca13a716262e0e4cda4ac994efb9e19893cbfe4d464b9210d099d808a08b3c4c3846e7529984899478639c4e6c46152ef49a04af9c8e6ff442d286c4613a3dac6a4bee4b40e1f6b030f2871dabe4223b250c3181ecd3bc6819004745aeb6bac567407f2b9c7d1978c45ee6712ae46930bc00638383f6696158bad488cbe7663d681c96c035481dbcf78e7a7fbaec3799163aa6914cef3365156bdc3e533a7c883d5974e3462ac6f19e3f9ce26800ae248a45c5f0dd3a48a185969224e6cd6af9a048241bdcac9800d94aeee970e08488fb961e36a769b6c185d185b4605dc9808517196bba9d00a3e37bca466c19187486db104ee03962d39fe473e276355618e44c965f05082bb027a7baa4bcc6d8c0775c1e8a481e77df36ddad91e75a982302937f543a11fe71922dcd4f46fe8f951f91cde412b359507f2b3b6df0374bfe55c9a126ad31ce254e67d64194d32d7955ec791c9555ea5a917fc47aba319e909de82da946eb36e12aff936708402228295db2712f2fc807c95092a86afd71220699df13e2d2fdf2857976cb1e605f72f1b2edabadba3ff05501221fe81333c13917c85d725ce92791e115eb0289a5d0b3330901bb8b0ed146abeb81381b7331f1c508fb14e057b05d8b0190a9e74a3d046dcd24e7ab747049945b3d8a120c4f6d88e67661b55573aa9b361367488a1ef7dffd967d64a1518";\n    #[test_only]\n    const GT_GENERATOR_MUL_BY_7_NEG_SERIALIZED: vector<u8> = x"2041ea7b66c19680e2c0bb23245a71918753220b31f88a925aa9b1e192e7c188a0b365cb994b3ec5e809206117c6411242b940b10caa37ce734496b3b7c63578a0e3c076f9b31a7ca13a716262e0e4cda4ac994efb9e19893cbfe4d464b9210d099d808a08b3c4c3846e7529984899478639c4e6c46152ef49a04af9c8e6ff442d286c4613a3dac6a4bee4b40e1f6b030f2871dabe4223b250c3181ecd3bc6819004745aeb6bac567407f2b9c7d1978c45ee6712ae46930bc00638383f6696158bad488cbe7663d681c96c035481dbcf78e7a7fbaec3799163aa6914cef3365156bdc3e533a7c883d5974e3462ac6f19e3f9ce26800ae248a45c5f0dd3a48a185969224e6cd6af9a048241bdcac9800d94aeee970e08488fb961e36a769b6c184e92a4b9fa2366b1ae8ebdf5542fa1e0ec390c90df40a91e5261800581b5492bd9640d1c5352babc551d1a49998f4517312f55b4339272b28a3e6b0c7d182e2bb61bd7d72b29ae3696db8fafe32b904ab5d0764e46bf21f9a0c9a1f7bedc6b12b9f64820fc8b3fd4a26541472be3c9c93d784cdd53a059d1604bf3292fedd1babfb00398128e3241bc63a5a47b5e9207fcb0c88f7bfddc376a242c9f0c032ba28eec8670f1fa1d47567593b4571c983b8015df91cfa1241b7fb8a57e0e6e01145b98de017eccc2a66e83ced9d83119a505e552467838d35b8ce2f4d7cc9a894f6dee922f35f0e72b7e96f0879b0c8614d3f9e5f5618b5be9b82381628448641a8bb0fd1dffb16c70e6831d8d69f61f2a2ef9e90c421f7a5b1ce7a5d113c7eb01";\n\n    #[test(fx = @std)]\n    fun test_gt(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Special constants.\n        assert!(R_SERIALIZED == order<Gt>(), 1);\n        let identity = zero<Gt>();\n        let generator = one<Gt>();\n\n        // Serialization/deserialization.\n        assert!(GT_GENERATOR_SERIALIZED == serialize<Gt, FormatGt>(&generator), 1);\n        let generator_from_deser = std::option::extract(&mut deserialize<Gt, FormatGt>(&GT_GENERATOR_SERIALIZED));\n        assert!(eq(&generator, &generator_from_deser), 1);\n        assert!(FQ12_ONE_SERIALIZED == serialize<Gt, FormatGt>(&identity), 1);\n        let identity_from_deser = std::option::extract(&mut deserialize<Gt, FormatGt>(&FQ12_ONE_SERIALIZED));\n        assert!(eq(&identity, &identity_from_deser), 1);\n        let element_7g_from_deser = std::option::extract(&mut deserialize<Gt, FormatGt>(&GT_GENERATOR_MUL_BY_7_SERIALIZED\n        ));\n        assert!(std::option::is_none(&deserialize<Gt, FormatGt>(&x"ffff")), 1);\n\n        // Deserialization should fail if given an element in Fq12 but not in the prime-order subgroup.\n        assert!(std::option::is_none(&deserialize<Gt, FormatGt>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<Gt, FormatGt>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n\n        // Element scalar multiplication.\n        let scalar_7 = from_u64<Fr>(7);\n        let element_7g_calc = scalar_mul(&generator, &scalar_7);\n        assert!(eq(&element_7g_calc, &element_7g_from_deser), 1);\n        assert!(GT_GENERATOR_MUL_BY_7_SERIALIZED == serialize<Gt, FormatGt>(&element_7g_calc), 1);\n\n        // Element negation.\n        let element_minus_7g_calc = neg(&element_7g_calc);\n        assert!(GT_GENERATOR_MUL_BY_7_NEG_SERIALIZED == serialize<Gt, FormatGt>(&element_minus_7g_calc), 1);\n\n        // Element addition.\n        let scalar_9 = from_u64<Fr>(9);\n        let element_9g = scalar_mul(&generator, &scalar_9);\n        let scalar_2 = from_u64<Fr>(2);\n        let element_2g = scalar_mul(&generator, &scalar_2);\n        let element_2g_calc = add(&element_minus_7g_calc, &element_9g);\n        assert!(eq(&element_2g, &element_2g_calc), 1);\n\n        // Subtraction.\n        assert!(eq(&element_9g, &sub(&element_2g, &element_minus_7g_calc)), 1);\n\n        // Upcasting to Fq12.\n        assert!(eq(&one<Fq12>(), &upcast<Gt, Fq12>(&identity)), 1);\n    }\n\n    #[test_only]\n    use aptos_std::crypto_algebra::{zero, one, from_u64, eq, deserialize, serialize, neg, add, sub, mul, div, inv, rand_insecure, sqr, order, scalar_mul, multi_scalar_mul, double, hash_to, upcast, enable_cryptography_algebra_natives, pairing, multi_pairing, downcast, Element};\n\n    #[test_only]\n    const FR_VAL_0_SERIALIZED_LSB: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FR_VAL_1_SERIALIZED_LSB: vector<u8> = x"0100000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FR_VAL_7_SERIALIZED_LSB: vector<u8> = x"0700000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FR_VAL_7_SERIALIZED_MSB: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000007";\n    #[test_only]\n    const FR_VAL_7_NEG_SERIALIZED_LSB: vector<u8> = x"fafffffffefffffffe5bfeff02a4bd5305d8a10908d83933487d9d2953a7ed73";\n\n    #[test(fx = @std)]\n    fun test_fr(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Constants.\n        assert!(R_SERIALIZED == order<Fr>(), 1);\n\n        // Serialization/deserialization.\n        let val_0 = zero<Fr>();\n        let val_1 = one<Fr>();\n        assert!(FR_VAL_0_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_0), 1);\n        assert!(FR_VAL_1_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_1), 1);\n        let val_7 = from_u64<Fr>(7);\n        let val_7_2nd = std::option::extract(&mut deserialize<Fr, FormatFrLsb>(&FR_VAL_7_SERIALIZED_LSB));\n        let val_7_3rd = std::option::extract(&mut deserialize<Fr, FormatFrMsb>(&FR_VAL_7_SERIALIZED_MSB));\n        assert!(eq(&val_7, &val_7_2nd), 1);\n        assert!(eq(&val_7, &val_7_3rd), 1);\n        assert!(FR_VAL_7_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_7), 1);\n        assert!(FR_VAL_7_SERIALIZED_MSB == serialize<Fr, FormatFrMsb>(&val_7), 1);\n\n        // Deserialization should fail if given a byte array of right size but the value is not a member.\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrLsb>(&x"01000000fffffffffe5bfeff02a4bd5305d8a10908d83933487d9d2953a7ed73")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrMsb>(&x"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrLsb>(&x"01000000fffffffffe5bfeff02a4bd5305d8a10908d83933487d9d2953a7ed7300")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrMsb>(&x"0073eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrLsb>(&x"ffff")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrMsb>(&x"ffff")), 1);\n\n        // Negation.\n        let val_minus_7 = neg(&val_7);\n        assert!(FR_VAL_7_NEG_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_minus_7), 1);\n\n        // Addition.\n        let val_9 = from_u64<Fr>(9);\n        let val_2 = from_u64<Fr>(2);\n        assert!(eq(&val_2, &add(&val_minus_7, &val_9)), 1);\n\n        // Subtraction.\n        assert!(eq(&val_9, &sub(&val_2, &val_minus_7)), 1);\n\n        // Multiplication.\n        let val_63 = from_u64<Fr>(63);\n        assert!(eq(&val_63, &mul(&val_7, &val_9)), 1);\n\n        // division.\n        let val_0 = from_u64<Fr>(0);\n        assert!(eq(&val_7, &std::option::extract(&mut div(&val_63, &val_9))), 1);\n        assert!(std::option::is_none(&div(&val_63, &val_0)), 1);\n\n        // Inversion.\n        assert!(eq(&val_minus_7, &neg(&val_7)), 1);\n        assert!(std::option::is_none(&inv(&val_0)), 1);\n\n        // Squaring.\n        let val_x = rand_insecure<Fr>();\n        assert!(eq(&mul(&val_x, &val_x), &sqr(&val_x)), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_pairing(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // pairing(a*P,b*Q) == (a*b)*pairing(P,Q)\n        let element_p = rand_insecure<G1>();\n        let element_q = rand_insecure<G2>();\n        let a = rand_insecure<Fr>();\n        let b = rand_insecure<Fr>();\n        let gt_element = pairing<G1, G2,Gt>(&scalar_mul(&element_p, &a), &scalar_mul(&element_q, &b));\n        let gt_element_another = scalar_mul(&pairing<G1, G2,Gt>(&element_p, &element_q), &mul(&a, &b));\n        assert!(eq(&gt_element, &gt_element_another), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_multi_pairing(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Will compute e(a0*P0,b0*Q0)+e(a1*P1,b1*Q1)+e(a2*P2,b2*Q2).\n        let a0 = rand_insecure<Fr>();\n        let a1 = rand_insecure<Fr>();\n        let a2 = rand_insecure<Fr>();\n        let element_p0 = rand_insecure<G1>();\n        let element_p1 = rand_insecure<G1>();\n        let element_p2 = rand_insecure<G1>();\n        let p0_a0 = scalar_mul(&element_p0, &a0);\n        let p1_a1 = scalar_mul(&element_p1, &a1);\n        let p2_a2 = scalar_mul(&element_p2, &a2);\n        let b0 = rand_insecure<Fr>();\n        let b1 = rand_insecure<Fr>();\n        let b2 = rand_insecure<Fr>();\n        let element_q0 = rand_insecure<G2>();\n        let element_q1 = rand_insecure<G2>();\n        let element_q2 = rand_insecure<G2>();\n        let q0_b0 = scalar_mul(&element_q0, &b0);\n        let q1_b1 = scalar_mul(&element_q1, &b1);\n        let q2_b2 = scalar_mul(&element_q2, &b2);\n\n        // Naive method.\n        let n0 = pairing<G1, G2,Gt>(&p0_a0, &q0_b0);\n        let n1 = pairing<G1, G2,Gt>(&p1_a1, &q1_b1);\n        let n2 = pairing<G1, G2,Gt>(&p2_a2, &q2_b2);\n        let n = zero<Gt>();\n        n = add(&n, &n0);\n        n = add(&n, &n1);\n        n = add(&n, &n2);\n\n        // Efficient API.\n        let m = multi_pairing<G1, G2, Gt>(&vector[p0_a0, p1_a1, p2_a2], &vector[q0_b0, q1_b1, q2_b2]);\n        assert!(eq(&n, &m), 1);\n    }\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x010002, location = aptos_std::crypto_algebra)]\n    fun test_multi_pairing_should_abort_when_sizes_mismatch(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let g1_elements = vector[rand_insecure<G1>()];\n        let g2_elements = vector[rand_insecure<G2>(), rand_insecure<G2>()];\n        multi_pairing<G1, G2, Gt>(&g1_elements, &g2_elements);\n    }\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x010002, location = aptos_std::crypto_algebra)]\n    fun test_multi_scalar_mul_should_abort_when_sizes_mismatch(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let elements = vector[rand_insecure<G1>()];\n        let scalars = vector[rand_insecure<Fr>(), rand_insecure<Fr>()];\n        multi_scalar_mul(&elements, &scalars);\n    }\n\n    #[test_only]\n    /// The maximum number of `G1` elements that can be created in a transaction,\n    /// calculated by the current memory limit (1MB) and the in-mem G1 representation size (144 bytes per element).\n    const G1_NUM_MAX: u64 = 1048576 / 144;\n\n    #[test(fx = @std)]\n    fun test_memory_limit(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let remaining = G1_NUM_MAX;\n        while (remaining > 0) {\n            zero<G1>();\n            remaining = remaining - 1;\n        }\n    }\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x090003, location = std::crypto_algebra)]\n    fun test_memory_limit_exceeded_with_g1(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let remaining = G1_NUM_MAX + 1;\n        while (remaining > 0) {\n            zero<G1>();\n            remaining = remaining - 1;\n        }\n    }\n\n    //\n    // (Tests end here.)\n    //\n}\n', "name": "bls12381_algebra.move" }, { "content": '/// This module defines marker types, constants and test cases for working with BN254 curves using the generic API defined in `algebra.move`.\n/// BN254 was sampled as part of the [\\[BCTV14\\]](https://eprint.iacr.org/2013/879.pdf) paper .\n/// The name denotes that it is a Barreto-Naehrig curve of embedding degree 12, defined over a 254-bit (prime) field.\n/// The scalar field is highly 2-adic which supports subgroups of roots of unity of size <= 2^28.\n/// (as (21888242871839275222246405745257275088548364400416034343698204186575808495617 - 1) mod 2^28 = 0)\n///\n/// This curve is also implemented in [libff](https://github.com/scipr-lab/libff/tree/master/libff/algebra/curves/alt_bn128) under the name `bn128`.\n/// It is the same as the `bn254` curve used in Ethereum (eg: [go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/bn254/cloudflare)).\n///\n/// #CAUTION\n/// **This curve does not satisfy the 128-bit security level anymore.**\n///\n/// Its current security is estimated at 128-bits (see "Updating Key Size Estimations for Pairings"; by Barbulescu, Razvan and Duquesne, Sylvain; in Journal of Cryptology; 2019; https://doi.org/10.1007/s00145-018-9280-5)\n///\n///\n/// Curve information:\n/// * Base field: q =\n///   21888242871839275222246405745257275088696311157297823662689037894645226208583\n/// * Scalar field: r =\n///   21888242871839275222246405745257275088548364400416034343698204186575808495617\n/// * valuation(q - 1, 2) = 1\n/// * valuation(r - 1, 2) = 28\n/// * G1 curve equation: y^2 = x^3 + 3\n/// * G2 curve equation: y^2 = x^3 + B, where\n///    * B = 3/(u+9) where Fq2 is represented as Fq\\[u\\]/(u^2+1) =\n///      Fq2(19485874751759354771024239261021720505790618469301721065564631296452457478373,\n///      266929791119991161246907387137283842545076965332900288569378510910307636690)\n///\n///\n/// Currently-supported BN254 structures include `Fq12`, `Fr`, `Fq`, `Fq2`, `G1`, `G2` and `Gt`,\n/// along with their widely-used serialization formats,\n/// the pairing between `G1`, `G2` and `Gt`.\n///\n/// Other unimplemented BN254 structures and serialization formats are also listed here,\n/// as they help define some of the currently supported structures.\n/// Their implementation may also be added in the future.\n///\n/// `Fq2`: The finite field $F_{q^2}$ that can be used as the base field of $G_2$\n/// which is an extension field of `Fq`, constructed as $F_{q^2}=F_{q}[u]/(u^2+1)$.\n///\n/// `FormatFq2LscLsb`: A serialization scheme for `Fq2` elements,\n/// where an element $(c_0+c_1\\cdot u)$ is represented by a byte array `b[]` of size N=64,\n/// which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first.\n/// - `b[0..32]` is $c_0$ serialized using `FormatFqLscLsb`.\n/// - `b[32..64]` is $c_1$ serialized using `FormatFqLscLsb`.\n///\n/// `Fq6`: the finite field $F_{q^6}$ used in BN254 curves,\n/// which is an extension field of `Fq2`, constructed as $F_{q^6}=F_{q^2}[v]/(v^3-u-9)$.\n///\n/// `FormatFq6LscLsb`: a serialization scheme for `Fq6` elements,\n/// where an element in the form $(c_0+c_1\\cdot v+c_2\\cdot v^2)$ is represented by a byte array `b[]` of size 192,\n/// which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first:\n/// - `b[0..64]` is $c_0$ serialized using `FormatFq2LscLsb`.\n/// - `b[64..128]` is $c_1$ serialized using `FormatFq2LscLsb`.\n/// - `b[128..192]` is $c_2$ serialized using `FormatFq2LscLsb`.\n///\n/// `G1Full`: a group constructed by the points on the BN254 curve $E(F_q): y^2=x^3+3$ and the point at infinity,\n/// under the elliptic curve point addition.\n/// It contains the prime-order subgroup $G_1$ used in pairing.\n///\n/// `G2Full`: a group constructed by the points on a curve $E\'(F_{q^2}): y^2=x^3+3/(u+9)$ and the point at infinity,\n/// under the elliptic curve point addition.\n/// It contains the prime-order subgroup $G_2$ used in pairing.\nmodule std::bn254_algebra {\n    //\n    // Marker types + serialization formats begin.\n    //\n\n    /// The finite field $F_r$ that can be used as the scalar fields\n    /// associated with the groups $G_1$, $G_2$, $G_t$ in BN254-based pairing.\n    struct Fr {}\n\n    /// A serialization format for `Fr` elements,\n    /// where an element is represented by a byte array `b[]` of size 32 with the least significant byte (LSB) coming first.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatFrLsb {}\n\n    /// A serialization scheme for `Fr` elements,\n    /// where an element is represented by a byte array `b[]` of size 32 with the most significant byte (MSB) coming first.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatFrMsb {}\n\n    /// The finite field $F_q$ that can be used as the base field of $G_1$\n    struct Fq {}\n\n    /// A serialization format for `Fq` elements,\n    /// where an element is represented by a byte array `b[]` of size 32 with the least significant byte (LSB) coming first.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatFqLsb {}\n\n    /// A serialization scheme for `Fq` elements,\n    /// where an element is represented by a byte array `b[]` of size 32 with the most significant byte (MSB) coming first.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatFqMsb {}\n\n    /// The finite field $F_{q^12}$ used in BN254 curves,\n    /// which is an extension field of `Fq6` (defined in the module documentation), constructed as $F_{q^12}=F_{q^6}[w]/(w^2-v)$.\n    /// The field can downcast to `Gt` if it\'s an element of the multiplicative subgroup `Gt` of `Fq12`\n    /// with a prime order $r$ = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.\n    struct Fq12 {}\n    /// A serialization scheme for `Fq12` elements,\n    /// where an element $(c_0+c_1\\cdot w)$ is represented by a byte array `b[]` of size 384,\n    /// which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first.\n    /// - `b[0..192]` is $c_0$ serialized using `FormatFq6LscLsb` (defined in the module documentation).\n    /// - `b[192..384]` is $c_1$ serialized using `FormatFq6LscLsb`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatFq12LscLsb {}\n\n    /// The group $G_1$ in BN254-based pairing $G_1 \\times G_2 \\rightarrow G_t$.\n    /// It is a subgroup of `G1Full` (defined in the module documentation) with a prime order $r$\n    /// equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.\n    /// (so `Fr` is the associated scalar field).\n    struct G1 {}\n\n    /// A serialization scheme for `G1` elements derived from arkworks.rs.\n    ///\n    /// Below is the serialization procedure that takes a `G1` element `p` and outputs a byte array of size N=64.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` and `y` into `b_x[]` and `b_y[]` respectively using `FormatFqLsb` (defined in the module documentation).\n    /// 1. Concatenate `b_x[]` and `b_y[]` into `b[]`.\n    /// 1. If `p` is the point at infinity, set the infinity bit: `b[N-1]: = b[N-1] | 0b0100_0000`.\n    /// 1. If `y > -y`, set the lexicographical bit:  `b[N-1]: = b[N-1] | 0b1000_0000`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G1` element or none.\n    /// 1. If the size of `b[]` is not N, return none.\n    /// 1. Compute the infinity flag as `b[N-1] & 0b0100_0000 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Deserialize `[b[0], b[1], ..., b[N/2-1]]` to `x` using `FormatFqLsb`. If `x` is none, return none.\n    /// 1. Deserialize `[b[N/2], ..., b[N] & 0b0011_1111]` to `y` using `FormatFqLsb`. If `y` is none, return none.\n    /// 1. Check if `(x,y)` is on curve `E`. If not, return none.\n    /// 1. Check if `(x,y)` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y)`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatG1Uncompr {}\n\n    /// A serialization scheme for `G1` elements derived from arkworks.rs\n    ///\n    /// Below is the serialization procedure that takes a `G1` element `p` and outputs a byte array of size N=32.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` into `b[]` using `FormatFqLsb` (defined in the module documentation).\n    /// 1. If `p` is the point at infinity, set the infinity bit: `b[N-1]: = b[N-1] | 0b0100_0000`.\n    /// 1. If `y > -y`, set the lexicographical flag: `b[N-1] := b[N-1] | 0x1000_0000`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G1` element or none.\n    /// 1. If the size of `b[]` is not N, return none.\n    /// 1. Compute the infinity flag as `b[N-1] & 0b0100_0000 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Compute the lexicographical flag as `b[N-1] & 0b1000_0000 != 0`.\n    /// 1. Deserialize `[b[0], b[1], ..., b[N/2-1] & 0b0011_1111]` to `x` using `FormatFqLsb`. If `x` is none, return none.\n    /// 1. Solve the curve equation with `x` for `y`. If no such `y` exists, return none.\n    /// 1. Let `y\'` be `max(y,-y)` if the lexicographical flag is set, or `min(y,-y)` otherwise.\n    /// 1. Check if `(x,y\')` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y\')`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatG1Compr {}\n\n    /// The group $G_2$ in BN254-based pairing $G_1 \\times G_2 \\rightarrow G_t$.\n    /// It is a subgroup of `G2Full` (defined in the module documentation) with a prime order $r$ equal to\n    /// 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.\n    /// (so `Fr` is the scalar field).\n    struct G2 {}\n\n    /// A serialization scheme for `G2` elements derived from arkworks.rs.\n    ///\n    /// Below is the serialization procedure that takes a `G2` element `p` and outputs a byte array of size N=128.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` and `y` into `b_x[]` and `b_y[]` respectively using `FormatFq2LscLsb` (defined in the module documentation).\n    /// 1. Concatenate `b_x[]` and `b_y[]` into `b[]`.\n    /// 1. If `p` is the point at infinity, set the infinity bit: `b[N-1]: = b[N-1] | 0b0100_0000`.\n    /// 1. If `y > -y`, set the lexicographical bit:  `b[N-1]: = b[N-1] | 0b1000_0000`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G1` element or none.\n    /// 1. If the size of `b[]` is not N, return none.\n    /// 1. Compute the infinity flag as `b[N-1] & 0b0100_0000 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Deserialize `[b[0], b[1], ..., b[N/2-1]]` to `x` using `FormatFq2LscLsb`. If `x` is none, return none.\n    /// 1. Deserialize `[b[N/2], ..., b[N] & 0b0011_1111]` to `y` using `FormatFq2LscLsb`. If `y` is none, return none.\n    /// 1. Check if `(x,y)` is on curve `E`. If not, return none.\n    /// 1. Check if `(x,y)` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y)`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatG2Uncompr {}\n\n    /// A serialization scheme for `G1` elements derived from arkworks.rs\n    ///\n    /// Below is the serialization procedure that takes a `G1` element `p` and outputs a byte array of size N=64.\n    /// 1. Let `(x,y)` be the coordinates of `p` if `p` is on the curve, or `(0,0)` otherwise.\n    /// 1. Serialize `x` into `b[]` using `FormatFq2LscLsb` (defined in the module documentation).\n    /// 1. If `p` is the point at infinity, set the infinity bit: `b[N-1]: = b[N-1] | 0b0100_0000`.\n    /// 1. If `y > -y`, set the lexicographical flag: `b[N-1] := b[N-1] | 0x1000_0000`.\n    /// 1. Return `b[]`.\n    ///\n    /// Below is the deserialization procedure that takes a byte array `b[]` and outputs either a `G1` element or none.\n    /// 1. If the size of `b[]` is not N, return none.\n    /// 1. Compute the infinity flag as `b[N-1] & 0b0100_0000 != 0`.\n    /// 1. If the infinity flag is set, return the point at infinity.\n    /// 1. Compute the lexicographical flag as `b[N-1] & 0b1000_0000 != 0`.\n    /// 1. Deserialize `[b[0], b[1], ..., b[N/2-1] & 0b0011_1111]` to `x` using `FormatFq2LscLsb`. If `x` is none, return none.\n    /// 1. Solve the curve equation with `x` for `y`. If no such `y` exists, return none.\n    /// 1. Let `y\'` be `max(y,-y)` if the lexicographical flag is set, or `min(y,-y)` otherwise.\n    /// 1. Check if `(x,y\')` is in the subgroup of order `r`. If not, return none.\n    /// 1. Return `(x,y\')`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatG2Compr {}\n\n    /// The group $G_t$ in BN254-based pairing $G_1 \\times G_2 \\rightarrow G_t$.\n    /// It is a multiplicative subgroup of `Fq12`, so it  can upcast to `Fq12`.\n    /// with a prime order $r$ equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.\n    /// (so `Fr` is the scalar field).\n    /// The identity of `Gt` is 1.\n    struct Gt {}\n\n    /// A serialization scheme for `Gt` elements.\n    ///\n    /// To serialize, it treats a `Gt` element `p` as an `Fq12` element and serialize it using `FormatFq12LscLsb`.\n    ///\n    /// To deserialize, it uses `FormatFq12LscLsb` to try deserializing to an `Fq12` element then test the membership in `Gt`.\n    ///\n    /// NOTE: other implementation(s) using this format: ark-bn254-0.4.0.\n    struct FormatGt {}\n\n    // Tests begin.\n\n    #[test_only]\n    fun rand_vector<S>(num: u64): vector<Element<S>> {\n        let elements = vector[];\n        while (num > 0) {\n            std::vector::push_back(&mut elements, rand_insecure<S>());\n            num = num - 1;\n        };\n        elements\n    }\n\n\n    #[test_only]\n    const FQ12_VAL_0_SERIALIZED: vector<u8> = x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ12_VAL_1_SERIALIZED: vector<u8> = x"010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ12_VAL_7_SERIALIZED: vector<u8> = x"070000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ12_VAL_7_NEG_SERIALIZED: vector<u8> = x"40fd7cd8168c203c8dca7168916a81975d588181b64550b829a031e1724e643000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const Q12_SERIALIZED: vector<u8> = x"21f186cad2e2d4c1dbaf8a066b0ebf41f734e3f859b1c523a6c1f4d457413fdbe3cd44add090135d3ae519acc30ee3bdb6bfac6573b767e975b18a77d53cdcddebf3672c74da9d1409d51b2b2db7ff000d59e3aa7cf09220159f925c86b65459ca6558c4eaa703bf45d85030ff85cc6a879c7e2c4034f7045faf20e4d3dcfffac5eb6634c3e7b939b69b2be70bdf6b9a4680297839b4e3a48cd746bd4d0ea82749ffb7e71bd9b3fb10aa684d71e6adab1250b1d8604d91b51c76c256a50b60ddba2f52b6cc853ac926c6ea86d09d400b2f2330e5c8e92e38905ba50a50c9e11cd979c284bf1327ccdc051a6da1a4a7eac5cec16757a27a1a2311bedd108a9b21ac0814269e7523a5dd3a1f5f4767ffe504a6cb3994fb0ec98d5cd5da00b9cb1188a85f2aa871ecb8a0f9d64141f1ccd2699c138e0ef9ac4d8d6a692b29db0f38b60eb08426ab46109fbab9a5221bb44dd338aafebcc4e6c10dd933597f3ff44ba41d04e82871447f3a759cfa9397c22c0c77f13618dfb65adc8aacf008";\n\n\n    #[test(fx = @std)]\n    fun test_fq12(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Constants.\n        assert!(Q12_SERIALIZED == order<Fq12>(), 1);\n\n        // Serialization/deserialization.\n        let val_0 = zero<Fq12>();\n        let val_1 = one<Fq12>();\n        assert!(FQ12_VAL_0_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_0), 1);\n        assert!(FQ12_VAL_1_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_1), 1);\n        let val_7 = from_u64<Fq12>(7);\n        let val_7_another = std::option::extract(&mut deserialize<Fq12, FormatFq12LscLsb>(&FQ12_VAL_7_SERIALIZED));\n        assert!(eq(&val_7, &val_7_another), 1);\n        assert!(FQ12_VAL_7_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_7), 1);\n        assert!(std::option::is_none(&deserialize<Fq12, FormatFq12LscLsb>(&x"ffff")), 1);\n\n        // Negation.\n        let val_minus_7 = neg(&val_7);\n        assert!(FQ12_VAL_7_NEG_SERIALIZED == serialize<Fq12, FormatFq12LscLsb>(&val_minus_7), 1);\n\n        // Addition.\n        let val_9 = from_u64<Fq12>(9);\n        let val_2 = from_u64<Fq12>(2);\n        assert!(eq(&val_2, &add(&val_minus_7, &val_9)), 1);\n\n        // Subtraction.\n        assert!(eq(&val_9, &sub(&val_2, &val_minus_7)), 1);\n\n        // Multiplication.\n        let val_63 = from_u64<Fq12>(63);\n        assert!(eq(&val_63, &mul(&val_7, &val_9)), 1);\n\n        // division.\n        let val_0 = from_u64<Fq12>(0);\n        assert!(eq(&val_7, &std::option::extract(&mut div(&val_63, &val_9))), 1);\n        assert!(std::option::is_none(&div(&val_63, &val_0)), 1);\n\n        // Inversion.\n        assert!(eq(&val_minus_7, &neg(&val_7)), 1);\n        assert!(std::option::is_none(&inv(&val_0)), 1);\n\n        // Squaring.\n        let val_x = rand_insecure<Fq12>();\n        assert!(eq(&mul(&val_x, &val_x), &sqr(&val_x)), 1);\n\n        // Downcasting.\n        assert!(eq(&zero<Gt>(), &std::option::extract(&mut downcast<Fq12, Gt>(&val_1))), 1);\n        // upcasting\n        assert!(eq(&val_1, &upcast<Gt, Fq12>(&zero<Gt>())), 1);\n    }\n\n    #[test_only]\n    const R_SERIALIZED: vector<u8> = x"010000f093f5e1439170b97948e833285d588181b64550b829a031e1724e6430";\n    #[test_only]\n    const G1_INF_SERIALIZED_COMP: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000040";\n    #[test_only]\n    const G1_INF_SERIALIZED_UNCOMP: vector<u8> = x"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040";\n    #[test_only]\n    const G1_GENERATOR_SERIALIZED_COMP: vector<u8> = x"0100000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const G1_GENERATOR_SERIALIZED_UNCOMP: vector<u8> = x"01000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_SERIALIZED_COMP: vector<u8> = x"78e0ffab866b3a9876bd01b8ecc66fcb86936277f425539a758dbbd32e2b0717";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP: vector<u8> = x"78e0ffab866b3a9876bd01b8ecc66fcb86936277f425539a758dbbd32e2b07179eafd4607f9f80771bf4185df03bfead7a3719fa4bb57b0152dd30d16cda8a16";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP: vector<u8> = x"78e0ffab866b3a9876bd01b8ecc66fcb86936277f425539a758dbbd32e2b0797";\n    #[test_only]\n    const G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP: vector<u8> = x"78e0ffab866b3a9876bd01b8ecc66fcb86936277f425539a758dbbd32e2b0717a94da87797ec9fc471d6580ba12e83e9e22068876a90d4b6d7c200100674d999";\n\n    #[test(fx = @std)]\n    fun test_g1affine(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Constants.\n        assert!(R_SERIALIZED == order<G1>(), 1);\n        let point_at_infinity = zero<G1>();\n        let generator = one<G1>();\n\n        // Serialization/deserialization.\n        assert!(G1_GENERATOR_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&generator), 1);\n        assert!(G1_GENERATOR_SERIALIZED_COMP == serialize<G1, FormatG1Compr>(&generator), 1);\n        let generator_from_comp = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&G1_GENERATOR_SERIALIZED_COMP));\n        let generator_from_uncomp = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&G1_GENERATOR_SERIALIZED_UNCOMP));\n        assert!(eq(&generator, &generator_from_comp), 1);\n        assert!(eq(&generator, &generator_from_uncomp), 1);\n\n        // Deserialization should fail if given a byte array of correct size but the value is not a member.\n        assert!(std::option::is_none(&deserialize<Fq12, FormatFq12LscLsb>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<Fq12, FormatFq12LscLsb>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        assert!(\n            G1_INF_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&point_at_infinity), 1);\n        assert!(G1_INF_SERIALIZED_COMP == serialize<G1, FormatG1Compr>(&point_at_infinity), 1);\n        let inf_from_uncomp = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&G1_INF_SERIALIZED_UNCOMP\n        ));\n        let inf_from_comp = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&G1_INF_SERIALIZED_COMP\n        ));\n        assert!(eq(&point_at_infinity, &inf_from_comp), 1);\n        assert!(eq(&point_at_infinity, &inf_from_uncomp), 1);\n\n        let point_7g_from_uncomp = std::option::extract(&mut deserialize<G1, FormatG1Uncompr>(&G1_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP\n        ));\n        let point_7g_from_comp = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&G1_GENERATOR_MUL_BY_7_SERIALIZED_COMP\n        ));\n        assert!(eq(&point_7g_from_comp, &point_7g_from_uncomp), 1);\n\n        // Deserialization should fail if given a point on the curve but off its prime-order subgroup, e.g., `(0,2)`.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given a valid point in (Fq,Fq) but not on the curve.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"8959e137e0719bf872abb08411010f437a8955bd42f5ba20fca64361af58ce188b1adb96ef229698bb7860b79e24ba12000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given an invalid point (x not in Fq).\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa76e9853b35f5c9b2002d9e5833fd8f9ab4cd3934a4722a06f6055bfca720c91629811e2ecae7f0cf301b6d07898a90f")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"9fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n\n        // Scalar multiplication.\n        let scalar_7 = from_u64<Fr>(7);\n        let point_7g_calc = scalar_mul(&generator, &scalar_7);\n        assert!(eq(&point_7g_calc, &point_7g_from_comp), 1);\n        assert!(G1_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&point_7g_calc), 1);\n        assert!(G1_GENERATOR_MUL_BY_7_SERIALIZED_COMP == serialize<G1, FormatG1Compr>( &point_7g_calc), 1);\n\n        // Multi-scalar multiplication.\n        let num_entries = 1;\n        while (num_entries < 10) {\n            let scalars = rand_vector<Fr>(num_entries);\n            let elements = rand_vector<G1>(num_entries);\n\n            let expected = zero<G1>();\n            let i = 0;\n            while (i < num_entries) {\n                let element = std::vector::borrow(&elements, i);\n                let scalar = std::vector::borrow(&scalars, i);\n                expected = add(&expected, &scalar_mul(element, scalar));\n                i = i + 1;\n            };\n\n            let actual = multi_scalar_mul(&elements, &scalars);\n            assert!(eq(&expected, &actual), 1);\n\n            num_entries = num_entries + 1;\n        };\n\n        // Doubling.\n        let scalar_2 = from_u64<Fr>(2);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_double_g = double(&generator);\n        assert!(eq(&point_2g, &point_double_g), 1);\n\n        // Negation.\n        let point_minus_7g_calc = neg(&point_7g_calc);\n        assert!(G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP == serialize<G1, FormatG1Compr>(&point_minus_7g_calc), 1);\n        assert!(G1_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP == serialize<G1, FormatG1Uncompr>(&point_minus_7g_calc), 1);\n\n        // Addition.\n        let scalar_9 = from_u64<Fr>(9);\n        let point_9g = scalar_mul(&generator, &scalar_9);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_2g_calc = add(&point_minus_7g_calc, &point_9g);\n        assert!(eq(&point_2g, &point_2g_calc), 1);\n\n        // Subtraction.\n        assert!(eq(&point_9g, &sub(&point_2g, &point_minus_7g_calc)), 1);\n    }\n\n    #[test_only]\n    const G2_INF_SERIALIZED_COMP: vector<u8> = x"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040";\n    #[test_only]\n    const G2_INF_SERIALIZED_UNCOMP: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040";\n    #[test_only]\n    const G2_GENERATOR_SERIALIZED_COMP: vector<u8> = x"edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e19";\n    #[test_only]\n    const G2_GENERATOR_SERIALIZED_UNCOMP: vector<u8> = x"edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e19aa7dfa6601cce64c7bd3430c69e7d1e38f40cb8d8071ab4aeb6d8cdba55ec8125b9722d1dcdaac55f38eb37033314bbc95330c69ad999eec75f05f58d0890609";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP: vector<u8> = x"08b328aa2a1490c3892ae375ba53a257162f1cde012e70edf8fc27435ddc4b2255243646bade3e596dee466e51d40fbe631e55841e085d6ae2bd9a5a01ba03293f23144105e8212ed8df28ca0e8031d47b7a7de372b3ccee1750262af5ff921dd8e03503be1eedbaadf7e6c4a1be3670d14a46da5fafee7adbdeb2a6cdb7c803";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_SERIALIZED_COMP: vector<u8> = x"08b328aa2a1490c3892ae375ba53a257162f1cde012e70edf8fc27435ddc4b2255243646bade3e596dee466e51d40fbe631e55841e085d6ae2bd9a5a01ba0329";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP: vector<u8> = x"08b328aa2a1490c3892ae375ba53a257162f1cde012e70edf8fc27435ddc4b2255243646bade3e596dee466e51d40fbe631e55841e085d6ae2bd9a5a01ba032908da689711a4fe0db5ea489e82ea4fc3e1dd039e439283c911500bb77d4ed1126f1c47d5586d3381dfd28aa3efab4a278c0d3ba75696613d4ec17e3aa5969bac";\n    #[test_only]\n    const G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP: vector<u8> = x"08b328aa2a1490c3892ae375ba53a257162f1cde012e70edf8fc27435ddc4b2255243646bade3e596dee466e51d40fbe631e55841e085d6ae2bd9a5a01ba03a9";\n\n    #[test(fx = @std)]\n    fun test_g2affine(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Special constants.\n        assert!(R_SERIALIZED == order<G2>(), 1);\n        let point_at_infinity = zero<G2>();\n        let generator = one<G2>();\n\n        // Serialization/deserialization.\n        assert!(G2_GENERATOR_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&generator), 1);\n        assert!(G2_GENERATOR_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&generator), 1);\n        let generator_from_uncomp = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&G2_GENERATOR_SERIALIZED_UNCOMP\n        ));\n        let generator_from_comp = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&G2_GENERATOR_SERIALIZED_COMP\n        ));\n        assert!(eq(&generator, &generator_from_comp), 1);\n        assert!(eq(&generator, &generator_from_uncomp), 1);\n        assert!(G2_INF_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&point_at_infinity), 1);\n        assert!(G2_INF_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&point_at_infinity), 1);\n        let inf_from_uncomp = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&G2_INF_SERIALIZED_UNCOMP));\n        let inf_from_comp = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&G2_INF_SERIALIZED_COMP));\n        assert!(eq(&point_at_infinity, &inf_from_comp), 1);\n        assert!(eq(&point_at_infinity, &inf_from_uncomp), 1);\n        let point_7g_from_uncomp = std::option::extract(&mut deserialize<G2, FormatG2Uncompr>(&G2_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP\n        ));\n        let point_7g_from_comp = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&G2_GENERATOR_MUL_BY_7_SERIALIZED_COMP\n        ));\n        assert!(eq(&point_7g_from_comp, &point_7g_from_uncomp), 1);\n\n        // Deserialization should fail if given a point on the curve but not in the prime-order subgroup.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890ddd862a6308796bf47e2265073c1f7d81afd69f9497fc1403e2e97a866129b43b672295229c21116d4a99f3e5c2ae720a31f181dbed8a93e15f909c20cf69d11a8879adbbe6890740def19814e6d4ed23fb0dcbd79291655caf48b466ac9cae04")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890d")), 1);\n\n        // Deserialization should fail if given a valid point in (Fq2,Fq2) but not on the curve.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given an invalid point (x not in Fq2).\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdd862a6308796bf47e2265073c1f7d81afd69f9497fc1403e2e97a866129b43b672295229c21116d4a99f3e5c2ae720a31f181dbed8a93e15f909c20cf69d11a8879adbbe6890740def19814e6d4ed23fb0dcbd79291655caf48b466ac9cae04")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Uncompr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n        assert!(std::option::is_none(&deserialize<G1, FormatG1Compr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n\n        // Scalar multiplication.\n        let scalar_7 = from_u64<Fr>(7);\n        let point_7g_calc = scalar_mul(&generator, &scalar_7);\n        assert!(eq(&point_7g_calc, &point_7g_from_comp), 1);\n        assert!(G2_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&point_7g_calc), 1);\n        assert!(G2_GENERATOR_MUL_BY_7_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&point_7g_calc), 1);\n\n        // Multi-scalar multiplication.\n        let num_entries = 1;\n        while (num_entries < 10) {\n            let scalars = rand_vector<Fr>(num_entries);\n            let elements = rand_vector<G2>(num_entries);\n\n            let expected = zero<G2>();\n            let i = 0;\n            while (i < num_entries) {\n                let element = std::vector::borrow(&elements, i);\n                let scalar = std::vector::borrow(&scalars, i);\n                expected = add(&expected, &scalar_mul(element, scalar));\n                i = i + 1;\n            };\n\n            let actual = multi_scalar_mul(&elements, &scalars);\n            assert!(eq(&expected, &actual), 1);\n\n            num_entries = num_entries + 1;\n        };\n\n        // Doubling.\n        let scalar_2 = from_u64<Fr>(2);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_double_g = double(&generator);\n        assert!(eq(&point_2g, &point_double_g), 1);\n\n        // Negation.\n        let point_minus_7g_calc = neg(&point_7g_calc);\n        assert!(G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&point_minus_7g_calc), 1);\n        assert!(G2_GENERATOR_MUL_BY_7_NEG_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&point_minus_7g_calc), 1);\n\n        // Addition.\n        let scalar_9 = from_u64<Fr>(9);\n        let point_9g = scalar_mul(&generator, &scalar_9);\n        let point_2g = scalar_mul(&generator, &scalar_2);\n        let point_2g_calc = add(&point_minus_7g_calc, &point_9g);\n        assert!(eq(&point_2g, &point_2g_calc), 1);\n\n        // Subtraction.\n        assert!(eq(&point_9g, &sub(&point_2g, &point_minus_7g_calc)), 1);\n    }\n\n    #[test_only]\n    const FQ12_ONE_SERIALIZED: vector<u8> = x"010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const GT_GENERATOR_SERIALIZED: vector<u8> = x"950e879d73631f5eb5788589eb5f7ef8d63e0a28de1ba00dfe4ca9ed3f252b264a8afb8eb4349db466ed1809ea4d7c39bdab7938821f1b0a00a295c72c2de002e01dbdfd0254134efcb1ec877395d25f937719b344adb1a58d129be2d6f2a9132b16a16e8ab030b130e69c69bd20b4c45986e6744a98314b5c1a0f50faa90b04dbaf9ef8aeeee3f50be31c210b598f4752f073987f9d35be8f6770d83f2ffc0af0d18dd9d2dbcdf943825acc12a7a9ddca45e629d962c6bd64908c3930a5541cfe2924dcc5580d5cef7a4bfdec90a91b59926f850d4a7923c01a5a5dbf0f5c094a2b9fb9d415820fa6b40c59bb9eade9c953407b0fc11da350a9d872cad6d3142974ca385854afdf5f583c04231adc5957c8914b6b20dc89660ed7c3bbe7c01d972be2d53ecdb27a1bcc16ac610db95aa7d237c8ff55a898cb88645a0e32530b23d7ebf5dafdd79b0f9c2ac4ba07ce18d3d16cf36e47916c4cae5d08d3afa813972c769e8514533e380c9443b3e1ee5c96fa3a0a73f301b626454721527bf900";\n    #[test_only]\n    const GT_GENERATOR_MUL_BY_7_SERIALIZED: vector<u8> = x"533a587534641b568125fb273eac723c789a347eba9fcfd58d93742b3a0b782fd61bbf6202e04b8a33b6c60150fc62a071cb9ac9749a79031fd0dbb6dd8a1f2bcf1eb450bdf58fd3d124b2e0aaf878d11e96af3051631145a4bf0530b5d19d08bfe2d515530b9059525b2826587f7bf1f146bfd0e91e84411c7722abb7a8c418b20b1660b41e6949beff93b2b36303e74804df3335ab5bd85bfd7959d6fd3101d0bf6f681eb809c9a6c3544db7f81444e5c4fbdd0a31e920616ae08a2ab5f51ebf064c4906c7b29521e8fda3d704830a9a6ef5d455a85ae09216f55fd0e74d0aaf83ad81ba50218f08024910184c9ddab42a28f51912c779556c41c61aba2d075cfc020b61a18a9366c9f71658f00b44369bd86929725cf867a0b8fda694a7134a2790ebf19cbea1f972eedfd51787683f98d80895f630ff0bd513edebd5a217c00e231869178bd41cf47a7c0125379a3926353e5310a578066dfbb974424802b942a8b4f6338d7f9d8b9c4031dc46163a59c58ff503eca69b642398b5a1212b";\n    #[test_only]\n    const GT_GENERATOR_MUL_BY_7_NEG_SERIALIZED: vector<u8> = x"533a587534641b568125fb273eac723c789a347eba9fcfd58d93742b3a0b782fd61bbf6202e04b8a33b6c60150fc62a071cb9ac9749a79031fd0dbb6dd8a1f2bcf1eb450bdf58fd3d124b2e0aaf878d11e96af3051631145a4bf0530b5d19d08bfe2d515530b9059525b2826587f7bf1f146bfd0e91e84411c7722abb7a8c418b20b1660b41e6949beff93b2b36303e74804df3335ab5bd85bfd7959d6fd3101d0bf6f681eb809c9a6c3544db7f81444e5c4fbdd0a31e920616ae08a2ab5f51e88f6308f10c56da66be273c4b965fe8cc3e98bac609df5d796893c81a26616269879cf565c3bffac84c82858791ee4bca82d598c9c33893ed433f01a58943629eb007acdb5ea95a826017a51397a755327bda8178dd3f3bfc1ff78e3cbb9bc1cfdd5ecec24ef619a93578388bb52fa2e1ec0a878214f1fb91dcb1df48678c11887ee59c0ad74956770d6f6eb8f454afd23324c436335ab3f23333627fe0b1c2e8ebad423205893bcef3ed527608e3a8123ffbbf1c04164118e3b0e49bdac4205";\n\n\n    #[test(fx = @std)]\n    fun test_gt(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Special constants.\n        assert!(R_SERIALIZED == order<Gt>(), 1);\n        let identity = zero<Gt>();\n        let generator = one<Gt>();\n\n        // Serialization/deserialization.\n        assert!(GT_GENERATOR_SERIALIZED == serialize<Gt, FormatGt>(&generator), 1);\n        let generator_from_deser = std::option::extract(&mut deserialize<Gt, FormatGt>(&GT_GENERATOR_SERIALIZED));\n        assert!(eq(&generator, &generator_from_deser), 1);\n        assert!(FQ12_ONE_SERIALIZED == serialize<Gt, FormatGt>(&identity), 1);\n        let identity_from_deser = std::option::extract(&mut deserialize<Gt, FormatGt>(&FQ12_ONE_SERIALIZED));\n        assert!(eq(&identity, &identity_from_deser), 1);\n        let element_7g_from_deser = std::option::extract(&mut deserialize<Gt, FormatGt>(&GT_GENERATOR_MUL_BY_7_SERIALIZED\n        ));\n        assert!(std::option::is_none(&deserialize<Gt, FormatGt>(&x"ffff")), 1);\n\n        // Deserialization should fail if given an element in Fq12 but not in the prime-order subgroup.\n        assert!(std::option::is_none(&deserialize<Gt, FormatGt>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<Gt, FormatGt>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab")), 1);\n\n        // Element scalar multiplication.\n        let scalar_7 = from_u64<Fr>(7);\n        let element_7g_calc = scalar_mul(&generator, &scalar_7);\n        assert!(eq(&element_7g_calc, &element_7g_from_deser), 1);\n        assert!(GT_GENERATOR_MUL_BY_7_SERIALIZED == serialize<Gt, FormatGt>(&element_7g_calc), 1);\n\n        // Element negation.\n        let element_minus_7g_calc = neg(&element_7g_calc);\n        assert!(GT_GENERATOR_MUL_BY_7_NEG_SERIALIZED == serialize<Gt, FormatGt>(&element_minus_7g_calc), 1);\n\n        // Element addition.\n        let scalar_9 = from_u64<Fr>(9);\n        let element_9g = scalar_mul(&generator, &scalar_9);\n        let scalar_2 = from_u64<Fr>(2);\n        let element_2g = scalar_mul(&generator, &scalar_2);\n        let element_2g_calc = add(&element_minus_7g_calc, &element_9g);\n        assert!(eq(&element_2g, &element_2g_calc), 1);\n\n        // Subtraction.\n        assert!(eq(&element_9g, &sub(&element_2g, &element_minus_7g_calc)), 1);\n\n        // Upcasting to Fq12.\n        assert!(eq(&one<Fq12>(), &upcast<Gt, Fq12>(&identity)), 1);\n    }\n\n    #[test_only]\n    use aptos_std::crypto_algebra::{zero, one, from_u64, eq, deserialize, serialize, neg, add, sub, mul, div, inv, rand_insecure, sqr, order, scalar_mul, multi_scalar_mul, double, upcast, enable_cryptography_algebra_natives, pairing, multi_pairing, downcast, Element};\n\n    #[test_only]\n    const FR_VAL_0_SERIALIZED_LSB: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FR_VAL_1_SERIALIZED_LSB: vector<u8> = x"0100000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FR_VAL_7_SERIALIZED_LSB: vector<u8> = x"0700000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FR_VAL_7_SERIALIZED_MSB: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000007";\n    #[test_only]\n    const FR_VAL_7_NEG_SERIALIZED_LSB: vector<u8> = x"faffffef93f5e1439170b97948e833285d588181b64550b829a031e1724e6430";\n\n    #[test(fx = @std)]\n    fun test_fr(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Constants.\n        assert!(R_SERIALIZED == order<Fr>(), 1);\n\n        // Serialization/deserialization.\n        let val_0 = zero<Fr>();\n        let val_1 = one<Fr>();\n        assert!(FR_VAL_0_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_0), 1);\n        assert!(FR_VAL_1_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_1), 1);\n        let val_7 = from_u64<Fr>(7);\n        let val_7_2nd = std::option::extract(&mut deserialize<Fr, FormatFrLsb>(&FR_VAL_7_SERIALIZED_LSB));\n        let val_7_3rd = std::option::extract(&mut deserialize<Fr, FormatFrMsb>(&FR_VAL_7_SERIALIZED_MSB));\n        assert!(eq(&val_7, &val_7_2nd), 1);\n        assert!(eq(&val_7, &val_7_3rd), 1);\n        assert!(FR_VAL_7_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_7), 1);\n        assert!(FR_VAL_7_SERIALIZED_MSB == serialize<Fr, FormatFrMsb>(&val_7), 1);\n\n        // Deserialization should fail if given a byte array of right size but the value is not a member.\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrLsb>(&x"01000000fffffffffe5bfeff02a4bd5305d8a10908d83933487d9d2953a7ed73")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrMsb>(&x"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrLsb>(&x"01000000fffffffffe5bfeff02a4bd5305d8a10908d83933487d9d2953a7ed7300")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrMsb>(&x"0073eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrLsb>(&x"ffff")), 1);\n        assert!(std::option::is_none(&deserialize<Fr, FormatFrMsb>(&x"ffff")), 1);\n\n        // Negation.\n        let val_minus_7 = neg(&val_7);\n        assert!(FR_VAL_7_NEG_SERIALIZED_LSB == serialize<Fr, FormatFrLsb>(&val_minus_7), 1);\n\n        // Addition.\n        let val_9 = from_u64<Fr>(9);\n        let val_2 = from_u64<Fr>(2);\n        assert!(eq(&val_2, &add(&val_minus_7, &val_9)), 1);\n\n        // Subtraction.\n        assert!(eq(&val_9, &sub(&val_2, &val_minus_7)), 1);\n\n        // Multiplication.\n        let val_63 = from_u64<Fr>(63);\n        assert!(eq(&val_63, &mul(&val_7, &val_9)), 1);\n\n        // division.\n        let val_0 = from_u64<Fr>(0);\n        assert!(eq(&val_7, &std::option::extract(&mut div(&val_63, &val_9))), 1);\n        assert!(std::option::is_none(&div(&val_63, &val_0)), 1);\n\n        // Inversion.\n        assert!(eq(&val_minus_7, &neg(&val_7)), 1);\n        assert!(std::option::is_none(&inv(&val_0)), 1);\n\n        // Squaring.\n        let val_x = rand_insecure<Fr>();\n        assert!(eq(&mul(&val_x, &val_x), &sqr(&val_x)), 1);\n    }\n\n    #[test_only]\n    const Q_SERIALIZED: vector<u8> = x"47fd7cd8168c203c8dca7168916a81975d588181b64550b829a031e1724e6430";\n    #[test_only]\n    const FQ_VAL_0_SERIALIZED_LSB: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ_VAL_1_SERIALIZED_LSB: vector<u8> = x"0100000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ_VAL_7_SERIALIZED_LSB: vector<u8> = x"0700000000000000000000000000000000000000000000000000000000000000";\n    #[test_only]\n    const FQ_VAL_7_SERIALIZED_MSB: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000007";\n    #[test_only]\n    const FQ_VAL_7_NEG_SERIALIZED_LSB: vector<u8> = x"40fd7cd8168c203c8dca7168916a81975d588181b64550b829a031e1724e6430";\n\n    #[test(fx = @std)]\n    fun test_fq(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Constants.\n        assert!(Q_SERIALIZED == order<Fq>(), 1);\n\n        // Serialization/deserialization.\n        let val_0 = zero<Fq>();\n        let val_1 = one<Fq>();\n        assert!(FQ_VAL_0_SERIALIZED_LSB == serialize<Fq, FormatFqLsb>(&val_0), 1);\n        assert!(FQ_VAL_1_SERIALIZED_LSB == serialize<Fq, FormatFqLsb>(&val_1), 1);\n        let val_7 = from_u64<Fq>(7);\n        let val_7_2nd = std::option::extract(&mut deserialize<Fq, FormatFqLsb>(&FQ_VAL_7_SERIALIZED_LSB));\n        let val_7_3rd = std::option::extract(&mut deserialize<Fq, FormatFqMsb>(&FQ_VAL_7_SERIALIZED_MSB));\n        assert!(eq(&val_7, &val_7_2nd), 1);\n        assert!(eq(&val_7, &val_7_3rd), 1);\n        assert!(FQ_VAL_7_SERIALIZED_LSB == serialize<Fq, FormatFqLsb>(&val_7), 1);\n        assert!(FQ_VAL_7_SERIALIZED_MSB == serialize<Fq, FormatFqMsb>(&val_7), 1);\n\n        // Deserialization should fail if given a byte array of right size but the value is not a member.\n        assert!(std::option::is_none(&deserialize<Fq, FormatFqLsb>(&x"47fd7cd8168c203c8dca7168916a81975d588181b64550b829a031e1724e6430")), 1);\n        assert!(std::option::is_none(&deserialize<Fq, FormatFqMsb>(&x"30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47")), 1);\n\n        // Deserialization should fail if given a byte array of wrong size.\n        assert!(std::option::is_none(&deserialize<Fq, FormatFqLsb>(&x"46fd7cd8168c203c8dca7168916a81975d588181b64550b829a031e1724e643000")), 1);\n        assert!(std::option::is_none(&deserialize<Fq, FormatFqMsb>(&x"30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4600")), 1);\n        assert!(std::option::is_none(&deserialize<Fq, FormatFqLsb>(&x"ffff")), 1);\n        assert!(std::option::is_none(&deserialize<Fq, FormatFqMsb>(&x"ffff")), 1);\n\n        // Negation.\n        let val_minus_7 = neg(&val_7);\n        assert!(FQ_VAL_7_NEG_SERIALIZED_LSB == serialize<Fq, FormatFqLsb>(&val_minus_7), 1);\n\n        // Addition.\n        let val_9 = from_u64<Fq>(9);\n        let val_2 = from_u64<Fq>(2);\n        assert!(eq(&val_2, &add(&val_minus_7, &val_9)), 1);\n\n        // Subtraction.\n        assert!(eq(&val_9, &sub(&val_2, &val_minus_7)), 1);\n\n        // Multiplication.\n        let val_63 = from_u64<Fq>(63);\n        assert!(eq(&val_63, &mul(&val_7, &val_9)), 1);\n\n        // division.\n        let val_0 = from_u64<Fq>(0);\n        assert!(eq(&val_7, &std::option::extract(&mut div(&val_63, &val_9))), 1);\n        assert!(std::option::is_none(&div(&val_63, &val_0)), 1);\n\n        // Inversion.\n        assert!(eq(&val_minus_7, &neg(&val_7)), 1);\n        assert!(std::option::is_none(&inv(&val_0)), 1);\n\n        // Squaring.\n        let val_x = rand_insecure<Fq>();\n        assert!(eq(&mul(&val_x, &val_x), &sqr(&val_x)), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_pairing(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // pairing(a*P,b*Q) == (a*b)*pairing(P,Q)\n        let element_p = rand_insecure<G1>();\n        let element_q = rand_insecure<G2>();\n        let a = rand_insecure<Fr>();\n        let b = rand_insecure<Fr>();\n        let gt_element = pairing<G1, G2,Gt>(&scalar_mul(&element_p, &a), &scalar_mul(&element_q, &b));\n        let gt_element_another = scalar_mul(&pairing<G1, G2,Gt>(&element_p, &element_q), &mul(&a, &b));\n        assert!(eq(&gt_element, &gt_element_another), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_multi_pairing(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Will compute e(a0*P0,b0*Q0)+e(a1*P1,b1*Q1)+e(a2*P2,b2*Q2).\n        let a0 = rand_insecure<Fr>();\n        let a1 = rand_insecure<Fr>();\n        let a2 = rand_insecure<Fr>();\n        let element_p0 = rand_insecure<G1>();\n        let element_p1 = rand_insecure<G1>();\n        let element_p2 = rand_insecure<G1>();\n        let p0_a0 = scalar_mul(&element_p0, &a0);\n        let p1_a1 = scalar_mul(&element_p1, &a1);\n        let p2_a2 = scalar_mul(&element_p2, &a2);\n        let b0 = rand_insecure<Fr>();\n        let b1 = rand_insecure<Fr>();\n        let b2 = rand_insecure<Fr>();\n        let element_q0 = rand_insecure<G2>();\n        let element_q1 = rand_insecure<G2>();\n        let element_q2 = rand_insecure<G2>();\n        let q0_b0 = scalar_mul(&element_q0, &b0);\n        let q1_b1 = scalar_mul(&element_q1, &b1);\n        let q2_b2 = scalar_mul(&element_q2, &b2);\n\n        // Naive method.\n        let n0 = pairing<G1, G2,Gt>(&p0_a0, &q0_b0);\n        let n1 = pairing<G1, G2,Gt>(&p1_a1, &q1_b1);\n        let n2 = pairing<G1, G2,Gt>(&p2_a2, &q2_b2);\n        let n = zero<Gt>();\n        n = add(&n, &n0);\n        n = add(&n, &n1);\n        n = add(&n, &n2);\n\n        // Efficient API.\n        let m = multi_pairing<G1, G2, Gt>(&vector[p0_a0, p1_a1, p2_a2], &vector[q0_b0, q1_b1, q2_b2]);\n        assert!(eq(&n, &m), 1);\n    }\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x010002, location = aptos_std::crypto_algebra)]\n    fun test_multi_pairing_should_abort_when_sizes_mismatch(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let g1_elements = vector[rand_insecure<G1>()];\n        let g2_elements = vector[rand_insecure<G2>(), rand_insecure<G2>()];\n        multi_pairing<G1, G2, Gt>(&g1_elements, &g2_elements);\n    }\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x010002, location = aptos_std::crypto_algebra)]\n    fun test_multi_scalar_mul_should_abort_when_sizes_mismatch(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let elements = vector[rand_insecure<G1>()];\n        let scalars = vector[rand_insecure<Fr>(), rand_insecure<Fr>()];\n        multi_scalar_mul(&elements, &scalars);\n    }\n\n    #[test_only]\n    /// The maximum number of `G1` elements that can be created in a transaction,\n    /// calculated by the current memory limit (1MB) and the in-mem G1 representation size (96 bytes per element).\n    const G1_NUM_MAX: u64 = 1048576 / 96;\n\n    #[test(fx = @std)]\n    fun test_memory_limit(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let remaining = G1_NUM_MAX;\n        while (remaining > 0) {\n            zero<G1>();\n            remaining = remaining - 1;\n        }\n    }\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x090003, location = std::crypto_algebra)]\n    fun test_memory_limit_exceeded_with_g1(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let remaining = G1_NUM_MAX + 1;\n        while (remaining > 0) {\n            zero<G1>();\n            remaining = remaining - 1;\n        }\n    }\n\n    //\n    // (Tests end here.)\n    //\n\n}\n', "name": "bn254_algebra.move" }, { "content": "/// This module provides generic structs/functions for operations of algebraic structures (e.g. fields and groups),\n/// which can be used to build generic cryptographic schemes atop.\n/// E.g., a Groth16 ZK proof verifier can be built to work over any pairing supported in this module.\n///\n/// In general, every structure implements basic operations like (de)serialization, equality check, random sampling.\n///\n/// A group may also implement the following operations. (Additive group notation is assumed.)\n/// - `order()` for getting the group order.\n/// - `zero()` for getting the group identity.\n/// - `one()` for getting the group generator (if exists).\n/// - `neg()` for group element inversion.\n/// - `add()` for group operation (i.e., a group addition).\n/// - `sub()` for group element subtraction.\n/// - `double()` for efficient doubling.\n/// - `scalar_mul()` for group scalar multiplication.\n/// - `multi_scalar_mul()` for efficient group multi-scalar multiplication.\n/// - `hash_to()` for hash-to-group.\n///\n/// A field may also implement the following operations.\n/// - `zero()` for getting the field additive identity.\n/// - `one()` for getting the field multiplicative identity.\n/// - `add()` for field addition.\n/// - `sub()` for field subtraction.\n/// - `mul()` for field multiplication.\n/// - `div()` for field division.\n/// - `neg()` for field negation.\n/// - `inv()` for field inversion.\n/// - `sqr()` for efficient field element squaring.\n/// - `from_u64()` for quick conversion from u64 to field element.\n///\n/// For 3 groups that admit a bilinear map, `pairing()` and `multi_pairing()` may be implemented.\n///\n/// For a subset/superset relationship between 2 structures, `upcast()` and `downcast()` may be implemented.\n/// E.g., in BLS12-381 pairing, since `Gt` is a subset of `Fq12`,\n/// `upcast<Gt, Fq12>()` and `downcast<Fq12, Gt>()` will be supported.\n///\n/// See `*_algebra.move` for currently implemented algebraic structures.\nmodule aptos_std::crypto_algebra {\n    use std::option::{Option, some, none};\n    use std::features;\n\n    const E_NOT_IMPLEMENTED: u64 = 1;\n    const E_NON_EQUAL_LENGTHS: u64 = 2;\n    const E_TOO_MUCH_MEMORY_USED: u64 = 3;\n\n    /// This struct represents an element of a structure `S`.\n    struct Element<phantom S> has copy, drop {\n        handle: u64\n    }\n\n    //\n    // Public functions begin.\n    //\n\n    /// Check if `x == y` for elements `x` and `y` of a structure `S`.\n    public fun eq<S>(x: &Element<S>, y: &Element<S>): bool {\n        abort_unless_cryptography_algebra_natives_enabled();\n        eq_internal<S>(x.handle, y.handle)\n    }\n\n    /// Convert a u64 to an element of a structure `S`.\n    public fun from_u64<S>(value: u64): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: from_u64_internal<S>(value)\n        }\n    }\n\n    /// Return the additive identity of field `S`, or the identity of group `S`.\n    public fun zero<S>(): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: zero_internal<S>()\n        }\n    }\n\n    /// Return the multiplicative identity of field `S`, or a fixed generator of group `S`.\n    public fun one<S>(): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: one_internal<S>()\n        }\n    }\n\n    /// Compute `-x` for an element `x` of a structure `S`.\n    public fun neg<S>(x: &Element<S>): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: neg_internal<S>(x.handle)\n        }\n    }\n\n    /// Compute `x + y` for elements `x` and `y` of structure `S`.\n    public fun add<S>(x: &Element<S>, y: &Element<S>): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: add_internal<S>(x.handle, y.handle)\n        }\n    }\n\n    /// Compute `x - y` for elements `x` and `y` of a structure `S`.\n    public fun sub<S>(x: &Element<S>, y: &Element<S>): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: sub_internal<S>(x.handle, y.handle)\n        }\n    }\n\n    /// Compute `x * y` for elements `x` and `y` of a structure `S`.\n    public fun mul<S>(x: &Element<S>, y: &Element<S>): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: mul_internal<S>(x.handle, y.handle)\n        }\n    }\n\n    /// Try computing `x / y` for elements `x` and `y` of a structure `S`.\n    /// Return none if `y` does not have a multiplicative inverse in the structure `S`\n    /// (e.g., when `S` is a field, and `y` is zero).\n    public fun div<S>(x: &Element<S>, y: &Element<S>): Option<Element<S>> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        let (succ, handle) = div_internal<S>(x.handle, y.handle);\n        if (succ) {\n            some(Element<S> { handle })\n        } else {\n            none()\n        }\n    }\n\n    /// Compute `x^2` for an element `x` of a structure `S`. Faster and cheaper than `mul(x, x)`.\n    public fun sqr<S>(x: &Element<S>): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: sqr_internal<S>(x.handle)\n        }\n    }\n\n    /// Try computing `x^(-1)` for an element `x` of a structure `S`.\n    /// Return none if `x` does not have a multiplicative inverse in the structure `S`\n    /// (e.g., when `S` is a field, and `x` is zero).\n    public fun inv<S>(x: &Element<S>): Option<Element<S>> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        let (succeeded, handle) = inv_internal<S>(x.handle);\n        if (succeeded) {\n            let scalar = Element<S> { handle };\n            some(scalar)\n        } else {\n            none()\n        }\n    }\n\n    /// Compute `2*P` for an element `P` of a structure `S`. Faster and cheaper than `add(P, P)`.\n    public fun double<S>(element_p: &Element<S>): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: double_internal<S>(element_p.handle)\n        }\n    }\n\n    /// Compute `k[0]*P[0]+...+k[n-1]*P[n-1]`, where\n    /// `P[]` are `n` elements of group `G` represented by parameter `elements`, and\n    /// `k[]` are `n` elements of the scalarfield `S` of group `G` represented by parameter `scalars`.\n    ///\n    /// Abort with code `std::error::invalid_argument(E_NON_EQUAL_LENGTHS)` if the sizes of `elements` and `scalars` do not match.\n    public fun multi_scalar_mul<G, S>(elements: &vector<Element<G>>, scalars: &vector<Element<S>>): Element<G> {\n        let element_handles = handles_from_elements(elements);\n        let scalar_handles = handles_from_elements(scalars);\n        Element<G> {\n            handle: multi_scalar_mul_internal<G, S>(element_handles, scalar_handles)\n        }\n    }\n\n    /// Compute `k*P`, where `P` is an element of a group `G` and `k` is an element of the scalar field `S` associated to the group `G`.\n    public fun scalar_mul<G, S>(element_p: &Element<G>, scalar_k: &Element<S>): Element<G> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<G> {\n            handle: scalar_mul_internal<G, S>(element_p.handle, scalar_k.handle)\n        }\n    }\n\n    /// Efficiently compute `e(P[0],Q[0])+...+e(P[n-1],Q[n-1])`,\n    /// where `e: (G1,G2) -> (Gt)` is the pairing function from groups `(G1,G2)` to group `Gt`,\n    /// `P[]` are `n` elements of group `G1` represented by parameter `g1_elements`, and\n    /// `Q[]` are `n` elements of group `G2` represented by parameter `g2_elements`.\n    ///\n    /// Abort with code `std::error::invalid_argument(E_NON_EQUAL_LENGTHS)` if the sizes of `g1_elements` and `g2_elements` do not match.\n    ///\n    /// NOTE: we are viewing the target group `Gt` of the pairing as an additive group,\n    /// rather than a multiplicative one (which is typically the case).\n    public fun multi_pairing<G1,G2,Gt>(g1_elements: &vector<Element<G1>>, g2_elements: &vector<Element<G2>>): Element<Gt> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        let g1_handles = handles_from_elements(g1_elements);\n        let g2_handles = handles_from_elements(g2_elements);\n        Element<Gt> {\n            handle: multi_pairing_internal<G1,G2,Gt>(g1_handles, g2_handles)\n        }\n    }\n\n    /// Compute the pairing function (a.k.a., bilinear map) on a `G1` element and a `G2` element.\n    /// Return an element in the target group `Gt`.\n    public fun pairing<G1,G2,Gt>(element_1: &Element<G1>, element_2: &Element<G2>): Element<Gt> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<Gt> {\n            handle: pairing_internal<G1,G2,Gt>(element_1.handle, element_2.handle)\n        }\n    }\n\n    /// Try deserializing a byte array to an element of an algebraic structure `S` using a given serialization format `F`.\n    /// Return none if the deserialization failed.\n    public fun deserialize<S, F>(bytes: &vector<u8>): Option<Element<S>> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        let (succeeded, handle) = deserialize_internal<S, F>(bytes);\n        if (succeeded) {\n            some(Element<S> { handle })\n        } else {\n            none()\n        }\n    }\n\n    /// Serialize an element of an algebraic structure `S` to a byte array using a given serialization format `F`.\n    public fun serialize<S, F>(element: &Element<S>): vector<u8> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        serialize_internal<S, F>(element.handle)\n    }\n\n    /// Get the order of structure `S`, a big integer little-endian encoded as a byte array.\n    public fun order<S>(): vector<u8> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        order_internal<S>()\n    }\n\n    /// Cast an element of a structure `S` to a parent structure `L`.\n    public fun upcast<S,L>(element: &Element<S>): Element<L> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<L> {\n            handle: upcast_internal<S,L>(element.handle)\n        }\n    }\n\n    /// Try casting an element `x` of a structure `L` to a sub-structure `S`.\n    /// Return none if `x` is not a member of `S`.\n    ///\n    /// NOTE: Membership check in `S` is performed inside, which can be expensive, depending on the structures `L` and `S`.\n    public fun downcast<L,S>(element_x: &Element<L>): Option<Element<S>> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        let (succ, new_handle) = downcast_internal<L,S>(element_x.handle);\n        if (succ) {\n            some(Element<S> { handle: new_handle })\n        } else {\n            none()\n        }\n    }\n\n    /// Hash an arbitrary-length byte array `msg` into structure `S` with a domain separation tag `dst`\n    /// using the given hash-to-structure suite `H`.\n    ///\n    /// NOTE: some hashing methods do not accept a `dst` and will abort if a non-empty one is provided.\n    public fun hash_to<S, H>(dst: &vector<u8>, msg: &vector<u8>): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element {\n            handle: hash_to_internal<S, H>(dst, msg)\n        }\n    }\n\n    #[test_only]\n    /// Generate a random element of an algebraic structure `S`.\n    public fun rand_insecure<S>(): Element<S> {\n        abort_unless_cryptography_algebra_natives_enabled();\n        Element<S> {\n            handle: rand_insecure_internal<S>()\n        }\n    }\n\n    //\n    // (Public functions end here.)\n    // Private functions begin.\n    //\n\n    fun abort_unless_cryptography_algebra_natives_enabled() {\n        if (features::cryptography_algebra_enabled()) return;\n        abort(std::error::not_implemented(0))\n    }\n\n    #[test_only]\n    public fun enable_cryptography_algebra_natives(fx: &signer) {\n        std::features::change_feature_flags_for_testing(fx, vector[std::features::get_cryptography_algebra_natives_feature()], vector[]);\n    }\n\n    fun handles_from_elements<S>(elements: &vector<Element<S>>): vector<u64> {\n        let num_elements = std::vector::length(elements);\n        let element_handles = std::vector::empty();\n        let i = 0;\n        while ({\n            spec {\n                invariant len(element_handles) == i;\n                invariant forall k in 0..i: element_handles[k] == elements[k].handle;\n            };\n            i < num_elements\n        }) {\n            std::vector::push_back(&mut element_handles, std::vector::borrow(elements, i).handle);\n            i = i + 1;\n        };\n        element_handles\n    }\n\n    //\n    // (Private functions end here.)\n    // Native functions begin.\n    //\n\n    native fun add_internal<S>(handle_1: u64, handle_2: u64): u64;\n    native fun deserialize_internal<S, F>(bytes: &vector<u8>): (bool, u64);\n    native fun div_internal<F>(handle_1: u64, handle_2: u64): (bool, u64);\n    native fun double_internal<G>(element_handle: u64): u64;\n    native fun downcast_internal<L,S>(handle: u64): (bool, u64);\n    native fun from_u64_internal<S>(value: u64): u64;\n    native fun eq_internal<S>(handle_1: u64, handle_2: u64): bool;\n    native fun hash_to_internal<S, H>(dst: &vector<u8>, bytes: &vector<u8>): u64;\n    native fun inv_internal<F>(handle: u64): (bool, u64);\n    #[test_only]\n    native fun rand_insecure_internal<S>(): u64;\n    native fun mul_internal<F>(handle_1: u64, handle_2: u64): u64;\n    native fun multi_pairing_internal<G1,G2,Gt>(g1_handles: vector<u64>, g2_handles: vector<u64>): u64;\n    native fun multi_scalar_mul_internal<G, S>(element_handles: vector<u64>, scalar_handles: vector<u64>): u64;\n    native fun neg_internal<F>(handle: u64): u64;\n    native fun one_internal<S>(): u64;\n    native fun order_internal<G>(): vector<u8>;\n    native fun pairing_internal<G1,G2,Gt>(g1_handle: u64, g2_handle: u64): u64;\n    native fun scalar_mul_internal<G, S>(element_handle: u64, scalar_handle: u64): u64;\n    native fun serialize_internal<S, F>(handle: u64): vector<u8>;\n    native fun sqr_internal<G>(handle: u64): u64;\n    native fun sub_internal<G>(handle_1: u64, handle_2: u64): u64;\n    native fun upcast_internal<S,L>(handle: u64): u64;\n    native fun zero_internal<S>(): u64;\n\n    //\n    // (Native functions end here.)\n    // Tests begin.\n    //\n\n    #[test_only]\n    struct MysteriousGroup {}\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x0c0001, location = Self)]\n    fun test_generic_operation_should_abort_with_unsupported_structures(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let _ = order<MysteriousGroup>();\n    }\n    // Tests end.\n}\n", "name": "crypto_algebra.move" }, { "content": '/// Contains functions for:\n///\n///  1. [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) digital signatures: i.e., EdDSA signatures over Edwards25519 curves with co-factor 8\n///\nmodule aptos_std::ed25519 {\n    use std::bcs;\n    use aptos_std::type_info::{Self, TypeInfo};\n    use std::option::{Self, Option};\n\n    //\n    // Error codes\n    //\n\n    /// Wrong number of bytes were given as input when deserializing an Ed25519 public key.\n    const E_WRONG_PUBKEY_SIZE: u64 = 1;\n\n    /// Wrong number of bytes were given as input when deserializing an Ed25519 signature.\n    const E_WRONG_SIGNATURE_SIZE: u64 = 2;\n\n    //\n    // Constants\n    //\n\n    /// The identifier of the Ed25519 signature scheme, which is used when deriving Aptos authentication keys by hashing\n    /// it together with an Ed25519 public key.\n    const SIGNATURE_SCHEME_ID: u8 = 0;\n\n    /// The size of a serialized public key, in bytes.\n    const PUBLIC_KEY_NUM_BYTES: u64 = 32;\n\n    /// The size of a serialized signature, in bytes.\n    const SIGNATURE_NUM_BYTES: u64 = 64;\n\n    //\n    // Structs\n    //\n\n    #[test_only]\n    /// This struct holds an Ed25519 secret key that can be used to generate Ed25519 signatures during testing.\n    struct SecretKey has drop {\n        bytes: vector<u8>\n    }\n\n    /// A BCS-serializable message, which one can verify signatures on via `signature_verify_strict_t`\n    struct SignedMessage<MessageType> has drop {\n        type_info: TypeInfo,\n        inner: MessageType,\n    }\n\n    /// An *unvalidated* Ed25519 public key: not necessarily an elliptic curve point, just a sequence of 32 bytes\n    struct UnvalidatedPublicKey has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A *validated* Ed25519 public key: not necessarily a prime-order point, could be mixed-order, but will never be\n    /// a small-order point.\n    ///\n    /// For now, this struct is not used in any verification functions, but it might be in the future.\n    struct ValidatedPublicKey has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A purported Ed25519 signature that can be verified via `signature_verify_strict` or `signature_verify_strict_t`.\n    struct Signature has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    //\n    // Functions\n    //\n\n    /// Parses the input 32 bytes as an *unvalidated* Ed25519 public key.\n    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {\n        assert!(std::vector::length(&bytes) == PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_WRONG_PUBKEY_SIZE));\n        UnvalidatedPublicKey { bytes }\n    }\n\n    /// Parses the input 32 bytes as a *validated* Ed25519 public key.\n    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {\n        if (public_key_validate_internal(bytes)) {\n            option::some(ValidatedPublicKey {\n                bytes\n            })\n        } else {\n            option::none<ValidatedPublicKey>()\n        }\n    }\n\n    /// Parses the input 64 bytes as a purported Ed25519 signature.\n    public fun new_signature_from_bytes(bytes: vector<u8>): Signature {\n        assert!(std::vector::length(&bytes) == SIGNATURE_NUM_BYTES, std::error::invalid_argument(E_WRONG_SIGNATURE_SIZE));\n        Signature { bytes }\n    }\n\n    /// Converts a ValidatedPublicKey to an UnvalidatedPublicKey, which can be used in the strict verification APIs.\n    public fun public_key_to_unvalidated(pk: &ValidatedPublicKey): UnvalidatedPublicKey {\n        UnvalidatedPublicKey {\n            bytes: pk.bytes\n        }\n    }\n\n    /// Moves a ValidatedPublicKey into an UnvalidatedPublicKey, which can be used in the strict verification APIs.\n    public fun public_key_into_unvalidated(pk: ValidatedPublicKey): UnvalidatedPublicKey {\n        UnvalidatedPublicKey {\n            bytes: pk.bytes\n        }\n    }\n\n    /// Serializes an UnvalidatedPublicKey struct to 32-bytes.\n    public fun unvalidated_public_key_to_bytes(pk: &UnvalidatedPublicKey): vector<u8> {\n        pk.bytes\n    }\n\n    /// Serializes an ValidatedPublicKey struct to 32-bytes.\n    public fun validated_public_key_to_bytes(pk: &ValidatedPublicKey): vector<u8> {\n        pk.bytes\n    }\n\n    /// Serializes a Signature struct to 64-bytes.\n    public fun signature_to_bytes(sig: &Signature): vector<u8> {\n        sig.bytes\n    }\n\n    /// Takes in an *unvalidated* public key and attempts to validate it.\n    /// Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.\n    public fun public_key_validate(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {\n        new_validated_public_key_from_bytes(pk.bytes)\n    }\n\n    /// Verifies a purported Ed25519 `signature` under an *unvalidated* `public_key` on the specified `message`.\n    /// This call will validate the public key by checking it is NOT in the small subgroup.\n    public fun signature_verify_strict(\n        signature: &Signature,\n        public_key: &UnvalidatedPublicKey,\n        message: vector<u8>\n    ): bool {\n        signature_verify_strict_internal(signature.bytes, public_key.bytes, message)\n    }\n\n    /// This function is used to verify a signature on any BCS-serializable type T. For now, it is used to verify the\n    /// proof of private key ownership when rotating authentication keys.\n    public fun signature_verify_strict_t<T: drop>(signature: &Signature, public_key: &UnvalidatedPublicKey, data: T): bool {\n        let encoded = SignedMessage {\n            type_info: type_info::type_of<T>(),\n            inner: data,\n        };\n\n        signature_verify_strict_internal(signature.bytes, public_key.bytes, bcs::to_bytes(&encoded))\n    }\n\n    /// Helper method to construct a SignedMessage struct.\n    public fun new_signed_message<T: drop>(data: T): SignedMessage<T> {\n        SignedMessage {\n            type_info: type_info::type_of<T>(),\n            inner: data,\n        }\n    }\n\n    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.\n    public fun unvalidated_public_key_to_authentication_key(pk: &UnvalidatedPublicKey): vector<u8> {\n        public_key_bytes_to_authentication_key(pk.bytes)\n    }\n\n    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.\n    public fun validated_public_key_to_authentication_key(pk: &ValidatedPublicKey): vector<u8> {\n        public_key_bytes_to_authentication_key(pk.bytes)\n    }\n\n    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.\n    fun public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8> {\n        std::vector::push_back(&mut pk_bytes, SIGNATURE_SCHEME_ID);\n        std::hash::sha3_256(pk_bytes)\n    }\n\n    #[test_only]\n    /// Generates an Ed25519 key pair.\n    public fun generate_keys(): (SecretKey, ValidatedPublicKey) {\n        let (sk_bytes, pk_bytes) = generate_keys_internal();\n        let sk = SecretKey {\n            bytes: sk_bytes\n        };\n        let pk = ValidatedPublicKey {\n            bytes: pk_bytes\n        };\n        (sk,pk)\n    }\n\n    #[test_only]\n    /// Generates an Ed25519 signature for a given byte array using a given signing key.\n    public fun sign_arbitrary_bytes(sk: &SecretKey, msg: vector<u8>): Signature {\n        Signature {\n            bytes: sign_internal(sk.bytes, msg)\n        }\n    }\n\n    #[test_only]\n    /// Generates an Ed25519 signature for given structured data using a given signing key.\n    public fun sign_struct<T:drop>(sk: &SecretKey, data: T): Signature {\n        let encoded = new_signed_message(data);\n        Signature {\n            bytes: sign_internal(sk.bytes, bcs::to_bytes(&encoded))\n        }\n    }\n\n    //\n    // Native functions\n    //\n\n    /// Return `true` if the bytes in `public_key` can be parsed as a valid Ed25519 public key: i.e., it passes\n    /// points-on-curve and not-in-small-subgroup checks.\n    /// Returns `false` otherwise.\n    native fun public_key_validate_internal(bytes: vector<u8>): bool;\n\n    /// Return true if the Ed25519 `signature` on `message` verifies against the Ed25519 `public_key`.\n    /// Returns `false` if either:\n    /// - `signature` or `public key` are of wrong sizes\n    /// - `public_key` does not pass points-on-curve or not-in-small-subgroup checks,\n    /// - `signature` does not pass points-on-curve or not-in-small-subgroup checks,\n    /// - the signature on `message` does not verify.\n    native fun signature_verify_strict_internal(\n        signature: vector<u8>,\n        public_key: vector<u8>,\n        message: vector<u8>\n    ): bool;\n\n    #[test_only]\n    /// Generates an Ed25519 key pair.\n    native fun generate_keys_internal(): (vector<u8>, vector<u8>);\n\n    #[test_only]\n    /// Generates an Ed25519 signature for a given byte array using a given signing key.\n    native fun sign_internal(sk: vector<u8>, msg: vector<u8>): vector<u8>;\n\n    //\n    // Tests\n    //\n\n    #[test_only]\n    struct TestMessage has copy, drop {\n        title: vector<u8>,\n        content: vector<u8>,\n    }\n\n    #[test]\n    fun test_gen_sign_verify_combo() {\n        let (sk, vpk) = generate_keys();\n        let pk = public_key_into_unvalidated(vpk);\n\n        let msg1: vector<u8> = x"0123456789abcdef";\n        let sig1 = sign_arbitrary_bytes(&sk, msg1);\n        assert!(signature_verify_strict(&sig1, &pk, msg1), std::error::invalid_state(1));\n\n        let msg2 = TestMessage {\n            title: b"Some Title",\n            content: b"That is it.",\n        };\n        let sig2 = sign_struct(&sk, copy msg2);\n        assert!(signature_verify_strict_t(&sig2, &pk, copy msg2), std::error::invalid_state(2));\n    }\n\n\n}\n', "name": "ed25519.move" }, { "content": '/// Exports MultiEd25519 multi-signatures in Move.\n/// This module has the exact same interface as the Ed25519 module.\n\nmodule aptos_std::multi_ed25519 {\n    use std::bcs;\n    use std::error;\n    use std::features;\n    use std::option::{Self, Option};\n    use std::vector;\n    use aptos_std::ed25519;\n\n    //\n    // Error codes\n    //\n\n    /// Wrong number of bytes were given as input when deserializing an Ed25519 public key.\n    const E_WRONG_PUBKEY_SIZE: u64 = 1;\n\n    /// Wrong number of bytes were given as input when deserializing an Ed25519 signature.\n    const E_WRONG_SIGNATURE_SIZE: u64 = 2;\n\n    /// The threshold must be in the range `[1, n]`, where n is the total number of signers.\n    const E_INVALID_THRESHOLD_OR_NUMBER_OF_SIGNERS: u64 = 3;\n\n    /// The native functions have not been rolled out yet.\n    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 4;\n\n    //\n    // Constants\n    //\n\n    /// The identifier of the MultiEd25519 signature scheme, which is used when deriving Aptos authentication keys by hashing\n    /// it together with an MultiEd25519 public key.\n    const SIGNATURE_SCHEME_ID: u8 = 1;\n\n    /// The size of an individual Ed25519 public key, in bytes.\n    /// (A MultiEd25519 public key consists of several of these, plus the threshold.)\n    const INDIVIDUAL_PUBLIC_KEY_NUM_BYTES: u64 = 32;\n\n    /// The size of an individual Ed25519 signature, in bytes.\n    /// (A MultiEd25519 signature consists of several of these, plus the signer bitmap.)\n    const INDIVIDUAL_SIGNATURE_NUM_BYTES: u64 = 64;\n\n    /// When serializing a MultiEd25519 public key, the threshold k will be encoded using this many bytes.\n    const THRESHOLD_SIZE_BYTES: u64 = 1;\n\n    /// When serializing a MultiEd25519 signature, the bitmap that indicates the signers will be encoded using this many\n    /// bytes.\n    const BITMAP_NUM_OF_BYTES: u64 = 4;\n\n    /// Max number of ed25519 public keys allowed in multi-ed25519 keys\n    const MAX_NUMBER_OF_PUBLIC_KEYS: u64 = 32;\n\n    //\n    // Structs\n    //\n    #[test_only]\n    struct SecretKey has drop {\n        bytes: vector<u8>,\n    }\n\n    /// An *unvalidated*, k out of n MultiEd25519 public key. The `bytes` field contains (1) several chunks of\n    /// `ed25519::PUBLIC_KEY_NUM_BYTES` bytes, each encoding a Ed25519 PK, and (2) a single byte encoding the threshold k.\n    /// *Unvalidated* means there is no guarantee that the underlying PKs are valid elliptic curve points of non-small\n    /// order.\n    struct UnvalidatedPublicKey has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A *validated* k out of n MultiEd25519 public key. *Validated* means that all the underlying PKs will be\n    /// elliptic curve points that are NOT of small-order. It does not necessarily mean they will be prime-order points.\n    /// This struct encodes the public key exactly as `UnvalidatedPublicKey`.\n    ///\n    /// For now, this struct is not used in any verification functions, but it might be in the future.\n    struct ValidatedPublicKey has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A purported MultiEd25519 multi-signature that can be verified via `signature_verify_strict` or\n    /// `signature_verify_strict_t`. The `bytes` field contains (1) several chunks of `ed25519::SIGNATURE_NUM_BYTES`\n    /// bytes, each encoding a Ed25519 signature, and (2) a `BITMAP_NUM_OF_BYTES`-byte bitmap encoding the signer\n    /// identities.\n    struct Signature has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    //\n    // Functions\n    //\n\n    #[test_only]\n    public fun generate_keys(threshold: u8, n: u8): (SecretKey, ValidatedPublicKey) {\n        assert!(1 <= threshold && threshold <= n, error::invalid_argument(E_INVALID_THRESHOLD_OR_NUMBER_OF_SIGNERS));\n        let (sk_bytes, pk_bytes) = generate_keys_internal(threshold, n);\n        let sk = SecretKey {\n            bytes: sk_bytes\n        };\n        let pk = ValidatedPublicKey {\n            bytes: pk_bytes\n        };\n        (sk, pk)\n    }\n\n    #[test_only]\n    public fun sign_arbitrary_bytes(sk: &SecretKey, msg: vector<u8>) : Signature {\n        Signature {\n            bytes: sign_internal(sk.bytes, msg)\n        }\n    }\n\n    #[test_only]\n    public fun sign_struct<T: drop>(sk: &SecretKey, data: T) : Signature {\n        let encoded = ed25519::new_signed_message(data);\n        Signature {\n            bytes: sign_internal(sk.bytes, bcs::to_bytes(&encoded)),\n        }\n    }\n\n    /// Parses the input 32 bytes as an *unvalidated* MultiEd25519 public key.\n    ///\n    /// NOTE: This function could have also checked that the # of sub-PKs is > 0, but it did not. However, since such\n    /// invalid PKs are rejected during signature verification  (see `bugfix_unvalidated_pk_from_zero_subpks`) they\n    /// will not cause problems.\n    ///\n    /// We could fix this API by adding a new one that checks the # of sub-PKs is > 0, but it is likely not a good idea\n    /// to reproduce the PK validation logic in Move. We should not have done so in the first place. Instead, we will\n    /// leave it as is and continue assuming `UnvalidatedPublicKey` objects could be invalid PKs that will safely be\n    /// rejected during signature verification.\n    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {\n        let len = vector::length(&bytes);\n        let num_sub_pks = len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;\n\n        assert!(num_sub_pks <= MAX_NUMBER_OF_PUBLIC_KEYS, error::invalid_argument(E_WRONG_PUBKEY_SIZE));\n        assert!(len % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES == THRESHOLD_SIZE_BYTES, error::invalid_argument(E_WRONG_PUBKEY_SIZE));\n        UnvalidatedPublicKey { bytes }\n    }\n\n    /// DEPRECATED: Use `new_validated_public_key_from_bytes_v2` instead. See `public_key_validate_internal` comments.\n    ///\n    /// (Incorrectly) parses the input bytes as a *validated* MultiEd25519 public key.\n    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {\n        // Note that `public_key_validate_internal` will check that `vector::length(&bytes) / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES <= MAX_NUMBER_OF_PUBLIC_KEYS`.\n        if (vector::length(&bytes) % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES == THRESHOLD_SIZE_BYTES &&\n            public_key_validate_internal(bytes)) {\n            option::some(ValidatedPublicKey {\n                bytes\n            })\n        } else {\n            option::none<ValidatedPublicKey>()\n        }\n    }\n\n    /// Parses the input bytes as a *validated* MultiEd25519 public key (see `public_key_validate_internal_v2`).\n    public fun new_validated_public_key_from_bytes_v2(bytes: vector<u8>): Option<ValidatedPublicKey> {\n        if (!features::multi_ed25519_pk_validate_v2_enabled()) {\n            abort(error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))\n        };\n\n        if (public_key_validate_v2_internal(bytes)) {\n            option::some(ValidatedPublicKey {\n                bytes\n            })\n        } else {\n            option::none<ValidatedPublicKey>()\n        }\n    }\n\n    /// Parses the input bytes as a purported MultiEd25519 multi-signature.\n    public fun new_signature_from_bytes(bytes: vector<u8>): Signature {\n        assert!(vector::length(&bytes) % INDIVIDUAL_SIGNATURE_NUM_BYTES == BITMAP_NUM_OF_BYTES, error::invalid_argument(E_WRONG_SIGNATURE_SIZE));\n        Signature { bytes }\n    }\n\n    /// Converts a ValidatedPublicKey to an UnvalidatedPublicKey, which can be used in the strict verification APIs.\n    public fun public_key_to_unvalidated(pk: &ValidatedPublicKey): UnvalidatedPublicKey {\n        UnvalidatedPublicKey {\n            bytes: pk.bytes\n        }\n    }\n\n    /// Moves a ValidatedPublicKey into an UnvalidatedPublicKey, which can be used in the strict verification APIs.\n    public fun public_key_into_unvalidated(pk: ValidatedPublicKey): UnvalidatedPublicKey {\n        UnvalidatedPublicKey {\n            bytes: pk.bytes\n        }\n    }\n\n    /// Serializes an UnvalidatedPublicKey struct to 32-bytes.\n    public fun unvalidated_public_key_to_bytes(pk: &UnvalidatedPublicKey): vector<u8> {\n        pk.bytes\n    }\n\n    /// Serializes a ValidatedPublicKey struct to 32-bytes.\n    public fun validated_public_key_to_bytes(pk: &ValidatedPublicKey): vector<u8> {\n        pk.bytes\n    }\n\n    /// Serializes a Signature struct to 64-bytes.\n    public fun signature_to_bytes(sig: &Signature): vector<u8> {\n        sig.bytes\n    }\n\n    /// DEPRECATED: Use `public_key_validate_v2` instead. See `public_key_validate_internal` comments.\n    ///\n    /// Takes in an *unvalidated* public key and attempts to validate it.\n    /// Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.\n    public fun public_key_validate(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {\n        new_validated_public_key_from_bytes(pk.bytes)\n    }\n\n    /// Takes in an *unvalidated* public key and attempts to validate it.\n    /// Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.\n    public fun public_key_validate_v2(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {\n        new_validated_public_key_from_bytes_v2(pk.bytes)\n    }\n\n    /// Verifies a purported MultiEd25519 `multisignature` under an *unvalidated* `public_key` on the specified `message`.\n    /// This call will validate the public key by checking it is NOT in the small subgroup.\n    public fun signature_verify_strict(\n        multisignature: &Signature,\n        public_key: &UnvalidatedPublicKey,\n        message: vector<u8>\n    ): bool {\n        signature_verify_strict_internal(multisignature.bytes, public_key.bytes, message)\n    }\n\n    /// This function is used to verify a multi-signature on any BCS-serializable type T. For now, it is used to verify the\n    /// proof of private key ownership when rotating authentication keys.\n    public fun signature_verify_strict_t<T: drop>(multisignature: &Signature, public_key: &UnvalidatedPublicKey, data: T): bool {\n        let encoded = ed25519::new_signed_message(data);\n\n        signature_verify_strict_internal(multisignature.bytes, public_key.bytes, bcs::to_bytes(&encoded))\n    }\n\n    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.\n    public fun unvalidated_public_key_to_authentication_key(pk: &UnvalidatedPublicKey): vector<u8> {\n        public_key_bytes_to_authentication_key(pk.bytes)\n    }\n\n    /// Returns the number n of sub-PKs in an unvalidated t-out-of-n MultiEd25519 PK.\n    /// If this `UnvalidatedPublicKey` would pass validation in `public_key_validate`, then the returned # of sub-PKs\n    /// can be relied upon as correct.\n    ///\n    /// We provide this API as a cheaper alternative to calling `public_key_validate` and then `validated_public_key_num_sub_pks`\n    /// when the input `pk` is known to be valid.\n    public fun unvalidated_public_key_num_sub_pks(pk: &UnvalidatedPublicKey): u8 {\n        let len = vector::length(&pk.bytes);\n\n        ((len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES) as u8)\n    }\n\n    /// Returns the number t of sub-PKs in an unvalidated t-out-of-n MultiEd25519 PK (i.e., the threshold) or `None`\n    /// if `bytes` does not correctly encode such a PK.\n    public fun unvalidated_public_key_threshold(pk: &UnvalidatedPublicKey): Option<u8> {\n        check_and_get_threshold(pk.bytes)\n    }\n\n    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.\n    public fun validated_public_key_to_authentication_key(pk: &ValidatedPublicKey): vector<u8> {\n        public_key_bytes_to_authentication_key(pk.bytes)\n    }\n\n    /// Returns the number n of sub-PKs in a validated t-out-of-n MultiEd25519 PK.\n    /// Since the format of this PK has been validated, the returned # of sub-PKs is guaranteed to be correct.\n    public fun validated_public_key_num_sub_pks(pk: &ValidatedPublicKey): u8 {\n        let len = vector::length(&pk.bytes);\n\n        ((len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES) as u8)\n    }\n\n    /// Returns the number t of sub-PKs in a validated t-out-of-n MultiEd25519 PK (i.e., the threshold).\n    public fun validated_public_key_threshold(pk: &ValidatedPublicKey): u8 {\n        let len = vector::length(&pk.bytes);\n        let threshold_byte = *vector::borrow(&pk.bytes, len - 1);\n\n        threshold_byte\n    }\n\n    /// Checks that the serialized format of a t-out-of-n MultiEd25519 PK correctly encodes 1 <= n <= 32 sub-PKs.\n    /// (All `ValidatedPublicKey` objects are guaranteed to pass this check.)\n    /// Returns the threshold t <= n of the PK.\n    public fun check_and_get_threshold(bytes: vector<u8>): Option<u8> {\n        let len = vector::length(&bytes);\n        if (len == 0) {\n            return option::none<u8>()\n        };\n\n        let threshold_num_of_bytes = len % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;\n        let num_of_keys = len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;\n        let threshold_byte = *vector::borrow(&bytes, len - 1);\n\n        if (num_of_keys == 0 || num_of_keys > MAX_NUMBER_OF_PUBLIC_KEYS || threshold_num_of_bytes != 1) {\n            return option::none<u8>()\n        } else if (threshold_byte == 0 || threshold_byte > (num_of_keys as u8)) {\n            return option::none<u8>()\n        } else {\n            return option::some(threshold_byte)\n        }\n    }\n\n    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.\n    fun public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8> {\n        vector::push_back(&mut pk_bytes, SIGNATURE_SCHEME_ID);\n        std::hash::sha3_256(pk_bytes)\n    }\n\n    //\n    // Native functions\n    //\n\n    /// DEPRECATED: Use `public_key_validate_internal_v2` instead. This function was NOT correctly implemented:\n    ///\n    ///  1. It does not check that the # of sub public keys is > 0, which leads to invalid `ValidatedPublicKey` objects\n    ///     against which no signature will verify, since `signature_verify_strict_internal` will reject such invalid PKs.\n    ///     This is not a security issue, but a correctness issue. See `bugfix_validated_pk_from_zero_subpks`.\n    ///  2. It charges too much gas: if the first sub-PK is invalid, it will charge for verifying all remaining sub-PKs.\n    ///\n    /// DEPRECATES:\n    ///  - new_validated_public_key_from_bytes\n    ///  - public_key_validate\n    ///\n    /// Return `true` if the bytes in `public_key` can be parsed as a valid MultiEd25519 public key: i.e., all underlying\n    /// PKs pass point-on-curve and not-in-small-subgroup checks.\n    /// Returns `false` otherwise.\n    native fun public_key_validate_internal(bytes: vector<u8>): bool;\n\n    /// Return `true` if the bytes in `public_key` can be parsed as a valid MultiEd25519 public key: i.e., all underlying\n    /// sub-PKs pass point-on-curve and not-in-small-subgroup checks.\n    /// Returns `false` otherwise.\n    native fun public_key_validate_v2_internal(bytes: vector<u8>): bool;\n\n    /// Return true if the MultiEd25519 `multisignature` on `message` verifies against the MultiEd25519 `public_key`.\n    /// Returns `false` if either:\n    /// - The PKs in `public_key` do not all pass points-on-curve or not-in-small-subgroup checks,\n    /// - The signatures in `multisignature` do not all pass points-on-curve or not-in-small-subgroup checks,\n    /// - the `multisignature` on `message` does not verify.\n    native fun signature_verify_strict_internal(\n        multisignature: vector<u8>,\n        public_key: vector<u8>,\n        message: vector<u8>\n    ): bool;\n\n    #[test_only]\n    native fun generate_keys_internal(threshold: u8, n: u8): (vector<u8>,vector<u8>);\n\n    #[test_only]\n    native fun sign_internal(sk: vector<u8>, message: vector<u8>): vector<u8>;\n\n    //\n    // Tests\n    //\n\n    #[test_only]\n    struct TestMessage has copy, drop {\n        foo: vector<u8>,\n        bar: u64,\n    }\n\n    #[test_only]\n    public fun maul_first_signature(sig: &mut Signature) {\n        let first_sig_byte = vector::borrow_mut(&mut sig.bytes, 0);\n        *first_sig_byte = *first_sig_byte ^ 0xff;\n    }\n\n\n    #[test(fx = @std)]\n    fun bugfix_validated_pk_from_zero_subpks(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::multi_ed25519_pk_validate_v2_feature()], vector[]);\n        let bytes = vector<u8>[1u8];\n        assert!(vector::length(&bytes) == 1, 1);\n\n        // Try deserializing a MultiEd25519 `ValidatedPublicKey` with 0 Ed25519 sub-PKs and 1 threshold byte.\n        // This would ideally NOT succeed, but it currently does. Regardless, such invalid PKs will be safely dismissed\n        // during signature verification.\n        let some = new_validated_public_key_from_bytes(bytes);\n        assert!(option::is_none(&check_and_get_threshold(bytes)), 1);   // ground truth\n        assert!(option::is_some(&some), 2);                             // incorrect\n\n        // In contrast, the v2 API will fail deserializing, as it should.\n        let none = new_validated_public_key_from_bytes_v2(bytes);\n        assert!(option::is_none(&none), 3);\n    }\n\n    #[test(fx = @std)]\n    fun test_validated_pk_without_threshold_byte(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::multi_ed25519_pk_validate_v2_feature()], vector[]);\n\n        let (_, subpk) = ed25519::generate_keys();\n        let bytes = ed25519::validated_public_key_to_bytes(&subpk);\n        assert!(vector::length(&bytes) == INDIVIDUAL_PUBLIC_KEY_NUM_BYTES, 1);\n\n        // Try deserializing a MultiEd25519 `ValidatedPublicKey` with 1 Ed25519 sub-PKs but no threshold byte, which\n        // will not succeed,\n        let none = new_validated_public_key_from_bytes(bytes);\n        assert!(option::is_none(&check_and_get_threshold(bytes)), 1);   // ground truth\n        assert!(option::is_none(&none), 2);                             // correct\n\n        // Similarly, the v2 API will also fail deserializing.\n        let none = new_validated_public_key_from_bytes_v2(bytes);\n        assert!(option::is_none(&none), 3);                             // also correct\n    }\n\n    #[test(fx = @std)]\n    fun test_validated_pk_from_small_order_subpk(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::multi_ed25519_pk_validate_v2_feature()], vector[]);\n        let torsion_point_with_threshold_1 = vector<u8>[\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 1,\n        ];\n\n        assert!(option::extract(&mut check_and_get_threshold(torsion_point_with_threshold_1)) == 1, 1);\n\n        // Try deserializing a MultiEd25519 `ValidatedPublicKey` with 1 Ed25519 sub-PKs and 1 threshold byte, as it should,\n        // except the sub-PK is of small order. This should not succeed,\n        let none = new_validated_public_key_from_bytes(torsion_point_with_threshold_1);\n        assert!(option::is_none(&none), 2);\n\n        // Similarly, the v2 API will also fail deserializing.\n        let none = new_validated_public_key_from_bytes_v2(torsion_point_with_threshold_1);\n        assert!(option::is_none(&none), 3);\n    }\n\n    #[test]\n    fun test_gen_sign_verify() {\n        let thresholds = vector[1, 1, 2, 2, 3, 15,]; // the thresholds, implicitly encoded in the public keys\n        let party_counts = vector[1, 2, 2, 3, 10, 32,];\n        let test_case_count = vector::length(&party_counts);\n        let test_case_idx = 0;\n\n        while (test_case_idx < test_case_count) {\n            let threshold = *vector::borrow(&thresholds, test_case_idx);\n            let group_size = *vector::borrow(&party_counts, test_case_idx);\n\n            let (sk, pk) = generate_keys(threshold, group_size);\n            assert!(validated_public_key_threshold(&pk) == threshold, 1);\n            assert!(validated_public_key_num_sub_pks(&pk) == group_size, 2);\n            assert!(public_key_validate_v2_internal(pk.bytes), 3);\n\n            let upk = public_key_into_unvalidated(pk);\n            assert!(option::extract(&mut unvalidated_public_key_threshold(&upk)) == threshold, 4);\n            assert!(unvalidated_public_key_num_sub_pks(&upk) == group_size, 5);\n\n            let msg1 = b"Hello Aptos!";\n            let sig1 = sign_arbitrary_bytes(&sk, msg1);\n            assert!(signature_verify_strict(&sig1, &upk, msg1), 6);\n\n            let obj2 = TestMessage {\n                foo: b"Hello Move!",\n                bar: 64,\n            };\n            let sig2 = sign_struct(&sk, copy obj2);\n            assert!(signature_verify_strict_t(&sig2, &upk, copy obj2), 7);\n\n            test_case_idx = test_case_idx + 1;\n        }\n    }\n\n    #[test]\n    fun test_threshold_not_met_rejection() {\n        let (sk,pk) = generate_keys(4, 5);\n        assert!(validated_public_key_threshold(&pk) == 4, 1);\n        assert!(validated_public_key_num_sub_pks(&pk) == 5, 2);\n        assert!(public_key_validate_v2_internal(pk.bytes), 3);\n\n        let upk = public_key_into_unvalidated(pk);\n        assert!(option::extract(&mut unvalidated_public_key_threshold(&upk)) == 4, 4);\n        assert!(unvalidated_public_key_num_sub_pks(&upk) == 5, 5);\n\n        let msg1 = b"Hello Aptos!";\n        let sig1 = sign_arbitrary_bytes(&sk, msg1);\n        maul_first_signature(&mut sig1);\n        assert!(!signature_verify_strict(&sig1, &upk, msg1), 6);\n\n        let obj2 = TestMessage {\n            foo: b"Hello Move!",\n            bar: 64,\n        };\n        let sig2 = sign_struct(&sk, copy obj2);\n        maul_first_signature(&mut sig2);\n        assert!(!signature_verify_strict_t(&sig2, &upk, copy obj2), 7);\n    }\n}\n', "name": "multi_ed25519.move" }, { "content": `/// This module contains functions for Ristretto255 curve arithmetic, assuming addition as the group operation.
///
/// The order of the Ristretto255 elliptic curve group is $\\ell = 2^252 + 27742317777372353535851937790883648493$, same
/// as the order of the prime-order subgroup of Curve25519.
///
/// This module provides two structs for encoding Ristretto elliptic curves to the developer:
///
///  - First, a 32-byte-sized CompressedRistretto struct, which is used to persist points in storage.
///
///  - Second, a larger, in-memory, RistrettoPoint struct, which is decompressable from a CompressedRistretto struct. This
/// larger struct can be used for fast arithmetic operations (additions, multiplications, etc.). The results can be saved
/// back into storage by compressing RistrettoPoint structs back to CompressedRistretto structs.
///
/// This module also provides a Scalar struct for persisting scalars in storage and doing fast arithmetic on them.
///
/// One invariant maintained by this module is that all CompressedRistretto structs store a canonically-encoded point,
/// which can always be decompressed into a valid point on the curve as a RistrettoPoint struct. Unfortunately, due to
/// limitations in our underlying curve25519-dalek elliptic curve library, this decompression will unnecessarily verify
/// the validity of the point and thus slightly decrease performance.
///
/// Similarly, all Scalar structs store a canonically-encoded scalar, which can always be safely operated on using
/// arithmetic operations.
///
/// In the future, we might support additional features:
///
/// * For scalars:
///    - batch_invert()
///
///  * For points:
///    - double()
///      + The challenge is that curve25519-dalek does NOT export double for Ristretto points (nor for Edwards)
///
///    - double_and_compress_batch()
///
///    - fixed-base, variable-time via optional_mixed_multiscalar_mul() in VartimePrecomputedMultiscalarMul
///      + This would require a storage-friendly RistrettoBasepointTable and an in-memory variant of it too
///      + Similar to the CompressedRistretto and RistrettoPoint structs in this module
///      + The challenge is that curve25519-dalek's RistrettoBasepointTable is not serializable

module aptos_std::ristretto255 {
    use std::features;
    use std::option::Option;

    #[test_only]
    use std::option;

    //
    // Constants
    //

    /// The order of the Ristretto255 group and its scalar field, in little-endian.
    const ORDER_ELL: vector<u8> = x"edd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    /// \`ORDER_ELL\` - 1: i.e., the "largest", reduced scalar in the field
    const L_MINUS_ONE: vector<u8> = x"ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    /// The maximum size in bytes of a canonically-encoded Scalar is 32 bytes.
    const MAX_SCALAR_NUM_BYTES: u64 = 32u64;

    /// The maximum size in bits of a canonically-encoded Scalar is 256 bits.
    const MAX_SCALAR_NUM_BITS: u64 = 256u64;

    /// The maximum size in bytes of a canonically-encoded Ristretto255 point is 32 bytes.
    const MAX_POINT_NUM_BYTES: u64 = 32u64;

    /// The basepoint (generator) of the Ristretto255 group
    const BASE_POINT: vector<u8> = x"e2f2ae0a6abc4e71a884a961c500515f58e30b6aa582dd8db6a65945e08d2d76";

    /// The hash of the basepoint of the Ristretto255 group using SHA3_512
    const HASH_BASE_POINT: vector<u8> = x"8c9240b456a9e6dc65c377a1048d745f94a08cdb7f44cbcd7b46f34048871134";

    //
    // Reasons for error codes
    //

    /// The number of scalars does not match the number of points.
    const E_DIFFERENT_NUM_POINTS_AND_SCALARS: u64 = 1;
    /// Expected more than zero points as input.
    const E_ZERO_POINTS: u64 = 2;
    /// Expected more than zero scalars as input.
    const E_ZERO_SCALARS: u64 = 3;
    /// Too many points have been created in the current transaction execution.
    const E_TOO_MANY_POINTS_CREATED: u64 = 4;
    /// The native function has not been deployed yet.
    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 5;

    //
    // Scalar and point structs
    //

    /// This struct represents a scalar as a little-endian byte encoding of an integer in $\\mathbb{Z}_\\ell$, which is
    /// stored in \`data\`. Here, \\ell denotes the order of the scalar field (and the underlying elliptic curve group).
    struct Scalar has copy, store, drop {
        data: vector<u8>
    }

    /// This struct represents a serialized point on the Ristretto255 curve, in 32 bytes.
    /// This struct can be decompressed from storage into an in-memory RistrettoPoint, on which fast curve arithmetic
    /// can be performed.
    struct CompressedRistretto has copy, store, drop {
        data: vector<u8>
    }

    /// This struct represents an in-memory Ristretto255 point and supports fast curve arithmetic.
    ///
    /// An important invariant: There will never be two RistrettoPoint's constructed with the same handle. One can have
    /// immutable references to the same RistrettoPoint, of course.
    struct RistrettoPoint has drop {
        handle: u64
    }

    //
    // Functions for arithmetic on points
    //

    /// Returns the identity point as a CompressedRistretto.
    public fun point_identity_compressed(): CompressedRistretto {
        CompressedRistretto {
            data: x"0000000000000000000000000000000000000000000000000000000000000000"
        }
    }

    /// Returns the identity point as a CompressedRistretto.
    public fun point_identity(): RistrettoPoint {
        RistrettoPoint {
            handle: point_identity_internal()
        }
    }

    /// Returns the basepoint (generator) of the Ristretto255 group as a compressed point
    public fun basepoint_compressed(): CompressedRistretto {
        CompressedRistretto {
            data: BASE_POINT
        }
    }

    /// Returns the hash-to-point result of serializing the basepoint of the Ristretto255 group.
    /// For use as the random value basepoint in Pedersen commitments
    public fun hash_to_point_base(): RistrettoPoint {
        let comp_res = CompressedRistretto { data: HASH_BASE_POINT };
        point_decompress(&comp_res)
    }

    /// Returns the basepoint (generator) of the Ristretto255 group
    public fun basepoint(): RistrettoPoint {
        let (handle, _) = point_decompress_internal(BASE_POINT);

        RistrettoPoint {
            handle
        }
    }

    /// Multiplies the basepoint (generator) of the Ristretto255 group by a scalar and returns the result.
    /// This call is much faster than \`point_mul(&basepoint(), &some_scalar)\` because of precomputation tables.
    public fun basepoint_mul(a: &Scalar): RistrettoPoint {
        RistrettoPoint {
            handle: basepoint_mul_internal(a.data)
        }
    }

    /// Creates a new CompressedRistretto point from a sequence of 32 bytes. If those bytes do not represent a valid
    /// point, returns None.
    public fun new_compressed_point_from_bytes(bytes: vector<u8>): Option<CompressedRistretto> {
        if (point_is_canonical_internal(bytes)) {
            std::option::some(CompressedRistretto {
                data: bytes
            })
        } else {
            std::option::none<CompressedRistretto>()
        }
    }

    /// Creates a new RistrettoPoint from a sequence of 32 bytes. If those bytes do not represent a valid point,
    /// returns None.
    public fun new_point_from_bytes(bytes: vector<u8>): Option<RistrettoPoint> {
        let (handle, is_canonical) = point_decompress_internal(bytes);
        if (is_canonical) {
            std::option::some(RistrettoPoint { handle })
        } else {
            std::option::none<RistrettoPoint>()
        }
    }

    /// Given a compressed ristretto point \`point\`, returns the byte representation of that point
    public fun compressed_point_to_bytes(point: CompressedRistretto): vector<u8> {
        point.data
    }

    /// DEPRECATED: Use the more clearly-named \`new_point_from_sha2_512\`
    ///
    /// Hashes the input to a uniformly-at-random RistrettoPoint via SHA512.
    public fun new_point_from_sha512(sha2_512_input: vector<u8>): RistrettoPoint {
        new_point_from_sha2_512(sha2_512_input)
    }

    /// Hashes the input to a uniformly-at-random RistrettoPoint via SHA2-512.
    public fun new_point_from_sha2_512(sha2_512_input: vector<u8>): RistrettoPoint {
        RistrettoPoint {
            handle: new_point_from_sha512_internal(sha2_512_input)
        }
    }

    /// Samples a uniformly-at-random RistrettoPoint given a sequence of 64 uniformly-at-random bytes. This function
    /// can be used to build a collision-resistant hash function that maps 64-byte messages to RistrettoPoint's.
    public fun new_point_from_64_uniform_bytes(bytes: vector<u8>): Option<RistrettoPoint> {
        if (std::vector::length(&bytes) == 64) {
            std::option::some(RistrettoPoint {
                handle: new_point_from_64_uniform_bytes_internal(bytes)
            })
        } else {
            std::option::none<RistrettoPoint>()
        }
    }

    /// Decompresses a CompressedRistretto from storage into a RistrettoPoint which can be used for fast arithmetic.
    public fun point_decompress(point: &CompressedRistretto): RistrettoPoint {
        // NOTE: Our CompressedRistretto invariant assures us that every CompressedRistretto in storage is a valid
        // RistrettoPoint
        let (handle, _) = point_decompress_internal(point.data);
        RistrettoPoint { handle }
    }

    /// Clones a RistrettoPoint.
    public fun point_clone(point: &RistrettoPoint): RistrettoPoint {
        if(!features::bulletproofs_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        RistrettoPoint {
            handle: point_clone_internal(point.handle)
        }
    }

    /// Compresses a RistrettoPoint to a CompressedRistretto which can be put in storage.
    public fun point_compress(point: &RistrettoPoint): CompressedRistretto {
        CompressedRistretto {
            data: point_compress_internal(point)
        }
    }

    /// Returns the sequence of bytes representin this Ristretto point.
    /// To convert a RistrettoPoint 'p' to bytes, first compress it via \`c = point_compress(&p)\`, and then call this
    /// function on \`c\`.
    public fun point_to_bytes(point: &CompressedRistretto): vector<u8> {
        point.data
    }

    /// Returns a * point.
    public fun point_mul(point: &RistrettoPoint, a: &Scalar): RistrettoPoint {
        RistrettoPoint {
            handle: point_mul_internal(point, a.data, false)
        }
    }

    /// Sets a *= point and returns 'a'.
    public fun point_mul_assign(point: &mut RistrettoPoint, a: &Scalar): &mut RistrettoPoint {
        point_mul_internal(point, a.data, true);
        point
    }

    /// Returns (a * a_base + b * base_point), where base_point is the Ristretto basepoint encoded in \`BASE_POINT\`.
    public fun basepoint_double_mul(a: &Scalar, a_base: &RistrettoPoint, b: &Scalar): RistrettoPoint {
        RistrettoPoint {
            handle: basepoint_double_mul_internal(a.data, a_base, b.data)
        }
    }

    /// Returns a + b
    public fun point_add(a: &RistrettoPoint, b: &RistrettoPoint): RistrettoPoint {
        RistrettoPoint {
            handle: point_add_internal(a, b, false)
        }
    }

    /// Sets a += b and returns 'a'.
    public fun point_add_assign(a: &mut RistrettoPoint, b: &RistrettoPoint): &mut RistrettoPoint {
        point_add_internal(a, b, true);
        a
    }

    /// Returns a - b
    public fun point_sub(a: &RistrettoPoint, b: &RistrettoPoint): RistrettoPoint {
        RistrettoPoint {
            handle: point_sub_internal(a, b, false)
        }
    }

    /// Sets a -= b and returns 'a'.
    public fun point_sub_assign(a: &mut RistrettoPoint, b: &RistrettoPoint): &mut RistrettoPoint {
        point_sub_internal(a, b, true);
        a
    }

    /// Returns -a
    public fun point_neg(a: &RistrettoPoint): RistrettoPoint {
        RistrettoPoint {
            handle: point_neg_internal(a, false)
        }
    }

    /// Sets a = -a, and returns 'a'.
    public fun point_neg_assign(a: &mut RistrettoPoint): &mut RistrettoPoint {
        point_neg_internal(a, true);
        a
    }

    /// Returns true if the two RistrettoPoints are the same points on the elliptic curve.
    native public fun point_equals(g: &RistrettoPoint, h: &RistrettoPoint): bool;

    /// Computes a double-scalar multiplication, returning a_1 p_1 + a_2 p_2
    /// This function is much faster than computing each a_i p_i using \`point_mul\` and adding up the results using \`point_add\`.
    public fun double_scalar_mul(scalar1: &Scalar, point1: &RistrettoPoint, scalar2: &Scalar, point2: &RistrettoPoint): RistrettoPoint {
        if(!features::bulletproofs_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        RistrettoPoint {
            handle: double_scalar_mul_internal(point1.handle, point2.handle, scalar1.data, scalar2.data)
        }
    }

    /// Computes a multi-scalar multiplication, returning a_1 p_1 + a_2 p_2 + ... + a_n p_n.
    /// This function is much faster than computing each a_i p_i using \`point_mul\` and adding up the results using \`point_add\`.
    public fun multi_scalar_mul(points: &vector<RistrettoPoint>, scalars: &vector<Scalar>): RistrettoPoint {
        assert!(!std::vector::is_empty(points), std::error::invalid_argument(E_ZERO_POINTS));
        assert!(!std::vector::is_empty(scalars), std::error::invalid_argument(E_ZERO_SCALARS));
        assert!(std::vector::length(points) == std::vector::length(scalars), std::error::invalid_argument(E_DIFFERENT_NUM_POINTS_AND_SCALARS));

        RistrettoPoint {
            handle: multi_scalar_mul_internal<RistrettoPoint, Scalar>(points, scalars)
        }
    }

    //
    // Functions for arithmetic on Scalars
    //

    /// Given a sequence of 32 bytes, checks if they canonically-encode a Scalar and return it.
    /// Otherwise, returns None.
    public fun new_scalar_from_bytes(bytes: vector<u8>): Option<Scalar> {
        if (scalar_is_canonical_internal(bytes)) {
            std::option::some(Scalar {
                data: bytes
            })
        } else {
            std::option::none<Scalar>()
        }
    }

    /// DEPRECATED: Use the more clearly-named \`new_scalar_from_sha2_512\`
    ///
    /// Hashes the input to a uniformly-at-random Scalar via SHA2-512
    public fun new_scalar_from_sha512(sha2_512_input: vector<u8>): Scalar {
        new_scalar_from_sha2_512(sha2_512_input)
    }

    /// Hashes the input to a uniformly-at-random Scalar via SHA2-512
    public fun new_scalar_from_sha2_512(sha2_512_input: vector<u8>): Scalar {
        Scalar {
            data: scalar_from_sha512_internal(sha2_512_input)
        }
    }

    /// Creates a Scalar from an u8.
    public fun new_scalar_from_u8(byte: u8): Scalar {
        let s = scalar_zero();
        let byte_zero = std::vector::borrow_mut(&mut s.data, 0);
        *byte_zero = byte;

        s
    }

    /// Creates a Scalar from an u32.
    public fun new_scalar_from_u32(four_bytes: u32): Scalar {
        Scalar {
            data: scalar_from_u64_internal((four_bytes as u64))
        }
    }

    /// Creates a Scalar from an u64.
    public fun new_scalar_from_u64(eight_bytes: u64): Scalar {
        Scalar {
            data: scalar_from_u64_internal(eight_bytes)
        }
    }

    /// Creates a Scalar from an u128.
    public fun new_scalar_from_u128(sixteen_bytes: u128): Scalar {
        Scalar {
            data: scalar_from_u128_internal(sixteen_bytes)
        }
    }

    /// Creates a Scalar from 32 bytes by reducing the little-endian-encoded number in those bytes modulo $\\ell$.
    public fun new_scalar_reduced_from_32_bytes(bytes: vector<u8>): Option<Scalar> {
        if (std::vector::length(&bytes) == 32) {
            std::option::some(Scalar {
                data: scalar_reduced_from_32_bytes_internal(bytes)
            })
        } else {
            std::option::none()
        }
    }

    /// Samples a scalar uniformly-at-random given 64 uniform-at-random bytes as input by reducing the little-endian-encoded number
    /// in those bytes modulo $\\ell$.
    public fun new_scalar_uniform_from_64_bytes(bytes: vector<u8>): Option<Scalar> {
        if (std::vector::length(&bytes) == 64) {
            std::option::some(Scalar {
                data: scalar_uniform_from_64_bytes_internal(bytes)
            })
        } else {
            std::option::none()
        }
    }

    /// Returns 0 as a Scalar.
    public fun scalar_zero(): Scalar {
        Scalar {
            data: x"0000000000000000000000000000000000000000000000000000000000000000"
        }
    }

    /// Returns true if the given Scalar equals 0.
    public fun scalar_is_zero(s: &Scalar): bool {
        s.data == x"0000000000000000000000000000000000000000000000000000000000000000"
    }

    /// Returns 1 as a Scalar.
    public fun scalar_one(): Scalar {
        Scalar {
            data: x"0100000000000000000000000000000000000000000000000000000000000000"
        }
    }

    /// Returns true if the given Scalar equals 1.
    public fun scalar_is_one(s: &Scalar): bool {
        s.data == x"0100000000000000000000000000000000000000000000000000000000000000"
    }

    /// Returns true if the two scalars are equal.
    public fun scalar_equals(lhs: &Scalar, rhs: &Scalar): bool {
        lhs.data == rhs.data
    }

    /// Returns the inverse s^{-1} mod \\ell of a scalar s.
    /// Returns None if s is zero.
    public fun scalar_invert(s: &Scalar): Option<Scalar> {
        if (scalar_is_zero(s)) {
            std::option::none<Scalar>()
        } else {
            std::option::some(Scalar {
                data: scalar_invert_internal(s.data)
            })
        }
    }

    /// Returns the product of the two scalars.
    public fun scalar_mul(a: &Scalar, b: &Scalar): Scalar {
        Scalar {
            data: scalar_mul_internal(a.data, b.data)
        }
    }

    /// Computes the product of 'a' and 'b' and assigns the result to 'a'.
    /// Returns 'a'.
    public fun scalar_mul_assign(a: &mut Scalar, b: &Scalar): &mut Scalar {
        a.data = scalar_mul(a, b).data;
        a
    }

    /// Returns the sum of the two scalars.
    public fun scalar_add(a: &Scalar, b: &Scalar): Scalar {
        Scalar {
            data: scalar_add_internal(a.data, b.data)
        }
    }

    /// Computes the sum of 'a' and 'b' and assigns the result to 'a'
    /// Returns 'a'.
    public fun scalar_add_assign(a: &mut Scalar, b: &Scalar): &mut Scalar {
        a.data = scalar_add(a, b).data;
        a
    }

    /// Returns the difference of the two scalars.
    public fun scalar_sub(a: &Scalar, b: &Scalar): Scalar {
        Scalar {
            data: scalar_sub_internal(a.data, b.data)
        }
    }

    /// Subtracts 'b' from 'a' and assigns the result to 'a'.
    /// Returns 'a'.
    public fun scalar_sub_assign(a: &mut Scalar, b: &Scalar): &mut Scalar {
        a.data = scalar_sub(a, b).data;
        a
    }

    /// Returns the negation of 'a': i.e., $(0 - a) \\mod \\ell$.
    public fun scalar_neg(a: &Scalar): Scalar {
        Scalar {
            data: scalar_neg_internal(a.data)
        }
    }

    /// Replaces 'a' by its negation.
    ///  Returns 'a'.
    public fun scalar_neg_assign(a: &mut Scalar): &mut Scalar {
        a.data = scalar_neg(a).data;
        a
    }

    /// Returns the byte-representation of the scalar.
    public fun scalar_to_bytes(s: &Scalar): vector<u8> {
        s.data
    }

    //
    // Only used internally for implementing CompressedRistretto and RistrettoPoint
    //

    // NOTE: This was supposed to be more clearly named with *_sha2_512_*.
    native fun new_point_from_sha512_internal(sha2_512_input: vector<u8>): u64;

    native fun new_point_from_64_uniform_bytes_internal(bytes: vector<u8>): u64;

    native fun point_is_canonical_internal(bytes: vector<u8>): bool;

    native fun point_identity_internal(): u64;

    native fun point_decompress_internal(maybe_non_canonical_bytes: vector<u8>): (u64, bool);

    native fun point_clone_internal(point_handle: u64): u64;
    native fun point_compress_internal(point: &RistrettoPoint): vector<u8>;

    native fun point_mul_internal(point: &RistrettoPoint, a: vector<u8>, in_place: bool): u64;

    native fun basepoint_mul_internal(a: vector<u8>): u64;

    native fun basepoint_double_mul_internal(a: vector<u8>, some_point: &RistrettoPoint, b: vector<u8>): u64;

    native fun point_add_internal(a: &RistrettoPoint, b: &RistrettoPoint, in_place: bool): u64;

    native fun point_sub_internal(a: &RistrettoPoint, b: &RistrettoPoint, in_place: bool): u64;

    native fun point_neg_internal(a: &RistrettoPoint, in_place: bool): u64;

    native fun double_scalar_mul_internal(point1: u64, point2: u64, scalar1: vector<u8>, scalar2: vector<u8>): u64;

    /// The generic arguments are needed to deal with some Move VM peculiarities which prevent us from borrowing the
    /// points (or scalars) inside a &vector in Rust.
    ///
    /// WARNING: This function can only be called with P = RistrettoPoint and S = Scalar.
    native fun multi_scalar_mul_internal<P, S>(points: &vector<P>, scalars: &vector<S>): u64;

    //
    // Only used internally for implementing Scalar.
    //

    native fun scalar_is_canonical_internal(s: vector<u8>): bool;

    native fun scalar_from_u64_internal(num: u64): vector<u8>;

    native fun scalar_from_u128_internal(num: u128): vector<u8>;

    native fun scalar_reduced_from_32_bytes_internal(bytes: vector<u8>): vector<u8>;

    native fun scalar_uniform_from_64_bytes_internal(bytes: vector<u8>): vector<u8>;

    native fun scalar_invert_internal(bytes: vector<u8>): vector<u8>;

    // NOTE: This was supposed to be more clearly named with *_sha2_512_*.
    native fun scalar_from_sha512_internal(sha2_512_input: vector<u8>): vector<u8>;

    native fun scalar_mul_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    native fun scalar_add_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    native fun scalar_sub_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    native fun scalar_neg_internal(a_bytes: vector<u8>): vector<u8>;

    #[test_only]
    native fun random_scalar_internal(): vector<u8>;

    //
    // Test-only functions
    //

    #[test_only]
    public fun random_scalar(): Scalar {
        Scalar {
            data: random_scalar_internal()
        }
    }

    #[test_only]
    public fun random_point(): RistrettoPoint {
        let s = random_scalar();

        basepoint_mul(&s)
    }

    //
    // Testing constants
    //

    // The scalar 2
    #[test_only]
    const TWO_SCALAR: vector<u8> = x"0200000000000000000000000000000000000000000000000000000000000000";

    // Non-canonical scalar: the order \\ell of the group + 1
    #[test_only]
    const L_PLUS_ONE: vector<u8> = x"eed3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    // Non-canonical scalar: the order \\ell of the group + 2
    #[test_only]
    const L_PLUS_TWO: vector<u8> = x"efd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    // Some random scalar denoted by X
    #[test_only]
    const X_SCALAR: vector<u8> = x"4e5ab4345d4708845913b4641bc27d5252a585101bcc4244d449f4a879d9f204";

    // X^{-1} = 1/X = 6859937278830797291664592131120606308688036382723378951768035303146619657244
    // 0x1CDC17FCE0E9A5BBD9247E56BB016347BBBA31EDD5A9BB96D50BCD7A3F962A0F
    #[test_only]
    const X_INV_SCALAR: vector<u8> = x"1cdc17fce0e9a5bbd9247e56bb016347bbba31edd5a9bb96d50bcd7a3f962a0f";

    // Some random scalar Y = 2592331292931086675770238855846338635550719849568364935475441891787804997264
    #[test_only]
    const Y_SCALAR: vector<u8> = x"907633fe1c4b66a4a28d2dd7678386c353d0de5455d4fc9de8ef7ac31f35bb05";

    // X * Y = 5690045403673944803228348699031245560686958845067437804563560795922180092780
    #[test_only]
    const X_TIMES_Y_SCALAR: vector<u8> = x"6c3374a1894f62210aaa2fe186a6f92ce0aa75c2779581c295fc08179a73940c";

    // X + 2^256 * X \\mod \\ell
    #[test_only]
    const REDUCED_X_PLUS_2_TO_256_TIMES_X_SCALAR: vector<u8> = x"d89ab38bd279024745639ed817ad3f64cc005b32db9939f91c521fc564a5c008";

    // sage: l = 2^252 + 27742317777372353535851937790883648493
    // sage: big = 2^256 - 1
    // sage: repr((big % l).digits(256))
    #[test_only]
    const REDUCED_2_256_MINUS_1_SCALAR: vector<u8> = x"1c95988d7431ecd670cf7d73f45befc6feffffffffffffffffffffffffffff0f";

    #[test_only]
    const NON_CANONICAL_ALL_ONES: vector<u8> = x"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";

    #[test_only]
    const A_SCALAR: vector<u8> = x"1a0e978a90f6622d3747023f8ad8264da758aa1b88e040d1589e7b7f2376ef09";

    // Generated in curve25519-dalek via:
    // \`\`\`
    //     let mut hasher = sha2::Sha512::default();
    //     hasher.update(b"bello!");
    //     let s = Scalar::from_hash(hasher);
    //     println!("scalar: {:x?}", s.to_bytes());
    // \`\`\`
    #[test_only]
    const B_SCALAR: vector<u8> = x"dbfd97afd38a06f0138d0527efb28ead5b7109b486465913bf3aa472a8ed4e0d";

    #[test_only]
    const A_TIMES_B_SCALAR: vector<u8> = x"2ab50e383d7c210f74d5387330735f18315112d10dfb98fcce1e2620c0c01402";

    #[test_only]
    const A_PLUS_B_SCALAR: vector<u8> = x"083839dd491e57c5743710c39a91d6e502cab3cf0e279ae417d91ff2cb633e07";

    #[test_only]
    /// A_SCALAR * BASE_POINT, computed by modifying a test in curve25519-dalek in src/edwards.rs to do:
    /// \`\`\`
    ///     let comp = RistrettoPoint(A_TIMES_BASEPOINT.decompress().unwrap()).compress();
    ///     println!("hex: {:x?}", comp.to_bytes());
    /// \`\`\`
    const A_TIMES_BASE_POINT: vector<u8> = x"96d52d9262ee1e1aae79fbaee8c1d9068b0d01bf9a4579e618090c3d1088ae10";

    #[test_only]
    const A_POINT: vector<u8> = x"e87feda199d72b83de4f5b2d45d34805c57019c6c59c42cb70ee3d19aa996f75";
    #[test_only]
    const B_POINT: vector<u8> = x"fa0b3624b081c62f364d0b2839dcc76d7c3ab0e27e31beb2b9ed766575f28e76";
    #[test_only]
    const A_PLUS_B_POINT: vector<u8> = x"70cf3753475b9ff33e2f84413ed6b5052073bccc0a0a81789d3e5675dc258056";

    //    const NON_CANONICAL_LARGEST_ED25519_S: vector<u8> = x"f8ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f";
    //    const CANONICAL_LARGEST_ED25519_S_PLUS_ONE: vector<u8> = x"7e344775474a7f9723b63a8be92ae76dffffffffffffffffffffffffffffff0f";
    //    const CANONICAL_LARGEST_ED25519_S_MINUS_ONE: vector<u8> = x"7c344775474a7f9723b63a8be92ae76dffffffffffffffffffffffffffffff0f";

    //
    // Tests
    //

    #[test]
    fun test_point_decompression() {
        let compressed = new_compressed_point_from_bytes(A_POINT);
        assert!(std::option::is_some(&compressed), 1);

        let point = new_point_from_bytes(A_POINT);
        assert!(std::option::is_some(&point), 1);

        let point = std::option::extract(&mut point);
        let compressed = std::option::extract(&mut compressed);
        let same_point = point_decompress(&compressed);

        assert!(point_equals(&point, &same_point), 1);
    }

    #[test]
    fun test_point_equals() {
        let g = basepoint();
        let same_g = std::option::extract(&mut new_point_from_bytes(BASE_POINT));
        let ag = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));

        assert!(point_equals(&g, &same_g), 1);
        assert!(!point_equals(&g, &ag), 1);
    }

    #[test]
    fun test_point_mul() {
        // fetch g
        let g = basepoint();
        // fetch a
        let a = std::option::extract(&mut new_scalar_from_bytes(A_SCALAR));
        // fetch expected a*g
        let ag = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));

        // compute a*g
        let p = point_mul(&g, &a);

        // sanity-check the handles
        assert!(g.handle == 0, 1);
        assert!(ag.handle == 1, 1);
        assert!(p.handle == 2, 1);

        assert!(!point_equals(&g, &ag), 1);     // make sure input g remains unmodifed
        assert!(point_equals(&p, &ag), 1);   // make sure output a*g is correct
    }

    #[test]
    fun test_point_mul_assign() {
        let g = basepoint();
        assert!(g.handle == 0, 1);

        let a = std::option::extract(&mut new_scalar_from_bytes(A_SCALAR));

        let ag = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));
        assert!(ag.handle == 1, 1);
        assert!(!point_equals(&g, &ag), 1);

        {
            // NOTE: new_g is just a mutable reference to g
            let upd_g = point_mul_assign(&mut g, &a);

            // in a mul_assign the returned &mut RistrettoPoint reference should have the same handle as 'g'
            assert!(upd_g.handle == 0, 1);

            assert!(point_equals(upd_g, &ag), 1);
        };

        assert!(point_equals(&g, &ag), 1);
    }

    #[test]
    fun test_point_add() {
        // fetch a
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        // fetch b
        let b = std::option::extract(&mut new_point_from_bytes(B_POINT));

        // fetch expected a + b
        let a_plus_b = std::option::extract(&mut new_point_from_bytes(A_PLUS_B_POINT));

        // compute a*g
        let result = point_add(&a, &b);

        assert!(!point_equals(&a, &b), 1);

        // sanity-check the handles
        assert!(a.handle == 0, 1);
        assert!(b.handle == 1, 1);
        assert!(a_plus_b.handle == 2, 1);
        assert!(result.handle == 3, 1);

        assert!(!point_equals(&a, &result), 1);     // make sure input a remains unmodifed
        assert!(!point_equals(&b, &result), 1);     // make sure input b remains unmodifed
        assert!(point_equals(&a_plus_b, &result), 1);   // make sure output a+b is correct
    }

    #[test]
    fun test_point_add_assign_0_0() {
        test_point_add_assign_internal(0, 0);
    }

    #[test]
    fun test_point_add_assign_1_0() {
        test_point_add_assign_internal(1, 0);
    }

    #[test]
    fun test_point_add_assign_0_1() {
        test_point_add_assign_internal(0, 1);
    }

    #[test]
    fun test_point_add_assign_3_7() {
        test_point_add_assign_internal(3, 7);
    }

    #[test_only]
    fun test_point_add_assign_internal(before_a_gap: u64, before_b_gap: u64) {
        // create extra RistrettoPoints here, so as to generate different PointStore layouts inside the native Rust implementation
        let c = before_a_gap;
        while (c > 0) {
            let _ignore = std::option::extract(&mut new_point_from_bytes(BASE_POINT));

            c = c - 1;
        };

        // fetch a
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        // create extra RistrettoPoints here, so as to generate different PointStore layouts inside the native Rust implementation
        let c = before_b_gap;
        while (c > 0) {
            let _ignore = std::option::extract(&mut new_point_from_bytes(BASE_POINT));

            c = c - 1;
        };
        // fetch b
        let b = std::option::extract(&mut new_point_from_bytes(B_POINT));

        let a_plus_b = std::option::extract(&mut new_point_from_bytes(A_PLUS_B_POINT));

        // sanity-check the handles
        assert!(a.handle == before_a_gap, 1);
        assert!(b.handle == 1 + before_a_gap + before_b_gap, 1);
        assert!(a_plus_b.handle == 2 + before_a_gap + before_b_gap, 1);

        assert!(!point_equals(&a, &b), 1);
        assert!(!point_equals(&a, &a_plus_b), 1);

        {
            // NOTE: new_h is just a mutable reference to g
            let upd_a = point_add_assign(&mut a, &b);

            // in a add_assign the returned &mut RistrettoPoint reference should have the same handle as 'a'
            assert!(upd_a.handle == before_a_gap, 1);

            assert!(point_equals(upd_a, &a_plus_b), 1);
        };

        assert!(point_equals(&a, &a_plus_b), 1);
    }

    #[test]
    fun test_point_sub() {
        // fetch a
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        // fetch b
        let b = std::option::extract(&mut new_point_from_bytes(B_POINT));

        // fetch expected a + b
        let a_plus_b = std::option::extract(&mut new_point_from_bytes(A_PLUS_B_POINT));

        // compute a*g
        let result = point_sub(&a_plus_b, &b);

        assert!(!point_equals(&a, &b), 1);

        // sanity-check the handles
        assert!(a.handle == 0, 1);
        assert!(b.handle == 1, 1);
        assert!(a_plus_b.handle == 2, 1);
        assert!(result.handle == 3, 1);

        assert!(!point_equals(&a_plus_b, &result), 1);     // make sure input a_plus_b remains unmodifed
        assert!(!point_equals(&b, &result), 1);     // make sure input b remains unmodifed
        assert!(point_equals(&a, &result), 1);   // make sure output 'a+b-b' is correct
    }

    #[test]
    fun test_point_neg() {
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        let neg_a = point_neg(&a);

        assert!(a.handle != neg_a.handle, 1);
        assert!(!point_equals(&a, &neg_a), 1);
        assert!(!point_equals(&point_add(&point_identity(), &a), &neg_a), 1);
        assert!(point_equals(&point_add(&a, &neg_a), &point_identity()), 1);

        let handle = a.handle;
        let neg_a_ref = point_neg_assign(&mut a);
        assert!(handle == neg_a_ref.handle, 1);
        assert!(point_equals(neg_a_ref, &neg_a), 1);
    }

    #[test]
    fun test_basepoint_mul() {
        let a = Scalar { data: A_SCALAR };
        let basepoint = basepoint();
        let expected = point_mul(&basepoint, &a);
        assert!(point_equals(&expected, &basepoint_mul(&a)), 1);
    }

    #[test(fx = @std)]
    fun test_basepoint_double_mul(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);

        let expected = option::extract(&mut new_point_from_bytes(x"be5d615d8b8f996723cdc6e1895b8b6d312cc75d1ffb0259873b99396a38c05a"));

        let a = Scalar { data: A_SCALAR };
        let a_point = option::extract(&mut new_point_from_bytes(A_POINT));
        let b = Scalar { data: B_SCALAR };
        let actual = basepoint_double_mul(&a, &a_point, &b);

        assert!(point_equals(&expected, &actual), 1);

        let expected = double_scalar_mul(&a, &a_point, &b, &basepoint());
        assert!(point_equals(&expected, &actual), 1);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_empty_scalars() {
        multi_scalar_mul(&vector[ basepoint() ], &vector[]);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_empty_points() {
        multi_scalar_mul(&vector[ ], &vector[ Scalar { data: A_SCALAR } ]);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_empty_all() {
        multi_scalar_mul(&vector[ ], &vector[ ]);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_different_sizes() {
        multi_scalar_mul(&vector[ basepoint() ], &vector[ Scalar { data: A_SCALAR }, Scalar { data: B_SCALAR }  ]);
    }

    #[test]
    fun test_multi_scalar_mul_single() {
        // Test single exp
        let points = vector[
            basepoint(),
        ];

        let scalars = vector[
            Scalar { data: A_SCALAR },
        ];

        let result = multi_scalar_mul(&points, &scalars);
        let expected = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));

        assert!(point_equals(&result, &expected), 1);
    }

    #[test]
    fun test_multi_scalar_mul_double() {
        // Test double exp
        let points = vector[
            basepoint(),
            basepoint(),
        ];

        let scalars = vector[
            Scalar { data: A_SCALAR },
            Scalar { data: B_SCALAR },
        ];

        let result = multi_scalar_mul(&points, &scalars);
        let expected = basepoint_double_mul(
            std::vector::borrow(&scalars, 0),
            &basepoint(),
            std::vector::borrow(&scalars, 1));

        assert!(point_equals(&result, &expected), 1);
    }

    #[test]
    fun test_multi_scalar_mul_many() {
        let scalars = vector[
            new_scalar_from_sha2_512(b"1"),
            new_scalar_from_sha2_512(b"2"),
            new_scalar_from_sha2_512(b"3"),
            new_scalar_from_sha2_512(b"4"),
            new_scalar_from_sha2_512(b"5"),
        ];

        let points = vector[
            new_point_from_sha2_512(b"1"),
            new_point_from_sha2_512(b"2"),
            new_point_from_sha2_512(b"3"),
            new_point_from_sha2_512(b"4"),
            new_point_from_sha2_512(b"5"),
        ];

        let expected = std::option::extract(&mut new_point_from_bytes(x"c4a98fbe6bd0f315a0c150858aec8508be397443093e955ef982e299c1318928"));
        let result = multi_scalar_mul(&points, &scalars);

        assert!(point_equals(&expected, &result), 1);
    }

    #[test]
    fun test_new_point_from_sha2_512() {
        let msg = b"To really appreciate architecture, you may even need to commit a murder";
        let expected = option::extract(&mut new_point_from_bytes(x"baaa91eb43e5e2f12ffc96347e14bc458fdb1772b2232b08977ee61ea9f84e31"));

        assert!(point_equals(&expected, &new_point_from_sha2_512(msg)), 1);
    }

    #[test]
    fun test_new_point_from_64_uniform_bytes() {
        let bytes_64 = x"baaa91eb43e5e2f12ffc96347e14bc458fdb1772b2232b08977ee61ea9f84e31e87feda199d72b83de4f5b2d45d34805c57019c6c59c42cb70ee3d19aa996f75";
        let expected = option::extract(&mut new_point_from_bytes(x"4a8e429f906478654232d7ae180ad60854754944ac67f38e20d8fa79e4b7d71e"));

        let point = option::extract(&mut new_point_from_64_uniform_bytes(bytes_64));
        assert!(point_equals(&expected, &point), 1);
    }

    #[test]
    fun test_scalar_basic_viability() {
        // Test conversion from u8
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_equals(&new_scalar_from_u8(2u8), &two), 1);

        // Test conversion from u64
        assert!(scalar_equals(&new_scalar_from_u64(2u64), &two), 1);

        // Test conversion from u128
        assert!(scalar_equals(&new_scalar_from_u128(2u128), &two), 1);

        // Test (0 - 1) % order = order - 1
        assert!(scalar_equals(&scalar_sub(&scalar_zero(), &scalar_one()), &Scalar { data: L_MINUS_ONE }), 1);
    }

    #[test]
    /// Tests deserializing a Scalar from a sequence of canonical bytes
    fun test_scalar_from_canonical_bytes() {
        // Too few bytes
        assert!(std::option::is_none(&new_scalar_from_bytes(x"00")), 1);

        // 32 zero bytes are canonical
        assert!(std::option::is_some(&new_scalar_from_bytes(x"0000000000000000000000000000000000000000000000000000000000000000")), 1);

        // Non-canonical because unreduced
        assert!(std::option::is_none(&new_scalar_from_bytes(x"1010101010101010101010101010101010101010101010101010101010101010")), 1);

        // Canonical because \\ell - 1
        assert!(std::option::is_some(&new_scalar_from_bytes(L_MINUS_ONE)), 1);

        // Non-canonical because \\ell
        assert!(std::option::is_none(&new_scalar_from_bytes(ORDER_ELL)), 1);

        // Non-canonical because \\ell+1
        assert!(std::option::is_none(&new_scalar_from_bytes(L_PLUS_ONE)), 1);

        // Non-canonical because \\ell+2
        assert!(std::option::is_none(&new_scalar_from_bytes(L_PLUS_TWO)), 1);

        // Non-canonical because high bit is set
        let non_canonical_highbit = vector[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128];
        let non_canonical_highbit_hex = x"0000000000000000000000000000000000000000000000000000000000000080";
        assert!(non_canonical_highbit == non_canonical_highbit_hex, 1);
        assert!(std::option::is_none(&new_scalar_from_bytes(non_canonical_highbit)), 1);
    }

    #[test]
    fun test_scalar_zero() {
        // 0 == 0
        assert!(scalar_is_zero(&scalar_zero()), 1);
        assert!(scalar_is_zero(&new_scalar_from_u8(0u8)), 1);

        // 0 != 1
        assert!(scalar_is_zero(&scalar_one()) == false, 1);

        // Pick a random scalar by hashing from some "random" bytes
        let s = new_scalar_from_sha2_512(x"deadbeef");

        // Technically, there is a negligible probability (i.e., 1/2^\\ell) that the hashed s is zero or one
        assert!(scalar_is_zero(&s) == false, 1);
        assert!(scalar_is_one(&s) == false, 1);

        // Multiply 0 with a random scalar and make sure you get zero
        assert!(scalar_is_zero(&scalar_mul(&scalar_zero(), &s)), 1);
        assert!(scalar_is_zero(&scalar_mul(&s, &scalar_zero())), 1);
    }

    #[test]
    fun test_scalar_one() {
        // 1 == 1
        assert!(scalar_is_one(&scalar_one()), 1);
        assert!(scalar_is_one(&new_scalar_from_u8(1u8)), 1);

        // 1 != 0
        assert!(scalar_is_one(&scalar_zero()) == false, 1);

        // Pick a random scalar by hashing from some "random" bytes
        let s = new_scalar_from_sha2_512(x"deadbeef");
        let inv = scalar_invert(&s);

        // Technically, there is a negligible probability (i.e., 1/2^\\ell) that s was zero and the call above returned None
        assert!(std::option::is_some(&inv), 1);

        let inv = std::option::extract(&mut inv);

        // Multiply s with s^{-1} and make sure you get one
        assert!(scalar_is_one(&scalar_mul(&s, &inv)), 1);
        assert!(scalar_is_one(&scalar_mul(&inv, &s)), 1);
    }

    #[test]
    fun test_scalar_from_sha2_512() {
        // Test a specific message hashes correctly to the field
        let str: vector<u8> = vector[];
        std::vector::append(&mut str, b"To really appreciate architecture, you may even need to commit a murder.");
        std::vector::append(&mut str, b"While the programs used for The Manhattan Transcripts are of the most extreme");
        std::vector::append(&mut str, b"nature, they also parallel the most common formula plot: the archetype of");
        std::vector::append(&mut str, b"murder. Other phantasms were occasionally used to underline the fact that");
        std::vector::append(&mut str, b"perhaps all architecture, rather than being about functional standards, is");
        std::vector::append(&mut str, b"about love and death.");

        let s = new_scalar_from_sha2_512(str);

        let expected: vector<u8> = vector[
            21, 88, 208, 252, 63, 122, 210, 152,
            154, 38, 15, 23, 16, 167, 80, 150,
            192, 221, 77, 226, 62, 25, 224, 148,
            239, 48, 176, 10, 185, 69, 168, 11
        ];

        assert!(s.data == expected, 1)
    }

    #[test]
    fun test_scalar_invert() {
        // Cannot invert zero
        assert!(std::option::is_none(&scalar_invert(&scalar_zero())), 1);

        // One's inverse is one
        let one = scalar_invert(&scalar_one());
        assert!(std::option::is_some(&one), 1);

        let one = std::option::extract(&mut one);
        assert!(scalar_is_one(&one), 1);

        // Test a random point X's inverse is correct
        let x = Scalar { data: X_SCALAR };
        let xinv = scalar_invert(&x);
        assert!(std::option::is_some(&xinv), 1);

        let xinv = std::option::extract(&mut xinv);
        let xinv_expected = Scalar { data: X_INV_SCALAR };

        assert!(scalar_equals(&xinv, &xinv_expected), 1)
    }

    #[test]
    fun test_scalar_neg() {
        // -(-X) == X
        let x = Scalar { data: X_SCALAR };

        let x_neg = scalar_neg(&x);
        let x_neg_neg = scalar_neg(&x_neg);

        assert!(scalar_equals(&x, &x_neg_neg), 1);
    }

    #[test]
    fun test_scalar_neg_assign() {
        let x = Scalar { data: X_SCALAR };
        let x_copy = x;

        scalar_neg_assign(&mut x);
        assert!(!scalar_equals(&x, &x_copy), 1);
        scalar_neg_assign(&mut x);
        assert!(scalar_equals(&x, &x_copy), 1);

        assert!(scalar_equals(scalar_neg_assign(scalar_neg_assign(&mut x)), &x_copy), 1);
    }

    #[test]
    fun test_scalar_mul() {
        // X * 1 == X
        let x = Scalar { data: X_SCALAR };
        assert!(scalar_equals(&x, &scalar_mul(&x, &scalar_one())), 1);

        // Test multiplication of two random scalars
        let y = Scalar { data: Y_SCALAR };
        let x_times_y = Scalar { data: X_TIMES_Y_SCALAR };
        assert!(scalar_equals(&scalar_mul(&x, &y), &x_times_y), 1);

        // A * B
        assert!(scalar_equals(&scalar_mul(&Scalar { data: A_SCALAR }, &Scalar { data: B_SCALAR }), &Scalar { data: A_TIMES_B_SCALAR }), 1);
    }

    #[test]
    fun test_scalar_mul_assign() {
        let x = Scalar { data: X_SCALAR };
        let y = Scalar { data: Y_SCALAR };
        let x_times_y = Scalar { data: X_TIMES_Y_SCALAR };

        scalar_mul_assign(&mut x, &y);

        assert!(scalar_equals(&x, &x_times_y), 1);
    }

    #[test]
    fun test_scalar_add() {
        // Addition reduces: \\ell-1 + 1 = \\ell = 0
        let ell_minus_one = Scalar { data: L_MINUS_ONE };
        assert!(scalar_is_zero(&scalar_add(&ell_minus_one, &scalar_one())), 1);

        // 1 + 1 = 2
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_equals(&scalar_add(&scalar_one(), &scalar_one()), &two), 1);

        // A + B
        assert!(scalar_equals(&scalar_add(&Scalar { data: A_SCALAR }, &Scalar { data: B_SCALAR }), &Scalar { data: A_PLUS_B_SCALAR }), 1);
    }

    #[test]
    fun test_scalar_sub() {
        // Subtraction reduces: 0 - 1 = \\ell - 1
        let ell_minus_one = Scalar { data: L_MINUS_ONE };
        assert!(scalar_equals(&scalar_sub(&scalar_zero(), &scalar_one()), &ell_minus_one), 1);

        // 2 - 1 = 1
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_is_one(&scalar_sub(&two, &scalar_one())), 1);

        // 1 - 2 = -1 = \\ell - 1
        let ell_minus_one = Scalar { data: L_MINUS_ONE };
        assert!(scalar_equals(&scalar_sub(&scalar_one(), &two), &ell_minus_one), 1);
    }

    #[test]
    fun test_scalar_reduced_from_32_bytes() {
        // \\ell + 2 = 0 + 2 = 2 (modulo \\ell)
        let s = std::option::extract(&mut new_scalar_reduced_from_32_bytes(L_PLUS_TWO));
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_equals(&s, &two), 1);

        // Reducing the all 1's bit vector yields $(2^256 - 1) \\mod \\ell$
        let biggest = std::option::extract(&mut new_scalar_reduced_from_32_bytes(NON_CANONICAL_ALL_ONES));
        assert!(scalar_equals(&biggest, &Scalar { data: REDUCED_2_256_MINUS_1_SCALAR }), 1);
    }

    #[test]
    fun test_scalar_from_64_uniform_bytes() {
        // Test X + 2^256 * X reduces correctly
        let x_plus_2_to_256_times_x: vector<u8> = vector[];

        std::vector::append(&mut x_plus_2_to_256_times_x, X_SCALAR);
        std::vector::append(&mut x_plus_2_to_256_times_x, X_SCALAR);

        let reduced = std::option::extract(&mut new_scalar_uniform_from_64_bytes(x_plus_2_to_256_times_x));
        let expected = Scalar { data: REDUCED_X_PLUS_2_TO_256_TIMES_X_SCALAR };
        assert!(scalar_equals(&reduced, &expected), 1)
    }

    #[test]
    fun test_scalar_to_bytes() {
        // zero is canonical
        assert!(scalar_is_canonical_internal(scalar_zero().data), 1);

        // ...but if we maul it and set the high bit to 1, it is non-canonical
        let non_can = scalar_zero();
        let last_byte = std::vector::borrow_mut(&mut non_can.data, 31);
        *last_byte = 128;
        assert!(!scalar_is_canonical_internal(non_can.data), 1);

        // This test makes sure scalar_to_bytes does not return a mutable reference to a scalar's bits
        let non_can = scalar_zero();
        let bytes = scalar_to_bytes(&scalar_zero());
        let last_byte = std::vector::borrow_mut(&mut bytes, 31);
        *last_byte = 128;
        assert!(scalar_is_canonical_internal(non_can.data), 1);
        assert!(scalar_equals(&non_can, &scalar_zero()), 1);
    }

    #[test]
    fun test_num_points_within_limit() {
        let limit = 10000;
        let i = 0;
        while (i < limit) {
            point_identity();
            i = i + 1;
        }
    }

    #[test]
    #[expected_failure(abort_code=0x090004, location=Self)]
    fun test_num_points_limit_exceeded() {
        let limit = 10001;
        let i = 0;
        while (i < limit) {
            point_identity();
            i = i + 1;
        }
    }
}
`, "name": "ristretto255.move" }, { "content": '/// This module implements a Bulletproof range proof verifier on the Ristretto255 curve.\n///\n/// A Bulletproof-based zero-knowledge range proof is a proof that a Pedersen commitment\n/// $c = v G + r H$ commits to an $n$-bit value $v$ (i.e., $v \\in [0, 2^n)$). Currently, this module only supports\n/// $n \\in \\{8, 16, 32, 64\\}$ for the number of bits.\nmodule aptos_std::ristretto255_bulletproofs {\n    use std::error;\n    use std::features;\n    use aptos_std::ristretto255_pedersen as pedersen;\n    use aptos_std::ristretto255::{Self, RistrettoPoint};\n\n    //\n    // Constants\n    //\n\n    /// The maximum range supported by the Bulletproofs library is $[0, 2^{64})$.\n    const MAX_RANGE_BITS : u64 = 64;\n\n    //\n    // Error codes\n    //\n\n    /// There was an error deserializing the range proof.\n    const E_DESERIALIZE_RANGE_PROOF: u64 = 1;\n\n    /// The committed value given to the prover is too large.\n    const E_VALUE_OUTSIDE_RANGE: u64 = 2;\n\n    /// The range proof system only supports proving ranges of type $[0, 2^b)$ where $b \\in \\{8, 16, 32, 64\\}$.\n    const E_RANGE_NOT_SUPPORTED: u64 = 3;\n\n    /// The native functions have not been rolled out yet.\n    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 4;\n\n    //\n    // Structs\n    //\n\n    /// Represents a zero-knowledge range proof that a value committed inside a Pedersen commitment lies in\n    /// `[0, 2^{MAX_RANGE_BITS})`.\n    struct RangeProof has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    //\n    // Public functions\n    //\n\n    /// Returns the maximum # of bits that the range proof system can verify proofs for.\n    public fun get_max_range_bits(): u64 {\n        MAX_RANGE_BITS\n    }\n\n    /// Deserializes a range proof from a sequence of bytes. The serialization format is the same as the format in\n    /// the zkcrypto\'s `bulletproofs` library (https://docs.rs/bulletproofs/4.0.0/bulletproofs/struct.RangeProof.html#method.from_bytes).\n    public fun range_proof_from_bytes(bytes: vector<u8>): RangeProof {\n        RangeProof {\n            bytes\n        }\n    }\n\n    /// Returns the byte-representation of a range proof.\n    public fun range_proof_to_bytes(proof: &RangeProof): vector<u8> {\n        proof.bytes\n    }\n\n    /// Verifies a zero-knowledge range proof that the value `v` committed in `com` (under the default Bulletproofs\n    /// commitment key; see `pedersen::new_commitment_for_bulletproof`) satisfies $v \\in [0, 2^b)$. Only works\n    /// for $b \\in \\{8, 16, 32, 64\\}$. Additionally, checks that the prover used `dst` as the domain-separation\n    /// tag (DST).\n    ///\n    /// WARNING: The DST check is VERY important for security as it prevents proofs computed for one application\n    /// (a.k.a., a _domain_) with `dst_1` from verifying in a different application with `dst_2 != dst_1`.\n    public fun verify_range_proof_pedersen(com: &pedersen::Commitment, proof: &RangeProof, num_bits: u64, dst: vector<u8>): bool {\n        assert!(features::bulletproofs_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));\n\n        verify_range_proof_internal(\n            ristretto255::point_to_bytes(&pedersen::commitment_as_compressed_point(com)),\n            &ristretto255::basepoint(), &ristretto255::hash_to_point_base(),\n            proof.bytes,\n            num_bits,\n            dst\n        )\n    }\n\n    /// Verifies a zero-knowledge range proof that the value `v` committed in `com` (as v * val_base + r * rand_base,\n    /// for some randomness `r`) satisfies `v` in `[0, 2^num_bits)`. Only works for `num_bits` in `{8, 16, 32, 64}`.\n    public fun verify_range_proof(\n        com: &RistrettoPoint,\n        val_base: &RistrettoPoint, rand_base: &RistrettoPoint,\n        proof: &RangeProof, num_bits: u64, dst: vector<u8>): bool\n    {\n        assert!(features::bulletproofs_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));\n\n        verify_range_proof_internal(\n            ristretto255::point_to_bytes(&ristretto255::point_compress(com)),\n            val_base, rand_base,\n            proof.bytes, num_bits, dst\n        )\n    }\n\n    #[test_only]\n    /// Computes a range proof for the Pedersen commitment to \'val\' with randomness \'r\', under the default Bulletproofs\n    /// commitment key; see `pedersen::new_commitment_for_bulletproof`. Returns the said commitment too.\n    ///  Only works for `num_bits` in `{8, 16, 32, 64}`.\n    public fun prove_range_pedersen(val: &Scalar, r: &Scalar, num_bits: u64, dst: vector<u8>): (RangeProof, pedersen::Commitment) {\n        let (bytes, compressed_comm) = prove_range_internal(scalar_to_bytes(val), scalar_to_bytes(r), num_bits, dst, &ristretto255::basepoint(), &ristretto255::hash_to_point_base());\n        let point = ristretto255::new_compressed_point_from_bytes(compressed_comm);\n        let point = &std::option::extract(&mut point);\n\n        (\n            RangeProof { bytes },\n            pedersen::commitment_from_compressed(point)\n        )\n    }\n\n    //\n    // Native functions\n    //\n\n    /// Aborts with `error::invalid_argument(E_DESERIALIZE_RANGE_PROOF)` if `proof` is not a valid serialization of a\n    /// range proof.\n    /// Aborts with `error::invalid_argument(E_RANGE_NOT_SUPPORTED)` if an unsupported `num_bits` is provided.\n    native fun verify_range_proof_internal(\n        com: vector<u8>,\n        val_base: &RistrettoPoint,\n        rand_base: &RistrettoPoint,\n        proof: vector<u8>,\n        num_bits: u64,\n        dst: vector<u8>): bool;\n\n    #[test_only]\n    /// Returns a tuple consisting of (1) a range proof for \'val\' committed with randomness \'r\' under the default Bulletproofs\n    /// commitment key and (2) the commitment itself.\n    ///\n    /// Aborts with `error::invalid_argument(E_RANGE_NOT_SUPPORTED)` if an unsupported `num_bits` is provided.\n    /// Aborts with `error::invalid_argument(E_VALUE_OUTSIDE_RANGE)` if an `val_base` is not `num_bits` wide.\n    native fun prove_range_internal(\n        val: vector<u8>,\n        r: vector<u8>,\n        num_bits: u64,\n        dst: vector<u8>,\n        val_base: &RistrettoPoint,\n        rand_base: &RistrettoPoint): (vector<u8>, vector<u8>);\n\n    //\n    // Testing\n    //\n\n    #[test_only]\n    use aptos_std::ristretto255::{Scalar, scalar_to_bytes, point_equals};\n\n    #[test_only]\n    const A_DST: vector<u8> = b"AptosBulletproofs";\n    #[test_only]\n    const A_VALUE: vector<u8> = x"870c2fa1b2e9ac45000000000000000000000000000000000000000000000000";  // i.e., 5020644638028926087u64\n    #[test_only]\n    const A_BLINDER: vector<u8> = x"e7c7b42b75503bfc7b1932783786d227ebf88f79da752b68f6b865a9c179640c";\n    // Pedersen commitment to A_VALUE with randomness A_BLINDER\n    #[test_only]\n    const A_COMM: vector<u8> = x"0a665260a4e42e575882c2cdcb3d0febd6cf168834f6de1e9e61e7b2e53dbf14";\n    // Range proof for A_COMM using domain-separation tag in A_DST, and MAX_RANGE_BITS\n    #[test_only]\n    const A_RANGE_PROOF_PEDERSEN: vector<u8> = x"d8d422d3fb9511d1942b78e3ec1a8c82fe1c01a0a690c55a4761e7e825633a753cca816667d2cbb716fe04a9c199cad748c2d4e59de4ed04fedf5f04f4341a74ae75b63c1997fd65d5fb3a8c03ad8771abe2c0a4f65d19496c11d948d6809503eac4d996f2c6be4e64ebe2df31102c96f106695bdf489dc9290c93b4d4b5411fb6298d0c33afa57e2e1948c38ef567268a661e7b1c099272e29591e717930a06a2c6e0e2d56aedea3078fd59334634f1a4543069865409eba074278f191039083102a9a0621791a9be09212a847e22061e083d7a712b05bca7274b25e4cb1201c679c4957f0842d7661fa1d3f5456a651e89112628b456026f8ad3a7abeaba3fec8031ec8b0392c0aa6c96205f7b21b0c2d6b5d064bd5bd1a1d91c41625d910688fa0dca35ec0f0e31a45792f8d6a330be970a22e1e0773111a083de893c89419ee7de97295978de90bcdf873a2826746809e64f9143417dbed09fa1c124e673febfed65c137cc45fabda963c96b64645802d1440cba5e58717e539f55f3321ab0c0f60410fba70070c5db500fee874265a343a2a59773fd150bcae09321a5166062e176e2e76bef0e3dd1a9250bcb7f4c971c10f0b24eb2a94e009b72c1fc21ee4267881e27b4edba8bed627ddf37e0c53cd425bc279d0c50d154d136503e54882e9541820d6394bd52ca2b438fd8c517f186fec0649c4846c4e43ce845d80e503dee157ce55392188039a7efc78719107ab989db8d9363b9dfc1946f01a84dbca5e742ed5f30b07ac61cf17ce2cf2c6a49d799ed3968a63a3ccb90d9a0e50960d959f17f202dd5cf0f2c375a8a702e063d339e48c0227e7cf710157f63f13136d8c3076c672ea2c1028fc1825366a145a4311de6c2cc46d3144ae3d2bc5808819b9817be3fce1664ecb60f74733e75e97ca8e567d1b81bdd4c56c7a340ba00";\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x010003, location = Self)]\n    fun test_unsupported_ranges(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);\n\n        let comm = ristretto255::new_point_from_bytes(A_COMM);\n        let comm = std::option::extract(&mut comm);\n        let comm = pedersen::commitment_from_point(comm);\n\n        assert!(verify_range_proof_pedersen(\n            &comm,\n            &range_proof_from_bytes(A_RANGE_PROOF_PEDERSEN), 10, A_DST), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_prover(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);\n\n        let v = ristretto255::new_scalar_from_u64(59);\n        let r = ristretto255::new_scalar_from_bytes(A_BLINDER);\n        let r = std::option::extract(&mut r);\n        let num_bits = 8;\n\n        let (proof, comm) = prove_range_pedersen(&v, &r, num_bits, A_DST);\n\n        assert!(verify_range_proof_pedersen(&comm, &proof, 64, A_DST) == false, 1);\n        assert!(verify_range_proof_pedersen(&comm, &proof, 32, A_DST) == false, 1);\n        assert!(verify_range_proof_pedersen(&comm, &proof, 16, A_DST) == false, 1);\n        assert!(verify_range_proof_pedersen(&comm, &proof, num_bits, A_DST), 1);\n    }\n\n    #[test(fx = @std)]\n    #[expected_failure(abort_code = 0x010001, location = Self)]\n    fun test_empty_range_proof(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);\n\n        let proof = &range_proof_from_bytes(vector[ ]);\n        let num_bits = 64;\n        let com = pedersen::new_commitment_for_bulletproof(\n            &ristretto255::scalar_one(),\n            &ristretto255::new_scalar_from_sha2_512(b"hello random world")\n        );\n\n        // This will fail with error::invalid_argument(E_DESERIALIZE_RANGE_PROOF)\n        verify_range_proof_pedersen(&com, proof, num_bits, A_DST);\n    }\n\n    #[test(fx = @std)]\n    fun test_valid_range_proof_verifies_against_comm(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);\n\n        let value = ristretto255::new_scalar_from_bytes(A_VALUE);\n        let value = std::option::extract(&mut value);\n\n        let blinder = ristretto255::new_scalar_from_bytes(A_BLINDER);\n        let blinder = std::option::extract(&mut blinder);\n\n        let comm = pedersen::new_commitment_for_bulletproof(&value, &blinder);\n\n        let expected_comm = std::option::extract(&mut ristretto255::new_point_from_bytes(A_COMM));\n        assert!(point_equals(pedersen::commitment_as_point(&comm), &expected_comm), 1);\n\n        assert!(verify_range_proof_pedersen(\n            &comm,\n            &range_proof_from_bytes(A_RANGE_PROOF_PEDERSEN), MAX_RANGE_BITS, A_DST), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_invalid_range_proof_fails_verification(fx: signer) {\n        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);\n\n        let comm = ristretto255::new_point_from_bytes(A_COMM);\n        let comm = std::option::extract(&mut comm);\n        let comm = pedersen::commitment_from_point(comm);\n\n        // Take a valid proof...\n        let range_proof_invalid = A_RANGE_PROOF_PEDERSEN;\n\n        // ...and modify a byte in the middle of the proof\n        let pos = std::vector::length(&range_proof_invalid) / 2;\n        let byte = std::vector::borrow_mut(&mut range_proof_invalid, pos);\n        *byte = *byte + 1;\n\n        assert!(verify_range_proof_pedersen(\n            &comm,\n            &range_proof_from_bytes(range_proof_invalid), MAX_RANGE_BITS, A_DST) == false, 1);\n    }\n}\n', "name": "ristretto255_bulletproofs.move" }, { "content": "/// This module implements an ElGamal encryption API, over the Ristretto255 curve, that can be used with the\n/// Bulletproofs module.\n///\n/// An ElGamal *ciphertext* is an encryption of a value `v` under a basepoint `G` and public key `Y = sk * G`, where `sk`\n/// is the corresponding secret key, is `(v * G + r * Y, r * G)`, for a random scalar `r`.\n///\n/// Note that we place the value `v` \"in the exponent\" of `G` so that ciphertexts are additively homomorphic: i.e., so\n/// that `Enc_Y(v, r) + Enc_Y(v', r') = Enc_Y(v + v', r + r')` where `v, v'` are plaintext messages, `Y` is a public key and `r, r'`\n/// are the randomness of the ciphertexts.\n\nmodule aptos_std::ristretto255_elgamal {\n    use aptos_std::ristretto255::{Self, RistrettoPoint, Scalar, CompressedRistretto, point_compress};\n    use std::option::Option;\n    use std::vector;\n\n    //\n    // Structs\n    //\n\n    /// An ElGamal ciphertext.\n    struct Ciphertext has drop {\n        left: RistrettoPoint,   // v * G + r * Y\n        right: RistrettoPoint,  // r * G\n    }\n\n    /// A compressed ElGamal ciphertext.\n    struct CompressedCiphertext has store, copy, drop {\n        left: CompressedRistretto,\n        right: CompressedRistretto,\n    }\n\n    /// An ElGamal public key.\n    struct CompressedPubkey has store, copy, drop {\n        point: CompressedRistretto,\n    }\n\n    //\n    // Public functions\n    //\n\n    /// Creates a new public key from a serialized Ristretto255 point.\n    public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {\n        let point = ristretto255::new_compressed_point_from_bytes(bytes);\n        if (std::option::is_some(&mut point)) {\n            let pk = CompressedPubkey {\n                point: std::option::extract(&mut point)\n            };\n            std::option::some(pk)\n        } else {\n            std::option::none<CompressedPubkey>()\n        }\n    }\n\n    /// Given an ElGamal public key `pubkey`, returns the byte representation of that public key.\n    public fun pubkey_to_bytes(pubkey: &CompressedPubkey): vector<u8> {\n        ristretto255::compressed_point_to_bytes(pubkey.point)\n    }\n\n    /// Given a public key `pubkey`, returns the underlying `RistrettoPoint` representing that key.\n    public fun pubkey_to_point(pubkey: &CompressedPubkey): RistrettoPoint {\n        ristretto255::point_decompress(&pubkey.point)\n    }\n\n    /// Given a public key, returns the underlying `CompressedRistretto` point representing that key.\n    public fun pubkey_to_compressed_point(pubkey: &CompressedPubkey): CompressedRistretto {\n        pubkey.point\n    }\n\n    /// Creates a new ciphertext from two serialized Ristretto255 points: the first 32 bytes store `r * G` while the\n    /// next 32 bytes store `v * G + r * Y`, where `Y` is the public key.\n    public fun new_ciphertext_from_bytes(bytes: vector<u8>): Option<Ciphertext> {\n        if(vector::length(&bytes) != 64) {\n            return std::option::none<Ciphertext>()\n        };\n\n        let bytes_right = vector::trim(&mut bytes, 32);\n\n        let left_point = ristretto255::new_point_from_bytes(bytes);\n        let right_point = ristretto255::new_point_from_bytes(bytes_right);\n\n        if (std::option::is_some<RistrettoPoint>(&mut left_point) && std::option::is_some<RistrettoPoint>(&mut right_point)) {\n            std::option::some<Ciphertext>(Ciphertext {\n                left: std::option::extract<RistrettoPoint>(&mut left_point),\n                right: std::option::extract<RistrettoPoint>(&mut right_point)\n            })\n        } else {\n            std::option::none<Ciphertext>()\n        }\n    }\n\n    /// Creates a new ciphertext `(val * G + 0 * Y, 0 * G) = (val * G, 0 * G)` where `G` is the Ristretto255 basepoint\n    /// and the randomness is set to zero.\n    public fun new_ciphertext_no_randomness(val: &Scalar): Ciphertext {\n        Ciphertext {\n            left: ristretto255::basepoint_mul(val),\n            right: ristretto255::point_identity(),\n        }\n    }\n\n    /// Moves a pair of Ristretto points into an ElGamal ciphertext.\n    public fun ciphertext_from_points(left: RistrettoPoint, right: RistrettoPoint): Ciphertext {\n        Ciphertext {\n            left,\n            right,\n        }\n    }\n\n    /// Moves a pair of `CompressedRistretto` points into an ElGamal ciphertext.\n    public fun ciphertext_from_compressed_points(left: CompressedRistretto, right: CompressedRistretto): CompressedCiphertext {\n        CompressedCiphertext {\n            left,\n            right,\n        }\n    }\n\n    /// Given a ciphertext `ct`, serializes that ciphertext into bytes.\n    public fun ciphertext_to_bytes(ct: &Ciphertext): vector<u8> {\n        let bytes_left = ristretto255::point_to_bytes(&ristretto255::point_compress(&ct.left));\n        let bytes_right = ristretto255::point_to_bytes(&ristretto255::point_compress(&ct.right));\n        let bytes = vector::empty<u8>();\n        vector::append<u8>(&mut bytes, bytes_left);\n        vector::append<u8>(&mut bytes, bytes_right);\n        bytes\n    }\n\n    /// Moves the ciphertext into a pair of `RistrettoPoint`'s.\n    public fun ciphertext_into_points(c: Ciphertext): (RistrettoPoint, RistrettoPoint) {\n        let Ciphertext { left, right } = c;\n        (left, right)\n    }\n\n    /// Returns the pair of `RistrettoPoint`'s representing the ciphertext.\n    public fun ciphertext_as_points(c: &Ciphertext): (&RistrettoPoint, &RistrettoPoint) {\n        (&c.left, &c.right)\n    }\n\n    /// Creates a new compressed ciphertext from a decompressed ciphertext.\n    public fun compress_ciphertext(ct: &Ciphertext): CompressedCiphertext {\n        CompressedCiphertext {\n            left: point_compress(&ct.left),\n            right: point_compress(&ct.right),\n        }\n    }\n\n    /// Creates a new decompressed ciphertext from a compressed ciphertext.\n    public fun decompress_ciphertext(ct: &CompressedCiphertext): Ciphertext {\n        Ciphertext {\n            left: ristretto255::point_decompress(&ct.left),\n            right: ristretto255::point_decompress(&ct.right),\n        }\n    }\n\n    /// Homomorphically combines two ciphertexts `lhs` and `rhs` as `lhs + rhs`.\n    /// Useful for re-randomizing the ciphertext or updating the committed value.\n    public fun ciphertext_add(lhs: &Ciphertext, rhs: &Ciphertext): Ciphertext {\n        Ciphertext {\n            left: ristretto255::point_add(&lhs.left, &rhs.left),\n            right: ristretto255::point_add(&lhs.right, &rhs.right),\n        }\n    }\n\n    /// Like `ciphertext_add` but assigns `lhs = lhs + rhs`.\n    public fun ciphertext_add_assign(lhs: &mut Ciphertext, rhs: &Ciphertext) {\n        ristretto255::point_add_assign(&mut lhs.left, &rhs.left);\n        ristretto255::point_add_assign(&mut lhs.right, &rhs.right);\n    }\n\n    /// Homomorphically combines two ciphertexts `lhs` and `rhs` as `lhs - rhs`.\n    /// Useful for re-randomizing the ciphertext or updating the committed value.\n    public fun ciphertext_sub(lhs: &Ciphertext, rhs: &Ciphertext): Ciphertext {\n        Ciphertext {\n            left: ristretto255::point_sub(&lhs.left, &rhs.left),\n            right: ristretto255::point_sub(&lhs.right, &rhs.right),\n        }\n    }\n\n    /// Like `ciphertext_add` but assigns `lhs = lhs - rhs`.\n    public fun ciphertext_sub_assign(lhs: &mut Ciphertext, rhs: &Ciphertext) {\n        ristretto255::point_sub_assign(&mut lhs.left, &rhs.left);\n        ristretto255::point_sub_assign(&mut lhs.right, &rhs.right);\n    }\n\n    /// Creates a copy of this ciphertext.\n    public fun ciphertext_clone(c: &Ciphertext): Ciphertext {\n        Ciphertext {\n            left: ristretto255::point_clone(&c.left),\n            right: ristretto255::point_clone(&c.right),\n        }\n    }\n\n    /// Returns true if the two ciphertexts are identical: i.e., same value and same randomness.\n    public fun ciphertext_equals(lhs: &Ciphertext, rhs: &Ciphertext): bool {\n        ristretto255::point_equals(&lhs.left, &rhs.left) &&\n        ristretto255::point_equals(&lhs.right, &rhs.right)\n    }\n\n    /// Returns the `RistrettoPoint` in the ciphertext which contains the encrypted value in the exponent.\n    public fun get_value_component(ct: &Ciphertext): &RistrettoPoint {\n        &ct.left\n    }\n\n    //\n    // Test-only functions\n    //\n\n    #[test_only]\n    /// Given an ElGamal secret key `sk`, returns the corresponding ElGamal public key as `sk * G`.\n    public fun pubkey_from_secret_key(sk: &Scalar): CompressedPubkey {\n        let point = ristretto255::basepoint_mul(sk);\n        CompressedPubkey {\n            point: point_compress(&point)\n        }\n    }\n\n    #[test_only]\n    /// Returns a ciphertext (v * point + r * pubkey, r * point) where `point` is *any* Ristretto255 point,\n    /// `pubkey` is the public key and `r` is the randomness.\n    public fun new_ciphertext(v: &Scalar, point: &RistrettoPoint, r: &Scalar, pubkey: &CompressedPubkey): Ciphertext {\n        Ciphertext {\n            left: ristretto255::double_scalar_mul(v, point, r, &pubkey_to_point(pubkey)),\n            right: ristretto255::point_mul(point, r),\n        }\n    }\n\n    #[test_only]\n    /// Returns a ciphertext (v * basepoint + r * pubkey, r * basepoint) where `basepoint` is the Ristretto255 basepoint\n    /// `pubkey` is the public key and `r` is the randomness.\n    public fun new_ciphertext_with_basepoint(v: &Scalar, r: &Scalar, pubkey: &CompressedPubkey): Ciphertext {\n        Ciphertext {\n            left: ristretto255::basepoint_double_mul(r, &pubkey_to_point(pubkey), v),\n            right: ristretto255::basepoint_mul(r),\n        }\n    }\n}\n", "name": "ristretto255_elgamal.move" }, { "content": '/// This module implements a Pedersen commitment API, over the Ristretto255 curve, that can be used with the\n/// Bulletproofs module.\n///\n/// A Pedersen commitment to a value `v` under _commitment key_ `(g, h)` is `v * g + r * h`, for a random scalar `r`.\n\nmodule aptos_std::ristretto255_pedersen {\n    use aptos_std::ristretto255::{Self, RistrettoPoint, Scalar, CompressedRistretto, point_compress};\n    use std::option::Option;\n\n    //\n    // Constants\n    //\n\n    /// The default Pedersen randomness base `h` used in our underlying Bulletproofs library.\n    /// This is obtained by hashing the compressed Ristretto255 basepoint using SHA3-512 (not SHA2-512).\n    const BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE : vector<u8> = x"8c9240b456a9e6dc65c377a1048d745f94a08cdb7f44cbcd7b46f34048871134";\n\n    //\n    // Structs\n    //\n\n    /// A Pedersen commitment to some value with some randomness.\n    struct Commitment has drop {\n        point: RistrettoPoint,\n    }\n\n    //\n    // Public functions\n    //\n\n    /// Creates a new public key from a serialized Ristretto255 point.\n    public fun new_commitment_from_bytes(bytes: vector<u8>): Option<Commitment> {\n        let point = ristretto255::new_point_from_bytes(bytes);\n        if (std::option::is_some(&mut point)) {\n            let comm = Commitment {\n                point: std::option::extract(&mut point)\n            };\n            std::option::some(comm)\n        } else {\n            std::option::none<Commitment>()\n        }\n    }\n\n    /// Returns a commitment as a serialized byte array\n    public fun commitment_to_bytes(comm: &Commitment): vector<u8> {\n        ristretto255::point_to_bytes(&ristretto255::point_compress(&comm.point))\n    }\n\n    /// Moves a Ristretto point into a Pedersen commitment.\n    public fun commitment_from_point(point: RistrettoPoint): Commitment {\n        Commitment {\n            point\n        }\n    }\n\n    /// Deserializes a commitment from a compressed Ristretto point.\n    public fun commitment_from_compressed(point: &CompressedRistretto): Commitment {\n        Commitment {\n            point: ristretto255::point_decompress(point)\n        }\n    }\n\n    /// Returns a commitment `v * val_base + r * rand_base` where `(val_base, rand_base)` is the commitment key.\n    public fun new_commitment(v: &Scalar, val_base: &RistrettoPoint, r: &Scalar, rand_base: &RistrettoPoint): Commitment {\n        Commitment {\n            point: ristretto255::double_scalar_mul(v, val_base, r, rand_base)\n        }\n    }\n\n    /// Returns a commitment `v * G + r * rand_base` where `G` is the Ristretto255 basepoint.\n    public fun new_commitment_with_basepoint(v: &Scalar, r: &Scalar, rand_base: &RistrettoPoint): Commitment {\n        Commitment {\n            point: ristretto255::basepoint_double_mul(r, rand_base, v)\n        }\n    }\n\n    /// Returns a commitment `v * G + r * H` where `G` is the Ristretto255 basepoint and `H` is the default randomness\n    /// base used in the Bulletproofs library (i.e., `BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE`).\n    public fun new_commitment_for_bulletproof(v: &Scalar, r: &Scalar): Commitment {\n        let rand_base = ristretto255::new_point_from_bytes(BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE);\n        let rand_base = std::option::extract(&mut rand_base);\n\n        Commitment {\n            point: ristretto255::basepoint_double_mul(r, &rand_base, v)\n        }\n    }\n\n    /// Homomorphically combines two commitments `lhs` and `rhs` as `lhs + rhs`.\n    /// Useful for re-randomizing the commitment or updating the committed value.\n    public fun commitment_add(lhs: &Commitment, rhs: &Commitment): Commitment {\n        Commitment {\n            point: ristretto255::point_add(&lhs.point, &rhs.point)\n        }\n    }\n\n    /// Like `commitment_add` but assigns `lhs = lhs + rhs`.\n    public fun commitment_add_assign(lhs: &mut Commitment, rhs: &Commitment) {\n        ristretto255::point_add_assign(&mut lhs.point, &rhs.point);\n    }\n\n    /// Homomorphically combines two commitments `lhs` and `rhs` as `lhs - rhs`.\n    /// Useful for re-randomizing the commitment or updating the committed value.\n    public fun commitment_sub(lhs: &Commitment, rhs: &Commitment): Commitment {\n        Commitment {\n            point: ristretto255::point_sub(&lhs.point, &rhs.point)\n        }\n    }\n\n    /// Like `commitment_add` but assigns `lhs = lhs - rhs`.\n    public fun commitment_sub_assign(lhs: &mut Commitment, rhs: &Commitment) {\n        ristretto255::point_sub_assign(&mut lhs.point, &rhs.point);\n    }\n\n    /// Creates a copy of this commitment.\n    public fun commitment_clone(c: &Commitment): Commitment {\n        Commitment {\n            point: ristretto255::point_clone(&c.point)\n        }\n    }\n\n    /// Returns true if the two commitments are identical: i.e., same value and same randomness.\n    public fun commitment_equals(lhs: &Commitment, rhs: &Commitment): bool {\n        ristretto255::point_equals(&lhs.point, &rhs.point)\n    }\n\n    /// Returns the underlying elliptic curve point representing the commitment as an in-memory `RistrettoPoint`.\n    public fun commitment_as_point(c: &Commitment): &RistrettoPoint {\n        &c.point\n    }\n\n    /// Returns the Pedersen commitment as a `CompressedRistretto` point.\n    public fun commitment_as_compressed_point(c: &Commitment): CompressedRistretto {\n        point_compress(&c.point)\n    }\n\n    /// Moves the Commitment into a CompressedRistretto point.\n    public fun commitment_into_point(c: Commitment): RistrettoPoint {\n        let Commitment { point } = c;\n        point\n    }\n\n    /// Moves the Commitment into a `CompressedRistretto` point.\n    public fun commitment_into_compressed_point(c: Commitment): CompressedRistretto {\n        point_compress(&c.point)\n    }\n\n    /// Returns the randomness base compatible with the Bulletproofs module.\n    ///\n    /// Recal that a Bulletproof range proof attests, in zero-knowledge, that a value `v` inside a Pedersen commitment\n    /// `v * g + r * h` is sufficiently "small" (e.g., is 32-bits wide). Here, `h` is referred to as the\n    /// "randomness base" of the commitment scheme.\n    ///\n    /// Bulletproof has a default choice for `g` and `h` and this function returns the default `h` as used in the\n    /// Bulletproofs Move module.\n    public fun randomness_base_for_bulletproof(): RistrettoPoint {\n        std::option::extract(&mut ristretto255::new_point_from_bytes(BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE))\n    }\n}\n', "name": "ristretto255_pedersen.move" }, { "content": '/// This module implements ECDSA signatures based on the prime-order secp256k1 ellptic curve (i.e., cofactor is 1).\n\nmodule aptos_std::secp256k1 {\n    use std::option::Option;\n\n    /// An error occurred while deserializing, for example due to wrong input size.\n    const E_DESERIALIZE: u64 = 1;   // This code must be the same, if ever returned from the native Rust implementation.\n\n    /// The size of a secp256k1-based ECDSA public key, in bytes.\n    const RAW_PUBLIC_KEY_NUM_BYTES: u64 = 64;\n    //const COMPRESSED_PUBLIC_KEY_SIZE: u64 = 33;\n\n    /// The size of a secp256k1-based ECDSA signature, in bytes.\n    const SIGNATURE_NUM_BYTES: u64 = 64;\n\n    /// A 64-byte ECDSA public key.\n    struct ECDSARawPublicKey has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// A 64-byte ECDSA signature.\n    struct ECDSASignature has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    /// Constructs an ECDSASignature struct from the given 64 bytes.\n    public fun ecdsa_signature_from_bytes(bytes: vector<u8>): ECDSASignature {\n        assert!(std::vector::length(&bytes) == SIGNATURE_NUM_BYTES, std::error::invalid_argument(E_DESERIALIZE));\n        ECDSASignature { bytes }\n    }\n\n    /// Constructs an ECDSARawPublicKey struct, given a 64-byte raw representation.\n    public fun ecdsa_raw_public_key_from_64_bytes(bytes: vector<u8>): ECDSARawPublicKey {\n        assert!(std::vector::length(&bytes) == RAW_PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_DESERIALIZE));\n        ECDSARawPublicKey { bytes }\n    }\n\n    /// Serializes an ECDSARawPublicKey struct to 64-bytes.\n    public fun ecdsa_raw_public_key_to_bytes(pk: &ECDSARawPublicKey): vector<u8> {\n        pk.bytes\n    }\n\n    /// Serializes an ECDSASignature struct to 64-bytes.\n    public fun ecdsa_signature_to_bytes(sig: &ECDSASignature): vector<u8> {\n        sig.bytes\n    }\n\n    /// Recovers the signer\'s raw (64-byte) public key from a secp256k1 ECDSA `signature` given the `recovery_id` and the signed\n    /// `message` (32 byte digest).\n    ///\n    /// Note that an invalid signature, or a signature from a different message, will result in the recovery of an\n    /// incorrect public key. This recovery algorithm can only be used to check validity of a signature if the signer\'s\n    /// public key (or its hash) is known beforehand.\n    public fun ecdsa_recover(\n        message: vector<u8>,\n        recovery_id: u8,\n        signature: &ECDSASignature,\n    ): Option<ECDSARawPublicKey> {\n        let (pk, success) = ecdsa_recover_internal(message, recovery_id, signature.bytes);\n        if (success) {\n            std::option::some(ecdsa_raw_public_key_from_64_bytes(pk))\n        } else {\n            std::option::none<ECDSARawPublicKey>()\n        }\n    }\n\n    //\n    // Native functions\n    //\n\n    /// Returns `(public_key, true)` if `signature` verifies on `message` under the recovered `public_key`\n    /// and returns `([], false)` otherwise.\n    native fun ecdsa_recover_internal(\n        message: vector<u8>,\n        recovery_id: u8,\n        signature: vector<u8>\n    ): (vector<u8>, bool);\n\n    //\n    // Tests\n    //\n\n    #[test]\n    /// Test on a valid secp256k1 ECDSA signature created using sk = x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"\n    fun test_ecdsa_recover() {\n        use std::hash;\n\n        let pk = ecdsa_recover(\n            hash::sha2_256(b"test aptos secp256k1"),\n            0,\n            &ECDSASignature { bytes: x"f7ad936da03f948c14c542020e3c5f4e02aaacd1f20427c11aa6e2fbf8776477646bba0e1a37f9e7c777c423a1d2849baafd7ff6a9930814a43c3f80d59db56f" },\n        );\n        assert!(std::option::is_some(&pk), 1);\n        assert!(std::option::extract(&mut pk).bytes == x"4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559", 1);\n\n        // Flipped bits; Signature stays valid\n        let pk = ecdsa_recover(\n            hash::sha2_256(b"test aptos secp256k1"),\n            0,\n            // NOTE: A \'7\' was flipped to an \'f\' here\n            &ECDSASignature { bytes: x"f7ad936da03f948c14c542020e3c5f4e02aaacd1f20427c11aa6e2fbf8776477646bba0e1a37f9e7c7f7c423a1d2849baafd7ff6a9930814a43c3f80d59db56f" },\n        );\n        assert!(std::option::is_some(&pk), 1);\n        assert!(std::option::extract(&mut pk).bytes != x"4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559", 1);\n\n        // Flipped bits; Signature becomes invalid\n        let pk = ecdsa_recover(\n            hash::sha2_256(b"test aptos secp256k1"),\n            0,\n            &ECDSASignature { bytes: x"ffad936da03f948c14c542020e3c5f4e02aaacd1f20427c11aa6e2fbf8776477646bba0e1a37f9e7c7f7c423a1d2849baafd7ff6a9930814a43c3f80d59db56f" },\n        );\n        assert!(std::option::is_none(&pk), 1);\n    }\n}\n', "name": "secp256k1.move" }, { "content": "module aptos_std::big_vector {\n    use std::error;\n    use std::vector;\n    use aptos_std::table_with_length::{Self, TableWithLength};\n    friend aptos_std::smart_vector;\n\n    /// Vector index is out of bounds\n    const EINDEX_OUT_OF_BOUNDS: u64 = 1;\n    /// Cannot destroy a non-empty vector\n    const EVECTOR_NOT_EMPTY: u64 = 2;\n    /// Cannot pop back from an empty vector\n    const EVECTOR_EMPTY: u64 = 3;\n    /// bucket_size cannot be 0\n    const EZERO_BUCKET_SIZE: u64 = 4;\n\n    /// A scalable vector implementation based on tables where elements are grouped into buckets.\n    /// Each bucket has a capacity of `bucket_size` elements.\n    struct BigVector<T> has store {\n        buckets: TableWithLength<u64, vector<T>>,\n        end_index: u64,\n        bucket_size: u64\n    }\n\n    /// Regular Vector API\n\n    /// Create an empty vector.\n    public(friend) fun empty<T: store>(bucket_size: u64): BigVector<T> {\n        assert!(bucket_size > 0, error::invalid_argument(EZERO_BUCKET_SIZE));\n        BigVector {\n            buckets: table_with_length::new(),\n            end_index: 0,\n            bucket_size,\n        }\n    }\n\n    /// Create a vector of length 1 containing the passed in element.\n    public(friend) fun singleton<T: store>(element: T, bucket_size: u64): BigVector<T> {\n        let v = empty(bucket_size);\n        push_back(&mut v, element);\n        v\n    }\n\n    /// Destroy the vector `v`.\n    /// Aborts if `v` is not empty.\n    public fun destroy_empty<T>(v: BigVector<T>) {\n        assert!(is_empty(&v), error::invalid_argument(EVECTOR_NOT_EMPTY));\n        let BigVector { buckets, end_index: _, bucket_size: _ } = v;\n        table_with_length::destroy_empty(buckets);\n    }\n\n    /// Destroy the vector `v` if T has `drop`\n    public fun destroy<T: drop>(v: BigVector<T>) {\n        let BigVector { buckets, end_index, bucket_size: _ } = v;\n        let i = 0;\n        while (end_index > 0) {\n            let num_elements = vector::length(&table_with_length::remove(&mut buckets, i));\n            end_index = end_index - num_elements;\n            i = i + 1;\n        };\n        table_with_length::destroy_empty(buckets);\n    }\n\n    /// Acquire an immutable reference to the `i`th element of the vector `v`.\n    /// Aborts if `i` is out of bounds.\n    public fun borrow<T>(v: &BigVector<T>, i: u64): &T {\n        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        vector::borrow(table_with_length::borrow(&v.buckets, i / v.bucket_size), i % v.bucket_size)\n    }\n\n    /// Return a mutable reference to the `i`th element in the vector `v`.\n    /// Aborts if `i` is out of bounds.\n    public fun borrow_mut<T>(v: &mut BigVector<T>, i: u64): &mut T {\n        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        vector::borrow_mut(table_with_length::borrow_mut(&mut v.buckets, i / v.bucket_size), i % v.bucket_size)\n    }\n\n    /// Empty and destroy the other vector, and push each of the elements in the other vector onto the lhs vector in the\n    /// same order as they occurred in other.\n    /// Disclaimer: This function is costly. Use it at your own discretion.\n    public fun append<T: store>(lhs: &mut BigVector<T>, other: BigVector<T>) {\n        let other_len = length(&other);\n        let half_other_len = other_len / 2;\n        let i = 0;\n        while (i < half_other_len) {\n            push_back(lhs, swap_remove(&mut other, i));\n            i = i + 1;\n        };\n        while (i < other_len) {\n            push_back(lhs, pop_back(&mut other));\n            i = i + 1;\n        };\n        destroy_empty(other);\n    }\n\n    /// Add element `val` to the end of the vector `v`. It grows the buckets when the current buckets are full.\n    /// This operation will cost more gas when it adds new bucket.\n    public fun push_back<T: store>(v: &mut BigVector<T>, val: T) {\n        let num_buckets = table_with_length::length(&v.buckets);\n        if (v.end_index == num_buckets * v.bucket_size) {\n            table_with_length::add(&mut v.buckets, num_buckets, vector::empty());\n            vector::push_back(table_with_length::borrow_mut(&mut v.buckets, num_buckets), val);\n        } else {\n            vector::push_back(table_with_length::borrow_mut(&mut v.buckets, num_buckets - 1), val);\n        };\n        v.end_index = v.end_index + 1;\n    }\n\n    /// Pop an element from the end of vector `v`. It doesn't shrink the buckets even if they're empty.\n    /// Call `shrink_to_fit` explicity to deallocate empty buckets.\n    /// Aborts if `v` is empty.\n    public fun pop_back<T>(v: &mut BigVector<T>): T {\n        assert!(!is_empty(v), error::invalid_state(EVECTOR_EMPTY));\n        let num_buckets = table_with_length::length(&v.buckets);\n        let last_bucket = table_with_length::borrow_mut(&mut v.buckets, num_buckets - 1);\n        let val = vector::pop_back(last_bucket);\n        // Shrink the table if the last vector is empty.\n        if (vector::is_empty(last_bucket)) {\n            move last_bucket;\n            vector::destroy_empty(table_with_length::remove(&mut v.buckets, num_buckets - 1));\n        };\n        v.end_index = v.end_index - 1;\n        val\n    }\n\n    /// Remove the element at index i in the vector v and return the owned value that was previously stored at i in v.\n    /// All elements occurring at indices greater than i will be shifted down by 1. Will abort if i is out of bounds.\n    /// Disclaimer: This function is costly. Use it at your own discretion.\n    public fun remove<T>(v: &mut BigVector<T>, i: u64): T {\n        let len = length(v);\n        assert!(i < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let num_buckets = table_with_length::length(&v.buckets);\n        let cur_bucket_index = i / v.bucket_size + 1;\n        let cur_bucket = table_with_length::borrow_mut(&mut v.buckets, cur_bucket_index - 1);\n        let res = vector::remove(cur_bucket, i % v.bucket_size);\n        v.end_index = v.end_index - 1;\n        move cur_bucket;\n        while ({\n            spec {\n                invariant cur_bucket_index <= num_buckets;\n                invariant table_with_length::spec_len(v.buckets) == num_buckets;\n            };\n            (cur_bucket_index < num_buckets)\n        }) {\n            // remove one element from the start of current vector\n            let cur_bucket = table_with_length::borrow_mut(&mut v.buckets, cur_bucket_index);\n            let t = vector::remove(cur_bucket, 0);\n            move cur_bucket;\n            // and put it at the end of the last one\n            let prev_bucket = table_with_length::borrow_mut(&mut v.buckets, cur_bucket_index - 1);\n            vector::push_back(prev_bucket, t);\n            cur_bucket_index = cur_bucket_index + 1;\n        };\n        spec {\n            assert cur_bucket_index == num_buckets;\n        };\n\n        // Shrink the table if the last vector is empty.\n        let last_bucket = table_with_length::borrow_mut(&mut v.buckets, num_buckets - 1);\n        if (vector::is_empty(last_bucket)) {\n            move last_bucket;\n            vector::destroy_empty(table_with_length::remove(&mut v.buckets, num_buckets - 1));\n        };\n\n        res\n    }\n\n    /// Swap the `i`th element of the vector `v` with the last element and then pop the vector.\n    /// This is O(1), but does not preserve ordering of elements in the vector.\n    /// Aborts if `i` is out of bounds.\n    public fun swap_remove<T>(v: &mut BigVector<T>, i: u64): T {\n        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let last_val = pop_back(v);\n        // if the requested value is the last one, return it\n        if (v.end_index == i) {\n            return last_val\n        };\n        // because the lack of mem::swap, here we swap remove the requested value from the bucket\n        // and append the last_val to the bucket then swap the last bucket val back\n        let bucket = table_with_length::borrow_mut(&mut v.buckets, i / v.bucket_size);\n        let bucket_len = vector::length(bucket);\n        let val = vector::swap_remove(bucket, i % v.bucket_size);\n        vector::push_back(bucket, last_val);\n        vector::swap(bucket, i % v.bucket_size, bucket_len - 1);\n        val\n    }\n\n    /// Swap the elements at the i'th and j'th indices in the vector v. Will abort if either of i or j are out of bounds\n    /// for v.\n    public fun swap<T>(v: &mut BigVector<T>, i: u64, j: u64) {\n        assert!(i < length(v) && j < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let i_bucket_index = i / v.bucket_size;\n        let j_bucket_index = j / v.bucket_size;\n        let i_vector_index = i % v.bucket_size;\n        let j_vector_index = j % v.bucket_size;\n        if (i_bucket_index == j_bucket_index) {\n            vector::swap(table_with_length::borrow_mut(&mut v.buckets, i_bucket_index), i_vector_index, j_vector_index);\n            return\n        };\n        // If i and j are in different buckets, take the buckets out first for easy mutation.\n        let bucket_i = table_with_length::remove(&mut v.buckets, i_bucket_index);\n        let bucket_j = table_with_length::remove(&mut v.buckets, j_bucket_index);\n        // Get the elements from buckets by calling `swap_remove`.\n        let element_i = vector::swap_remove(&mut bucket_i, i_vector_index);\n        let element_j = vector::swap_remove(&mut bucket_j, j_vector_index);\n        // Swap the elements and push back to the other bucket.\n        vector::push_back(&mut bucket_i, element_j);\n        vector::push_back(&mut bucket_j, element_i);\n        let last_index_in_bucket_i = vector::length(&bucket_i) - 1;\n        let last_index_in_bucket_j = vector::length(&bucket_j) - 1;\n        // Re-position the swapped elements to the right index.\n        vector::swap(&mut bucket_i, i_vector_index, last_index_in_bucket_i);\n        vector::swap(&mut bucket_j, j_vector_index, last_index_in_bucket_j);\n        // Add back the buckets.\n        table_with_length::add(&mut v.buckets, i_bucket_index, bucket_i);\n        table_with_length::add(&mut v.buckets, j_bucket_index, bucket_j);\n    }\n\n    /// Reverse the order of the elements in the vector v in-place.\n    /// Disclaimer: This function is costly. Use it at your own discretion.\n    public fun reverse<T>(v: &mut BigVector<T>) {\n        let new_buckets = vector[];\n        let push_bucket = vector[];\n        let num_buckets = table_with_length::length(&v.buckets);\n        let num_buckets_left = num_buckets;\n\n        while (num_buckets_left > 0) {\n            let pop_bucket = table_with_length::remove(&mut v.buckets, num_buckets_left - 1);\n            vector::for_each_reverse(pop_bucket, |val| {\n                vector::push_back(&mut push_bucket, val);\n                if (vector::length(&push_bucket) == v.bucket_size) {\n                    vector::push_back(&mut new_buckets, push_bucket);\n                    push_bucket = vector[];\n                };\n            });\n            num_buckets_left = num_buckets_left - 1;\n        };\n\n        if (vector::length(&push_bucket) > 0) {\n            vector::push_back(&mut new_buckets, push_bucket);\n        } else {\n            vector::destroy_empty(push_bucket);\n        };\n\n        vector::reverse(&mut new_buckets);\n        let i = 0;\n        assert!(table_with_length::length(&v.buckets) == 0, 0);\n        while (i < num_buckets) {\n            table_with_length::add(&mut v.buckets, i, vector::pop_back(&mut new_buckets));\n            i = i + 1;\n        };\n        vector::destroy_empty(new_buckets);\n    }\n\n    /// Return the index of the first occurrence of an element in v that is equal to e. Returns (true, index) if such an\n    /// element was found, and (false, 0) otherwise.\n    /// Disclaimer: This function is costly. Use it at your own discretion.\n    public fun index_of<T>(v: &BigVector<T>, val: &T): (bool, u64) {\n        let num_buckets = table_with_length::length(&v.buckets);\n        let bucket_index = 0;\n        while (bucket_index < num_buckets) {\n            let cur = table_with_length::borrow(&v.buckets, bucket_index);\n            let (found, i) = vector::index_of(cur, val);\n            if (found) {\n                return (true, bucket_index * v.bucket_size + i)\n            };\n            bucket_index = bucket_index + 1;\n        };\n        (false, 0)\n    }\n\n    /// Return if an element equal to e exists in the vector v.\n    /// Disclaimer: This function is costly. Use it at your own discretion.\n    public fun contains<T>(v: &BigVector<T>, val: &T): bool {\n        if (is_empty(v)) return false;\n        let (exist, _) = index_of(v, val);\n        exist\n    }\n\n    /// Convert a big vector to a native vector, which is supposed to be called mostly by view functions to get an\n    /// atomic view of the whole vector.\n    /// Disclaimer: This function may be costly as the big vector may be huge in size. Use it at your own discretion.\n    public fun to_vector<T: copy>(v: &BigVector<T>): vector<T> {\n        let res = vector[];\n        let num_buckets = table_with_length::length(&v.buckets);\n        let i = 0;\n        while (i < num_buckets) {\n            vector::append(&mut res, *table_with_length::borrow(&v.buckets, i));\n            i = i + 1;\n        };\n        res\n    }\n\n    /// Return the length of the vector.\n    public fun length<T>(v: &BigVector<T>): u64 {\n        v.end_index\n    }\n\n    /// Return `true` if the vector `v` has no elements and `false` otherwise.\n    public fun is_empty<T>(v: &BigVector<T>): bool {\n        length(v) == 0\n    }\n\n    #[test]\n    fun big_vector_test() {\n        let v = empty(5);\n        let i = 0;\n        while (i < 100) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        let j = 0;\n        while (j < 100) {\n            let val = borrow(&v, j);\n            assert!(*val == j, 0);\n            j = j + 1;\n        };\n        while (i > 0) {\n            i = i - 1;\n            let (exist, index) = index_of(&v, &i);\n            let j = pop_back(&mut v);\n            assert!(exist, 0);\n            assert!(index == i, 0);\n            assert!(j == i, 0);\n        };\n        while (i < 100) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        let last_index = length(&v) - 1;\n        assert!(swap_remove(&mut v, last_index) == 99, 0);\n        assert!(swap_remove(&mut v, 0) == 0, 0);\n        while (length(&v) > 0) {\n            // the vector is always [N, 1, 2, ... N-1] with repetitive swap_remove(&mut v, 0)\n            let expected = length(&v);\n            let val = swap_remove(&mut v, 0);\n            assert!(val == expected, 0);\n        };\n        destroy_empty(v);\n    }\n\n    #[test]\n    fun big_vector_append_edge_case_test() {\n        let v1 = empty(5);\n        let v2 = singleton(1u64, 7);\n        let v3 = empty(6);\n        let v4 = empty(8);\n        append(&mut v3, v4);\n        assert!(length(&v3) == 0, 0);\n        append(&mut v2, v3);\n        assert!(length(&v2) == 1, 0);\n        append(&mut v1, v2);\n        assert!(length(&v1) == 1, 0);\n        destroy(v1);\n    }\n\n    #[test]\n    fun big_vector_append_test() {\n        let v1 = empty(5);\n        let v2 = empty(7);\n        let i = 0;\n        while (i < 7) {\n            push_back(&mut v1, i);\n            i = i + 1;\n        };\n        while (i < 25) {\n            push_back(&mut v2, i);\n            i = i + 1;\n        };\n        append(&mut v1, v2);\n        assert!(length(&v1) == 25, 0);\n        i = 0;\n        while (i < 25) {\n            assert!(*borrow(&v1, i) == i, 0);\n            i = i + 1;\n        };\n        destroy(v1);\n    }\n\n    #[test]\n    fun big_vector_to_vector_test() {\n        let v1 = empty(7);\n        let i = 0;\n        while (i < 100) {\n            push_back(&mut v1, i);\n            i = i + 1;\n        };\n        let v2 = to_vector(&v1);\n        let j = 0;\n        while (j < 100) {\n            assert!(*vector::borrow(&v2, j) == j, 0);\n            j = j + 1;\n        };\n        destroy(v1);\n    }\n\n    #[test]\n    fun big_vector_remove_and_reverse_test() {\n        let v = empty(11);\n        let i = 0;\n        while (i < 101) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        remove(&mut v, 100);\n        remove(&mut v, 90);\n        remove(&mut v, 80);\n        remove(&mut v, 70);\n        remove(&mut v, 60);\n        remove(&mut v, 50);\n        remove(&mut v, 40);\n        remove(&mut v, 30);\n        remove(&mut v, 20);\n        remove(&mut v, 10);\n        remove(&mut v, 0);\n        assert!(length(&v) == 90, 0);\n\n        let index = 0;\n        i = 0;\n        while (i < 101) {\n            if (i % 10 != 0) {\n                assert!(*borrow(&v, index) == i, 0);\n                index = index + 1;\n            };\n            i = i + 1;\n        };\n        destroy(v);\n    }\n\n    #[test]\n    fun big_vector_swap_test() {\n        let v = empty(11);\n        let i = 0;\n        while (i < 101) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        i = 0;\n        while (i < 51) {\n            swap(&mut v, i, 100 - i);\n            i = i + 1;\n        };\n        i = 0;\n        while (i < 101) {\n            assert!(*borrow(&v, i) == 100 - i, 0);\n            i = i + 1;\n        };\n        destroy(v);\n    }\n\n    #[test]\n    fun big_vector_index_of_test() {\n        let v = empty(11);\n        let i = 0;\n        while (i < 100) {\n            push_back(&mut v, i);\n            let (found, idx) = index_of(&mut v, &i);\n            assert!(found && idx == i, 0);\n            i = i + 1;\n        };\n        destroy(v);\n    }\n\n    #[test]\n    fun big_vector_empty_contains() {\n        let v = empty<u64>(10);\n        assert!(!contains<u64>(&v, &(1 as u64)), 0);\n        destroy_empty(v);\n    }\n}\n", "name": "big_vector.move" }, { "content": '/// A smart table implementation based on linear hashing. (https://en.wikipedia.org/wiki/Linear_hashing)\n/// Compare to Table, it uses less storage slots but has higher chance of collision, a trade-off between space and time.\n/// Compare to other dynamic hashing implementation, linear hashing splits one bucket a time instead of doubling buckets\n/// when expanding to avoid unexpected gas cost.\n/// SmartTable uses faster hash function SipHash instead of cryptographically secure hash functions like sha3-256 since\n/// it tolerates collisions.\nmodule aptos_std::smart_table {\n    use std::error;\n    use std::vector;\n    use aptos_std::aptos_hash::sip_hash_from_value;\n    use aptos_std::table_with_length::{Self, TableWithLength};\n    use aptos_std::type_info::size_of_val;\n    use aptos_std::math64::max;\n    use aptos_std::simple_map::SimpleMap;\n    use aptos_std::simple_map;\n    use std::option::{Self, Option};\n\n    /// Key not found in the smart table\n    const ENOT_FOUND: u64 = 1;\n    /// Smart table capacity must be larger than 0\n    const EZERO_CAPACITY: u64 = 2;\n    /// Cannot destroy non-empty hashmap\n    const ENOT_EMPTY: u64 = 3;\n    /// Key already exists\n    const EALREADY_EXIST: u64 = 4;\n    /// Invalid load threshold percent to trigger split.\n    const EINVALID_LOAD_THRESHOLD_PERCENT: u64 = 5;\n    /// Invalid target bucket size.\n    const EINVALID_TARGET_BUCKET_SIZE: u64 = 6;\n    /// Invalid target bucket size.\n    const EEXCEED_MAX_BUCKET_SIZE: u64 = 7;\n    /// Invalid bucket index.\n    const EINVALID_BUCKET_INDEX: u64 = 8;\n    /// Invalid vector index within a bucket.\n    const EINVALID_VECTOR_INDEX: u64 = 9;\n\n    /// SmartTable entry contains both the key and value.\n    struct Entry<K, V> has copy, drop, store {\n        hash: u64,\n        key: K,\n        value: V,\n    }\n\n    struct SmartTable<K, V> has store {\n        buckets: TableWithLength<u64, vector<Entry<K, V>>>,\n        num_buckets: u64,\n        // number of bits to represent num_buckets\n        level: u8,\n        // total number of items\n        size: u64,\n        // Split will be triggered when target load threshold in percentage is reached when adding a new entry.\n        split_load_threshold: u8,\n        // The target size of each bucket, which is NOT enforced so oversized buckets can exist.\n        target_bucket_size: u64,\n    }\n\n    /// Create an empty SmartTable with default configurations.\n    public fun new<K: copy + drop + store, V: store>(): SmartTable<K, V> {\n        new_with_config<K, V>(0, 0, 0)\n    }\n\n    /// Create an empty SmartTable with customized configurations.\n    /// `num_initial_buckets`: The number of buckets on initialization. 0 means using default value.\n    /// `split_load_threshold`: The percent number which once reached, split will be triggered. 0 means using default\n    /// value.\n    /// `target_bucket_size`: The target number of entries per bucket, though not guaranteed. 0 means not set and will\n    /// dynamically assgined by the contract code.\n    public fun new_with_config<K: copy + drop + store, V: store>(\n        num_initial_buckets: u64,\n        split_load_threshold: u8,\n        target_bucket_size: u64\n    ): SmartTable<K, V> {\n        assert!(split_load_threshold <= 100, error::invalid_argument(EINVALID_LOAD_THRESHOLD_PERCENT));\n        let buckets = table_with_length::new();\n        table_with_length::add(&mut buckets, 0, vector::empty());\n        let table = SmartTable {\n            buckets,\n            num_buckets: 1,\n            level: 0,\n            size: 0,\n            // The default split load threshold is 75%.\n            split_load_threshold: if (split_load_threshold == 0) { 75 } else { split_load_threshold },\n            target_bucket_size,\n        };\n        // The default number of initial buckets is 2.\n        if (num_initial_buckets == 0) {\n            num_initial_buckets = 2;\n        };\n        while (num_initial_buckets > 1) {\n            num_initial_buckets = num_initial_buckets - 1;\n            split_one_bucket(&mut table);\n        };\n        table\n    }\n\n    /// Destroy empty table.\n    /// Aborts if it\'s not empty.\n    public fun destroy_empty<K, V>(table: SmartTable<K, V>) {\n        assert!(table.size == 0, error::invalid_argument(ENOT_EMPTY));\n        let i = 0;\n        while (i < table.num_buckets) {\n            vector::destroy_empty(table_with_length::remove(&mut table.buckets, i));\n            i = i + 1;\n        };\n        let SmartTable { buckets, num_buckets: _, level: _, size: _, split_load_threshold: _, target_bucket_size: _ } = table;\n        table_with_length::destroy_empty(buckets);\n    }\n\n    /// Destroy a table completely when V has `drop`.\n    public fun destroy<K: drop, V: drop>(table: SmartTable<K, V>) {\n        clear(&mut table);\n        destroy_empty(table);\n    }\n\n    /// Clear a table completely when T has `drop`.\n    public fun clear<K: drop, V: drop>(table: &mut SmartTable<K, V>) {\n        *table_with_length::borrow_mut(&mut table.buckets, 0) = vector::empty();\n        let i = 1;\n        while (i < table.num_buckets) {\n            table_with_length::remove(&mut table.buckets, i);\n            i = i + 1;\n        };\n        table.num_buckets = 1;\n        table.level = 0;\n        table.size = 0;\n    }\n\n    /// Add (key, value) pair in the hash map, it may grow one bucket if current load factor exceeds the threshold.\n    /// Note it may not split the actual overflowed bucket. Instead, it was determined by `num_buckets` and `level`.\n    /// For standard linear hash algorithm, it is stored as a variable but `num_buckets` here could be leveraged.\n    /// Abort if `key` already exists.\n    /// Note: This method may occasionally cost much more gas when triggering bucket split.\n    public fun add<K, V>(table: &mut SmartTable<K, V>, key: K, value: V) {\n        let hash = sip_hash_from_value(&key);\n        let index = bucket_index(table.level, table.num_buckets, hash);\n        let bucket = table_with_length::borrow_mut(&mut table.buckets, index);\n        // We set a per-bucket limit here with a upper bound (10000) that nobody should normally reach.\n        assert!(vector::length(bucket) <= 10000, error::permission_denied(EEXCEED_MAX_BUCKET_SIZE));\n        assert!(vector::all(bucket, | entry | {\n            let e: &Entry<K, V> = entry;\n            &e.key != &key\n        }), error::invalid_argument(EALREADY_EXIST));\n        let e = Entry { hash, key, value };\n        if (table.target_bucket_size == 0) {\n            let estimated_entry_size = max(size_of_val(&e), 1);\n            table.target_bucket_size = max(1024 /* free_write_quota */ / estimated_entry_size, 1);\n        };\n        vector::push_back(bucket, e);\n        table.size = table.size + 1;\n\n        if (load_factor(table) >= (table.split_load_threshold as u64)) {\n            split_one_bucket(table);\n        }\n    }\n\n    /// Add multiple key/value pairs to the smart table. The keys must not already exist.\n    public fun add_all<K, V>(table: &mut SmartTable<K, V>, keys: vector<K>, values: vector<V>) {\n        vector::zip(keys, values, |key, value| { add(table, key, value); });\n    }\n\n    inline fun unzip_entries<K: copy, V: copy>(entries: &vector<Entry<K, V>>): (vector<K>, vector<V>) {\n        let keys = vector[];\n        let values = vector[];\n        vector::for_each_ref(entries, |e|{\n            let entry: &Entry<K, V> = e;\n            vector::push_back(&mut keys, entry.key);\n            vector::push_back(&mut values, entry.value);\n        });\n        (keys, values)\n    }\n\n    /// Convert a smart table to a simple_map, which is supposed to be called mostly by view functions to get an atomic\n    /// view of the whole table.\n    /// Disclaimer: This function may be costly as the smart table may be huge in size. Use it at your own discretion.\n    public fun to_simple_map<K: store + copy + drop, V: store + copy>(\n        table: &SmartTable<K, V>,\n    ): SimpleMap<K, V> {\n        let i = 0;\n        let res = simple_map::new<K, V>();\n        while (i < table.num_buckets) {\n            let (keys, values) = unzip_entries(table_with_length::borrow(&table.buckets, i));\n            simple_map::add_all(&mut res, keys, values);\n            i = i + 1;\n        };\n        res\n    }\n\n    /// Get all keys in a smart table.\n    ///\n    /// For a large enough smart table this function will fail due to execution gas limits, and\n    /// `keys_paginated` should be used instead.\n    public fun keys<K: store + copy + drop, V: store + copy>(\n        table_ref: &SmartTable<K, V>\n    ): vector<K> {\n        let (keys, _, _) = keys_paginated(table_ref, 0, 0, length(table_ref));\n        keys\n    }\n\n    /// Get keys from a smart table, paginated.\n    ///\n    /// This function can be used to paginate all keys in a large smart table outside of runtime,\n    /// e.g. through chained view function calls. The maximum `num_keys_to_get` before hitting gas\n    /// limits depends on the data types in the smart table.\n    ///\n    /// When starting pagination, pass `starting_bucket_index` = `starting_vector_index` = 0.\n    ///\n    /// The function will then return a vector of keys, an optional bucket index, and an optional\n    /// vector index. The unpacked return indices can then be used as inputs to another pagination\n    /// call, which will return a vector of more keys. This process can be repeated until the\n    /// returned bucket index and vector index value options are both none, which means that\n    /// pagination is complete. For an example, see `test_keys()`.\n    public fun keys_paginated<K: store + copy + drop, V: store + copy>(\n        table_ref: &SmartTable<K, V>,\n        starting_bucket_index: u64,\n        starting_vector_index: u64,\n        num_keys_to_get: u64,\n    ): (\n        vector<K>,\n        Option<u64>,\n        Option<u64>,\n    ) {\n        let num_buckets = table_ref.num_buckets;\n        let buckets_ref = &table_ref.buckets;\n        assert!(starting_bucket_index < num_buckets, EINVALID_BUCKET_INDEX);\n        let bucket_ref = table_with_length::borrow(buckets_ref, starting_bucket_index);\n        let bucket_length = vector::length(bucket_ref);\n        assert!(\n            // In the general case, starting vector index should never be equal to bucket length\n            // because then iteration will attempt to borrow a vector element that is out of bounds.\n            // However starting vector index can be equal to bucket length in the special case of\n            // starting iteration at the beginning of an empty bucket since buckets are never\n            // destroyed, only emptied.\n            starting_vector_index < bucket_length || starting_vector_index == 0,\n            EINVALID_VECTOR_INDEX\n        );\n        let keys = vector[];\n        if (num_keys_to_get == 0) return\n            (keys, option::some(starting_bucket_index), option::some(starting_vector_index));\n        for (bucket_index in starting_bucket_index..num_buckets) {\n            bucket_ref = table_with_length::borrow(buckets_ref, bucket_index);\n            bucket_length = vector::length(bucket_ref);\n            for (vector_index in starting_vector_index..bucket_length) {\n                vector::push_back(&mut keys, vector::borrow(bucket_ref, vector_index).key);\n                num_keys_to_get = num_keys_to_get - 1;\n                if (num_keys_to_get == 0) {\n                    vector_index = vector_index + 1;\n                    return if (vector_index == bucket_length) {\n                        bucket_index = bucket_index + 1;\n                        if (bucket_index < num_buckets) {\n                            (keys, option::some(bucket_index), option::some(0))\n                        } else {\n                            (keys, option::none(), option::none())\n                        }\n                    } else {\n                        (keys, option::some(bucket_index), option::some(vector_index))\n                    }\n                };\n            };\n            starting_vector_index = 0; // Start parsing the next bucket at vector index 0.\n        };\n        (keys, option::none(), option::none())\n    }\n\n    /// Decide which is the next bucket to split and split it into two with the elements inside the bucket.\n    fun split_one_bucket<K, V>(table: &mut SmartTable<K, V>) {\n        let new_bucket_index = table.num_buckets;\n        // the next bucket to split is num_bucket without the most significant bit.\n        let to_split = new_bucket_index ^ (1 << table.level);\n        table.num_buckets = new_bucket_index + 1;\n        // if the whole level is splitted once, bump the level.\n        if (to_split + 1 == 1 << table.level) {\n            table.level = table.level + 1;\n        };\n        let old_bucket = table_with_length::borrow_mut(&mut table.buckets, to_split);\n        // partition the bucket, [0..p) stays in old bucket, [p..len) goes to new bucket\n        let p = vector::partition(old_bucket, |e| {\n            let entry: &Entry<K, V> = e; // Explicit type to satisfy compiler\n            bucket_index(table.level, table.num_buckets, entry.hash) != new_bucket_index\n        });\n        let new_bucket = vector::trim_reverse(old_bucket, p);\n        table_with_length::add(&mut table.buckets, new_bucket_index, new_bucket);\n    }\n\n    /// Return the expected bucket index to find the hash.\n    /// Basically, it use different base `1 << level` vs `1 << (level + 1)` in modulo operation based on the target\n    /// bucket index compared to the index of the next bucket to split.\n    fun bucket_index(level: u8, num_buckets: u64, hash: u64): u64 {\n        let index = hash % (1 << (level + 1));\n        if (index < num_buckets) {\n            // in existing bucket\n            index\n        } else {\n            // in unsplitted bucket\n            index % (1 << level)\n        }\n    }\n\n    /// Acquire an immutable reference to the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun borrow<K: drop, V>(table: &SmartTable<K, V>, key: K): &V {\n        let index = bucket_index(table.level, table.num_buckets, sip_hash_from_value(&key));\n        let bucket = table_with_length::borrow(&table.buckets, index);\n        let i = 0;\n        let len = vector::length(bucket);\n        while (i < len) {\n            let entry = vector::borrow(bucket, i);\n            if (&entry.key == &key) {\n                return &entry.value\n            };\n            i = i + 1;\n        };\n        abort error::invalid_argument(ENOT_FOUND)\n    }\n\n    /// Acquire an immutable reference to the value which `key` maps to.\n    /// Returns specified default value if there is no entry for `key`.\n    public fun borrow_with_default<K: copy + drop, V>(table: &SmartTable<K, V>, key: K, default: &V): &V {\n        if (!contains(table, copy key)) {\n            default\n        } else {\n            borrow(table, copy key)\n        }\n    }\n\n    /// Acquire a mutable reference to the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun borrow_mut<K: drop, V>(table: &mut SmartTable<K, V>, key: K): &mut V {\n        let index = bucket_index(table.level, table.num_buckets, sip_hash_from_value(&key));\n        let bucket = table_with_length::borrow_mut(&mut table.buckets, index);\n        let i = 0;\n        let len = vector::length(bucket);\n        while (i < len) {\n            let entry = vector::borrow_mut(bucket, i);\n            if (&entry.key == &key) {\n                return &mut entry.value\n            };\n            i = i + 1;\n        };\n        abort error::invalid_argument(ENOT_FOUND)\n    }\n\n    /// Acquire a mutable reference to the value which `key` maps to.\n    /// Insert the pair (`key`, `default`) first if there is no entry for `key`.\n    public fun borrow_mut_with_default<K: copy + drop, V: drop>(\n        table: &mut SmartTable<K, V>,\n        key: K,\n        default: V\n    ): &mut V {\n        if (!contains(table, copy key)) {\n            add(table, copy key, default)\n        };\n        borrow_mut(table, key)\n    }\n\n    /// Returns true iff `table` contains an entry for `key`.\n    public fun contains<K: drop, V>(table: &SmartTable<K, V>, key: K): bool {\n        let hash = sip_hash_from_value(&key);\n        let index = bucket_index(table.level, table.num_buckets, hash);\n        let bucket = table_with_length::borrow(&table.buckets, index);\n        vector::any(bucket, | entry | {\n            let e: &Entry<K, V> = entry;\n            e.hash == hash && &e.key == &key\n        })\n    }\n\n    /// Remove from `table` and return the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun remove<K: copy + drop, V>(table: &mut SmartTable<K, V>, key: K): V {\n        let index = bucket_index(table.level, table.num_buckets, sip_hash_from_value(&key));\n        let bucket = table_with_length::borrow_mut(&mut table.buckets, index);\n        let i = 0;\n        let len = vector::length(bucket);\n        while (i < len) {\n            let entry = vector::borrow(bucket, i);\n            if (&entry.key == &key) {\n                let Entry { hash: _, key: _, value } = vector::swap_remove(bucket, i);\n                table.size = table.size - 1;\n                return value\n            };\n            i = i + 1;\n        };\n        abort error::invalid_argument(ENOT_FOUND)\n    }\n\n    /// Insert the pair (`key`, `value`) if there is no entry for `key`.\n    /// update the value of the entry for `key` to `value` otherwise\n    public fun upsert<K: copy + drop, V: drop>(table: &mut SmartTable<K, V>, key: K, value: V) {\n        if (!contains(table, copy key)) {\n            add(table, copy key, value)\n        } else {\n            let ref = borrow_mut(table, key);\n            *ref = value;\n        };\n    }\n\n    /// Returns the length of the table, i.e. the number of entries.\n    public fun length<K, V>(table: &SmartTable<K, V>): u64 {\n        table.size\n    }\n\n    /// Return the load factor of the hashtable.\n    public fun load_factor<K, V>(table: &SmartTable<K, V>): u64 {\n        table.size * 100 / table.num_buckets / table.target_bucket_size\n    }\n\n    /// Update `split_load_threshold`.\n    public fun update_split_load_threshold<K, V>(table: &mut SmartTable<K, V>, split_load_threshold: u8) {\n        assert!(\n            split_load_threshold <= 100 && split_load_threshold > 0,\n            error::invalid_argument(EINVALID_LOAD_THRESHOLD_PERCENT)\n        );\n        table.split_load_threshold = split_load_threshold;\n    }\n\n    /// Update `target_bucket_size`.\n    public fun update_target_bucket_size<K, V>(table: &mut SmartTable<K, V>, target_bucket_size: u64) {\n        assert!(target_bucket_size > 0, error::invalid_argument(EINVALID_TARGET_BUCKET_SIZE));\n        table.target_bucket_size = target_bucket_size;\n    }\n\n    /// Apply the function to a reference of each key-value pair in the table.\n    public inline fun for_each_ref<K, V>(table: &SmartTable<K, V>, f: |&K, &V|) {\n        let i = 0;\n        while (i < aptos_std::smart_table::num_buckets(table)) {\n            vector::for_each_ref(\n                aptos_std::table_with_length::borrow(aptos_std::smart_table::borrow_buckets(table), i),\n                |elem| {\n                    let (key, value) = aptos_std::smart_table::borrow_kv(elem);\n                    f(key, value)\n                }\n            );\n            i = i + 1;\n        }\n    }\n\n    /// Apply the function to a mutable reference of each key-value pair in the table.\n    public inline fun for_each_mut<K, V>(table: &mut SmartTable<K, V>, f: |&K, &mut V|) {\n        let i = 0;\n        while (i < aptos_std::smart_table::num_buckets(table)) {\n            vector::for_each_mut(\n                table_with_length::borrow_mut(aptos_std::smart_table::borrow_buckets_mut(table), i),\n                |elem| {\n                    let (key, value) = aptos_std::smart_table::borrow_kv_mut(elem);\n                    f(key, value)\n                }\n            );\n            i = i + 1;\n        };\n    }\n\n    /// Map the function over the references of key-value pairs in the table without modifying it.\n    public inline fun map_ref<K: copy + drop + store, V1, V2: store>(\n        table: &SmartTable<K, V1>,\n        f: |&V1|V2\n    ): SmartTable<K, V2> {\n        let new_table = new<K, V2>();\n        for_each_ref(table, |key, value| add(&mut new_table, *key, f(value)));\n        new_table\n    }\n\n    /// Return true if any key-value pair in the table satisfies the predicate.\n    public inline fun any<K, V>(\n        table: &SmartTable<K, V>,\n        p: |&K, &V|bool\n    ): bool {\n        let found = false;\n        let i = 0;\n        while (i < aptos_std::smart_table::num_buckets(table)) {\n            found = vector::any(table_with_length::borrow(aptos_std::smart_table::borrow_buckets(table), i), |elem| {\n                let (key, value) = aptos_std::smart_table::borrow_kv(elem);\n                p(key, value)\n            });\n            if (found) break;\n            i = i + 1;\n        };\n        found\n    }\n\n    // Helper functions to circumvent the scope issue of inline functions.\n    public fun borrow_kv<K, V>(e: &Entry<K, V>): (&K, &V) {\n        (&e.key, &e.value)\n    }\n\n    public fun borrow_kv_mut<K, V>(e: &mut Entry<K, V>): (&mut K, &mut V) {\n        (&mut e.key, &mut e.value)\n    }\n\n    public fun num_buckets<K, V>(table: &SmartTable<K, V>): u64 {\n        table.num_buckets\n    }\n\n    public fun borrow_buckets<K, V>(table: &SmartTable<K, V>): &TableWithLength<u64, vector<Entry<K, V>>> {\n        &table.buckets\n    }\n\n    public fun borrow_buckets_mut<K, V>(table: &mut SmartTable<K, V>): &mut TableWithLength<u64, vector<Entry<K, V>>> {\n        &mut table.buckets\n    }\n\n\n    #[test]\n    fun smart_table_test() {\n        let table = new();\n        let i = 0;\n        while (i < 200) {\n            add(&mut table, i, i);\n            i = i + 1;\n        };\n        assert!(length(&table) == 200, 0);\n        i = 0;\n        while (i < 200) {\n            *borrow_mut(&mut table, i) = i * 2;\n            assert!(*borrow(&table, i) == i * 2, 0);\n            i = i + 1;\n        };\n        i = 0;\n        assert!(table.num_buckets > 5, table.num_buckets);\n        while (i < 200) {\n            assert!(contains(&table, i), 0);\n            assert!(remove(&mut table, i) == i * 2, 0);\n            i = i + 1;\n        };\n        destroy_empty(table);\n    }\n\n    #[test]\n    fun smart_table_split_test() {\n        let table: SmartTable<u64, u64> = new_with_config(1, 100, 1);\n        let i = 1;\n        let level = 0;\n        while (i <= 256) {\n            assert!(table.num_buckets == i, 0);\n            assert!(table.level == level, i);\n            add(&mut table, i, i);\n            i = i + 1;\n            if (i == 1 << (level + 1)) {\n                level = level + 1;\n            };\n        };\n        let i = 1;\n        while (i <= 256) {\n            assert!(*borrow(&table, i) == i, 0);\n            i = i + 1;\n        };\n        assert!(table.num_buckets == 257, table.num_buckets);\n        assert!(load_factor(&table) == 99, 0);\n        assert!(length(&table) == 256, 0);\n        destroy(table);\n    }\n\n    #[test]\n    fun smart_table_update_configs() {\n        let table = new();\n        let i = 0;\n        while (i < 200) {\n            add(&mut table, i, i);\n            i = i + 1;\n        };\n        assert!(length(&table) == 200, 0);\n        update_target_bucket_size(&mut table, 10);\n        update_split_load_threshold(&mut table, 50);\n        while (i < 400) {\n            add(&mut table, i, i);\n            i = i + 1;\n        };\n        assert!(length(&table) == 400, 0);\n        i = 0;\n        while (i < 400) {\n            assert!(contains(&table, i), 0);\n            assert!(remove(&mut table, i) == i, 0);\n            i = i + 1;\n        };\n        destroy_empty(table);\n    }\n\n    #[test]\n    public fun smart_table_add_all_test() {\n        let table: SmartTable<u64, u64> = new_with_config(1, 100, 2);\n        assert!(length(&table) == 0, 0);\n        add_all(&mut table, vector[1, 2, 3, 4, 5, 6, 7], vector[1, 2, 3, 4, 5, 6, 7]);\n        assert!(length(&table) == 7, 1);\n        let i = 1;\n        while (i < 8) {\n            assert!(*borrow(&table, i) == i, 0);\n            i = i + 1;\n        };\n        i = i - 1;\n        while (i > 0) {\n            remove(&mut table, i);\n            i = i - 1;\n        };\n        destroy_empty(table);\n    }\n\n    #[test]\n    public fun smart_table_to_simple_map_test() {\n        let table = new();\n        let i = 0;\n        while (i < 200) {\n            add(&mut table, i, i);\n            i = i + 1;\n        };\n        let map = to_simple_map(&table);\n        assert!(simple_map::length(&map) == 200, 0);\n        destroy(table);\n    }\n\n    #[test]\n    public fun smart_table_clear_test() {\n        let table = new();\n        let i = 0u64;\n        while (i < 200) {\n            add(&mut table, i, i);\n            i = i + 1;\n        };\n        clear(&mut table);\n        let i = 0;\n        while (i < 200) {\n            add(&mut table, i, i);\n            i = i + 1;\n        };\n        assert!(table.size == 200, 0);\n        destroy(table);\n    }\n\n    #[test]\n    fun test_keys() {\n        let i = 0;\n        let table = new();\n        let expected_keys = vector[];\n        let keys = keys(&table);\n        assert!(vector::is_empty(&keys), 0);\n        let starting_bucket_index = 0;\n        let starting_vector_index = 0;\n        let (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(\n            &table,\n            starting_bucket_index,\n            starting_vector_index,\n            0\n        );\n        assert!(starting_bucket_index_r == option::some(starting_bucket_index), 0);\n        assert!(starting_vector_index_r == option::some(starting_vector_index), 0);\n        assert!(vector::is_empty(&keys), 0);\n        while (i < 100) {\n            add(&mut table, i, 0);\n            vector::push_back(&mut expected_keys, i);\n            i = i + 1;\n        };\n        let keys = keys(&table);\n        assert!(vector::length(&keys) == vector::length(&expected_keys), 0);\n        vector::for_each_ref(&keys, |e_ref| {\n            assert!(vector::contains(&expected_keys, e_ref), 0);\n        });\n        let keys = vector[];\n        let starting_bucket_index = 0;\n        let starting_vector_index = 0;\n        let returned_keys = vector[];\n        vector::length(&returned_keys); // To eliminate erroneous compiler "unused" warning\n        loop {\n            (returned_keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(\n                &table,\n                starting_bucket_index,\n                starting_vector_index,\n                15\n            );\n            vector::append(&mut keys, returned_keys);\n            if (\n                starting_bucket_index_r == option::none() ||\n                starting_vector_index_r == option::none()\n            ) break;\n            starting_bucket_index = option::destroy_some(starting_bucket_index_r);\n            starting_vector_index = option::destroy_some(starting_vector_index_r);\n        };\n        assert!(vector::length(&keys) == vector::length(&expected_keys), 0);\n        vector::for_each_ref(&keys, |e_ref| {\n            assert!(vector::contains(&expected_keys, e_ref), 0);\n        });\n        destroy(table);\n        table = new();\n        add(&mut table, 1, 0);\n        add(&mut table, 2, 0);\n        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(&table, 0, 0, 1);\n        (returned_keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(\n            &table,\n            option::destroy_some(starting_bucket_index_r),\n            option::destroy_some(starting_vector_index_r),\n            1,\n        );\n        vector::append(&mut keys, returned_keys);\n        assert!(keys == vector[1, 2] || keys == vector[2, 1], 0);\n        assert!(starting_bucket_index_r == option::none(), 0);\n        assert!(starting_vector_index_r == option::none(), 0);\n        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(&table, 0, 0, 0);\n        assert!(keys == vector[], 0);\n        assert!(starting_bucket_index_r == option::some(0), 0);\n        assert!(starting_vector_index_r == option::some(0), 0);\n        destroy(table);\n    }\n\n    #[test]\n    fun test_keys_corner_cases() {\n        let table = new();\n        let expected_keys = vector[];\n        for (i in 0..100) {\n            add(&mut table, i, 0);\n            vector::push_back(&mut expected_keys, i);\n        };\n        let (keys, starting_bucket_index_r, starting_vector_index_r) =\n            keys_paginated(&table, 0, 0, 5); // Both indices 0.\n        assert!(vector::length(&keys) == 5, 0);\n        vector::for_each_ref(&keys, |e_ref| {\n            assert!(vector::contains(&expected_keys, e_ref), 0);\n        });\n        let starting_bucket_index = option::destroy_some(starting_bucket_index_r);\n        let starting_vector_index = option::destroy_some(starting_vector_index_r);\n        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(\n            &table,\n            starting_bucket_index,\n            starting_vector_index,\n            0, // Number of keys 0.\n        );\n        assert!(keys == vector[], 0);\n        assert!(starting_bucket_index_r == option::some(starting_bucket_index), 0);\n        assert!(starting_vector_index_r == option::some(starting_vector_index), 0);\n        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(\n            &table,\n            starting_bucket_index,\n            0, // Vector index 0.\n            50,\n        );\n        assert!(vector::length(&keys) == 50, 0);\n        vector::for_each_ref(&keys, |e_ref| {\n            assert!(vector::contains(&expected_keys, e_ref), 0);\n        });\n        let starting_bucket_index = option::destroy_some(starting_bucket_index_r);\n        assert!(starting_bucket_index > 0, 0);\n        assert!(option::is_some(&starting_vector_index_r), 0);\n        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(\n            &table,\n            0, // Bucket index 0.\n            1,\n            50,\n        );\n        assert!(vector::length(&keys) == 50, 0);\n        vector::for_each_ref(&keys, |e_ref| {\n            assert!(vector::contains(&expected_keys, e_ref), 0);\n        });\n        assert!(option::is_some(&starting_bucket_index_r), 0);\n        assert!(option::is_some(&starting_vector_index_r), 0);\n        destroy(table);\n    }\n\n    #[test, expected_failure(abort_code = EINVALID_BUCKET_INDEX)]\n    fun test_keys_invalid_bucket_index() {\n        let table = new();\n        add(&mut table, 1, 0);\n        let num_buckets = table.num_buckets;\n        keys_paginated(&table, num_buckets + 1, 0, 1);\n        destroy(table);\n    }\n\n    #[test, expected_failure(abort_code = EINVALID_VECTOR_INDEX)]\n    fun test_keys_invalid_vector_index() {\n        let table = new();\n        add(&mut table, 1, 0);\n        keys_paginated(&table, 0, 1, 1);\n        destroy(table);\n    }\n}\n', "name": "smart_table.move" }, { "content": "module aptos_std::smart_vector {\n    use std::error;\n    use std::vector;\n    use aptos_std::big_vector::{Self, BigVector};\n    use aptos_std::math64::max;\n    use aptos_std::type_info::size_of_val;\n    use std::option::{Self, Option};\n\n    /// Vector index is out of bounds\n    const EINDEX_OUT_OF_BOUNDS: u64 = 1;\n    /// Cannot destroy a non-empty vector\n    const EVECTOR_NOT_EMPTY: u64 = 2;\n    /// Cannot pop back from an empty vector\n    const EVECTOR_EMPTY: u64 = 3;\n    /// bucket_size cannot be 0\n    const EZERO_BUCKET_SIZE: u64 = 4;\n    /// The length of the smart vectors are not equal.\n    const ESMART_VECTORS_LENGTH_MISMATCH: u64 = 0x20005;\n\n    /// A Scalable vector implementation based on tables, Ts are grouped into buckets with `bucket_size`.\n    /// The option wrapping BigVector saves space in the metadata associated with BigVector when smart_vector is\n    /// so small that inline_vec vector can hold all the data.\n    struct SmartVector<T> has store {\n        inline_vec: vector<T>,\n        big_vec: Option<BigVector<T>>,\n        inline_capacity: Option<u64>,\n        bucket_size: Option<u64>,\n    }\n\n    /// Regular Vector API\n\n    /// Create an empty vector using default logic to estimate `inline_capacity` and `bucket_size`, which may be\n    /// inaccurate.\n    /// This is exactly the same as empty() but is more standardized as all other data structures have new().\n    public fun new<T: store>(): SmartVector<T> {\n        empty()\n    }\n\n    #[deprecated]\n    /// Create an empty vector using default logic to estimate `inline_capacity` and `bucket_size`, which may be\n    /// inaccurate.\n    public fun empty<T: store>(): SmartVector<T> {\n        SmartVector {\n            inline_vec: vector[],\n            big_vec: option::none(),\n            inline_capacity: option::none(),\n            bucket_size: option::none(),\n        }\n    }\n\n    /// Create an empty vector with customized config.\n    /// When inline_capacity = 0, SmartVector degrades to a wrapper of BigVector.\n    public fun empty_with_config<T: store>(inline_capacity: u64, bucket_size: u64): SmartVector<T> {\n        assert!(bucket_size > 0, error::invalid_argument(EZERO_BUCKET_SIZE));\n        SmartVector {\n            inline_vec: vector[],\n            big_vec: option::none(),\n            inline_capacity: option::some(inline_capacity),\n            bucket_size: option::some(bucket_size),\n        }\n    }\n\n    /// Create a vector of length 1 containing the passed in T.\n    public fun singleton<T: store>(element: T): SmartVector<T> {\n        let v = empty();\n        push_back(&mut v, element);\n        v\n    }\n\n    /// Destroy the vector `v`.\n    /// Aborts if `v` is not empty.\n    public fun destroy_empty<T>(v: SmartVector<T>) {\n        assert!(is_empty(&v), error::invalid_argument(EVECTOR_NOT_EMPTY));\n        let SmartVector { inline_vec, big_vec, inline_capacity: _, bucket_size: _ } = v;\n        vector::destroy_empty(inline_vec);\n        option::destroy_none(big_vec);\n    }\n\n    /// Destroy a vector completely when T has `drop`.\n    public fun destroy<T: drop>(v: SmartVector<T>) {\n        clear(&mut v);\n        destroy_empty(v);\n    }\n\n    /// Clear a vector completely when T has `drop`.\n    public fun clear<T: drop>(v: &mut SmartVector<T>) {\n        v.inline_vec = vector[];\n        if (option::is_some(&v.big_vec)) {\n            big_vector::destroy(option::extract(&mut v.big_vec));\n        }\n    }\n\n    /// Acquire an immutable reference to the `i`th T of the vector `v`.\n    /// Aborts if `i` is out of bounds.\n    public fun borrow<T>(v: &SmartVector<T>, i: u64): &T {\n        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let inline_len = vector::length(&v.inline_vec);\n        if (i < inline_len) {\n            vector::borrow(&v.inline_vec, i)\n        } else {\n            big_vector::borrow(option::borrow(&v.big_vec), i - inline_len)\n        }\n    }\n\n    /// Return a mutable reference to the `i`th T in the vector `v`.\n    /// Aborts if `i` is out of bounds.\n    public fun borrow_mut<T>(v: &mut SmartVector<T>, i: u64): &mut T {\n        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let inline_len = vector::length(&v.inline_vec);\n        if (i < inline_len) {\n            vector::borrow_mut(&mut v.inline_vec, i)\n        } else {\n            big_vector::borrow_mut(option::borrow_mut(&mut v.big_vec), i - inline_len)\n        }\n    }\n\n    /// Empty and destroy the other vector, and push each of the Ts in the other vector onto the lhs vector in the\n    /// same order as they occurred in other.\n    /// Disclaimer: This function may be costly. Use it at your own discretion.\n    public fun append<T: store>(lhs: &mut SmartVector<T>, other: SmartVector<T>) {\n        let other_len = length(&other);\n        let half_other_len = other_len / 2;\n        let i = 0;\n        while (i < half_other_len) {\n            push_back(lhs, swap_remove(&mut other, i));\n            i = i + 1;\n        };\n        while (i < other_len) {\n            push_back(lhs, pop_back(&mut other));\n            i = i + 1;\n        };\n        destroy_empty(other);\n    }\n\n    /// Add multiple values to the vector at once.\n    public fun add_all<T: store>(v: &mut SmartVector<T>, vals: vector<T>) {\n        vector::for_each(vals, |val| { push_back(v, val); })\n    }\n\n    /// Convert a smart vector to a native vector, which is supposed to be called mostly by view functions to get an\n    /// atomic view of the whole vector.\n    /// Disclaimer: This function may be costly as the smart vector may be huge in size. Use it at your own discretion.\n    public fun to_vector<T: store + copy>(v: &SmartVector<T>): vector<T> {\n        let res = v.inline_vec;\n        if (option::is_some(&v.big_vec)) {\n            let big_vec = option::borrow(&v.big_vec);\n            vector::append(&mut res, big_vector::to_vector(big_vec));\n        };\n        res\n    }\n\n    /// Add T `val` to the end of the vector `v`. It grows the buckets when the current buckets are full.\n    /// This operation will cost more gas when it adds new bucket.\n    public fun push_back<T: store>(v: &mut SmartVector<T>, val: T) {\n        let len = length(v);\n        let inline_len = vector::length(&v.inline_vec);\n        if (len == inline_len) {\n            let bucket_size = if (option::is_some(&v.inline_capacity)) {\n                if (len < *option::borrow(&v.inline_capacity)) {\n                    vector::push_back(&mut v.inline_vec, val);\n                    return\n                };\n                *option::borrow(&v.bucket_size)\n            } else {\n                let val_size = size_of_val(&val);\n                if (val_size * (inline_len + 1) < 150 /* magic number */) {\n                    vector::push_back(&mut v.inline_vec, val);\n                    return\n                };\n                let estimated_avg_size = max((size_of_val(&v.inline_vec) + val_size) / (inline_len + 1), 1);\n                max(1024 /* free_write_quota */ / estimated_avg_size, 1)\n            };\n            option::fill(&mut v.big_vec, big_vector::empty(bucket_size));\n        };\n        big_vector::push_back(option::borrow_mut(&mut v.big_vec), val);\n    }\n\n    /// Pop an T from the end of vector `v`. It does shrink the buckets if they're empty.\n    /// Aborts if `v` is empty.\n    public fun pop_back<T>(v: &mut SmartVector<T>): T {\n        assert!(!is_empty(v), error::invalid_state(EVECTOR_EMPTY));\n        let big_vec_wrapper = &mut v.big_vec;\n        if (option::is_some(big_vec_wrapper)) {\n            let big_vec = option::extract(big_vec_wrapper);\n            let val = big_vector::pop_back(&mut big_vec);\n            if (big_vector::is_empty(&big_vec)) {\n                big_vector::destroy_empty(big_vec)\n            } else {\n                option::fill(big_vec_wrapper, big_vec);\n            };\n            val\n        } else {\n            vector::pop_back(&mut v.inline_vec)\n        }\n    }\n\n    /// Remove the T at index i in the vector v and return the owned value that was previously stored at i in v.\n    /// All Ts occurring at indices greater than i will be shifted down by 1. Will abort if i is out of bounds.\n    /// Disclaimer: This function may be costly. Use it at your own discretion.\n    public fun remove<T>(v: &mut SmartVector<T>, i: u64): T {\n        let len = length(v);\n        assert!(i < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let inline_len = vector::length(&v.inline_vec);\n        if (i < inline_len) {\n            vector::remove(&mut v.inline_vec, i)\n        } else {\n            let big_vec_wrapper = &mut v.big_vec;\n            let big_vec = option::extract(big_vec_wrapper);\n            let val = big_vector::remove(&mut big_vec, i - inline_len);\n            if (big_vector::is_empty(&big_vec)) {\n                big_vector::destroy_empty(big_vec)\n            } else {\n                option::fill(big_vec_wrapper, big_vec);\n            };\n            val\n        }\n    }\n\n    /// Swap the `i`th T of the vector `v` with the last T and then pop the vector.\n    /// This is O(1), but does not preserve ordering of Ts in the vector.\n    /// Aborts if `i` is out of bounds.\n    public fun swap_remove<T>(v: &mut SmartVector<T>, i: u64): T {\n        let len = length(v);\n        assert!(i < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let inline_len = vector::length(&v.inline_vec);\n        let big_vec_wrapper = &mut v.big_vec;\n        let inline_vec = &mut v.inline_vec;\n        if (i >= inline_len) {\n            let big_vec = option::extract(big_vec_wrapper);\n            let val = big_vector::swap_remove(&mut big_vec, i - inline_len);\n            if (big_vector::is_empty(&big_vec)) {\n                big_vector::destroy_empty(big_vec)\n            } else {\n                option::fill(big_vec_wrapper, big_vec);\n            };\n            val\n        } else {\n            if (inline_len < len) {\n                let big_vec = option::extract(big_vec_wrapper);\n                let last_from_big_vec = big_vector::pop_back(&mut big_vec);\n                if (big_vector::is_empty(&big_vec)) {\n                    big_vector::destroy_empty(big_vec)\n                } else {\n                    option::fill(big_vec_wrapper, big_vec);\n                };\n                vector::push_back(inline_vec, last_from_big_vec);\n            };\n            vector::swap_remove(inline_vec, i)\n        }\n    }\n\n    /// Swap the Ts at the i'th and j'th indices in the vector v. Will abort if either of i or j are out of bounds\n    /// for v.\n    public fun swap<T: store>(v: &mut SmartVector<T>, i: u64, j: u64) {\n        if (i > j) {\n            return swap(v, j, i)\n        };\n        let len = length(v);\n        assert!(j < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));\n        let inline_len = vector::length(&v.inline_vec);\n        if (i >= inline_len) {\n            big_vector::swap(option::borrow_mut(&mut v.big_vec), i - inline_len, j - inline_len);\n        } else if (j < inline_len) {\n            vector::swap(&mut v.inline_vec, i, j);\n        } else {\n            let big_vec = option::borrow_mut(&mut v.big_vec);\n            let inline_vec = &mut v.inline_vec;\n            let element_i = vector::swap_remove(inline_vec, i);\n            let element_j = big_vector::swap_remove(big_vec, j - inline_len);\n            vector::push_back(inline_vec, element_j);\n            vector::swap(inline_vec, i, inline_len - 1);\n            big_vector::push_back(big_vec, element_i);\n            big_vector::swap(big_vec, j - inline_len, len - inline_len - 1);\n        }\n    }\n\n    /// Reverse the order of the Ts in the vector v in-place.\n    /// Disclaimer: This function may be costly. Use it at your own discretion.\n    public fun reverse<T: store>(v: &mut SmartVector<T>) {\n        let inline_len = vector::length(&v.inline_vec);\n        let i = 0;\n        let new_inline_vec = vector[];\n        // Push the last `inline_len` Ts into a temp vector.\n        while (i < inline_len) {\n            vector::push_back(&mut new_inline_vec, pop_back(v));\n            i = i + 1;\n        };\n        vector::reverse(&mut new_inline_vec);\n        // Reverse the big_vector left if exists.\n        if (option::is_some(&v.big_vec)) {\n            big_vector::reverse(option::borrow_mut(&mut v.big_vec));\n        };\n        // Mem::swap the two vectors.\n        let temp_vec = vector[];\n        while (!vector::is_empty(&mut v.inline_vec)) {\n            vector::push_back(&mut temp_vec, vector::pop_back(&mut v.inline_vec));\n        };\n        vector::reverse(&mut temp_vec);\n        while (!vector::is_empty(&mut new_inline_vec)) {\n            vector::push_back(&mut v.inline_vec, vector::pop_back(&mut new_inline_vec));\n        };\n        vector::destroy_empty(new_inline_vec);\n        // Push the rest Ts originally left in inline_vector back to the end of the smart vector.\n        while (!vector::is_empty(&mut temp_vec)) {\n            push_back(v, vector::pop_back(&mut temp_vec));\n        };\n        vector::destroy_empty(temp_vec);\n    }\n\n    /// Return `(true, i)` if `val` is in the vector `v` at index `i`.\n    /// Otherwise, returns `(false, 0)`.\n    /// Disclaimer: This function may be costly. Use it at your own discretion.\n    public fun index_of<T>(v: &SmartVector<T>, val: &T): (bool, u64) {\n        let (found, i) = vector::index_of(&v.inline_vec, val);\n        if (found) {\n            (true, i)\n        } else if (option::is_some(&v.big_vec)) {\n            let (found, i) = big_vector::index_of(option::borrow(&v.big_vec), val);\n            (found, i + vector::length(&v.inline_vec))\n        } else {\n            (false, 0)\n        }\n    }\n\n    /// Return true if `val` is in the vector `v`.\n    /// Disclaimer: This function may be costly. Use it at your own discretion.\n    public fun contains<T>(v: &SmartVector<T>, val: &T): bool {\n        if (is_empty(v)) return false;\n        let (exist, _) = index_of(v, val);\n        exist\n    }\n\n    /// Return the length of the vector.\n    public fun length<T>(v: &SmartVector<T>): u64 {\n        vector::length(&v.inline_vec) + if (option::is_none(&v.big_vec)) {\n            0\n        } else {\n            big_vector::length(option::borrow(&v.big_vec))\n        }\n    }\n\n    /// Return `true` if the vector `v` has no Ts and `false` otherwise.\n    public fun is_empty<T>(v: &SmartVector<T>): bool {\n        length(v) == 0\n    }\n\n    /// Apply the function to each T in the vector, consuming it.\n    public inline fun for_each<T: store>(v: SmartVector<T>, f: |T|) {\n        aptos_std::smart_vector::reverse(&mut v); // We need to reverse the vector to consume it efficiently\n        aptos_std::smart_vector::for_each_reverse(v, |e| f(e));\n    }\n\n    /// Apply the function to each T in the vector, consuming it.\n    public inline fun for_each_reverse<T>(v: SmartVector<T>, f: |T|) {\n        let len = aptos_std::smart_vector::length(&v);\n        while (len > 0) {\n            f(aptos_std::smart_vector::pop_back(&mut v));\n            len = len - 1;\n        };\n        aptos_std::smart_vector::destroy_empty(v)\n    }\n\n    /// Apply the function to a reference of each T in the vector.\n    public inline fun for_each_ref<T>(v: &SmartVector<T>, f: |&T|) {\n        let i = 0;\n        let len = aptos_std::smart_vector::length(v);\n        while (i < len) {\n            f(aptos_std::smart_vector::borrow(v, i));\n            i = i + 1\n        }\n    }\n\n    /// Apply the function to a mutable reference to each T in the vector.\n    public inline fun for_each_mut<T>(v: &mut SmartVector<T>, f: |&mut T|) {\n        let i = 0;\n        let len = aptos_std::smart_vector::length(v);\n        while (i < len) {\n            f(aptos_std::smart_vector::borrow_mut(v, i));\n            i = i + 1\n        }\n    }\n\n    /// Apply the function to a reference of each T in the vector with its index.\n    public inline fun enumerate_ref<T>(v: &SmartVector<T>, f: |u64, &T|) {\n        let i = 0;\n        let len = aptos_std::smart_vector::length(v);\n        while (i < len) {\n            f(i, aptos_std::smart_vector::borrow(v, i));\n            i = i + 1;\n        };\n    }\n\n    /// Apply the function to a mutable reference of each T in the vector with its index.\n    public inline fun enumerate_mut<T>(v: &mut SmartVector<T>, f: |u64, &mut T|) {\n        let i = 0;\n        let len = length(v);\n        while (i < len) {\n            f(i, borrow_mut(v, i));\n            i = i + 1;\n        };\n    }\n\n    /// Fold the function over the Ts. For example, `fold(vector[1,2,3], 0, f)` will execute\n    /// `f(f(f(0, 1), 2), 3)`\n    public inline fun fold<Accumulator, T: store>(\n        v: SmartVector<T>,\n        init: Accumulator,\n        f: |Accumulator, T|Accumulator\n    ): Accumulator {\n        let accu = init;\n        aptos_std::smart_vector::for_each(v, |elem| accu = f(accu, elem));\n        accu\n    }\n\n    /// Fold right like fold above but working right to left. For example, `fold(vector[1,2,3], 0, f)` will execute\n    /// `f(1, f(2, f(3, 0)))`\n    public inline fun foldr<Accumulator, T>(\n        v: SmartVector<T>,\n        init: Accumulator,\n        f: |T, Accumulator|Accumulator\n    ): Accumulator {\n        let accu = init;\n        aptos_std::smart_vector::for_each_reverse(v, |elem| accu = f(elem, accu));\n        accu\n    }\n\n    /// Map the function over the references of the Ts of the vector, producing a new vector without modifying the\n    /// original vector.\n    public inline fun map_ref<T1, T2: store>(\n        v: &SmartVector<T1>,\n        f: |&T1|T2\n    ): SmartVector<T2> {\n        let result = aptos_std::smart_vector::new<T2>();\n        aptos_std::smart_vector::for_each_ref(v, |elem| aptos_std::smart_vector::push_back(&mut result, f(elem)));\n        result\n    }\n\n    /// Map the function over the Ts of the vector, producing a new vector.\n    public inline fun map<T1: store, T2: store>(\n        v: SmartVector<T1>,\n        f: |T1|T2\n    ): SmartVector<T2> {\n        let result = aptos_std::smart_vector::new<T2>();\n        aptos_std::smart_vector::for_each(v, |elem| push_back(&mut result, f(elem)));\n        result\n    }\n\n    /// Filter the vector using the boolean function, removing all Ts for which `p(e)` is not true.\n    public inline fun filter<T: store + drop>(\n        v: SmartVector<T>,\n        p: |&T|bool\n    ): SmartVector<T> {\n        let result = aptos_std::smart_vector::new<T>();\n        aptos_std::smart_vector::for_each(v, |elem| {\n            if (p(&elem)) aptos_std::smart_vector::push_back(&mut result, elem);\n        });\n        result\n    }\n\n    public inline fun zip<T1: store, T2: store>(v1: SmartVector<T1>, v2: SmartVector<T2>, f: |T1, T2|) {\n        // We need to reverse the vectors to consume it efficiently\n        aptos_std::smart_vector::reverse(&mut v1);\n        aptos_std::smart_vector::reverse(&mut v2);\n        aptos_std::smart_vector::zip_reverse(v1, v2, |e1, e2| f(e1, e2));\n    }\n\n    /// Apply the function to each pair of elements in the two given vectors in the reverse order, consuming them.\n    /// This errors out if the vectors are not of the same length.\n    public inline fun zip_reverse<T1, T2>(\n        v1: SmartVector<T1>,\n        v2: SmartVector<T2>,\n        f: |T1, T2|,\n    ) {\n        let len = aptos_std::smart_vector::length(&v1);\n        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(len == aptos_std::smart_vector::length(&v2), 0x20005);\n        while (len > 0) {\n            f(aptos_std::smart_vector::pop_back(&mut v1), aptos_std::smart_vector::pop_back(&mut v2));\n            len = len - 1;\n        };\n        aptos_std::smart_vector::destroy_empty(v1);\n        aptos_std::smart_vector::destroy_empty(v2);\n    }\n\n    /// Apply the function to the references of each pair of elements in the two given vectors.\n    /// This errors out if the vectors are not of the same length.\n    public inline fun zip_ref<T1, T2>(\n        v1: &SmartVector<T1>,\n        v2: &SmartVector<T2>,\n        f: |&T1, &T2|,\n    ) {\n        let len = aptos_std::smart_vector::length(v1);\n        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(len == aptos_std::smart_vector::length(v2), 0x20005);\n        let i = 0;\n        while (i < len) {\n            f(aptos_std::smart_vector::borrow(v1, i), aptos_std::smart_vector::borrow(v2, i));\n            i = i + 1\n        }\n    }\n\n    /// Apply the function to mutable references to each pair of elements in the two given vectors.\n    /// This errors out if the vectors are not of the same length.\n    public inline fun zip_mut<T1, T2>(\n        v1: &mut SmartVector<T1>,\n        v2: &mut SmartVector<T2>,\n        f: |&mut T1, &mut T2|,\n    ) {\n        let i = 0;\n        let len = aptos_std::smart_vector::length(v1);\n        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(len == aptos_std::smart_vector::length(v2), 0x20005);\n        while (i < len) {\n            f(aptos_std::smart_vector::borrow_mut(v1, i), aptos_std::smart_vector::borrow_mut(v2, i));\n            i = i + 1\n        }\n    }\n\n    /// Map the function over the element pairs of the two vectors, producing a new vector.\n    public inline fun zip_map<T1: store, T2: store, NewT: store>(\n        v1: SmartVector<T1>,\n        v2: SmartVector<T2>,\n        f: |T1, T2|NewT\n    ): SmartVector<NewT> {\n        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(aptos_std::smart_vector::length(&v1) == aptos_std::smart_vector::length(&v2), 0x20005);\n\n        let result = aptos_std::smart_vector::new<NewT>();\n        aptos_std::smart_vector::zip(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));\n        result\n    }\n\n    /// Map the function over the references of the element pairs of two vectors, producing a new vector from the return\n    /// values without modifying the original vectors.\n    public inline fun zip_map_ref<T1, T2, NewT: store>(\n        v1: &SmartVector<T1>,\n        v2: &SmartVector<T2>,\n        f: |&T1, &T2|NewT\n    ): SmartVector<NewT> {\n        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it\n        // due to how inline functions work.\n        assert!(aptos_std::smart_vector::length(v1) == aptos_std::smart_vector::length(v2), 0x20005);\n\n        let result = aptos_std::smart_vector::new<NewT>();\n        aptos_std::smart_vector::zip_ref(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));\n        result\n    }\n\n    #[test]\n    fun smart_vector_test() {\n        let v = empty();\n        let i = 0;\n        while (i < 100) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        let j = 0;\n        while (j < 100) {\n            let val = borrow(&v, j);\n            assert!(*val == j, 0);\n            j = j + 1;\n        };\n        while (i > 0) {\n            i = i - 1;\n            let (exist, index) = index_of(&v, &i);\n            let j = pop_back(&mut v);\n            assert!(exist, 0);\n            assert!(index == i, 0);\n            assert!(j == i, 0);\n        };\n        while (i < 100) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        let last_index = length(&v) - 1;\n        assert!(swap_remove(&mut v, last_index) == 99, 0);\n        assert!(swap_remove(&mut v, 0) == 0, 0);\n        while (length(&v) > 0) {\n            // the vector is always [N, 1, 2, ... N-1] with repetitive swap_remove(&mut v, 0)\n            let expected = length(&v);\n            let val = swap_remove(&mut v, 0);\n            assert!(val == expected, 0);\n        };\n        destroy_empty(v);\n    }\n\n    #[test]\n    fun smart_vector_append_edge_case_test() {\n        let v1 = empty();\n        let v2 = singleton(1u64);\n        let v3 = empty();\n        let v4 = empty();\n        append(&mut v3, v4);\n        assert!(length(&v3) == 0, 0);\n        append(&mut v2, v3);\n        assert!(length(&v2) == 1, 0);\n        append(&mut v1, v2);\n        assert!(length(&v1) == 1, 0);\n        destroy(v1);\n    }\n\n    #[test]\n    fun smart_vector_append_test() {\n        let v1 = empty();\n        let v2 = empty();\n        let i = 0;\n        while (i < 7) {\n            push_back(&mut v1, i);\n            i = i + 1;\n        };\n        while (i < 25) {\n            push_back(&mut v2, i);\n            i = i + 1;\n        };\n        append(&mut v1, v2);\n        assert!(length(&v1) == 25, 0);\n        i = 0;\n        while (i < 25) {\n            assert!(*borrow(&v1, i) == i, 0);\n            i = i + 1;\n        };\n        destroy(v1);\n    }\n\n    #[test]\n    fun smart_vector_remove_test() {\n        let v = empty();\n        let i = 0u64;\n        while (i < 101) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        let inline_len = vector::length(&v.inline_vec);\n        remove(&mut v, 100);\n        remove(&mut v, 90);\n        remove(&mut v, 80);\n        remove(&mut v, 70);\n        remove(&mut v, 60);\n        remove(&mut v, 50);\n        remove(&mut v, 40);\n        remove(&mut v, 30);\n        remove(&mut v, 20);\n        assert!(vector::length(&v.inline_vec) == inline_len, 0);\n        remove(&mut v, 10);\n        assert!(vector::length(&v.inline_vec) + 1 == inline_len, 0);\n        remove(&mut v, 0);\n        assert!(vector::length(&v.inline_vec) + 2 == inline_len, 0);\n        assert!(length(&v) == 90, 0);\n\n        let index = 0;\n        i = 0;\n        while (i < 101) {\n            if (i % 10 != 0) {\n                assert!(*borrow(&v, index) == i, 0);\n                index = index + 1;\n            };\n            i = i + 1;\n        };\n        destroy(v);\n    }\n\n    #[test]\n    fun smart_vector_reverse_test() {\n        let v = empty();\n        let i = 0u64;\n        while (i < 10) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        reverse(&mut v);\n        let k = 0;\n        while (k < 10) {\n            assert!(*vector::borrow(&v.inline_vec, k) == 9 - k, 0);\n            k = k + 1;\n        };\n        while (i < 100) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        while (!vector::is_empty(&v.inline_vec)) {\n            remove(&mut v, 0);\n        };\n        reverse(&mut v);\n        i = 0;\n        let len = length(&v);\n        while (i + 1 < len) {\n            assert!(\n                *big_vector::borrow(option::borrow(&v.big_vec), i) == *big_vector::borrow(\n                    option::borrow(&v.big_vec),\n                    i + 1\n                ) + 1,\n                0\n            );\n            i = i + 1;\n        };\n        destroy(v);\n    }\n\n    #[test]\n    fun smart_vector_add_all_test() {\n        let v = empty_with_config(1, 2);\n        add_all(&mut v, vector[1, 2, 3, 4, 5, 6]);\n        assert!(length(&v) == 6, 0);\n        let i = 0;\n        while (i < 6) {\n            assert!(*borrow(&v, i) == i + 1, 0);\n            i = i + 1;\n        };\n        destroy(v);\n    }\n\n    #[test]\n    fun smart_vector_to_vector_test() {\n        let v1 = empty_with_config(7, 11);\n        let i = 0;\n        while (i < 100) {\n            push_back(&mut v1, i);\n            i = i + 1;\n        };\n        let v2 = to_vector(&v1);\n        let j = 0;\n        while (j < 100) {\n            assert!(*vector::borrow(&v2, j) == j, 0);\n            j = j + 1;\n        };\n        destroy(v1);\n    }\n\n    #[test]\n    fun smart_vector_swap_test() {\n        let v = empty();\n        let i = 0;\n        while (i < 101) {\n            push_back(&mut v, i);\n            i = i + 1;\n        };\n        i = 0;\n        while (i < 51) {\n            swap(&mut v, i, 100 - i);\n            i = i + 1;\n        };\n        i = 0;\n        while (i < 101) {\n            assert!(*borrow(&v, i) == 100 - i, 0);\n            i = i + 1;\n        };\n        destroy(v);\n    }\n\n    #[test]\n    fun smart_vector_index_of_test() {\n        let v = empty();\n        let i = 0;\n        while (i < 100) {\n            push_back(&mut v, i);\n            let (found, idx) = index_of(&mut v, &i);\n            assert!(found && idx == i, 0);\n            i = i + 1;\n        };\n        destroy(v);\n    }\n}\n", "name": "smart_vector.move" }, { "content": '/// Module providing debug functionality.\nmodule aptos_std::debug {\n    use std::string::String;\n\n    public fun print<T>(x: &T) {\n        native_print(format(x));\n    }\n\n    public fun print_stack_trace() {\n        native_print(native_stack_trace());\n    }\n\n    inline fun format<T>(x: &T): String {\n        aptos_std::string_utils::debug_string(x)\n    }\n\n    native fun native_print(x: String);\n    native fun native_stack_trace(): String;\n\n    #[test_only]\n    use std::vector;\n\n    #[test_only]\n    struct Foo has drop {}\n    #[test_only]\n    struct Bar has drop { x: u128, y: Foo, z: bool }\n    #[test_only]\n    struct Box<T> has drop { x: T }\n\n    #[test_only]\n    struct GenericStruct<phantom T> has drop {\n        val: u64,\n    }\n\n    #[test_only]\n    struct TestInner has drop {\n        val: u128,\n        vec: vector<u128>,\n        msgs: vector<vector<u8>>\n    }\n\n    #[test_only]\n    struct TestStruct has drop {\n        addr: address,\n        number: u8,\n        bytes: vector<u8>,\n        name: String,\n        vec: vector<TestInner>,\n    }\n\n    #[test_only]\n    fun assert_equal<T>(x: &T, expected: vector<u8>) {\n        if (std::string::bytes(&format(x)) != &expected) {\n            print(&format(x));\n            print(&std::string::utf8(expected));\n            assert!(false, 1);\n        };\n    }\n\n    #[test_only]\n    fun assert_string_equal(x: vector<u8>, expected: vector<u8>) {\n        assert!(std::string::bytes(&format(&std::string::utf8(x))) == &expected, 1);\n    }\n\n    #[test]\n    public fun test()  {\n        let x = 42;\n        assert_equal(&x, b"42");\n\n        let v = vector::empty();\n        vector::push_back(&mut v, 100);\n        vector::push_back(&mut v, 200);\n        vector::push_back(&mut v, 300);\n        assert_equal(&v, b"[ 100, 200, 300 ]");\n\n        let foo = Foo {};\n        assert_equal(&foo, b"0x1::debug::Foo {\\n  dummy_field: false\\n}");\n\n        let bar = Bar { x: 404, y: Foo {}, z: true };\n        assert_equal(&bar, b"0x1::debug::Bar {\\n  x: 404,\\n  y: 0x1::debug::Foo {\\n    dummy_field: false\\n  },\\n  z: true\\n}");\n\n        let box = Box { x: Foo {} };\n        assert_equal(&box, b"0x1::debug::Box<0x1::debug::Foo> {\\n  x: 0x1::debug::Foo {\\n    dummy_field: false\\n  }\\n}");\n    }\n\n    #[test]\n    fun test_print_string() {\n        let str_bytes = b"Hello, sane Move debugging!";\n\n        assert_equal(&str_bytes, b"0x48656c6c6f2c2073616e65204d6f766520646562756767696e6721");\n\n        let str = std::string::utf8(str_bytes);\n        assert_equal(&str, b"\\"Hello, sane Move debugging!\\"");\n    }\n\n    #[test]\n    fun test_print_quoted_string() {\n        let str_bytes = b"Can you say \\"Hel\\\\lo\\"?";\n\n        let str = std::string::utf8(str_bytes);\n        assert_equal(&str, b"\\"Can you say \\\\\\"Hel\\\\\\\\lo\\\\\\"?\\"");\n    }\n\n\n    #[test_only]\n    use std::features;\n    #[test(s = @0x123)]\n    fun test_print_primitive_types(s: signer) {\n        let u8 = 255u8;\n        assert_equal(&u8, b"255");\n\n        let u16 = 65535u16;\n        assert_equal(&u16, b"65535");\n\n        let u32 = 4294967295u32;\n        assert_equal(&u32, b"4294967295");\n\n        let u64 = 18446744073709551615u64;\n        assert_equal(&u64, b"18446744073709551615");\n\n        let u128 = 340282366920938463463374607431768211455u128;\n        assert_equal(&u128, b"340282366920938463463374607431768211455");\n\n        let u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935u256;\n        assert_equal(&u256, b"115792089237316195423570985008687907853269984665640564039457584007913129639935");\n\n        let bool = false;\n        assert_equal(&bool, b"false");\n\n        let bool = true;\n        assert_equal(&bool, b"true");\n\n        let a = @0x1234c0ffee;\n        assert_equal(&a, b"@0x1234c0ffee");\n\n        if (features::signer_native_format_fix_enabled()) {\n            let signer = s;\n            assert_equal(&signer, b"signer(@0x123)");\n        }\n    }\n\n    const MSG_1 : vector<u8> = b"abcdef";\n    const MSG_2 : vector<u8> = b"123456";\n\n    #[test]\n    fun test_print_struct() {\n        let obj = TestInner {\n            val: 100,\n            vec: vector[200u128, 400u128],\n            msgs: vector[MSG_1, MSG_2],\n        };\n\n        assert_equal(&obj, b"0x1::debug::TestInner {\\n  val: 100,\\n  vec: [ 200, 400 ],\\n  msgs: [\\n    0x616263646566,\\n    0x313233343536\\n  ]\\n}");\n\n        let obj = TestInner {\n            val: 10,\n            vec: vector[],\n            msgs: vector[],\n        };\n\n        assert_equal(&obj, b"0x1::debug::TestInner {\\n  val: 10,\\n  vec: [],\\n  msgs: []\\n}");\n    }\n\n    #[test(s1 = @0x123, s2 = @0x456)]\n    fun test_print_vectors(s1: signer, s2: signer) {\n        let v_u8 = x"ffabcdef";\n        assert_equal(&v_u8, b"0xffabcdef");\n\n        let v_u16 = vector[16u16, 17u16, 18u16, 19u16];\n        assert_equal(&v_u16, b"[ 16, 17, 18, 19 ]");\n\n        let v_u32 = vector[32u32, 33u32, 34u32, 35u32];\n        assert_equal(&v_u32, b"[ 32, 33, 34, 35 ]");\n\n        let v_u64 = vector[64u64, 65u64, 66u64, 67u64];\n        assert_equal(&v_u64, b"[ 64, 65, 66, 67 ]");\n\n        let v_u128 = vector[128u128, 129u128, 130u128, 131u128];\n        assert_equal(&v_u128, b"[ 128, 129, 130, 131 ]");\n\n        let v_u256 = vector[256u256, 257u256, 258u256, 259u256];\n        assert_equal(&v_u256, b"[ 256, 257, 258, 259 ]");\n\n        let v_bool = vector[true, false];\n        assert_equal(&v_bool, b"[ true, false ]");\n\n        let v_addr = vector[@0x1234, @0x5678, @0xabcdef];\n        assert_equal(&v_addr, b"[ @0x1234, @0x5678, @0xabcdef ]");\n\n        if (features::signer_native_format_fix_enabled()) {\n            let v_signer = vector[s1, s2];\n            assert_equal(&v_signer, b"[ signer(@0x123), signer(@0x456) ]");\n        };\n\n        let v = vector[\n            TestInner {\n                val: 4u128,\n                vec: vector[127u128, 128u128],\n                msgs: vector[x"00ff", x"abcd"],\n            },\n            TestInner {\n                val: 8u128 ,\n                vec: vector[128u128, 129u128],\n                msgs: vector[x"0000"],\n            }\n        ];\n        assert_equal(&v, b"[\\n  0x1::debug::TestInner {\\n    val: 4,\\n    vec: [ 127, 128 ],\\n    msgs: [\\n      0x00ff,\\n      0xabcd\\n    ]\\n  },\\n  0x1::debug::TestInner {\\n    val: 8,\\n    vec: [ 128, 129 ],\\n    msgs: [\\n      0x0000\\n    ]\\n  }\\n]");\n    }\n\n    #[test(s1 = @0x123, s2 = @0x456)]\n    fun test_print_vector_of_vectors(s1: signer, s2: signer) {\n        let v_u8 = vector[x"ffab", x"cdef"];\n        assert_equal(&v_u8, b"[\\n  0xffab,\\n  0xcdef\\n]");\n\n        let v_u16 = vector[vector[16u16, 17u16], vector[18u16, 19u16]];\n        assert_equal(&v_u16, b"[\\n  [ 16, 17 ],\\n  [ 18, 19 ]\\n]");\n\n        let v_u32 = vector[vector[32u32, 33u32], vector[34u32, 35u32]];\n        assert_equal(&v_u32, b"[\\n  [ 32, 33 ],\\n  [ 34, 35 ]\\n]");\n\n        let v_u64 = vector[vector[64u64, 65u64], vector[66u64, 67u64]];\n        assert_equal(&v_u64, b"[\\n  [ 64, 65 ],\\n  [ 66, 67 ]\\n]");\n\n        let v_u128 = vector[vector[128u128, 129u128], vector[130u128, 131u128]];\n        assert_equal(&v_u128, b"[\\n  [ 128, 129 ],\\n  [ 130, 131 ]\\n]");\n\n        let v_u256 = vector[vector[256u256, 257u256], vector[258u256, 259u256]];\n        assert_equal(&v_u256, b"[\\n  [ 256, 257 ],\\n  [ 258, 259 ]\\n]");\n\n        let v_bool = vector[vector[true, false], vector[false, true]];\n        assert_equal(&v_bool, b"[\\n  [ true, false ],\\n  [ false, true ]\\n]");\n\n        let v_addr = vector[vector[@0x1234, @0x5678], vector[@0xabcdef, @0x9999]];\n        assert_equal(&v_addr, b"[\\n  [ @0x1234, @0x5678 ],\\n  [ @0xabcdef, @0x9999 ]\\n]");\n\n        if (features::signer_native_format_fix_enabled()) {\n            let v_signer = vector[vector[s1], vector[s2]];\n            assert_equal(&v_signer, b"[\\n  [ signer(@0x123) ],\\n  [ signer(@0x456) ]\\n]");\n        };\n\n        let v = vector[\n            vector[\n                TestInner { val: 4u128, vec: vector[127u128, 128u128], msgs: vector[] },\n                TestInner { val: 8u128 , vec: vector[128u128, 129u128], msgs: vector[] }\n            ],\n            vector[\n                TestInner { val: 4u128, vec: vector[127u128, 128u128], msgs: vector[] },\n                TestInner { val: 8u128 , vec: vector[128u128, 129u128], msgs: vector[] }\n            ]\n        ];\n        assert_equal(&v, b"[\\n  [\\n    0x1::debug::TestInner {\\n      val: 4,\\n      vec: [ 127, 128 ],\\n      msgs: []\\n    },\\n    0x1::debug::TestInner {\\n      val: 8,\\n      vec: [ 128, 129 ],\\n      msgs: []\\n    }\\n  ],\\n  [\\n    0x1::debug::TestInner {\\n      val: 4,\\n      vec: [ 127, 128 ],\\n      msgs: []\\n    },\\n    0x1::debug::TestInner {\\n      val: 8,\\n      vec: [ 128, 129 ],\\n      msgs: []\\n    }\\n  ]\\n]");\n    }\n\n    #[test]\n    fun test_print_nested_struct() {\n        let obj = TestStruct {\n            addr: @0x1,\n            number: 255u8,\n            bytes: x"c0ffee",\n            name: std::string::utf8(b"He\\"llo"),\n            vec: vector[\n                TestInner { val: 1, vec: vector[130u128, 131u128], msgs: vector[] },\n                TestInner { val: 2, vec: vector[132u128, 133u128], msgs: vector[] }\n            ],\n        };\n\n        assert_equal(&obj, b"0x1::debug::TestStruct {\\n  addr: @0x1,\\n  number: 255,\\n  bytes: 0xc0ffee,\\n  name: \\"He\\\\\\"llo\\",\\n  vec: [\\n    0x1::debug::TestInner {\\n      val: 1,\\n      vec: [ 130, 131 ],\\n      msgs: []\\n    },\\n    0x1::debug::TestInner {\\n      val: 2,\\n      vec: [ 132, 133 ],\\n      msgs: []\\n    }\\n  ]\\n}");\n    }\n\n    #[test]\n    fun test_print_generic_struct() {\n        let obj = GenericStruct<Foo> {\n            val: 60u64,\n        };\n\n        assert_equal(&obj, b"0x1::debug::GenericStruct<0x1::debug::Foo> {\\n  val: 60\\n}");\n    }\n}\n', "name": "debug.move" }, { "content": "/// Defines a fixed-point numeric type with a 64-bit integer part and\n/// a 64-bit fractional part.\n\nmodule aptos_std::fixed_point64 {\n\n    /// Define a fixed-point numeric type with 64 fractional bits.\n    /// This is just a u128 integer but it is wrapped in a struct to\n    /// make a unique type. This is a binary representation, so decimal\n    /// values may not be exactly representable, but it provides more\n    /// than 9 decimal digits of precision both before and after the\n    /// decimal point (18 digits total). For comparison, double precision\n    /// floating-point has less than 16 decimal digits of precision, so\n    /// be careful about using floating-point to convert these values to\n    /// decimal.\n    struct FixedPoint64 has copy, drop, store { value: u128 }\n\n    const MAX_U128: u256 = 340282366920938463463374607431768211455;\n\n    /// The denominator provided was zero\n    const EDENOMINATOR: u64 = 0x10001;\n    /// The quotient value would be too large to be held in a `u128`\n    const EDIVISION: u64 = 0x20002;\n    /// The multiplied value would be too large to be held in a `u128`\n    const EMULTIPLICATION: u64 = 0x20003;\n    /// A division by zero was encountered\n    const EDIVISION_BY_ZERO: u64 = 0x10004;\n    /// The computed ratio when converting to a `FixedPoint64` would be unrepresentable\n    const ERATIO_OUT_OF_RANGE: u64 = 0x20005;\n    /// Abort code on calculation result is negative.\n    const ENEGATIVE_RESULT: u64 = 0x10006;\n\n    /// Returns x - y. x must be not less than y.\n    public fun sub(x: FixedPoint64, y: FixedPoint64): FixedPoint64 {\n        let x_raw = get_raw_value(x);\n        let y_raw = get_raw_value(y);\n        assert!(x_raw >= y_raw, ENEGATIVE_RESULT);\n        create_from_raw_value(x_raw - y_raw)\n    }\n    spec sub {\n        pragma opaque;\n        aborts_if x.value < y.value with ENEGATIVE_RESULT;\n        ensures result.value == x.value - y.value;\n    }\n\n    /// Returns x + y. The result cannot be greater than MAX_U128.\n    public fun add(x: FixedPoint64, y: FixedPoint64): FixedPoint64 {\n        let x_raw = get_raw_value(x);\n        let y_raw = get_raw_value(y);\n        let result = (x_raw as u256) + (y_raw as u256);\n        assert!(result <= MAX_U128, ERATIO_OUT_OF_RANGE);\n        create_from_raw_value((result as u128))\n    }\n    spec add {\n        pragma opaque;\n        aborts_if (x.value as u256) + (y.value as u256) > MAX_U128 with ERATIO_OUT_OF_RANGE;\n        ensures result.value == x.value + y.value;\n    }\n\n    /// Multiply a u128 integer by a fixed-point number, truncating any\n    /// fractional part of the product. This will abort if the product\n    /// overflows.\n    public fun multiply_u128(val: u128, multiplier: FixedPoint64): u128 {\n        // The product of two 128 bit values has 256 bits, so perform the\n        // multiplication with u256 types and keep the full 256 bit product\n        // to avoid losing accuracy.\n        let unscaled_product = (val as u256) * (multiplier.value as u256);\n        // The unscaled product has 64 fractional bits (from the multiplier)\n        // so rescale it by shifting away the low bits.\n        let product = unscaled_product >> 64;\n        // Check whether the value is too large.\n        assert!(product <= MAX_U128, EMULTIPLICATION);\n        (product as u128)\n    }\n    spec multiply_u128 {\n        pragma opaque;\n        include MultiplyAbortsIf;\n        ensures result == spec_multiply_u128(val, multiplier);\n    }\n    spec schema MultiplyAbortsIf {\n        val: num;\n        multiplier: FixedPoint64;\n        aborts_if spec_multiply_u128(val, multiplier) > MAX_U128 with EMULTIPLICATION;\n    }\n    spec fun spec_multiply_u128(val: num, multiplier: FixedPoint64): num {\n        (val * multiplier.value) >> 64\n    }\n\n    /// Divide a u128 integer by a fixed-point number, truncating any\n    /// fractional part of the quotient. This will abort if the divisor\n    /// is zero or if the quotient overflows.\n    public fun divide_u128(val: u128, divisor: FixedPoint64): u128 {\n        // Check for division by zero.\n        assert!(divisor.value != 0, EDIVISION_BY_ZERO);\n        // First convert to 256 bits and then shift left to\n        // add 64 fractional zero bits to the dividend.\n        let scaled_value = (val as u256) << 64;\n        let quotient = scaled_value / (divisor.value as u256);\n        // Check whether the value is too large.\n        assert!(quotient <= MAX_U128, EDIVISION);\n        // the value may be too large, which will cause the cast to fail\n        // with an arithmetic error.\n        (quotient as u128)\n    }\n    spec divide_u128 {\n        pragma opaque;\n        include DivideAbortsIf;\n        ensures result == spec_divide_u128(val, divisor);\n    }\n    spec schema DivideAbortsIf {\n        val: num;\n        divisor: FixedPoint64;\n        aborts_if divisor.value == 0 with EDIVISION_BY_ZERO;\n        aborts_if spec_divide_u128(val, divisor) > MAX_U128 with EDIVISION;\n    }\n    spec fun spec_divide_u128(val: num, divisor: FixedPoint64): num {\n        (val << 64) / divisor.value\n    }\n\n    /// Create a fixed-point value from a rational number specified by its\n    /// numerator and denominator. Calling this function should be preferred\n    /// for using `Self::create_from_raw_value` which is also available.\n    /// This will abort if the denominator is zero. It will also\n    /// abort if the numerator is nonzero and the ratio is not in the range\n    /// 2^-64 .. 2^64-1. When specifying decimal fractions, be careful about\n    /// rounding errors: if you round to display N digits after the decimal\n    /// point, you can use a denominator of 10^N to avoid numbers where the\n    /// very small imprecision in the binary representation could change the\n    /// rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.\n    public fun create_from_rational(numerator: u128, denominator: u128): FixedPoint64 {\n        // If the denominator is zero, this will abort.\n        // Scale the numerator to have 64 fractional bits, so that the quotient will have 64\n        // fractional bits.\n        let scaled_numerator = (numerator as u256) << 64;\n        assert!(denominator != 0, EDENOMINATOR);\n        let quotient = scaled_numerator / (denominator as u256);\n        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);\n        // Return the quotient as a fixed-point number. We first need to check whether the cast\n        // can succeed.\n        assert!(quotient <= MAX_U128, ERATIO_OUT_OF_RANGE);\n        FixedPoint64 { value: (quotient as u128) }\n    }\n    spec create_from_rational {\n        pragma opaque;\n        pragma verify_duration_estimate = 1000; // TODO: set because of timeout (property proved).\n        include CreateFromRationalAbortsIf;\n        ensures result == spec_create_from_rational(numerator, denominator);\n    }\n    spec schema CreateFromRationalAbortsIf {\n        numerator: u128;\n        denominator: u128;\n        let scaled_numerator = (numerator as u256)<< 64;\n        let scaled_denominator = (denominator as u256);\n        let quotient = scaled_numerator / scaled_denominator;\n        aborts_if scaled_denominator == 0 with EDENOMINATOR;\n        aborts_if quotient == 0 && scaled_numerator != 0 with ERATIO_OUT_OF_RANGE;\n        aborts_if quotient > MAX_U128 with ERATIO_OUT_OF_RANGE;\n    }\n    spec fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint64 {\n        FixedPoint64{value: (numerator << 128) / (denominator << 64)}\n    }\n\n    /// Create a fixedpoint value from a raw value.\n    public fun create_from_raw_value(value: u128): FixedPoint64 {\n        FixedPoint64 { value }\n    }\n    spec create_from_raw_value {\n        pragma opaque;\n        aborts_if false;\n        ensures result.value == value;\n    }\n\n    /// Accessor for the raw u128 value. Other less common operations, such as\n    /// adding or subtracting FixedPoint64 values, can be done using the raw\n    /// values directly.\n    public fun get_raw_value(num: FixedPoint64): u128 {\n        num.value\n    }\n\n    /// Returns true if the ratio is zero.\n    public fun is_zero(num: FixedPoint64): bool {\n        num.value == 0\n    }\n\n    /// Returns the smaller of the two FixedPoint64 numbers.\n    public fun min(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {\n        if (num1.value < num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n    spec min {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_min(num1, num2);\n    }\n    spec fun spec_min(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {\n        if (num1.value < num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n\n    /// Returns the larger of the two FixedPoint64 numbers.\n    public fun max(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {\n        if (num1.value > num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n    spec max {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_max(num1, num2);\n    }\n    spec fun spec_max(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {\n        if (num1.value > num2.value) {\n            num1\n        } else {\n            num2\n        }\n    }\n\n    /// Returns true if num1 <= num2\n    public fun less_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value <= num2.value\n    }\n    spec less_or_equal {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_less_or_equal(num1, num2);\n    }\n    spec fun spec_less_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value <= num2.value\n    }\n\n    /// Returns true if num1 < num2\n    public fun less(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value < num2.value\n    }\n    spec less {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_less(num1, num2);\n    }\n    spec fun spec_less(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value < num2.value\n    }\n\n    /// Returns true if num1 >= num2\n    public fun greater_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value >= num2.value\n    }\n    spec greater_or_equal {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_greater_or_equal(num1, num2);\n    }\n    spec fun spec_greater_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value >= num2.value\n    }\n\n    /// Returns true if num1 > num2\n    public fun greater(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value > num2.value\n    }\n    spec greater {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_greater(num1, num2);\n    }\n    spec fun spec_greater(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value > num2.value\n    }\n\n    /// Returns true if num1 = num2\n    public fun equal(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value == num2.value\n    }\n    spec equal {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_equal(num1, num2);\n    }\n    spec fun spec_equal(num1: FixedPoint64, num2: FixedPoint64): bool {\n        num1.value == num2.value\n    }\n\n    /// Returns true if num1 almost equals to num2, which means abs(num1-num2) <= precision\n    public fun almost_equal(num1: FixedPoint64, num2: FixedPoint64, precision: FixedPoint64): bool {\n        if (num1.value > num2.value) {\n            (num1.value - num2.value <= precision.value)\n        } else {\n            (num2.value - num1.value <= precision.value)\n        }\n    }\n    spec almost_equal {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_almost_equal(num1, num2, precision);\n    }\n    spec fun spec_almost_equal(num1: FixedPoint64, num2: FixedPoint64, precision: FixedPoint64): bool {\n        if (num1.value > num2.value) {\n            (num1.value - num2.value <= precision.value)\n        } else {\n            (num2.value - num1.value <= precision.value)\n        }\n    }\n    /// Create a fixedpoint value from a u128 value.\n    public fun create_from_u128(val: u128): FixedPoint64 {\n        let value = (val as u256) << 64;\n        assert!(value <= MAX_U128, ERATIO_OUT_OF_RANGE);\n        FixedPoint64 {value: (value as u128)}\n    }\n    spec create_from_u128 {\n        pragma opaque;\n        include CreateFromU64AbortsIf;\n        ensures result == spec_create_from_u128(val);\n    }\n    spec schema CreateFromU64AbortsIf {\n        val: num;\n        let scaled_value = (val as u256) << 64;\n        aborts_if scaled_value > MAX_U128;\n    }\n    spec fun spec_create_from_u128(val: num): FixedPoint64 {\n        FixedPoint64 {value: val << 64}\n    }\n\n    /// Returns the largest integer less than or equal to a given number.\n    public fun floor(num: FixedPoint64): u128 {\n        num.value >> 64\n    }\n    spec floor {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_floor(num);\n    }\n    spec fun spec_floor(val: FixedPoint64): u128 {\n        let fractional = val.value % (1 << 64);\n        if (fractional == 0) {\n            val.value >> 64\n        } else {\n            (val.value - fractional) >> 64\n        }\n    }\n\n    /// Rounds up the given FixedPoint64 to the next largest integer.\n    public fun ceil(num: FixedPoint64): u128 {\n        let floored_num = floor(num) << 64;\n        if (num.value == floored_num) {\n            return floored_num >> 64\n        };\n        let val = ((floored_num as u256) + (1 << 64));\n        (val >> 64 as u128)\n    }\n    spec ceil {\n        // TODO: set because of timeout (property proved).\n        pragma verify_duration_estimate = 1000;\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_ceil(num);\n    }\n    spec fun spec_ceil(val: FixedPoint64): u128 {\n        let fractional = val.value % (1 << 64);\n        let one = 1 << 64;\n        if (fractional == 0) {\n            val.value >> 64\n        } else {\n            (val.value - fractional + one) >> 64\n        }\n    }\n\n    /// Returns the value of a FixedPoint64 to the nearest integer.\n    public fun round(num: FixedPoint64): u128 {\n        let floored_num = floor(num) << 64;\n        let boundary = floored_num + ((1 << 64) / 2);\n        if (num.value < boundary) {\n            floored_num >> 64\n        } else {\n            ceil(num)\n        }\n    }\n    spec round {\n        pragma opaque;\n        aborts_if false;\n        ensures result == spec_round(num);\n    }\n    spec fun spec_round(val: FixedPoint64): u128 {\n        let fractional = val.value % (1 << 64);\n        let boundary = (1 << 64) / 2;\n        let one = 1 << 64;\n        if (fractional < boundary) {\n            (val.value - fractional) >> 64\n        } else {\n            (val.value - fractional + one) >> 64\n        }\n    }\n\n    // **************** SPECIFICATIONS ****************\n\n    spec module {} // switch documentation context to module level\n\n    spec module {\n        pragma aborts_if_is_strict;\n    }\n\n    #[test]\n    public entry fun test_sub() {\n        let x = create_from_rational(9, 7);\n        let y = create_from_rational(1, 3);\n        let result = sub(x, y);\n        // 9/7 - 1/3 = 20/21\n        let expected_result = create_from_rational(20, 21);\n        assert_approx_the_same((get_raw_value(result) as u256), (get_raw_value(expected_result) as u256), 16);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x10006, location = Self)]\n    public entry fun test_sub_should_abort() {\n        let x = create_from_rational(1, 3);\n        let y = create_from_rational(9, 7);\n        let _ = sub(x, y);\n    }\n\n    #[test_only]\n    /// For functions that approximate a value it's useful to test a value is close\n    /// to the most correct value up to last digit\n    fun assert_approx_the_same(x: u256, y: u256, precission: u128) {\n        if (x < y) {\n            let tmp = x;\n            x = y;\n            y = tmp;\n        };\n        let mult = 1u256;\n        let n = 10u256;\n        while (precission > 0) {\n            if (precission % 2 == 1) {\n                mult = mult * n;\n            };\n            precission = precission / 2;\n            n = n * n;\n        };\n        assert!((x - y) * mult < x, 0);\n    }\n}\n", "name": "fixed_point64.move" }, { "content": '/// This module provides a number of functions to convert _primitive_ types from their representation in `std::bcs`\n/// to values. This is the opposite of `bcs::to_bytes`. Note that it is not safe to define a generic public `from_bytes`\n/// function because this can violate implicit struct invariants, therefore only primitive types are offerred. If\n/// a general conversion back-and-force is needed, consider the `aptos_std::Any` type which preserves invariants.\n///\n/// Example:\n/// ```\n/// use std::bcs;\n/// use aptos_std::from_bcs;\n///\n/// assert!(from_bcs::to_address(bcs::to_bytes(&@0xabcdef)) == @0xabcdef, 0);\n/// ```\nmodule aptos_std::from_bcs {\n    use std::string::{Self, String};\n\n    /// UTF8 check failed in conversion from bytes to string\n    const EINVALID_UTF8: u64 = 0x1;\n\n    public fun to_bool(v: vector<u8>): bool {\n        from_bytes<bool>(v)\n    }\n\n    public fun to_u8(v: vector<u8>): u8 {\n        from_bytes<u8>(v)\n    }\n\n    public fun to_u16(v: vector<u8>): u16 {\n        from_bytes<u16>(v)\n    }\n\n    public fun to_u32(v: vector<u8>): u32 {\n        from_bytes<u32>(v)\n    }\n\n    public fun to_u64(v: vector<u8>): u64 {\n        from_bytes<u64>(v)\n    }\n\n    public fun to_u128(v: vector<u8>): u128 {\n        from_bytes<u128>(v)\n    }\n\n    public fun to_u256(v: vector<u8>): u256 {\n        from_bytes<u256>(v)\n    }\n\n    public fun to_address(v: vector<u8>): address {\n        from_bytes<address>(v)\n    }\n\n    public fun to_bytes(v: vector<u8>): vector<u8> {\n        from_bytes<vector<u8>>(v)\n    }\n\n    public fun to_string(v: vector<u8>): String {\n        // To make this safe, we need to evaluate the utf8 invariant.\n        let s = from_bytes<String>(v);\n        assert!(string::internal_check_utf8(string::bytes(&s)), EINVALID_UTF8);\n        s\n    }\n\n    /// Package private native function to deserialize a type T.\n    ///\n    /// Note that this function does not put any constraint on `T`. If code uses this function to\n    /// deserialize a linear value, its their responsibility that the data they deserialize is\n    /// owned.\n    public(friend) native fun from_bytes<T>(bytes: vector<u8>): T;\n    friend aptos_std::any;\n    friend aptos_std::copyable_any;\n\n\n    #[test_only]\n    use std::bcs;\n\n    #[test]\n    fun test_address() {\n        let addr = @0x01;\n        let addr_vec = x"0000000000000000000000000000000000000000000000000000000000000001";\n        let addr_out = to_address(addr_vec);\n        let addr_vec_out = bcs::to_bytes(&addr_out);\n        assert!(addr == addr_out, 0);\n        assert!(addr_vec == addr_vec_out, 1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x10001, location = Self)]\n    fun test_address_fail() {\n        let bad_vec = b"01";\n        to_address(bad_vec);\n    }\n}\n', "name": "from_bcs.move" }, { "content": '/// Cryptographic hashes:\n/// - Keccak-256: see https://keccak.team/keccak.html\n///\n/// In addition, SHA2-256 and SHA3-256 are available in `std::hash`. Note that SHA3-256 is a variant of Keccak: it is\n/// NOT the same as Keccak-256.\n///\n/// Non-cryptograhic hashes:\n/// - SipHash: an add-rotate-xor (ARX) based family of pseudorandom functions created by Jean-Philippe Aumasson and Daniel J. Bernstein in 2012\nmodule aptos_std::aptos_hash {\n    use std::bcs;\n    use std::features;\n\n    //\n    // Constants\n    //\n\n    /// A newly-added native function is not yet enabled.\n    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 1;\n\n    //\n    // Functions\n    //\n\n    /// Returns the (non-cryptographic) SipHash of `bytes`. See https://en.wikipedia.org/wiki/SipHash\n    native public fun sip_hash(bytes: vector<u8>): u64;\n\n    /// Returns the (non-cryptographic) SipHash of the BCS serialization of `v`. See https://en.wikipedia.org/wiki/SipHash\n    public fun sip_hash_from_value<MoveValue>(v: &MoveValue): u64 {\n        let bytes = bcs::to_bytes(v);\n\n        sip_hash(bytes)\n    }\n\n    /// Returns the Keccak-256 hash of `bytes`.\n    native public fun keccak256(bytes: vector<u8>): vector<u8>;\n\n    /// Returns the SHA2-512 hash of `bytes`.\n    public fun sha2_512(bytes: vector<u8>): vector<u8> {\n        if(!features::sha_512_and_ripemd_160_enabled()) {\n            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))\n        };\n\n        sha2_512_internal(bytes)\n    }\n\n    /// Returns the SHA3-512 hash of `bytes`.\n    public fun sha3_512(bytes: vector<u8>): vector<u8> {\n        if(!features::sha_512_and_ripemd_160_enabled()) {\n            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))\n        };\n\n        sha3_512_internal(bytes)\n    }\n\n\n    /// Returns the RIPEMD-160 hash of `bytes`.\n    ///\n    /// WARNING: Only 80-bit security is provided by this function. This means an adversary who can compute roughly 2^80\n    /// hashes will, with high probability, find a collision x_1 != x_2 such that RIPEMD-160(x_1) = RIPEMD-160(x_2).\n    public fun ripemd160(bytes: vector<u8>): vector<u8> {\n        if(!features::sha_512_and_ripemd_160_enabled()) {\n            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))\n        };\n\n        ripemd160_internal(bytes)\n    }\n\n    /// Returns the BLAKE2B-256 hash of `bytes`.\n    public fun blake2b_256(bytes: vector<u8>): vector<u8> {\n        if(!features::blake2b_256_enabled()) {\n            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))\n        };\n\n        blake2b_256_internal(bytes)\n    }\n\n    //\n    // Private native functions\n    //\n\n    /// Returns the SHA2-512 hash of `bytes`.\n    native fun sha2_512_internal(bytes: vector<u8>): vector<u8>;\n\n\n    /// Returns the SHA3-512 hash of `bytes`.\n    native fun sha3_512_internal(bytes: vector<u8>): vector<u8>;\n\n    /// Returns the RIPEMD-160 hash of `bytes`.\n    ///\n    /// WARNING: Only 80-bit security is provided by this function. This means an adversary who can compute roughly 2^80\n    /// hashes will, with high probability, find a collision x_1 != x_2 such that RIPEMD-160(x_1) = RIPEMD-160(x_2).\n    native fun ripemd160_internal(bytes: vector<u8>): vector<u8>;\n\n    /// Returns the BLAKE2B-256 hash of `bytes`.\n    native fun blake2b_256_internal(bytes: vector<u8>): vector<u8>;\n\n    //\n    // Testing\n    //\n\n    #[test]\n    fun keccak256_test() {\n        let inputs = vector[\n            b"testing",\n            b"",\n        ];\n\n        let outputs = vector[\n            x"5f16f4c7f149ac4f9510d9cf8cf384038ad348b3bcdc01915f95de12df9d1b02",\n            x"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",\n        ];\n\n        let i = 0;\n        while (i < std::vector::length(&inputs)) {\n            let input = *std::vector::borrow(&inputs, i);\n            let hash_expected = *std::vector::borrow(&outputs, i);\n            let hash = keccak256(input);\n\n            assert!(hash_expected == hash, 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test(fx = @aptos_std)]\n    fun sha2_512_test(fx: signer) {\n        // We need to enable the feature in order for the native call to be allowed.\n        features::change_feature_flags_for_testing(&fx, vector[features::get_sha_512_and_ripemd_160_feature()], vector[]);\n\n        let inputs = vector[\n        b"testing",\n        b"",\n        ];\n\n        // From https://emn178.github.io/online-tools/sha512.html\n        let outputs = vector[\n        x"521b9ccefbcd14d179e7a1bb877752870a6d620938b28a66a107eac6e6805b9d0989f45b5730508041aa5e710847d439ea74cd312c9355f1f2dae08d40e41d50",\n        x"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e",\n        ];\n\n        let i = 0;\n        while (i < std::vector::length(&inputs)) {\n            let input = *std::vector::borrow(&inputs, i);\n            let hash_expected = *std::vector::borrow(&outputs, i);\n            let hash = sha2_512(input);\n\n            assert!(hash_expected == hash, 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test(fx = @aptos_std)]\n    fun sha3_512_test(fx: signer) {\n        // We need to enable the feature in order for the native call to be allowed.\n        features::change_feature_flags_for_testing(&fx, vector[features::get_sha_512_and_ripemd_160_feature()], vector[]);\n        let inputs = vector[\n        b"testing",\n        b"",\n        ];\n\n        // From https://emn178.github.io/online-tools/sha3_512.html\n        let outputs = vector[\n        x"881c7d6ba98678bcd96e253086c4048c3ea15306d0d13ff48341c6285ee71102a47b6f16e20e4d65c0c3d677be689dfda6d326695609cbadfafa1800e9eb7fc1",\n        x"a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26",\n        ];\n\n        let i = 0;\n        while (i < std::vector::length(&inputs)) {\n            let input = *std::vector::borrow(&inputs, i);\n            let hash_expected = *std::vector::borrow(&outputs, i);\n            let hash = sha3_512(input);\n\n            assert!(hash_expected == hash, 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test(fx = @aptos_std)]\n    fun ripemd160_test(fx: signer) {\n        // We need to enable the feature in order for the native call to be allowed.\n        features::change_feature_flags_for_testing(&fx, vector[features::get_sha_512_and_ripemd_160_feature()], vector[]);\n        let inputs = vector[\n        b"testing",\n        b"",\n        ];\n\n        // From https://www.browserling.com/tools/ripemd160-hash\n        let outputs = vector[\n        x"b89ba156b40bed29a5965684b7d244c49a3a769b",\n        x"9c1185a5c5e9fc54612808977ee8f548b2258d31",\n        ];\n\n        let i = 0;\n        while (i < std::vector::length(&inputs)) {\n            let input = *std::vector::borrow(&inputs, i);\n            let hash_expected = *std::vector::borrow(&outputs, i);\n            let hash = ripemd160(input);\n\n            assert!(hash_expected == hash, 1);\n\n            i = i + 1;\n        };\n    }\n\n    #[test(fx = @aptos_std)]\n    #[expected_failure(abort_code = 196609, location = Self)]\n    fun blake2b_256_aborts(fx: signer) {\n        // We disable the feature to make sure the `blake2b_256` call aborts\n        features::change_feature_flags_for_testing(&fx, vector[], vector[features::get_blake2b_256_feature()]);\n\n        blake2b_256(b"This will abort");\n    }\n\n    #[test(fx = @aptos_std)]\n    fun blake2b_256_test(fx: signer) {\n        // We need to enable the feature in order for the native call to be allowed.\n        features::change_feature_flags_for_testing(&fx, vector[features::get_blake2b_256_feature()], vector[]);\n        let inputs = vector[\n        b"",\n        b"testing",\n        b"testing again", // empty message doesn\'t yield an output on the online generator\n        ];\n\n        // From https://www.toolkitbay.com/tkb/tool/BLAKE2b_256\n        //\n        // For computing the hash of an empty string, we use the following Python3 script:\n        // ```\n        //   #!/usr/bin/python3\n        //\n        //   import hashlib\n        //\n        //   print(hashlib.blake2b(b\'\', digest_size=32).hexdigest());\n        // ```\n        let outputs = vector[\n        x"0e5751c026e543b2e8ab2eb06099daa1d1e5df47778f7787faab45cdf12fe3a8",\n        x"99397ff32ae348b8b6536d5c213f343d7e9fdeaa10e8a23a9f90ab21a1658565",\n        x"1deab5a4eb7481453ca9b29e1f7c4be8ba44de4faeeafdf173b310cbaecfc84c",\n        ];\n\n        let i = 0;\n        while (i < std::vector::length(&inputs)) {\n            let input = *std::vector::borrow(&inputs, i);\n            let hash_expected = *std::vector::borrow(&outputs, i);\n            let hash = blake2b_256(input);\n\n            assert!(hash_expected == hash, 1);\n\n            i = i + 1;\n        };\n    }\n}\n', "name": "hash.move" }, { "content": "/// Standard math utilities missing in the Move Language.\nmodule aptos_std::math128 {\n\n    use std::fixed_point32::FixedPoint32;\n    use std::fixed_point32;\n    use aptos_std::fixed_point64::FixedPoint64;\n    use aptos_std::fixed_point64;\n\n    /// Cannot log2 the value 0\n    const EINVALID_ARG_FLOOR_LOG2: u64 = 1;\n\n    /// Return the largest of two numbers.\n    public fun max(a: u128, b: u128): u128 {\n        if (a >= b) a else b\n    }\n\n    /// Return the smallest of two numbers.\n    public fun min(a: u128, b: u128): u128 {\n        if (a < b) a else b\n    }\n\n    /// Return the average of two.\n    public fun average(a: u128, b: u128): u128 {\n        if (a < b) {\n            a + (b - a) / 2\n        } else {\n            b + (a - b) / 2\n        }\n    }\n\n    /// Return greatest common divisor of `a` & `b`, via the Euclidean algorithm.\n    public inline fun gcd(a: u128, b: u128): u128 {\n        let (large, small) = if (a > b) (a, b) else (b, a);\n        while (small != 0) {\n            let tmp = small;\n            small = large % small;\n            large = tmp;\n        };\n        large\n    }\n\n    /// Returns a * b / c going through u256 to prevent intermediate overflow\n    public inline fun mul_div(a: u128, b: u128, c: u128): u128 {\n        // Inline functions cannot take constants, as then every module using it needs the constant\n        assert!(c != 0, std::error::invalid_argument(4));\n        (((a as u256) * (b as u256) / (c as u256)) as u128)\n    }\n\n    /// Return x clamped to the interval [lower, upper].\n    public fun clamp(x: u128, lower: u128, upper: u128): u128 {\n        min(upper, max(lower, x))\n    }\n\n    /// Return the value of n raised to power e\n    public fun pow(n: u128, e: u128): u128 {\n        if (e == 0) {\n            1\n        } else {\n            let p = 1;\n            while (e > 1) {\n                if (e % 2 == 1) {\n                    p = p * n;\n                };\n                e = e / 2;\n                n = n * n;\n            };\n            p * n\n        }\n    }\n\n    /// Returns floor(log2(x))\n    public fun floor_log2(x: u128): u8 {\n        let res = 0;\n        assert!(x != 0, std::error::invalid_argument(EINVALID_ARG_FLOOR_LOG2));\n        // Effectively the position of the most significant set bit\n        let n = 64;\n        while (n > 0) {\n            if (x >= (1 << n)) {\n                x = x >> n;\n                res = res + n;\n            };\n            n = n >> 1;\n        };\n        res\n    }\n\n    // Returns log2(x)\n    public fun log2(x: u128): FixedPoint32 {\n        let integer_part = floor_log2(x);\n        // Normalize x to [1, 2) in fixed point 32.\n        if (x >= 1 << 32) {\n            x = x >> (integer_part - 32);\n        } else {\n            x = x << (32 - integer_part);\n        };\n        let frac = 0;\n        let delta = 1 << 31;\n        while (delta != 0) {\n            // log x = 1/2 log x^2\n            // x in [1, 2)\n            x = (x * x) >> 32;\n            // x is now in [1, 4)\n            // if x in [2, 4) then log x = 1 + log (x / 2)\n            if (x >= (2 << 32)) { frac = frac + delta; x = x >> 1; };\n            delta = delta >> 1;\n        };\n        fixed_point32::create_from_raw_value (((integer_part as u64) << 32) + frac)\n    }\n\n    // Return log2(x) as FixedPoint64\n    public fun log2_64(x: u128): FixedPoint64 {\n        let integer_part = floor_log2(x);\n        // Normalize x to [1, 2) in fixed point 63. To ensure x is smaller then 1<<64\n        if (x >= 1 << 63) {\n            x = x >> (integer_part - 63);\n        } else {\n            x = x << (63 - integer_part);\n        };\n        let frac = 0;\n        let delta = 1 << 63;\n        while (delta != 0) {\n            // log x = 1/2 log x^2\n            // x in [1, 2)\n            x = (x * x) >> 63;\n            // x is now in [1, 4)\n            // if x in [2, 4) then log x = 1 + log (x / 2)\n            if (x >= (2 << 63)) { frac = frac + delta; x = x >> 1; };\n            delta = delta >> 1;\n        };\n        fixed_point64::create_from_raw_value (((integer_part as u128) << 64) + frac)\n    }\n\n    /// Returns square root of x, precisely floor(sqrt(x))\n    public fun sqrt(x: u128): u128 {\n        if (x == 0) return 0;\n        // Note the plus 1 in the expression. Let n = floor_lg2(x) we have x in [2^n, 2^{n+1}) and thus the answer in\n        // the half-open interval [2^(n/2), 2^{(n+1)/2}). For even n we can write this as [2^(n/2), sqrt(2) 2^{n/2})\n        // for odd n [2^((n+1)/2)/sqrt(2), 2^((n+1)/2). For even n the left end point is integer for odd the right\n        // end point is integer. If we choose as our first approximation the integer end point we have as maximum\n        // relative error either (sqrt(2) - 1) or (1 - 1/sqrt(2)) both are smaller then 1/2.\n        let res = 1 << ((floor_log2(x) + 1) >> 1);\n        // We use standard newton-rhapson iteration to improve the initial approximation.\n        // The error term evolves as delta_i+1 = delta_i^2 / 2 (quadratic convergence).\n        // It turns out that after 5 iterations the delta is smaller than 2^-64 and thus below the treshold.\n        res = (res + x / res) >> 1;\n        res = (res + x / res) >> 1;\n        res = (res + x / res) >> 1;\n        res = (res + x / res) >> 1;\n        res = (res + x / res) >> 1;\n        min(res, x / res)\n    }\n\n    public inline fun ceil_div(x: u128, y: u128): u128 {\n        // ceil_div(x, y) = floor((x + y - 1) / y) = floor((x - 1) / y) + 1\n        // (x + y - 1) could spuriously overflow. so we use the later version\n        if (x == 0) {\n            // Inline functions cannot take constants, as then every module using it needs the constant\n            assert!(y != 0, std::error::invalid_argument(4));\n            0\n        }\n        else (x - 1) / y + 1\n    }\n\n    #[test]\n    public entry fun test_ceil_div() {\n        assert!(ceil_div(9, 3) == 3, 0);\n        assert!(ceil_div(10, 3) == 4, 0);\n        assert!(ceil_div(11, 3) == 4, 0);\n        assert!(ceil_div(12, 3) == 4, 0);\n        assert!(ceil_div(13, 3) == 5, 0);\n\n        // No overflow\n        assert!(ceil_div((((1u256<<128) - 9) as u128), 11) == 30934760629176223951215873402888019223, 0);\n    }\n\n    #[test]\n    fun test_gcd() {\n        assert!(gcd(20, 8) == 4, 0);\n        assert!(gcd(8, 20) == 4, 0);\n        assert!(gcd(1, 100) == 1, 0);\n        assert!(gcd(100, 1) == 1, 0);\n        assert!(gcd(210, 45) == 15, 0);\n        assert!(gcd(45, 210) == 15, 0);\n        assert!(gcd(0, 0) == 0, 0);\n        assert!(gcd(1, 0) == 1, 0);\n        assert!(gcd(50, 0) == 50, 0);\n        assert!(gcd(0, 1) == 1, 0);\n        assert!(gcd(0, 50) == 50, 0);\n        assert!(gcd(54, 24) == 6, 0);\n        assert!(gcd(24, 54) == 6, 0);\n        assert!(gcd(10, 10) == 10, 0);\n        assert!(gcd(1071, 462) == 21, 0);\n        assert!(gcd(462, 1071) == 21, 0);\n    }\n\n    #[test]\n    public entry fun test_max() {\n        let result = max(3u128, 6u128);\n        assert!(result == 6, 0);\n\n        let result = max(15u128, 12u128);\n        assert!(result == 15, 1);\n    }\n\n    #[test]\n    public entry fun test_min() {\n        let result = min(3u128, 6u128);\n        assert!(result == 3, 0);\n\n        let result = min(15u128, 12u128);\n        assert!(result == 12, 1);\n    }\n\n    #[test]\n    public entry fun test_average() {\n        let result = average(3u128, 6u128);\n        assert!(result == 4, 0);\n\n        let result = average(15u128, 12u128);\n        assert!(result == 13, 0);\n    }\n\n    #[test]\n    public entry fun test_pow() {\n        let result = pow(10u128, 18u128);\n        assert!(result == 1000000000000000000, 0);\n\n        let result = pow(10u128, 1u128);\n        assert!(result == 10, 0);\n\n        let result = pow(10u128, 0u128);\n        assert!(result == 1, 0);\n    }\n\n    #[test]\n    public entry fun test_mul_div() {\n        let tmp: u128 = 1<<127;\n        assert!(mul_div(tmp,tmp,tmp) == tmp, 0);\n\n        assert!(mul_div(tmp,5,5) == tmp, 0);\n        // Note that ordering other way is imprecise.\n        assert!((tmp / 5) * 5 != tmp, 0);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x10004, location = aptos_std::math128)]\n    public entry fun test_mul_div_by_zero() {\n        mul_div(1, 1, 0);\n    }\n\n    #[test]\n    public entry fun test_floor_log2() {\n        let idx: u8 = 0;\n        while (idx < 128) {\n            assert!(floor_log2(1<<idx) == idx, 0);\n            idx = idx + 1;\n        };\n        idx = 1;\n        while (idx <= 128) {\n            assert!(floor_log2((((1u256<<idx) - 1) as u128)) == idx - 1, 0);\n            idx = idx + 1;\n        };\n    }\n\n    #[test]\n    public entry fun test_log2() {\n        let idx: u8 = 0;\n        while (idx < 128) {\n            let res = log2(1<<idx);\n            assert!(fixed_point32::get_raw_value(res) == (idx as u64) << 32, 0);\n            idx = idx + 1;\n        };\n        idx = 10;\n        while (idx <= 128) {\n            let res = log2((((1u256<<idx) - 1) as u128));\n            // idx + log2 (1 - 1/2^idx) = idx + ln (1-1/2^idx)/ln2\n            // Use 3rd order taylor to approximate expected result\n            let expected = (idx as u128) << 32;\n            let taylor1 = ((1 << 32) / ((1u256<<idx)) as u128);\n            let taylor2 = (taylor1 * taylor1) >> 32;\n            let taylor3 = (taylor2 * taylor1) >> 32;\n            let expected = expected - ((taylor1 + taylor2 / 2 + taylor3 / 3) << 32) / 2977044472;\n            // verify it matches to 8 significant digits\n            assert_approx_the_same((fixed_point32::get_raw_value(res) as u128), expected, 8);\n            idx = idx + 1;\n        };\n    }\n\n    #[test]\n    public entry fun test_log2_64() {\n        let idx: u8 = 0;\n        while (idx < 128) {\n            let res = log2_64(1<<idx);\n            assert!(fixed_point64::get_raw_value(res) == (idx as u128) << 64, 0);\n            idx = idx + 1;\n        };\n        idx = 10;\n        while (idx <= 128) {\n            let res = log2_64((((1u256<<idx) - 1) as u128));\n            // idx + log2 (1 - 1/2^idx) = idx + ln (1-1/2^idx)/ln2\n            // Use 3rd order taylor to approximate expected result\n            let expected = (idx as u256) << 64;\n            let taylor1 = (1 << 64) / ((1u256<<idx));\n            let taylor2 = (taylor1 * taylor1) >> 64;\n            let taylor3 = (taylor2 * taylor1) >> 64;\n            let taylor4 = (taylor3 * taylor1) >> 64;\n            let expected = expected - ((taylor1 + taylor2 / 2 + taylor3 / 3 + taylor4 / 4) << 64) / 12786308645202655660;\n            // verify it matches to 8 significant digits\n            assert_approx_the_same(fixed_point64::get_raw_value(res), (expected as u128), 14);\n            idx = idx + 1;\n        };\n    }\n\n    #[test]\n    public entry fun test_sqrt() {\n        let result = sqrt(0);\n        assert!(result == 0, 0);\n\n        let result = sqrt(1);\n        assert!(result == 1, 0);\n\n        let result = sqrt(256);\n        assert!(result == 16, 0);\n\n        let result = sqrt(1<<126);\n        assert!(result == 1<<63, 0);\n\n        let result = sqrt((((1u256 << 128) - 1) as u128));\n        assert!(result == (1u128 << 64) - 1, 0);\n\n        let result = sqrt((1u128 << 127));\n        assert!(result == 13043817825332782212, 0);\n\n        let result = sqrt((1u128 << 127) - 1);\n        assert!(result == 13043817825332782212, 0);\n    }\n\n    #[test_only]\n    /// For functions that approximate a value it's useful to test a value is close\n    /// to the most correct value up to last digit\n    fun assert_approx_the_same(x: u128, y: u128, precission: u128) {\n        if (x < y) {\n            let tmp = x;\n            x = y;\n            y = tmp;\n        };\n        let mult = pow(10, precission);\n        assert!((x - y) * mult < x, 0);\n    }\n}\n", "name": "math128.move" }, { "content": "/// Standard math utilities missing in the Move Language.\nmodule aptos_std::math64 {\n\n    use std::fixed_point32::FixedPoint32;\n    use std::fixed_point32;\n\n    /// Cannot log2 the value 0\n    const EINVALID_ARG_FLOOR_LOG2: u64 = 1;\n\n    /// Return the largest of two numbers.\n    public fun max(a: u64, b: u64): u64 {\n        if (a >= b) a else b\n    }\n\n    /// Return the smallest of two numbers.\n    public fun min(a: u64, b: u64): u64 {\n        if (a < b) a else b\n    }\n\n    /// Return the average of two.\n    public fun average(a: u64, b: u64): u64 {\n        if (a < b) {\n            a + (b - a) / 2\n        } else {\n            b + (a - b) / 2\n        }\n    }\n\n    /// Return greatest common divisor of `a` & `b`, via the Euclidean algorithm.\n    public inline fun gcd(a: u64, b: u64): u64 {\n        let (large, small) = if (a > b) (a, b) else (b, a);\n        while (small != 0) {\n            let tmp = small;\n            small = large % small;\n            large = tmp;\n        };\n        large\n    }\n\n    /// Returns a * b / c going through u128 to prevent intermediate overflow\n    public inline fun mul_div(a: u64, b: u64, c: u64): u64 {\n        // Inline functions cannot take constants, as then every module using it needs the constant\n        assert!(c != 0, std::error::invalid_argument(4));\n        (((a as u128) * (b as u128) / (c as u128)) as u64)\n    }\n\n    /// Return x clamped to the interval [lower, upper].\n    public fun clamp(x: u64, lower: u64, upper: u64): u64 {\n        min(upper, max(lower, x))\n    }\n\n    /// Return the value of n raised to power e\n    public fun pow(n: u64, e: u64): u64 {\n        if (e == 0) {\n            1\n        } else {\n            let p = 1;\n            while (e > 1) {\n                if (e % 2 == 1) {\n                    p = p * n;\n                };\n                e = e / 2;\n                n = n * n;\n            };\n            p * n\n        }\n    }\n\n    /// Returns floor(lg2(x))\n    public fun floor_log2(x: u64): u8 {\n        let res = 0;\n        assert!(x != 0, std::error::invalid_argument(EINVALID_ARG_FLOOR_LOG2));\n        // Effectively the position of the most significant set bit\n        let n = 32;\n        while (n > 0) {\n            if (x >= (1 << n)) {\n                x = x >> n;\n                res = res + n;\n            };\n            n = n >> 1;\n        };\n        res\n    }\n\n    // Returns log2(x)\n    public fun log2(x: u64): FixedPoint32 {\n        let integer_part = floor_log2(x);\n        // Normalize x to [1, 2) in fixed point 32.\n        let y = (if (x >= 1 << 32) {\n            x >> (integer_part - 32)\n        } else {\n            x << (32 - integer_part)\n        } as u128);\n        let frac = 0;\n        let delta = 1 << 31;\n        while (delta != 0) {\n            // log x = 1/2 log x^2\n            // x in [1, 2)\n            y = (y * y) >> 32;\n            // x is now in [1, 4)\n            // if x in [2, 4) then log x = 1 + log (x / 2)\n            if (y >= (2 << 32)) { frac = frac + delta; y = y >> 1; };\n            delta = delta >> 1;\n        };\n        fixed_point32::create_from_raw_value (((integer_part as u64) << 32) + frac)\n    }\n\n    /// Returns square root of x, precisely floor(sqrt(x))\n    public fun sqrt(x: u64): u64 {\n        if (x == 0) return 0;\n        // Note the plus 1 in the expression. Let n = floor_lg2(x) we have x in [2^n, 2^(n+1)> and thus the answer in\n        // the half-open interval [2^(n/2), 2^((n+1)/2)>. For even n we can write this as [2^(n/2), sqrt(2) 2^(n/2)>\n        // for odd n [2^((n+1)/2)/sqrt(2), 2^((n+1)/2>. For even n the left end point is integer for odd the right\n        // end point is integer. If we choose as our first approximation the integer end point we have as maximum\n        // relative error either (sqrt(2) - 1) or (1 - 1/sqrt(2)) both are smaller then 1/2.\n        let res = 1 << ((floor_log2(x) + 1) >> 1);\n        // We use standard newton-rhapson iteration to improve the initial approximation.\n        // The error term evolves as delta_i+1 = delta_i^2 / 2 (quadratic convergence).\n        // It turns out that after 4 iterations the delta is smaller than 2^-32 and thus below the treshold.\n        res = (res + x / res) >> 1;\n        res = (res + x / res) >> 1;\n        res = (res + x / res) >> 1;\n        res = (res + x / res) >> 1;\n        min(res, x / res)\n    }\n\n    public inline fun ceil_div(x: u64, y: u64): u64 {\n        // ceil_div(x, y) = floor((x + y - 1) / y) = floor((x - 1) / y) + 1\n        // (x + y - 1) could spuriously overflow. so we use the later version\n        if (x == 0) {\n            // Inline functions cannot take constants, as then every module using it needs the constant\n            assert!(y != 0, std::error::invalid_argument(4));\n            0\n        }\n        else (x - 1) / y + 1\n    }\n\n    #[test]\n    public entry fun test_ceil_div() {\n        assert!(ceil_div(9, 3) == 3, 0);\n        assert!(ceil_div(10, 3) == 4, 0);\n        assert!(ceil_div(11, 3) == 4, 0);\n        assert!(ceil_div(12, 3) == 4, 0);\n        assert!(ceil_div(13, 3) == 5, 0);\n\n        // No overflow\n        assert!(ceil_div((((1u128<<64) - 9) as u64), 11) == 1676976733973595601, 0);\n    }\n\n    #[test]\n    fun test_gcd() {\n        assert!(gcd(20, 8) == 4, 0);\n        assert!(gcd(8, 20) == 4, 0);\n        assert!(gcd(1, 100) == 1, 0);\n        assert!(gcd(100, 1) == 1, 0);\n        assert!(gcd(210, 45) == 15, 0);\n        assert!(gcd(45, 210) == 15, 0);\n        assert!(gcd(0, 0) == 0, 0);\n        assert!(gcd(1, 0) == 1, 0);\n        assert!(gcd(50, 0) == 50, 0);\n        assert!(gcd(0, 1) == 1, 0);\n        assert!(gcd(0, 50) == 50, 0);\n        assert!(gcd(54, 24) == 6, 0);\n        assert!(gcd(24, 54) == 6, 0);\n        assert!(gcd(10, 10) == 10, 0);\n        assert!(gcd(1071, 462) == 21, 0);\n        assert!(gcd(462, 1071) == 21, 0);\n    }\n\n    #[test]\n    public entry fun test_max_64() {\n        let result = max(3u64, 6u64);\n        assert!(result == 6, 0);\n\n        let result = max(15u64, 12u64);\n        assert!(result == 15, 1);\n    }\n\n    #[test]\n    public entry fun test_min() {\n        let result = min(3u64, 6u64);\n        assert!(result == 3, 0);\n\n        let result = min(15u64, 12u64);\n        assert!(result == 12, 1);\n    }\n\n    #[test]\n    public entry fun test_average() {\n        let result = average(3u64, 6u64);\n        assert!(result == 4, 0);\n\n        let result = average(15u64, 12u64);\n        assert!(result == 13, 0);\n    }\n\n    #[test]\n    public entry fun test_average_does_not_overflow() {\n        let result = average(18446744073709551615, 18446744073709551615);\n        assert!(result == 18446744073709551615, 0);\n    }\n\n    #[test]\n    public entry fun test_pow() {\n        let result = pow(10u64, 18u64);\n        assert!(result == 1000000000000000000, 0);\n\n        let result = pow(10u64, 1u64);\n        assert!(result == 10, 0);\n\n        let result = pow(10u64, 0u64);\n        assert!(result == 1, 0);\n    }\n\n    #[test]\n    public entry fun test_mul_div() {\n        let tmp: u64 = 1<<63;\n        assert!(mul_div(tmp,tmp,tmp) == tmp, 0);\n\n        assert!(mul_div(tmp,5,5) == tmp, 0);\n        // Note that ordering other way is imprecise.\n        assert!((tmp / 5) * 5 != tmp, 0);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 0x10004, location = aptos_std::math64)]\n    public entry fun test_mul_div_by_zero() {\n        mul_div(1, 1, 0);\n    }\n\n    #[test]\n    public entry fun test_floor_lg2() {\n        let idx: u8 = 0;\n        while (idx < 64) {\n            assert!(floor_log2(1<<idx) == idx, 0);\n            idx = idx + 1;\n        };\n        idx = 1;\n        while (idx <= 64) {\n            assert!(floor_log2((((1u128<<idx) - 1) as u64)) == idx - 1, 0);\n            idx = idx + 1;\n        };\n    }\n\n    #[test]\n    public entry fun test_log2() {\n        let idx: u8 = 0;\n        while (idx < 64) {\n            let res = log2(1<<idx);\n            assert!(fixed_point32::get_raw_value(res) == (idx as u64) << 32, 0);\n            idx = idx + 1;\n        };\n        idx = 10;\n        while (idx <= 64) {\n            let res = log2((((1u128<<idx) - 1) as u64));\n            // idx + log2 (1 - 1/2^idx) = idx + ln (1-1/2^idx)/ln2\n            // Use 3rd order taylor to approximate expected result\n            let expected = (idx as u128) << 32;\n            let taylor1 = ((1 << 32) / ((1u256<<idx)) as u128);\n            let taylor2 = (taylor1 * taylor1) >> 32;\n            let taylor3 = (taylor2 * taylor1) >> 32;\n            let expected = expected - ((taylor1 + taylor2 / 2 + taylor3 / 3) << 32) / 2977044472;\n            // verify it matches to 8 significant digits\n            assert_approx_the_same((fixed_point32::get_raw_value(res) as u128), expected, 8);\n            idx = idx + 1;\n        };\n    }\n\n    #[test]\n    public entry fun test_sqrt() {\n        let result = sqrt(0);\n        assert!(result == 0, 0);\n\n        let result = sqrt(1);\n        assert!(result == 1, 0);\n\n        let result = sqrt(256);\n        assert!(result == 16, 0);\n\n        let result = sqrt(1<<62);\n        assert!(result == 1<<31, 0);\n\n        let result = sqrt((((1u128 << 64) - 1) as u64));\n        assert!(result == (1u64 << 32) - 1, 0);\n\n        let result = sqrt((1u64 << 63));\n        assert!(result == 3037000499, 0);\n\n        let result = sqrt((1u64 << 63) - 1);\n        assert!(result == 3037000499, 0);\n    }\n\n    #[test_only]\n    /// For functions that approximate a value it's useful to test a value is close\n    /// to the most correct value up to last digit\n    fun assert_approx_the_same(x: u128, y: u128, precission: u64) {\n        if (x < y) {\n            let tmp = x;\n            x = y;\n            y = tmp;\n        };\n        let mult = (pow(10, precission) as u128);\n        assert!((x - y) * mult < x, 0);\n    }\n}\n", "name": "math64.move" }, { "content": "/// Standard math utilities missing in the Move Language.\nmodule aptos_std::math_fixed {\n    use std::fixed_point32;\n    use std::fixed_point32::FixedPoint32;\n    use aptos_std::math128;\n    use aptos_std::math64;\n\n    /// Abort code on overflow\n    const EOVERFLOW_EXP: u64 = 1;\n\n    /// Natural log 2 in 32 bit fixed point\n    const LN2: u128 = 2977044472;  // ln(2) in fixed 32 representation\n    const LN2_X_32: u64 = 32 * 2977044472;  // 32 * ln(2) in fixed 32 representation\n\n    /// Square root of fixed point number\n    public fun sqrt(x: FixedPoint32): FixedPoint32 {\n        let y = (fixed_point32::get_raw_value(x) as u128);\n        fixed_point32::create_from_raw_value((math128::sqrt(y << 32) as u64))\n    }\n\n    /// Exponent function with a precission of 9 digits.\n    public fun exp(x: FixedPoint32): FixedPoint32 {\n        let raw_value = (fixed_point32::get_raw_value(x) as u128);\n        fixed_point32::create_from_raw_value((exp_raw(raw_value) as u64))\n    }\n\n    /// Because log2 is negative for values < 1 we instead return log2(x) + 32 which\n    /// is positive for all values of x.\n    public fun log2_plus_32(x: FixedPoint32): FixedPoint32 {\n        let raw_value = (fixed_point32::get_raw_value(x) as u128);\n        math128::log2(raw_value)\n    }\n\n    public fun ln_plus_32ln2(x: FixedPoint32): FixedPoint32 {\n        let raw_value = (fixed_point32::get_raw_value(x) as u128);\n        let x = (fixed_point32::get_raw_value(math128::log2(raw_value)) as u128);\n        fixed_point32::create_from_raw_value((x * LN2 >> 32 as u64))\n    }\n\n    /// Integer power of a fixed point number\n    public fun pow(x: FixedPoint32, n: u64): FixedPoint32 {\n        let raw_value = (fixed_point32::get_raw_value(x) as u128);\n        fixed_point32::create_from_raw_value((pow_raw(raw_value, (n as u128)) as u64))\n    }\n\n    /// Specialized function for x * y / z that omits intermediate shifting\n    public fun mul_div(x: FixedPoint32, y: FixedPoint32, z: FixedPoint32): FixedPoint32 {\n        let a = fixed_point32::get_raw_value(x);\n        let b = fixed_point32::get_raw_value(y);\n        let c = fixed_point32::get_raw_value(z);\n        fixed_point32::create_from_raw_value (math64::mul_div(a, b, c))\n    }\n\n    // Calculate e^x where x and the result are fixed point numbers\n    fun exp_raw(x: u128): u128 {\n        // exp(x / 2^32) = 2^(x / (2^32 * ln(2))) = 2^(floor(x / (2^32 * ln(2))) + frac(x / (2^32 * ln(2))))\n        let shift_long = x / LN2;\n        assert!(shift_long <= 31, std::error::invalid_state(EOVERFLOW_EXP));\n        let shift = (shift_long as u8);\n        let remainder = x % LN2;\n        // At this point we want to calculate 2^(remainder / ln2) << shift\n        // ln2 = 595528 * 4999 which means\n        let bigfactor = 595528;\n        let exponent = remainder / bigfactor;\n        let x = remainder % bigfactor;\n        // 2^(remainder / ln2) = (2^(1/4999))^exponent * exp(x / 2^32)\n        let roottwo = 4295562865;  // fixed point representation of 2^(1/4999)\n        // This has an error of 5000 / 4 10^9 roughly 6 digits of precission\n        let power = pow_raw(roottwo, exponent);\n        let eps_correction = 1241009291;\n        power = power + ((power * eps_correction * exponent) >> 64);\n        // x is fixed point number smaller than 595528/2^32 < 0.00014 so we need only 2 tayler steps\n        // to get the 6 digits of precission\n        let taylor1 = (power * x) >> (32 - shift);\n        let taylor2 = (taylor1 * x) >> 32;\n        let taylor3 = (taylor2 * x) >> 32;\n        (power << shift) + taylor1 + taylor2 / 2 + taylor3 / 6\n    }\n\n    // Calculate x to the power of n, where x and the result are fixed point numbers.\n    fun pow_raw(x: u128, n: u128): u128 {\n        let res: u256 = 1 << 64;\n        x = x << 32;\n        while (n != 0) {\n            if (n & 1 != 0) {\n                res = (res * (x as u256)) >> 64;\n            };\n            n = n >> 1;\n            x = ((((x as u256) * (x as u256)) >> 64) as u128);\n        };\n        ((res >> 32) as u128)\n    }\n\n    #[test]\n    public entry fun test_sqrt() {\n        // Sqrt is based on math128::sqrt and thus most of the testing is done there.\n        let fixed_base = 1 << 32;\n        let result = sqrt(fixed_point32::create_from_u64(1));\n        assert!(fixed_point32::get_raw_value(result) == fixed_base, 0);\n\n        let result = sqrt(fixed_point32::create_from_u64(2));\n        assert_approx_the_same((fixed_point32::get_raw_value(result) as u128), 6074001000, 9);\n    }\n\n    #[test]\n    public entry fun test_exp() {\n        let fixed_base = 1 << 32;\n        let result = exp_raw(0);\n        assert!(result == fixed_base, 0);\n\n        let result = exp_raw(fixed_base);\n        let e = 11674931554;  // e in 32 bit fixed point\n        assert_approx_the_same(result, e, 9);\n\n        let result = exp_raw(10 * fixed_base);\n        let exp10 = 94602950235157;  // e^10 in 32 bit fixed point\n        assert_approx_the_same(result, exp10, 9);\n    }\n\n    #[test]\n    public entry fun test_pow() {\n        // We use the case of exp\n        let result = pow_raw(4295562865, 4999);\n        assert_approx_the_same(result,  1 << 33, 6);\n    }\n\n    #[test_only]\n    /// For functions that approximate a value it's useful to test a value is close\n    /// to the most correct value up to last digit\n    fun assert_approx_the_same(x: u128, y: u128, precission: u128) {\n        if (x < y) {\n            let tmp = x;\n            x = y;\n            y = tmp;\n        };\n        let mult = math128::pow(10, precission);\n        assert!((x - y) * mult < x, 0);\n    }\n}\n", "name": "math_fixed.move" }, { "content": "/// Standard math utilities missing in the Move Language.\n\nmodule aptos_std::math_fixed64 {\n    use aptos_std::fixed_point64;\n    use aptos_std::fixed_point64::FixedPoint64;\n    use aptos_std::math128;\n\n    /// Abort code on overflow\n    const EOVERFLOW_EXP: u64 = 1;\n\n    /// Natural log 2 in 32 bit fixed point\n    const LN2: u256 = 12786308645202655660;  // ln(2) in fixed 64 representation\n\n    /// Square root of fixed point number\n    public fun sqrt(x: FixedPoint64): FixedPoint64 {\n        let y = fixed_point64::get_raw_value(x);\n        let z = (math128::sqrt(y) << 32 as u256);\n        z = (z + ((y as u256) << 64) / z) >> 1;\n        fixed_point64::create_from_raw_value((z as u128))\n    }\n\n    /// Exponent function with a precission of 9 digits.\n    public fun exp(x: FixedPoint64): FixedPoint64 {\n        let raw_value = (fixed_point64::get_raw_value(x) as u256);\n        fixed_point64::create_from_raw_value((exp_raw(raw_value) as u128))\n    }\n\n    /// Because log2 is negative for values < 1 we instead return log2(x) + 64 which\n    /// is positive for all values of x.\n    public fun log2_plus_64(x: FixedPoint64): FixedPoint64 {\n        let raw_value = (fixed_point64::get_raw_value(x) as u128);\n        math128::log2_64(raw_value)\n    }\n\n    public fun ln_plus_32ln2(x: FixedPoint64): FixedPoint64 {\n        let raw_value = fixed_point64::get_raw_value(x);\n        let x = (fixed_point64::get_raw_value(math128::log2_64(raw_value)) as u256);\n        fixed_point64::create_from_raw_value(((x * LN2) >> 64 as u128))\n    }\n\n    /// Integer power of a fixed point number\n    public fun pow(x: FixedPoint64, n: u64): FixedPoint64 {\n        let raw_value = (fixed_point64::get_raw_value(x) as u256);\n        fixed_point64::create_from_raw_value((pow_raw(raw_value, (n as u128)) as u128))\n    }\n\n    /// Specialized function for x * y / z that omits intermediate shifting\n    public fun mul_div(x: FixedPoint64, y: FixedPoint64, z: FixedPoint64): FixedPoint64 {\n        let a = fixed_point64::get_raw_value(x);\n        let b = fixed_point64::get_raw_value(y);\n        let c = fixed_point64::get_raw_value(z);\n        fixed_point64::create_from_raw_value (math128::mul_div(a, b, c))\n    }\n\n    // Calculate e^x where x and the result are fixed point numbers\n    fun exp_raw(x: u256): u256 {\n        // exp(x / 2^64) = 2^(x / (2^64 * ln(2))) = 2^(floor(x / (2^64 * ln(2))) + frac(x / (2^64 * ln(2))))\n        let shift_long = x / LN2;\n        assert!(shift_long <= 63, std::error::invalid_state(EOVERFLOW_EXP));\n        let shift = (shift_long as u8);\n        let remainder = x % LN2;\n        // At this point we want to calculate 2^(remainder / ln2) << shift\n        // ln2 = 580 * 22045359733108027\n        let bigfactor = 22045359733108027;\n        let exponent = remainder / bigfactor;\n        let x = remainder % bigfactor;\n        // 2^(remainder / ln2) = (2^(1/580))^exponent * exp(x / 2^64)\n        let roottwo = 18468802611690918839;  // fixed point representation of 2^(1/580)\n        // 2^(1/580) = roottwo(1 - eps), so the number we seek is roottwo^exponent (1 - eps * exponent)\n        let power = pow_raw(roottwo, (exponent as u128));\n        let eps_correction = 219071715585908898;\n        power = power - ((power * eps_correction * exponent) >> 128);\n        // x is fixed point number smaller than bigfactor/2^64 < 0.0011 so we need only 5 tayler steps\n        // to get the 15 digits of precission\n        let taylor1 = (power * x) >> (64 - shift);\n        let taylor2 = (taylor1 * x) >> 64;\n        let taylor3 = (taylor2 * x) >> 64;\n        let taylor4 = (taylor3 * x) >> 64;\n        let taylor5 = (taylor4 * x) >> 64;\n        let taylor6 = (taylor5 * x) >> 64;\n        (power << shift) + taylor1 + taylor2 / 2 + taylor3 / 6 + taylor4 / 24 + taylor5 / 120 + taylor6 / 720\n    }\n\n    // Calculate x to the power of n, where x and the result are fixed point numbers.\n    fun pow_raw(x: u256, n: u128): u256 {\n        let res: u256 = 1 << 64;\n        while (n != 0) {\n            if (n & 1 != 0) {\n                res = (res * x) >> 64;\n            };\n            n = n >> 1;\n            x = (x * x) >> 64;\n        };\n        res\n    }\n\n    #[test]\n    public entry fun test_sqrt() {\n        // Sqrt is based on math128::sqrt and thus most of the testing is done there.\n        let fixed_base = 1 << 64;\n        let result = sqrt(fixed_point64::create_from_u128(1));\n        assert!(fixed_point64::get_raw_value(result) == fixed_base, 0);\n\n        let result = sqrt(fixed_point64::create_from_u128(2));\n        assert_approx_the_same((fixed_point64::get_raw_value(result) as u256), 26087635650665564424, 16);\n    }\n\n    #[test]\n    public entry fun test_exp() {\n        let fixed_base = 1 << 64;\n        let result = exp_raw(0);\n        assert!(result == fixed_base, 0);\n\n        let result = exp_raw(fixed_base);\n        let e = 50143449209799256682;  // e in 32 bit fixed point\n        assert_approx_the_same(result, e, 16);\n\n        let result = exp_raw(10 * fixed_base);\n        let exp10 = 406316577365116946489258;  // e^10 in 32 bit fixed point\n        assert_approx_the_same(result, exp10, 16);\n    }\n\n    #[test]\n    public entry fun test_pow() {\n        // We use the case of exp\n        let result = pow_raw(18468802611690918839, 580);\n        assert_approx_the_same(result,  1 << 65, 16);\n    }\n\n    #[test_only]\n    /// For functions that approximate a value it's useful to test a value is close\n    /// to the most correct value up to last digit\n    fun assert_approx_the_same(x: u256, y: u256, precission: u128) {\n        if (x < y) {\n            let tmp = x;\n            x = y;\n            y = tmp;\n        };\n        let mult = (math128::pow(10, precission) as u256);\n        assert!((x - y) * mult < x, 0);\n    }\n}\n", "name": "math_fixed64.move" }, { "content": "///\n/// Simple module for tracking and calculating shares of a pool of coins. The shares are worth more as the total coins in\n/// the pool increases. New shareholder can buy more shares or redeem their existing shares.\n///\n/// Example flow:\n/// 1. Pool start outs empty.\n/// 2. Shareholder A buys in with 1000 coins. A will receive 1000 shares in the pool. Pool now has 1000 total coins and\n/// 1000 total shares.\n/// 3. Pool appreciates in value from rewards and now has 2000 coins. A's 1000 shares are now worth 2000 coins.\n/// 4. Shareholder B now buys in with 1000 coins. Since before the buy in, each existing share is worth 2 coins, B will\n/// receive 500 shares in exchange for 1000 coins. Pool now has 1500 shares and 3000 coins.\n/// 5. Pool appreciates in value from rewards and now has 6000 coins.\n/// 6. A redeems 500 shares. Each share is worth 6000 / 1500 = 4. A receives 2000 coins. Pool has 4000 coins and 1000\n/// shares left.\n///\nmodule aptos_std::pool_u64 {\n    use aptos_std::simple_map::{Self, SimpleMap};\n    use std::error;\n    use std::vector;\n\n    /// Shareholder not present in pool.\n    const ESHAREHOLDER_NOT_FOUND: u64 = 1;\n    /// There are too many shareholders in the pool.\n    const ETOO_MANY_SHAREHOLDERS: u64 = 2;\n    /// Cannot destroy non-empty pool.\n    const EPOOL_IS_NOT_EMPTY: u64 = 3;\n    /// Cannot redeem more shares than the shareholder has in the pool.\n    const EINSUFFICIENT_SHARES: u64 = 4;\n    /// Shareholder cannot have more than u64.max shares.\n    const ESHAREHOLDER_SHARES_OVERFLOW: u64 = 5;\n    /// Pool's total coins cannot exceed u64.max.\n    const EPOOL_TOTAL_COINS_OVERFLOW: u64 = 6;\n    /// Pool's total shares cannot exceed u64.max.\n    const EPOOL_TOTAL_SHARES_OVERFLOW: u64 = 7;\n\n    const MAX_U64: u64 = 18446744073709551615;\n\n    struct Pool has store {\n        shareholders_limit: u64,\n        total_coins: u64,\n        total_shares: u64,\n        shares: SimpleMap<address, u64>,\n        shareholders: vector<address>,\n        // Default to 1. This can be used to minimize rounding errors when computing shares and coins amount.\n        // However, users need to make sure the coins amount don't overflow when multiplied by the scaling factor.\n        scaling_factor: u64,\n    }\n\n    /// Create a new pool.\n    public fun new(shareholders_limit: u64): Pool {\n        // Default to a scaling factor of 1 (effectively no scaling).\n        create_with_scaling_factor(shareholders_limit, 1)\n    }\n\n    #[deprecated]\n    /// Deprecated. Use `new` instead.\n    /// Create a new pool.\n    public fun create(shareholders_limit: u64): Pool {\n        new(shareholders_limit)\n    }\n\n    /// Create a new pool with custom `scaling_factor`.\n    public fun create_with_scaling_factor(shareholders_limit: u64, scaling_factor: u64): Pool {\n        Pool {\n            shareholders_limit,\n            total_coins: 0,\n            total_shares: 0,\n            shares: simple_map::create<address, u64>(),\n            shareholders: vector::empty<address>(),\n            scaling_factor,\n        }\n    }\n\n    /// Destroy an empty pool. This will fail if the pool has any balance of coins.\n    public fun destroy_empty(pool: Pool) {\n        assert!(pool.total_coins == 0, error::invalid_state(EPOOL_IS_NOT_EMPTY));\n        let Pool {\n            shareholders_limit: _,\n            total_coins: _,\n            total_shares: _,\n            shares: _,\n            shareholders: _,\n            scaling_factor: _,\n        } = pool;\n    }\n\n    /// Return `pool`'s total balance of coins.\n    public fun total_coins(pool: &Pool): u64 {\n        pool.total_coins\n    }\n\n    /// Return the total number of shares across all shareholders in `pool`.\n    public fun total_shares(pool: &Pool): u64 {\n        pool.total_shares\n    }\n\n    /// Return true if `shareholder` is in `pool`.\n    public fun contains(pool: &Pool, shareholder: address): bool {\n        simple_map::contains_key(&pool.shares, &shareholder)\n    }\n\n    /// Return the number of shares of `stakeholder` in `pool`.\n    public fun shares(pool: &Pool, shareholder: address): u64 {\n        if (contains(pool, shareholder)) {\n            *simple_map::borrow(&pool.shares, &shareholder)\n        } else {\n            0\n        }\n    }\n\n    /// Return the balance in coins of `shareholder` in `pool.`\n    public fun balance(pool: &Pool, shareholder: address): u64 {\n        let num_shares = shares(pool, shareholder);\n        shares_to_amount(pool, num_shares)\n    }\n\n    /// Return the list of shareholders in `pool`.\n    public fun shareholders(pool: &Pool): vector<address> {\n        pool.shareholders\n    }\n\n    /// Return the number of shareholders in `pool`.\n    public fun shareholders_count(pool: &Pool): u64 {\n        vector::length(&pool.shareholders)\n    }\n\n    /// Update `pool`'s total balance of coins.\n    public fun update_total_coins(pool: &mut Pool, new_total_coins: u64) {\n        pool.total_coins = new_total_coins;\n    }\n\n    /// Allow an existing or new shareholder to add their coins to the pool in exchange for new shares.\n    public fun buy_in(pool: &mut Pool, shareholder: address, coins_amount: u64): u64 {\n        if (coins_amount == 0) return 0;\n\n        let new_shares = amount_to_shares(pool, coins_amount);\n        assert!(MAX_U64 - pool.total_coins >= coins_amount, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));\n        assert!(MAX_U64 - pool.total_shares >= new_shares, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));\n\n        pool.total_coins = pool.total_coins + coins_amount;\n        pool.total_shares = pool.total_shares + new_shares;\n        add_shares(pool, shareholder, new_shares);\n        new_shares\n    }\n\n    /// Add the number of shares directly for `shareholder` in `pool`.\n    /// This would dilute other shareholders if the pool's balance of coins didn't change.\n    fun add_shares(pool: &mut Pool, shareholder: address, new_shares: u64): u64 {\n        if (contains(pool, shareholder)) {\n            let existing_shares = simple_map::borrow_mut(&mut pool.shares, &shareholder);\n            let current_shares = *existing_shares;\n            assert!(MAX_U64 - current_shares >= new_shares, error::invalid_argument(ESHAREHOLDER_SHARES_OVERFLOW));\n\n            *existing_shares = current_shares + new_shares;\n            *existing_shares\n        } else if (new_shares > 0) {\n            assert!(\n                vector::length(&pool.shareholders) < pool.shareholders_limit,\n                error::invalid_state(ETOO_MANY_SHAREHOLDERS),\n            );\n\n            vector::push_back(&mut pool.shareholders, shareholder);\n            simple_map::add(&mut pool.shares, shareholder, new_shares);\n            new_shares\n        } else {\n            new_shares\n        }\n    }\n\n    /// Allow `shareholder` to redeem their shares in `pool` for coins.\n    public fun redeem_shares(pool: &mut Pool, shareholder: address, shares_to_redeem: u64): u64 {\n        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));\n        assert!(shares(pool, shareholder) >= shares_to_redeem, error::invalid_argument(EINSUFFICIENT_SHARES));\n\n        if (shares_to_redeem == 0) return 0;\n\n        let redeemed_coins = shares_to_amount(pool, shares_to_redeem);\n        pool.total_coins = pool.total_coins - redeemed_coins;\n        pool.total_shares = pool.total_shares - shares_to_redeem;\n        deduct_shares(pool, shareholder, shares_to_redeem);\n\n        redeemed_coins\n    }\n\n    /// Transfer shares from `shareholder_1` to `shareholder_2`.\n    public fun transfer_shares(\n        pool: &mut Pool,\n        shareholder_1: address,\n        shareholder_2: address,\n        shares_to_transfer: u64,\n    ) {\n        assert!(contains(pool, shareholder_1), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));\n        assert!(shares(pool, shareholder_1) >= shares_to_transfer, error::invalid_argument(EINSUFFICIENT_SHARES));\n        if (shares_to_transfer == 0) return;\n\n        deduct_shares(pool, shareholder_1, shares_to_transfer);\n        add_shares(pool, shareholder_2, shares_to_transfer);\n    }\n\n    /// Directly deduct `shareholder`'s number of shares in `pool` and return the number of remaining shares.\n    fun deduct_shares(pool: &mut Pool, shareholder: address, num_shares: u64): u64 {\n        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));\n        assert!(shares(pool, shareholder) >= num_shares, error::invalid_argument(EINSUFFICIENT_SHARES));\n\n        let existing_shares = simple_map::borrow_mut(&mut pool.shares, &shareholder);\n        *existing_shares = *existing_shares - num_shares;\n\n        // Remove the shareholder completely if they have no shares left.\n        let remaining_shares = *existing_shares;\n        if (remaining_shares == 0) {\n            let (_, shareholder_index) = vector::index_of(&pool.shareholders, &shareholder);\n            vector::remove(&mut pool.shareholders, shareholder_index);\n            simple_map::remove(&mut pool.shares, &shareholder);\n        };\n\n        remaining_shares\n    }\n\n    /// Return the number of new shares `coins_amount` can buy in `pool`.\n    /// `amount` needs to big enough to avoid rounding number.\n    public fun amount_to_shares(pool: &Pool, coins_amount: u64): u64 {\n        amount_to_shares_with_total_coins(pool, coins_amount, pool.total_coins)\n    }\n\n    /// Return the number of new shares `coins_amount` can buy in `pool` with a custom total coins number.\n    /// `amount` needs to big enough to avoid rounding number.\n    public fun amount_to_shares_with_total_coins(pool: &Pool, coins_amount: u64, total_coins: u64): u64 {\n        // No shares yet so amount is worth the same number of shares.\n        if (pool.total_coins == 0 || pool.total_shares == 0) {\n            // Multiply by scaling factor to minimize rounding errors during internal calculations for buy ins/redeems.\n            // This can overflow but scaling factor is expected to be chosen carefully so this would not overflow.\n            coins_amount * pool.scaling_factor\n        } else {\n            // Shares price = total_coins / total existing shares.\n            // New number of shares = new_amount / shares_price = new_amount * existing_shares / total_amount.\n            // We rearrange the calc and do multiplication first to avoid rounding errors.\n            multiply_then_divide(pool, coins_amount, pool.total_shares, total_coins)\n        }\n    }\n\n    /// Return the number of coins `shares` are worth in `pool`.\n    /// `shares` needs to big enough to avoid rounding number.\n    public fun shares_to_amount(pool: &Pool, shares: u64): u64 {\n        shares_to_amount_with_total_coins(pool, shares, pool.total_coins)\n    }\n\n    /// Return the number of coins `shares` are worth in `pool` with a custom total coins number.\n    /// `shares` needs to big enough to avoid rounding number.\n    public fun shares_to_amount_with_total_coins(pool: &Pool, shares: u64, total_coins: u64): u64 {\n        // No shares or coins yet so shares are worthless.\n        if (pool.total_coins == 0 || pool.total_shares == 0) {\n            0\n        } else {\n            // Shares price = total_coins / total existing shares.\n            // Shares worth = shares * shares price = shares * total_coins / total existing shares.\n            // We rearrange the calc and do multiplication first to avoid rounding errors.\n            multiply_then_divide(pool, shares, total_coins, pool.total_shares)\n        }\n    }\n\n    public fun multiply_then_divide(_pool: &Pool, x: u64, y: u64, z: u64): u64 {\n        let result = (to_u128(x) * to_u128(y)) / to_u128(z);\n        (result as u64)\n    }\n\n    fun to_u128(num: u64): u128 {\n        (num as u128)\n    }\n\n    #[test_only]\n    public fun destroy_pool(pool: Pool) {\n        let Pool {\n            shareholders_limit: _,\n            total_coins: _,\n            total_shares: _,\n            shares: _,\n            shareholders: _,\n            scaling_factor: _,\n        } = pool;\n    }\n\n    #[test]\n    public entry fun test_buy_in_and_redeem() {\n        let pool = new(5);\n\n        // Shareholders 1 and 2 buy in first.\n        buy_in(&mut pool, @1, 1000);\n        buy_in(&mut pool, @2, 2000);\n        assert!(shareholders_count(&pool) == 2, 0);\n        assert!(total_coins(&pool) == 3000, 1);\n        assert!(total_shares(&pool) == 3000, 2);\n        assert!(shares(&pool, @1) == 1000, 3);\n        assert!(shares(&pool, @2) == 2000, 4);\n        assert!(balance(&pool, @1) == 1000, 5);\n        assert!(balance(&pool, @2) == 2000, 6);\n\n        // Pool increases in value.\n        update_total_coins(&mut pool, 5000);\n        assert!(shares(&pool, @1) == 1000, 7);\n        assert!(shares(&pool, @2) == 2000, 8);\n        let expected_balance_1 = 1000 * 5000 / 3000;\n        assert!(balance(&pool, @1) == expected_balance_1, 9);\n        let expected_balance_2 = 2000 * 5000 / 3000;\n        assert!(balance(&pool, @2) == expected_balance_2, 10);\n\n        // Shareholder 3 buys in into the 5000-coin pool with 1000 coins. There are 3000 existing shares.\n        let expected_shares = 1000 * 3000 / 5000;\n        buy_in(&mut pool, @3, 1000);\n        assert!(shares(&pool, @3) == expected_shares, 11);\n        assert!(balance(&pool, @3) == 1000, 12);\n\n        // Pool increases more in value.\n        update_total_coins(&mut pool, 8000);\n\n        // Shareholders 1 and 2 redeem.\n        let all_shares = 3000 + expected_shares;\n        assert!(total_shares(&pool) == all_shares, 13);\n        let expected_value_per_500_shares = 500 * 8000 / all_shares;\n        assert!(redeem_shares(&mut pool, @1, 500) == expected_value_per_500_shares, 14);\n        assert!(redeem_shares(&mut pool, @1, 500) == expected_value_per_500_shares, 15);\n        assert!(redeem_shares(&mut pool, @2, 2000) == expected_value_per_500_shares * 4, 16);\n\n        // Due to a very small rounding error of 1, shareholder 3 actually has 1 more coin.\n        let shareholder_3_balance = expected_value_per_500_shares * 6 / 5 + 1;\n        assert!(balance(&pool, @3) == shareholder_3_balance, 17);\n        assert!(total_coins(&pool) == shareholder_3_balance, 18);\n        assert!(shareholders_count(&pool) == 1, 19);\n        let num_shares_3 = shares(&pool, @3);\n        assert!(redeem_shares(&mut pool, @3, num_shares_3) == shareholder_3_balance, 20);\n\n        // Nothing left.\n        assert!(shareholders_count(&pool) == 0, 21);\n        destroy_empty(pool);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 196611, location = Self)]\n    public entry fun test_destroy_empty_should_fail_if_not_empty() {\n        let pool = new(1);\n        update_total_coins(&mut pool, 100);\n        destroy_empty(pool);\n    }\n\n    #[test]\n    public entry fun test_buy_in_and_redeem_large_numbers() {\n        let pool = new(2);\n        let half_max_u64 = MAX_U64 / 2;\n        let shares_1 = buy_in(&mut pool, @1, half_max_u64);\n        assert!(shares_1 == half_max_u64, 0);\n        let shares_2 = buy_in(&mut pool, @2, half_max_u64 + 1);\n        assert!(shares_2 == half_max_u64 + 1, 1);\n        assert!(total_shares(&pool) == MAX_U64, 2);\n        assert!(total_coins(&pool) == MAX_U64, 3);\n        assert!(redeem_shares(&mut pool, @1, shares_1) == half_max_u64, 4);\n        assert!(redeem_shares(&mut pool, @2, shares_2) == half_max_u64 + 1, 5);\n        destroy_empty(pool);\n    }\n\n    #[test]\n    public entry fun test_buy_in_and_redeem_large_numbers_with_scaling_factor() {\n        let scaling_factor = 100;\n        let pool = create_with_scaling_factor(2, scaling_factor);\n        let coins_amount = MAX_U64 / 100;\n        let shares = buy_in(&mut pool, @1, coins_amount);\n        assert!(total_shares(&pool) == coins_amount * scaling_factor, 0);\n        assert!(total_coins(&pool) == coins_amount, 1);\n        assert!(redeem_shares(&mut pool, @1, shares) == coins_amount, 2);\n        destroy_empty(pool);\n    }\n\n    #[test]\n    public entry fun test_buy_in_zero_amount() {\n        let pool = new(2);\n        buy_in(&mut pool, @1, 100);\n        assert!(buy_in(&mut pool, @2, 0) == 0, 0);\n        assert!(total_shares(&pool) == shares(&pool, @1), 1);\n        assert!(shareholders_count(&pool) == 1, 2);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_buy_in_with_small_coins_amount() {\n        let pool = new(2);\n        // Shareholder 1 buys in with 1e17 coins.\n        buy_in(&mut pool, @1, 100000000000000000);\n        // Shareholder 2 buys in with a very small amount.\n        assert!(buy_in(&mut pool, @2, 1) == 1, 0);\n        // Pool's total coins increases by 20%. Shareholder 2 shouldn't see any actual balance increase as it gets\n        // rounded down.\n        let total_coins = total_coins(&pool);\n        update_total_coins(&mut pool, total_coins * 6 / 5);\n        // Minus 1 due to rounding error.\n        assert!(balance(&pool, @1) == 100000000000000000 * 6 / 5 - 1, 1);\n        assert!(balance(&pool, @2) == 1, 2);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_add_zero_shares_should_not_add_shareholder() {\n        let pool = new(1);\n        update_total_coins(&mut pool, 1000);\n        assert!(add_shares(&mut pool, @1, 0) == 0, 0);\n        assert!(shareholders_count(&pool) == 0, 1);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_add_zero_shares_returns_existing_number_of_shares() {\n        let pool = new(1);\n        update_total_coins(&mut pool, 1000);\n        add_shares(&mut pool, @1, 1);\n        assert!(shares(&pool, @1) == add_shares(&mut pool, @1, 0), 0);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_add_shares_existing_shareholder() {\n        let pool = new(1);\n        update_total_coins(&mut pool, 1000);\n        add_shares(&mut pool, @1, 1);\n        add_shares(&mut pool, @1, 2);\n        assert!(shares(&mut pool, @1) == 3, 0);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_add_shares_new_shareholder() {\n        let pool = new(2);\n        update_total_coins(&mut pool, 1000);\n        add_shares(&mut pool, @1, 1);\n        add_shares(&mut pool, @2, 2);\n        assert!(shares(&mut pool, @1) == 1, 0);\n        assert!(shares(&mut pool, @2) == 2, 1);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 196610, location = Self)]\n    public entry fun test_add_shares_should_enforce_shareholder_limit() {\n        let pool = new(2);\n        add_shares(&mut pool, @1, 1);\n        add_shares(&mut pool, @2, 2);\n        add_shares(&mut pool, @3, 2);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_add_shares_should_work_after_reducing_shareholders_below_limit() {\n        let pool = new(3);\n        add_shares(&mut pool, @1, 1);\n        add_shares(&mut pool, @2, 2);\n        deduct_shares(&mut pool, @2, 2);\n        add_shares(&mut pool, @3, 3);\n        assert!(shares(&pool, @3) == 3, 0);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 65537, location = Self)]\n    public entry fun test_redeem_shares_non_existent_shareholder() {\n        let pool = new(1);\n        add_shares(&mut pool, @1, 1);\n        redeem_shares(&mut pool, @2, 1);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 65540, location = Self)]\n    public entry fun test_redeem_shares_insufficient_shares() {\n        let pool = new(1);\n        add_shares(&mut pool, @1, 1);\n        redeem_shares(&mut pool, @1, 2);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_redeem_small_number_of_shares() {\n        let pool = new(2);\n        // 1e17 shares and coins.\n        buy_in(&mut pool, @1, 100000000000000000);\n        buy_in(&mut pool, @2, 100000000000000000);\n        assert!(redeem_shares(&mut pool, @1, 1) == 1, 0);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_redeem_zero_shares() {\n        let pool = new(2);\n        buy_in(&mut pool, @1, 1);\n        assert!(redeem_shares(&mut pool, @1, 0) == 0, 0);\n        assert!(shares(&pool, @1) == 1, 1);\n        assert!(total_coins(&pool) == 1, 2);\n        assert!(total_shares(&pool) == 1, 3);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 65537, location = Self)]\n    public entry fun test_deduct_shares_non_existent_shareholder() {\n        let pool = new(1);\n        add_shares(&mut pool, @1, 1);\n        deduct_shares(&mut pool, @2, 1);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 65540, location = Self)]\n    public entry fun test_deduct_shares_insufficient_shares() {\n        let pool = new(1);\n        add_shares(&mut pool, @1, 1);\n        deduct_shares(&mut pool, @1, 2);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_deduct_shares_remove_shareholder_with_no_shares() {\n        let pool = new(2);\n        add_shares(&mut pool, @1, 1);\n        add_shares(&mut pool, @2, 2);\n        assert!(shareholders_count(&pool) == 2, 0);\n        deduct_shares(&mut pool, @1, 1);\n        assert!(shareholders_count(&pool) == 1, 1);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_transfer_shares() {\n        let pool = new(2);\n        add_shares(&mut pool, @1, 2);\n        add_shares(&mut pool, @2, 2);\n        assert!(shareholders_count(&pool) == 2, 0);\n        transfer_shares(&mut pool, @1, @2, 1);\n        assert!(shares(&pool, @1) == 1, 0);\n        assert!(shares(&pool, @2) == 3, 0);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_amount_to_shares_empty_pool() {\n        let pool = new(1);\n        // No total shares and total coins.\n        assert!(amount_to_shares(&pool, 1000) == 1000, 0);\n\n        // No total shares but some total coins.\n        update_total_coins(&mut pool, 1000);\n        assert!(amount_to_shares(&pool, 1000) == 1000, 1);\n\n        // No total coins but some total shares.\n        update_total_coins(&mut pool, 0);\n        add_shares(&mut pool, @1, 100);\n        assert!(amount_to_shares(&pool, 1000) == 1000, 2);\n        destroy_pool(pool);\n    }\n\n    #[test]\n    public entry fun test_shares_to_amount_empty_pool() {\n        let pool = new(1);\n        // No total shares and total coins.\n        assert!(shares_to_amount(&pool, 1000) == 0, 0);\n\n        // No total shares but some total coins.\n        update_total_coins(&mut pool, 1000);\n        assert!(shares_to_amount(&pool, 1000) == 0, 1);\n\n        // No total coins but some total shares.\n        update_total_coins(&mut pool, 0);\n        add_shares(&mut pool, @1, 100);\n        assert!(shares_to_amount(&pool, 1000) == 0, 2);\n        destroy_pool(pool);\n    }\n}\n", "name": "pool_u64.move" }, { "content": "///\n/// Simple module for tracking and calculating shares of a pool of coins. The shares are worth more as the total coins in\n/// the pool increases. New shareholder can buy more shares or redeem their existing shares.\n///\n/// Example flow:\n/// 1. Pool start outs empty.\n/// 2. Shareholder A buys in with 1000 coins. A will receive 1000 shares in the pool. Pool now has 1000 total coins and\n/// 1000 total shares.\n/// 3. Pool appreciates in value from rewards and now has 2000 coins. A's 1000 shares are now worth 2000 coins.\n/// 4. Shareholder B now buys in with 1000 coins. Since before the buy in, each existing share is worth 2 coins, B will\n/// receive 500 shares in exchange for 1000 coins. Pool now has 1500 shares and 3000 coins.\n/// 5. Pool appreciates in value from rewards and now has 6000 coins.\n/// 6. A redeems 500 shares. Each share is worth 6000 / 1500 = 4. A receives 2000 coins. Pool has 4000 coins and 1000\n/// shares left.\n///\nmodule aptos_std::pool_u64_unbound {\n    use aptos_std::table_with_length::{Self as table, TableWithLength as Table};\n    use std::error;\n\n    /// Shareholder not present in pool.\n    const ESHAREHOLDER_NOT_FOUND: u64 = 1;\n    /// There are too many shareholders in the pool.\n    const ETOO_MANY_SHAREHOLDERS: u64 = 2;\n    /// Cannot destroy non-empty pool.\n    const EPOOL_IS_NOT_EMPTY: u64 = 3;\n    /// Cannot redeem more shares than the shareholder has in the pool.\n    const EINSUFFICIENT_SHARES: u64 = 4;\n    /// Shareholder cannot have more than u64.max shares.\n    const ESHAREHOLDER_SHARES_OVERFLOW: u64 = 5;\n    /// Pool's total coins cannot exceed u64.max.\n    const EPOOL_TOTAL_COINS_OVERFLOW: u64 = 6;\n    /// Pool's total shares cannot exceed u64.max.\n    const EPOOL_TOTAL_SHARES_OVERFLOW: u64 = 7;\n\n    const MAX_U64: u64 = 18446744073709551615;\n\n    const MAX_U128: u128 = 340282366920938463463374607431768211455;\n\n    struct Pool has store {\n        total_coins: u64,\n        total_shares: u128,\n        shares: Table<address, u128>,\n        // Default to 1. This can be used to minimize rounding errors when computing shares and coins amount.\n        // However, users need to make sure the coins amount don't overflow when multiplied by the scaling factor.\n        scaling_factor: u64,\n    }\n\n    /// Create a new pool.\n    public fun new(): Pool {\n        // Default to a scaling factor of 1 (effectively no scaling).\n        create_with_scaling_factor(1)\n    }\n\n    #[deprecated]\n    /// Deprecated. Use `new` instead.\n    /// Create a new pool.\n    public fun create(): Pool {\n        new()\n    }\n\n    /// Create a new pool with custom `scaling_factor`.\n    public fun create_with_scaling_factor(scaling_factor: u64): Pool {\n        Pool {\n            total_coins: 0,\n            total_shares: 0,\n            shares: table::new<address, u128>(),\n            scaling_factor,\n        }\n    }\n\n    /// Destroy an empty pool. This will fail if the pool has any balance of coins.\n    public fun destroy_empty(pool: Pool) {\n        assert!(pool.total_coins == 0, error::invalid_state(EPOOL_IS_NOT_EMPTY));\n        let Pool {\n            total_coins: _,\n            total_shares: _,\n            shares,\n            scaling_factor: _,\n        } = pool;\n        table::destroy_empty<address, u128>(shares);\n    }\n\n    /// Return `pool`'s total balance of coins.\n    public fun total_coins(pool: &Pool): u64 {\n        pool.total_coins\n    }\n\n    /// Return the total number of shares across all shareholders in `pool`.\n    public fun total_shares(pool: &Pool): u128 {\n        pool.total_shares\n    }\n\n    /// Return true if `shareholder` is in `pool`.\n    public fun contains(pool: &Pool, shareholder: address): bool {\n        table::contains(&pool.shares, shareholder)\n    }\n\n    /// Return the number of shares of `stakeholder` in `pool`.\n    public fun shares(pool: &Pool, shareholder: address): u128 {\n        if (contains(pool, shareholder)) {\n            *table::borrow(&pool.shares, shareholder)\n        } else {\n            0\n        }\n    }\n\n    /// Return the balance in coins of `shareholder` in `pool.`\n    public fun balance(pool: &Pool, shareholder: address): u64 {\n        let num_shares = shares(pool, shareholder);\n        shares_to_amount(pool, num_shares)\n    }\n\n    /// Return the number of shareholders in `pool`.\n    public fun shareholders_count(pool: &Pool): u64 {\n        table::length(&pool.shares)\n    }\n\n    /// Update `pool`'s total balance of coins.\n    public fun update_total_coins(pool: &mut Pool, new_total_coins: u64) {\n        pool.total_coins = new_total_coins;\n    }\n\n    /// Allow an existing or new shareholder to add their coins to the pool in exchange for new shares.\n    public fun buy_in(pool: &mut Pool, shareholder: address, coins_amount: u64): u128 {\n        if (coins_amount == 0) return 0;\n\n        let new_shares = amount_to_shares(pool, coins_amount);\n        assert!(MAX_U64 - pool.total_coins >= coins_amount, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));\n        assert!(MAX_U128 - pool.total_shares >= new_shares, error::invalid_argument(EPOOL_TOTAL_SHARES_OVERFLOW));\n\n        pool.total_coins = pool.total_coins + coins_amount;\n        pool.total_shares = pool.total_shares + new_shares;\n        add_shares(pool, shareholder, new_shares);\n        new_shares\n    }\n\n    /// Add the number of shares directly for `shareholder` in `pool`.\n    /// This would dilute other shareholders if the pool's balance of coins didn't change.\n    fun add_shares(pool: &mut Pool, shareholder: address, new_shares: u128): u128 {\n        if (contains(pool, shareholder)) {\n            let existing_shares = table::borrow_mut(&mut pool.shares, shareholder);\n            let current_shares = *existing_shares;\n            assert!(MAX_U128 - current_shares >= new_shares, error::invalid_argument(ESHAREHOLDER_SHARES_OVERFLOW));\n\n            *existing_shares = current_shares + new_shares;\n            *existing_shares\n        } else if (new_shares > 0) {\n            table::add(&mut pool.shares, shareholder, new_shares);\n            new_shares\n        } else {\n            new_shares\n        }\n    }\n\n    /// Allow `shareholder` to redeem their shares in `pool` for coins.\n    public fun redeem_shares(pool: &mut Pool, shareholder: address, shares_to_redeem: u128): u64 {\n        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));\n        assert!(shares(pool, shareholder) >= shares_to_redeem, error::invalid_argument(EINSUFFICIENT_SHARES));\n\n        if (shares_to_redeem == 0) return 0;\n\n        let redeemed_coins = shares_to_amount(pool, shares_to_redeem);\n        pool.total_coins = pool.total_coins - redeemed_coins;\n        pool.total_shares = pool.total_shares - shares_to_redeem;\n        deduct_shares(pool, shareholder, shares_to_redeem);\n\n        redeemed_coins\n    }\n\n    /// Transfer shares from `shareholder_1` to `shareholder_2`.\n    public fun transfer_shares(\n        pool: &mut Pool,\n        shareholder_1: address,\n        shareholder_2: address,\n        shares_to_transfer: u128,\n    ) {\n        assert!(contains(pool, shareholder_1), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));\n        assert!(shares(pool, shareholder_1) >= shares_to_transfer, error::invalid_argument(EINSUFFICIENT_SHARES));\n        if (shares_to_transfer == 0) return;\n\n        deduct_shares(pool, shareholder_1, shares_to_transfer);\n        add_shares(pool, shareholder_2, shares_to_transfer);\n    }\n\n    /// Directly deduct `shareholder`'s number of shares in `pool` and return the number of remaining shares.\n    fun deduct_shares(pool: &mut Pool, shareholder: address, num_shares: u128): u128 {\n        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));\n        assert!(shares(pool, shareholder) >= num_shares, error::invalid_argument(EINSUFFICIENT_SHARES));\n\n        let existing_shares = table::borrow_mut(&mut pool.shares, shareholder);\n        *existing_shares = *existing_shares - num_shares;\n\n        // Remove the shareholder completely if they have no shares left.\n        let remaining_shares = *existing_shares;\n        if (remaining_shares == 0) {\n            table::remove(&mut pool.shares, shareholder);\n        };\n\n        remaining_shares\n    }\n\n    /// Return the number of new shares `coins_amount` can buy in `pool`.\n    /// `amount` needs to big enough to avoid rounding number.\n    public fun amount_to_shares(pool: &Pool, coins_amount: u64): u128 {\n        amount_to_shares_with_total_coins(pool, coins_amount, pool.total_coins)\n    }\n\n    /// Return the number of new shares `coins_amount` can buy in `pool` with a custom total coins number.\n    /// `amount` needs to big enough to avoid rounding number.\n    public fun amount_to_shares_with_total_coins(pool: &Pool, coins_amount: u64, total_coins: u64): u128 {\n        // No shares yet so amount is worth the same number of shares.\n        if (pool.total_coins == 0 || pool.total_shares == 0) {\n            // Multiply by scaling factor to minimize rounding errors during internal calculations for buy ins/redeems.\n            // This can overflow but scaling factor is expected to be chosen carefully so this would not overflow.\n            to_u128(coins_amount) * to_u128(pool.scaling_factor)\n        } else {\n            // Shares price = total_coins / total existing shares.\n            // New number of shares = new_amount / shares_price = new_amount * existing_shares / total_amount.\n            // We rearrange the calc and do multiplication first to avoid rounding errors.\n            multiply_then_divide(pool, to_u128(coins_amount), pool.total_shares, to_u128(total_coins))\n        }\n    }\n\n    /// Return the number of coins `shares` are worth in `pool`.\n    /// `shares` needs to big enough to avoid rounding number.\n    public fun shares_to_amount(pool: &Pool, shares: u128): u64 {\n        shares_to_amount_with_total_coins(pool, shares, pool.total_coins)\n    }\n\n    /// Return the number of coins `shares` are worth in `pool` with a custom total coins number.\n    /// `shares` needs to big enough to avoid rounding number.\n    public fun shares_to_amount_with_total_coins(pool: &Pool, shares: u128, total_coins: u64): u64 {\n        // No shares or coins yet so shares are worthless.\n        if (pool.total_coins == 0 || pool.total_shares == 0) {\n            0\n        } else {\n            // Shares price = total_coins / total existing shares.\n            // Shares worth = shares * shares price = shares * total_coins / total existing shares.\n            // We rearrange the calc and do multiplication first to avoid rounding errors.\n            (multiply_then_divide(pool, shares, to_u128(total_coins), pool.total_shares) as u64)\n        }\n    }\n\n    /// Return the number of coins `shares` are worth in `pool` with custom total coins and shares numbers.\n    public fun shares_to_amount_with_total_stats(\n        pool: &Pool,\n        shares: u128,\n        total_coins: u64,\n        total_shares: u128,\n    ): u64 {\n        if (pool.total_coins == 0 || total_shares == 0) {\n            0\n        } else {\n            (multiply_then_divide(pool, shares, to_u128(total_coins), total_shares) as u64)\n        }\n    }\n\n    public fun multiply_then_divide(_pool: &Pool, x: u128, y: u128, z: u128): u128 {\n        let result = (to_u256(x) * to_u256(y)) / to_u256(z);\n        (result as u128)\n    }\n\n    fun to_u128(num: u64): u128 {\n        (num as u128)\n    }\n\n    fun to_u256(num: u128): u256 {\n        (num as u256)\n    }\n}\n", "name": "pool_u64_unbound.move" }, { "content": "/// This module provides a solution for unsorted maps, that is it has the properties that\n/// 1) Keys point to Values\n/// 2) Each Key must be unique\n/// 3) A Key can be found within O(N) time\n/// 4) The keys are unsorted.\n/// 5) Adds and removals take O(N) time\nmodule aptos_std::simple_map {\n    use std::error;\n    use std::option;\n    use std::vector;\n\n    /// Map key already exists\n    const EKEY_ALREADY_EXISTS: u64 = 1;\n    /// Map key is not found\n    const EKEY_NOT_FOUND: u64 = 2;\n\n    struct SimpleMap<Key, Value> has copy, drop, store {\n        data: vector<Element<Key, Value>>,\n    }\n\n    struct Element<Key, Value> has copy, drop, store {\n        key: Key,\n        value: Value,\n    }\n\n    public fun length<Key: store, Value: store>(map: &SimpleMap<Key, Value>): u64 {\n        vector::length(&map.data)\n    }\n\n    /// Create an empty SimpleMap.\n    public fun new<Key: store, Value: store>(): SimpleMap<Key, Value> {\n        SimpleMap {\n            data: vector::empty(),\n        }\n    }\n\n    /// Create a SimpleMap from a vector of keys and values. The keys must be unique.\n    public fun new_from<Key: store, Value: store>(\n        keys: vector<Key>,\n        values: vector<Value>,\n    ): SimpleMap<Key, Value> {\n        let map = new();\n        add_all(&mut map, keys, values);\n        map\n    }\n\n    #[deprecated]\n    /// Create an empty SimpleMap.\n    /// This function is deprecated, use `new` instead.\n    public fun create<Key: store, Value: store>(): SimpleMap<Key, Value> {\n        new()\n    }\n\n    public fun borrow<Key: store, Value: store>(\n        map: &SimpleMap<Key, Value>,\n        key: &Key,\n    ): &Value {\n        let maybe_idx = find(map, key);\n        assert!(option::is_some(&maybe_idx), error::invalid_argument(EKEY_NOT_FOUND));\n        let idx = option::extract(&mut maybe_idx);\n        &vector::borrow(&map.data, idx).value\n    }\n\n    public fun borrow_mut<Key: store, Value: store>(\n        map: &mut SimpleMap<Key, Value>,\n        key: &Key,\n    ): &mut Value {\n        let maybe_idx = find(map, key);\n        assert!(option::is_some(&maybe_idx), error::invalid_argument(EKEY_NOT_FOUND));\n        let idx = option::extract(&mut maybe_idx);\n        &mut vector::borrow_mut(&mut map.data, idx).value\n    }\n\n    public fun contains_key<Key: store, Value: store>(\n        map: &SimpleMap<Key, Value>,\n        key: &Key,\n    ): bool {\n        let maybe_idx = find(map, key);\n        option::is_some(&maybe_idx)\n    }\n\n    public fun destroy_empty<Key: store, Value: store>(map: SimpleMap<Key, Value>) {\n        let SimpleMap { data } = map;\n        vector::destroy_empty(data);\n    }\n\n    /// Add a key/value pair to the map. The key must not already exist.\n    public fun add<Key: store, Value: store>(\n        map: &mut SimpleMap<Key, Value>,\n        key: Key,\n        value: Value,\n    ) {\n        let maybe_idx = find(map, &key);\n        assert!(option::is_none(&maybe_idx), error::invalid_argument(EKEY_ALREADY_EXISTS));\n\n        vector::push_back(&mut map.data, Element { key, value });\n    }\n\n    /// Add multiple key/value pairs to the map. The keys must not already exist.\n    public fun add_all<Key: store, Value: store>(\n        map: &mut SimpleMap<Key, Value>,\n        keys: vector<Key>,\n        values: vector<Value>,\n    ) {\n        vector::zip(keys, values, |key, value| {\n            add(map, key, value);\n        });\n    }\n\n    /// Insert key/value pair or update an existing key to a new value\n    public fun upsert<Key: store, Value: store>(\n        map: &mut SimpleMap<Key, Value>,\n        key: Key,\n        value: Value\n    ): (std::option::Option<Key>, std::option::Option<Value>) {\n        let data = &mut map.data;\n        let len = vector::length(data);\n        let i = 0;\n        while (i < len) {\n            let element = vector::borrow(data, i);\n            if (&element.key == &key) {\n                vector::push_back(data, Element { key, value });\n                vector::swap(data, i, len);\n                let Element { key, value } = vector::pop_back(data);\n                return (std::option::some(key), std::option::some(value))\n            };\n            i = i + 1;\n        };\n        vector::push_back(&mut map.data, Element { key, value });\n        (std::option::none(), std::option::none())\n    }\n\n    /// Return all keys in the map. This requires keys to be copyable.\n    public fun keys<Key: copy, Value>(map: &SimpleMap<Key, Value>): vector<Key> {\n        vector::map_ref(&map.data, |e| {\n            let e: &Element<Key, Value> = e;\n            e.key\n        })\n    }\n\n    /// Return all values in the map. This requires values to be copyable.\n    public fun values<Key, Value: copy>(map: &SimpleMap<Key, Value>): vector<Value> {\n        vector::map_ref(&map.data, |e| {\n            let e: &Element<Key, Value> = e;\n            e.value\n        })\n    }\n\n    /// Transform the map into two vectors with the keys and values respectively\n    /// Primarily used to destroy a map\n    public fun to_vec_pair<Key: store, Value: store>(\n        map: SimpleMap<Key, Value>): (vector<Key>, vector<Value>) {\n        let keys: vector<Key> = vector::empty();\n        let values: vector<Value> = vector::empty();\n        let SimpleMap { data } = map;\n        vector::for_each(data, |e| {\n            let Element { key, value } = e;\n            vector::push_back(&mut keys, key);\n            vector::push_back(&mut values, value);\n        });\n        (keys, values)\n    }\n\n    /// For maps that cannot be dropped this is a utility to destroy them\n    /// using lambdas to destroy the individual keys and values.\n    public inline fun destroy<Key: store, Value: store>(\n        map: SimpleMap<Key, Value>,\n        dk: |Key|,\n        dv: |Value|\n    ) {\n        let (keys, values) = to_vec_pair(map);\n        vector::destroy(keys, |_k| dk(_k));\n        vector::destroy(values, |_v| dv(_v));\n    }\n\n    /// Remove a key/value pair from the map. The key must exist.\n    public fun remove<Key: store, Value: store>(\n        map: &mut SimpleMap<Key, Value>,\n        key: &Key,\n    ): (Key, Value) {\n        let maybe_idx = find(map, key);\n        assert!(option::is_some(&maybe_idx), error::invalid_argument(EKEY_NOT_FOUND));\n        let placement = option::extract(&mut maybe_idx);\n        let Element { key, value } = vector::swap_remove(&mut map.data, placement);\n        (key, value)\n    }\n\n    fun find<Key: store, Value: store>(\n        map: &SimpleMap<Key, Value>,\n        key: &Key,\n    ): option::Option<u64> {\n        let leng = vector::length(&map.data);\n        let i = 0;\n        while (i < leng) {\n            let element = vector::borrow(&map.data, i);\n            if (&element.key == key) {\n                return option::some(i)\n            };\n            i = i + 1;\n        };\n        option::none<u64>()\n    }\n\n    #[test]\n    public fun test_add_remove_many() {\n        let map = create<u64, u64>();\n\n        assert!(length(&map) == 0, 0);\n        assert!(!contains_key(&map, &3), 1);\n        add(&mut map, 3, 1);\n        assert!(length(&map) == 1, 2);\n        assert!(contains_key(&map, &3), 3);\n        assert!(borrow(&map, &3) == &1, 4);\n        *borrow_mut(&mut map, &3) = 2;\n        assert!(borrow(&map, &3) == &2, 5);\n\n        assert!(!contains_key(&map, &2), 6);\n        add(&mut map, 2, 5);\n        assert!(length(&map) == 2, 7);\n        assert!(contains_key(&map, &2), 8);\n        assert!(borrow(&map, &2) == &5, 9);\n        *borrow_mut(&mut map, &2) = 9;\n        assert!(borrow(&map, &2) == &9, 10);\n\n        remove(&mut map, &2);\n        assert!(length(&map) == 1, 11);\n        assert!(!contains_key(&map, &2), 12);\n        assert!(borrow(&map, &3) == &2, 13);\n\n        remove(&mut map, &3);\n        assert!(length(&map) == 0, 14);\n        assert!(!contains_key(&map, &3), 15);\n\n        destroy_empty(map);\n    }\n\n    #[test]\n    public fun test_add_all() {\n        let map = create<u64, u64>();\n\n        assert!(length(&map) == 0, 0);\n        add_all(&mut map, vector[1, 2, 3], vector[10, 20, 30]);\n        assert!(length(&map) == 3, 1);\n        assert!(borrow(&map, &1) == &10, 2);\n        assert!(borrow(&map, &2) == &20, 3);\n        assert!(borrow(&map, &3) == &30, 4);\n\n        remove(&mut map, &1);\n        remove(&mut map, &2);\n        remove(&mut map, &3);\n        destroy_empty(map);\n    }\n\n    #[test]\n    public fun test_keys() {\n        let map = create<u64, u64>();\n        assert!(keys(&map) == vector[], 0);\n        add(&mut map, 2, 1);\n        add(&mut map, 3, 1);\n\n        assert!(keys(&map) == vector[2, 3], 0);\n    }\n\n    #[test]\n    public fun test_values() {\n        let map = create<u64, u64>();\n        assert!(values(&map) == vector[], 0);\n        add(&mut map, 2, 1);\n        add(&mut map, 3, 2);\n\n        assert!(values(&map) == vector[1, 2], 0);\n    }\n\n    #[test]\n    #[expected_failure]\n    public fun test_add_twice() {\n        let map = create<u64, u64>();\n        add(&mut map, 3, 1);\n        add(&mut map, 3, 1);\n\n        remove(&mut map, &3);\n        destroy_empty(map);\n    }\n\n    #[test]\n    #[expected_failure]\n    public fun test_remove_twice() {\n        let map = create<u64, u64>();\n        add(&mut map, 3, 1);\n        remove(&mut map, &3);\n        remove(&mut map, &3);\n\n        destroy_empty(map);\n    }\n\n    #[test]\n    public fun test_upsert_test() {\n        let map = create<u64, u64>();\n        // test adding 3 elements using upsert\n        upsert<u64, u64>(&mut map, 1, 1);\n        upsert(&mut map, 2, 2);\n        upsert(&mut map, 3, 3);\n\n        assert!(length(&map) == 3, 0);\n        assert!(contains_key(&map, &1), 1);\n        assert!(contains_key(&map, &2), 2);\n        assert!(contains_key(&map, &3), 3);\n        assert!(borrow(&map, &1) == &1, 4);\n        assert!(borrow(&map, &2) == &2, 5);\n        assert!(borrow(&map, &3) == &3, 6);\n\n        // change mapping 1->1 to 1->4\n        upsert(&mut map, 1, 4);\n\n        assert!(length(&map) == 3, 7);\n        assert!(contains_key(&map, &1), 8);\n        assert!(borrow(&map, &1) == &4, 9);\n    }\n}\n", "name": "simple_map.move" }, { "content": '/// A module for formatting move values as strings.\nmodule aptos_std::string_utils {\n    use std::string::String;\n\n    /// The number of values in the list does not match the number of "{}" in the format string.\n    const EARGS_MISMATCH: u64 = 1;\n    /// The format string is not valid.\n    const EINVALID_FORMAT: u64 = 2;\n    /// Formatting is not possible because the value contains delayed fields such as aggregators.\n    const EUNABLE_TO_FORMAT_DELAYED_FIELD: u64 = 3;\n\n    /// Format a move value as a human readable string,\n    /// eg. `to_string(&1u64) == "1"`, `to_string(&false) == "false"`, `to_string(&@0x1) == "@0x1"`.\n    /// For vectors and structs the format is similar to rust, eg.\n    /// `to_string(&cons(1,2)) == "Cons { car: 1, cdr: 2 }"` and `to_string(&vector[1, 2, 3]) == "[ 1, 2, 3 ]"`\n    /// For vectors of u8 the output is hex encoded, eg. `to_string(&vector[1u8, 2u8, 3u8]) == "0x010203"`\n    /// For std::string::String the output is the string itself including quotes, eg.\n    /// `to_string(&std::string::utf8(b"My string")) == "\\"My string\\""`\n    public fun to_string<T>(s: &T): String {\n        native_format(s, false, false, true, false)\n    }\n\n    /// Format addresses as 64 zero-padded hexadecimals.\n    public fun to_string_with_canonical_addresses<T>(s: &T): String {\n        native_format(s, false, true, true, false)\n    }\n\n    /// Format emitting integers with types ie. 6u8 or 128u32.\n    public fun to_string_with_integer_types<T>(s: &T): String {\n        native_format(s, false, true, true, false)\n    }\n\n    /// Format vectors and structs with newlines and indentation.\n    public fun debug_string<T>(s: &T): String {\n        native_format(s, true, false, false, false)\n    }\n\n    /// Formatting with a rust-like format string, eg. `format2(&b"a = {}, b = {}", 1, 2) == "a = 1, b = 2"`.\n    public fun format1<T0: drop>(fmt: &vector<u8>, a: T0): String {\n        native_format_list(fmt, &list1(a))\n    }\n    public fun format2<T0: drop, T1: drop>(fmt: &vector<u8>, a: T0, b: T1): String {\n        native_format_list(fmt, &list2(a, b))\n    }\n    public fun format3<T0: drop, T1: drop, T2: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2): String {\n        native_format_list(fmt, &list3(a, b, c))\n    }\n    public fun format4<T0: drop, T1: drop, T2: drop, T3: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2, d: T3): String {\n        native_format_list(fmt, &list4(a, b, c, d))\n    }\n\n    // Helper struct to allow passing a generic heterogeneous list of values to native_format_list.\n    struct Cons<T, N> has copy, drop, store {\n        car: T,\n        cdr: N,\n    }\n\n    struct NIL has copy, drop, store {}\n\n    // Create a pair of values.\n    fun cons<T, N>(car: T, cdr: N): Cons<T, N> { Cons { car, cdr } }\n\n    // Create a nil value.\n    fun nil(): NIL { NIL {} }\n\n    // Create a list of values.\n    inline fun list1<T0>(a: T0): Cons<T0, NIL> { cons(a, nil()) }\n    inline fun list2<T0, T1>(a: T0, b: T1): Cons<T0, Cons<T1, NIL>> { cons(a, list1(b)) }\n    inline fun list3<T0, T1, T2>(a: T0, b: T1, c: T2): Cons<T0, Cons<T1, Cons<T2, NIL>>> { cons(a, list2(b, c)) }\n    inline fun list4<T0, T1, T2, T3>(a: T0, b: T1, c: T2, d: T3): Cons<T0, Cons<T1, Cons<T2, Cons<T3, NIL>>>> { cons(a, list3(b, c, d)) }\n\n    // Native functions\n    native fun native_format<T>(s: &T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): String;\n    native fun native_format_list<T>(fmt: &vector<u8>, val: &T): String;\n\n    #[test]\n    fun test_format() {\n        assert!(to_string(&1u64) == std::string::utf8(b"1"), 1);\n        assert!(to_string(&false) == std::string::utf8(b"false"), 2);\n        assert!(to_string(&1u256) == std::string::utf8(b"1"), 3);\n        assert!(to_string(&vector[1, 2, 3]) == std::string::utf8(b"[ 1, 2, 3 ]"), 4);\n        assert!(to_string(&cons(std::string::utf8(b"My string"),2)) == std::string::utf8(b"Cons { car: \\"My string\\", cdr: 2 }"), 5);\n        assert!(to_string(&std::option::none<u64>()) == std::string::utf8(b"None"), 6);\n        assert!(to_string(&std::option::some(1)) == std::string::utf8(b"Some(1)"), 7);\n    }\n\n    #[test]\n    fun test_format_list() {\n        let s = format3(&b"a = {} b = {} c = {}", 1, 2, std::string::utf8(b"My string"));\n        assert!(s == std::string::utf8(b"a = 1 b = 2 c = \\"My string\\""), 1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EARGS_MISMATCH)]\n    fun test_format_list_to_many_vals() {\n        format4(&b"a = {} b = {} c = {}", 1, 2, 3, 4);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EARGS_MISMATCH)]\n    fun test_format_list_not_enough_vals() {\n        format2(&b"a = {} b = {} c = {}", 1, 2);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EARGS_MISMATCH)]\n    fun test_format_list_not_valid_nil() {\n        let l = cons(1, cons(2, cons(3, 4)));\n        native_format_list(&b"a = {} b = {} c = {}", &l);\n    }\n\n    /// #[test_only]\n    struct FakeCons<T, N> has copy, drop, store {\n        car: T,\n        cdr: N,\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EARGS_MISMATCH)]\n    fun test_format_list_not_valid_list() {\n        let l = cons(1, FakeCons { car: 2, cdr: cons(3, nil())});\n        native_format_list(&b"a = {} b = {} c = {}", &l);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EINVALID_FORMAT)]\n    fun test_format_unclosed_braces() {\n        format3(&b"a = {} b = {} c = {", 1, 2 ,3);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EINVALID_FORMAT)]\n    fun test_format_unclosed_braces_2() {\n        format3(&b"a = {} b = { c = {}", 1, 2, 3);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = EINVALID_FORMAT)]\n    fun test_format_unopened_braces() {\n        format3(&b"a = } b = {} c = {}", 1, 2, 3);\n    }\n\n    #[test]\n    fun test_format_escape_braces_works() {\n        let s = format3(&b"{{a = {} b = {} c = {}}}", 1, 2, 3);\n        assert!(s == std::string::utf8(b"{a = 1 b = 2 c = 3}"), 1);\n    }\n}\n', "name": "string_utils.move" }, { "content": "/// Type of large-scale storage tables.\n/// source: https://github.com/move-language/move/blob/1b6b7513dcc1a5c866f178ca5c1e74beb2ce181e/language/extensions/move-table-extension/sources/Table.move#L1\n///\n/// It implements the Table type which supports individual table items to be represented by\n/// separate global state items. The number of items and a unique handle are tracked on the table\n/// struct itself, while the operations are implemented as native functions. No traversal is provided.\n\nmodule aptos_std::table {\n    friend aptos_std::table_with_length;\n\n    /// Type of tables\n    struct Table<phantom K: copy + drop, phantom V> has store {\n        handle: address,\n    }\n\n    /// Create a new Table.\n    public fun new<K: copy + drop, V: store>(): Table<K, V> {\n        Table {\n            handle: new_table_handle<K, V>(),\n        }\n    }\n\n    /// Add a new entry to the table. Aborts if an entry for this\n    /// key already exists. The entry itself is not stored in the\n    /// table, and cannot be discovered from it.\n    public fun add<K: copy + drop, V>(table: &mut Table<K, V>, key: K, val: V) {\n        add_box<K, V, Box<V>>(table, key, Box { val })\n    }\n\n    /// Acquire an immutable reference to the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun borrow<K: copy + drop, V>(table: &Table<K, V>, key: K): &V {\n        &borrow_box<K, V, Box<V>>(table, key).val\n    }\n\n    /// Acquire an immutable reference to the value which `key` maps to.\n    /// Returns specified default value if there is no entry for `key`.\n    public fun borrow_with_default<K: copy + drop, V>(table: &Table<K, V>, key: K, default: &V): &V {\n        if (!contains(table, copy key)) {\n            default\n        } else {\n            borrow(table, copy key)\n        }\n    }\n\n    /// Acquire a mutable reference to the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun borrow_mut<K: copy + drop, V>(table: &mut Table<K, V>, key: K): &mut V {\n        &mut borrow_box_mut<K, V, Box<V>>(table, key).val\n    }\n\n    /// Acquire a mutable reference to the value which `key` maps to.\n    /// Insert the pair (`key`, `default`) first if there is no entry for `key`.\n    public fun borrow_mut_with_default<K: copy + drop, V: drop>(table: &mut Table<K, V>, key: K, default: V): &mut V {\n        if (!contains(table, copy key)) {\n            add(table, copy key, default)\n        };\n        borrow_mut(table, key)\n    }\n\n    /// Insert the pair (`key`, `value`) if there is no entry for `key`.\n    /// update the value of the entry for `key` to `value` otherwise\n    public fun upsert<K: copy + drop, V: drop>(table: &mut Table<K, V>, key: K, value: V) {\n        if (!contains(table, copy key)) {\n            add(table, copy key, value)\n        } else {\n            let ref = borrow_mut(table, key);\n            *ref = value;\n        };\n    }\n\n    /// Remove from `table` and return the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun remove<K: copy + drop, V>(table: &mut Table<K, V>, key: K): V {\n        let Box { val } = remove_box<K, V, Box<V>>(table, key);\n        val\n    }\n\n    /// Returns true iff `table` contains an entry for `key`.\n    public fun contains<K: copy + drop, V>(table: &Table<K, V>, key: K): bool {\n        contains_box<K, V, Box<V>>(table, key)\n    }\n\n    #[test_only]\n    /// Testing only: allows to drop a table even if it is not empty.\n    public fun drop_unchecked<K: copy + drop, V>(table: Table<K, V>) {\n        drop_unchecked_box<K, V, Box<V>>(table)\n    }\n\n    public(friend) fun destroy<K: copy + drop, V>(table: Table<K, V>) {\n        destroy_empty_box<K, V, Box<V>>(&table);\n        drop_unchecked_box<K, V, Box<V>>(table)\n    }\n\n    #[test_only]\n    struct TableHolder<phantom K: copy + drop, phantom V: drop> has key {\n        t: Table<K, V>\n    }\n\n    #[test(account = @0x1)]\n    fun test_upsert(account: signer) {\n        let t = new<u64, u8>();\n        let key: u64 = 111;\n        let error_code: u64 = 1;\n        assert!(!contains(&t, key), error_code);\n        upsert(&mut t, key, 12);\n        assert!(*borrow(&t, key) == 12, error_code);\n        upsert(&mut t, key, 23);\n        assert!(*borrow(&t, key) == 23, error_code);\n\n        move_to(&account, TableHolder { t });\n    }\n\n    #[test(account = @0x1)]\n    fun test_borrow_with_default(account: signer) {\n        let t = new<u64, u8>();\n        let key: u64 = 100;\n        let error_code: u64 = 1;\n        assert!(!contains(&t, key), error_code);\n        assert!(*borrow_with_default(&t, key, &12) == 12, error_code);\n        add(&mut t, key, 1);\n        assert!(*borrow_with_default(&t, key, &12) == 1, error_code);\n\n        move_to(&account, TableHolder{ t });\n    }\n\n    // ======================================================================================================\n    // Internal API\n\n    /// Wrapper for values. Required for making values appear as resources in the implementation.\n    struct Box<V> has key, drop, store {\n        val: V\n    }\n\n    // Primitives which take as an additional type parameter `Box<V>`, so the implementation\n    // can use this to determine serialization layout.\n    native fun new_table_handle<K, V>(): address;\n\n    native fun add_box<K: copy + drop, V, B>(table: &mut Table<K, V>, key: K, val: Box<V>);\n\n    native fun borrow_box<K: copy + drop, V, B>(table: &Table<K, V>, key: K): &Box<V>;\n\n    native fun borrow_box_mut<K: copy + drop, V, B>(table: &mut Table<K, V>, key: K): &mut Box<V>;\n\n    native fun contains_box<K: copy + drop, V, B>(table: &Table<K, V>, key: K): bool;\n\n    native fun remove_box<K: copy + drop, V, B>(table: &mut Table<K, V>, key: K): Box<V>;\n\n    native fun destroy_empty_box<K: copy + drop, V, B>(table: &Table<K, V>);\n\n    native fun drop_unchecked_box<K: copy + drop, V, B>(table: Table<K, V>);\n}\n", "name": "table.move" }, { "content": "/// Extends Table and provides functions such as length and the ability to be destroyed\n\nmodule aptos_std::table_with_length {\n    use std::error;\n    use aptos_std::table::{Self, Table};\n\n    // native code raises this with error::invalid_arguments()\n    const EALREADY_EXISTS: u64 = 100;\n    // native code raises this with error::invalid_arguments()\n    const ENOT_FOUND: u64 = 101;\n    const ENOT_EMPTY: u64 = 102;\n\n    /// Type of tables\n    struct TableWithLength<phantom K: copy + drop, phantom V> has store {\n        inner: Table<K, V>,\n        length: u64,\n    }\n\n    /// Create a new Table.\n    public fun new<K: copy + drop, V: store>(): TableWithLength<K, V> {\n        TableWithLength {\n            inner: table::new<K, V>(),\n            length: 0,\n        }\n    }\n\n    /// Destroy a table. The table must be empty to succeed.\n    public fun destroy_empty<K: copy + drop, V>(table: TableWithLength<K, V>) {\n        assert!(table.length == 0, error::invalid_state(ENOT_EMPTY));\n        let TableWithLength { inner, length: _ } = table;\n        table::destroy(inner)\n    }\n\n    /// Add a new entry to the table. Aborts if an entry for this\n    /// key already exists. The entry itself is not stored in the\n    /// table, and cannot be discovered from it.\n    public fun add<K: copy + drop, V>(table: &mut TableWithLength<K, V>, key: K, val: V) {\n        table::add(&mut table.inner, key, val);\n        table.length = table.length + 1;\n    }\n\n    /// Acquire an immutable reference to the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun borrow<K: copy + drop, V>(table: &TableWithLength<K, V>, key: K): &V {\n        table::borrow(&table.inner, key)\n    }\n\n    /// Acquire a mutable reference to the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun borrow_mut<K: copy + drop, V>(table: &mut TableWithLength<K, V>, key: K): &mut V {\n        table::borrow_mut(&mut table.inner, key)\n    }\n\n    /// Returns the length of the table, i.e. the number of entries.\n    public fun length<K: copy + drop, V>(table: &TableWithLength<K, V>): u64 {\n        table.length\n    }\n\n    /// Returns true if this table is empty.\n    public fun empty<K: copy + drop, V>(table: &TableWithLength<K, V>): bool {\n        table.length == 0\n    }\n\n    /// Acquire a mutable reference to the value which `key` maps to.\n    /// Insert the pair (`key`, `default`) first if there is no entry for `key`.\n    public fun borrow_mut_with_default<K: copy + drop, V: drop>(table: &mut TableWithLength<K, V>, key: K, default: V): &mut V {\n        if (table::contains(&table.inner, key)) {\n            table::borrow_mut(&mut table.inner, key)\n        } else {\n            table::add(&mut table.inner, key, default);\n            table.length = table.length + 1;\n            table::borrow_mut(&mut table.inner, key)\n        }\n    }\n\n    /// Insert the pair (`key`, `value`) if there is no entry for `key`.\n    /// update the value of the entry for `key` to `value` otherwise\n    public fun upsert<K: copy + drop, V: drop>(table: &mut TableWithLength<K, V>, key: K, value: V) {\n        if (!table::contains(&table.inner, key)) {\n            add(table, copy key, value)\n        } else {\n            let ref = table::borrow_mut(&mut table.inner, key);\n            *ref = value;\n        };\n    }\n\n    /// Remove from `table` and return the value which `key` maps to.\n    /// Aborts if there is no entry for `key`.\n    public fun remove<K: copy + drop, V>(table: &mut TableWithLength<K, V>, key: K): V {\n        let val = table::remove(&mut table.inner, key);\n        table.length = table.length - 1;\n        val\n    }\n\n    /// Returns true iff `table` contains an entry for `key`.\n    public fun contains<K: copy + drop, V>(table: &TableWithLength<K, V>, key: K): bool {\n        table::contains(&table.inner, key)\n    }\n\n    #[test_only]\n    /// Drop table even if not empty, only when testing.\n    public fun drop_unchecked<K: copy + drop, V>(table: TableWithLength<K, V>) {\n        // Unpack table with length, dropping length count but not\n        // inner table.\n        let TableWithLength{inner, length: _} = table;\n        table::drop_unchecked(inner); // Drop inner table.\n    }\n\n    #[test]\n    /// Verify test-only drop functionality.\n    fun test_drop_unchecked() {\n        let table = new<bool, bool>(); // Declare new table.\n        add(&mut table, true, false); // Add table entry.\n        drop_unchecked(table); // Drop table.\n    }\n\n    #[test]\n    fun test_upsert() {\n        let t = new<u8, u8>();\n        // Table should not have key 0 yet\n        assert!(!contains(&t, 0), 1);\n        // This should insert key 0, with value 10, and length should be 1\n        upsert(&mut t, 0, 10);\n        // Ensure the value is correctly set to 10\n        assert!(*borrow(&t, 0) == 10, 1);\n        // Ensure the length is correctly set\n        assert!(length(&t) == 1, 1);\n        // Lets upsert the value to something else, and verify it's correct\n        upsert(&mut t, 0, 23);\n        assert!(*borrow(&t, 0) == 23, 1);\n        // Since key 0 already existed, the length should not have changed\n        assert!(length(&t) == 1, 1);\n        // If we upsert a non-existing key, the length should increase\n        upsert(&mut t, 1, 7);\n        assert!(length(&t) == 2, 1);\n\n        remove(&mut t, 0);\n        remove(&mut t, 1);\n        destroy_empty(t);\n    }\n}\n", "name": "table_with_length.move" }, { "content": 'module aptos_std::type_info {\n    use std::bcs;\n    use std::features;\n    use std::string::{Self, String};\n    use std::vector;\n\n    //\n    // Error codes\n    //\n\n    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 1;\n\n    //\n    // Structs\n    //\n\n    struct TypeInfo has copy, drop, store {\n        account_address: address,\n        module_name: vector<u8>,\n        struct_name: vector<u8>,\n    }\n\n    //\n    // Public functions\n    //\n\n    public fun account_address(type_info: &TypeInfo): address {\n        type_info.account_address\n    }\n\n    public fun module_name(type_info: &TypeInfo): vector<u8> {\n        type_info.module_name\n    }\n\n    public fun struct_name(type_info: &TypeInfo): vector<u8> {\n        type_info.struct_name\n    }\n\n    /// Returns the current chain ID, mirroring what `aptos_framework::chain_id::get()` would return, except in `#[test]`\n    /// functions, where this will always return `4u8` as the chain ID, whereas `aptos_framework::chain_id::get()` will\n    /// return whichever ID was passed to `aptos_framework::chain_id::initialize_for_test()`.\n    public fun chain_id(): u8 {\n        if (!features::aptos_stdlib_chain_id_enabled()) {\n            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))\n        };\n\n        chain_id_internal()\n    }\n\n    /// Return the `TypeInfo` struct containing  for the type `T`.\n    public native fun type_of<T>(): TypeInfo;\n\n    /// Return the human readable string for the type, including the address, module name, and any type arguments.\n    /// Example: 0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>\n    /// Or: 0x1::table::Table<0x1::string::String, 0x1::string::String>\n    public native fun type_name<T>(): String;\n\n    native fun chain_id_internal(): u8;\n\n    /// Return the BCS size, in bytes, of value at `val_ref`.\n    ///\n    /// See the [BCS spec](https://github.com/diem/bcs)\n    ///\n    /// See `test_size_of_val()` for an analysis of common types and\n    /// nesting patterns, as well as `test_size_of_val_vectors()` for an\n    /// analysis of vector size dynamism.\n    public fun size_of_val<T>(val_ref: &T): u64 {\n        // Return vector length of vectorized BCS representation.\n        vector::length(&bcs::to_bytes(val_ref))\n    }\n\n    #[test_only]\n    use aptos_std::table::Table;\n\n    #[test]\n    fun test_type_of() {\n        let type_info = type_of<TypeInfo>();\n        assert!(account_address(&type_info) == @aptos_std, 0);\n        assert!(module_name(&type_info) == b"type_info", 1);\n        assert!(struct_name(&type_info) == b"TypeInfo", 2);\n    }\n\n    #[test]\n    fun test_type_of_with_type_arg() {\n        let type_info = type_of<Table<String, String>>();\n        assert!(account_address(&type_info) == @aptos_std, 0);\n        assert!(module_name(&type_info) == b"table", 1);\n        assert!(struct_name(&type_info) == b"Table<0x1::string::String, 0x1::string::String>", 2);\n    }\n\n    #[test(fx = @std)]\n    fun test_chain_id(fx: signer) {\n        // We need to enable the feature in order for the native call to be allowed.\n        features::change_feature_flags_for_testing(&fx, vector[features::get_aptos_stdlib_chain_id_feature()], vector[]);\n\n        // The testing environment chain ID is 4u8.\n        assert!(chain_id() == 4u8, 1);\n    }\n\n    #[test]\n    fun test_type_name() {\n\n\n        assert!(type_name<bool>() == string::utf8(b"bool"), 0);\n        assert!(type_name<u8>() == string::utf8(b"u8"), 1);\n        assert!(type_name<u64>() == string::utf8(b"u64"), 2);\n        assert!(type_name<u128>() == string::utf8(b"u128"), 3);\n        assert!(type_name<address>() == string::utf8(b"address"), 4);\n        assert!(type_name<signer>() == string::utf8(b"signer"), 5);\n\n        // vector\n        assert!(type_name<vector<u8>>() == string::utf8(b"vector<u8>"), 6);\n        assert!(type_name<vector<vector<u8>>>() == string::utf8(b"vector<vector<u8>>"), 7);\n        assert!(type_name<vector<vector<TypeInfo>>>() == string::utf8(b"vector<vector<0x1::type_info::TypeInfo>>"), 8);\n\n\n        // struct\n        assert!(type_name<TypeInfo>() == string::utf8(b"0x1::type_info::TypeInfo"), 9);\n        assert!(type_name<\n            Table<\n                TypeInfo,\n                Table<u8, vector<TypeInfo>>\n            >\n        >() == string::utf8(b"0x1::table::Table<0x1::type_info::TypeInfo, 0x1::table::Table<u8, vector<0x1::type_info::TypeInfo>>>"), 10);\n    }\n\n    #[verify_only]\n    fun verify_type_of() {\n        let type_info = type_of<TypeInfo>();\n        let account_address = account_address(&type_info);\n        let module_name = module_name(&type_info);\n        let struct_name = struct_name(&type_info);\n        spec {\n            assert account_address == @aptos_std;\n            assert module_name == b"type_info";\n            assert struct_name == b"TypeInfo";\n        };\n    }\n\n    #[verify_only]\n    fun verify_type_of_generic<T>() {\n        let type_info = type_of<T>();\n        let account_address = account_address(&type_info);\n        let module_name = module_name(&type_info);\n        let struct_name = struct_name(&type_info);\n        spec {\n            assert account_address == type_of<T>().account_address;\n            assert module_name == type_of<T>().module_name;\n            assert struct_name == type_of<T>().struct_name;\n        };\n    }\n    spec verify_type_of_generic {\n        aborts_if !spec_is_struct<T>();\n    }\n\n    #[test_only]\n    struct CustomType has drop {}\n\n    #[test_only]\n    struct SimpleStruct has copy, drop {\n        field: u8\n    }\n\n    #[test_only]\n    struct ComplexStruct<T> has copy, drop {\n        field_1: bool,\n        field_2: u8,\n        field_3: u64,\n        field_4: u128,\n        field_5: SimpleStruct,\n        field_6: T\n    }\n\n    #[test_only]\n    struct TwoBools has drop {\n        bool_1: bool,\n        bool_2: bool\n    }\n\n    #[test_only]\n    use std::option;\n\n    #[test(account = @0x0)]\n    /// Ensure valid returns across native types and nesting schemas.\n    fun test_size_of_val(\n        account: &signer\n    ) {\n        assert!(size_of_val(&false) == 1, 0); // Bool takes 1 byte.\n        assert!(size_of_val<u8>(&0) == 1, 0); // u8 takes 1 byte.\n        assert!(size_of_val<u64>(&0) == 8, 0); // u64 takes 8 bytes.\n        assert!(size_of_val<u128>(&0) == 16, 0); // u128 takes 16 bytes.\n        // Address is a u256.\n        assert!(size_of_val(&@0x0) == 32, 0);\n        assert!(size_of_val(account) == 32, 0); // Signer is an address.\n        // Assert custom type without fields has size 1.\n        assert!(size_of_val(&CustomType{}) == 1, 0);\n        // Declare a simple struct with a 1-byte field.\n        let simple_struct = SimpleStruct{field: 0};\n        // Assert size is indicated as 1 byte.\n        assert!(size_of_val(&simple_struct) == 1, 0);\n        let complex_struct = ComplexStruct<u128>{\n            field_1: false,\n            field_2: 0,\n            field_3: 0,\n            field_4: 0,\n            field_5: simple_struct,\n            field_6: 0\n        }; // Declare a complex struct with another nested inside.\n        // Assert size is bytewise sum of components.\n        assert!(size_of_val(&complex_struct) == (1 + 1 + 8 + 16 + 1 + 16), 0);\n        // Declare a struct with two boolean values.\n        let two_bools = TwoBools{bool_1: false, bool_2: false};\n        // Assert size is two bytes.\n        assert!(size_of_val(&two_bools) == 2, 0);\n        // Declare an empty vector of element type u64.\n        let empty_vector_u64 = vector::empty<u64>();\n        // Declare an empty vector of element type u128.\n        let empty_vector_u128 = vector::empty<u128>();\n        // Assert size is 1 byte regardless of underlying element type.\n        assert!(size_of_val(&empty_vector_u64) == 1, 0);\n        // Assert size is 1 byte regardless of underlying element type.\n        assert!(size_of_val(&empty_vector_u128) == 1, 0);\n        // Declare a bool in a vector.\n        let bool_vector = vector::singleton(false);\n        // Push back another bool.\n        vector::push_back(&mut bool_vector, false);\n        // Assert size is 3 bytes (1 per element, 1 for base vector).\n        assert!(size_of_val(&bool_vector) == 3, 0);\n        // Get a some option, which is implemented as a vector.\n        let u64_option = option::some(0);\n        // Assert size is 9 bytes (8 per element, 1 for base vector).\n        assert!(size_of_val(&u64_option) == 9, 0);\n        option::extract(&mut u64_option); // Remove the value inside.\n        // Assert size reduces to 1 byte.\n        assert!(size_of_val(&u64_option) == 1, 0);\n    }\n\n    #[test]\n    /// Verify returns for base vector size at different lengths, with\n    /// different underlying fixed-size elements.\n    ///\n    /// For a vector of length n containing fixed-size elements, the\n    /// size of the vector is b + n * s bytes, where s is the size of an\n    /// element in bytes, and b is a "base size" in bytes that varies\n    /// with n.\n    ///\n    /// The base size is an artifact of vector BCS encoding, namely,\n    /// with b leading bytes that declare how many elements are in the\n    /// vector. Each such leading byte has a reserved control bit (e.g.\n    /// is this the last leading byte?), such that 7 bits per leading\n    /// byte remain for the actual element count. Hence for a single\n    /// leading byte, the maximum element count that can be described is\n    /// (2 ^ 7) - 1, and for b leading bytes, the maximum element count\n    /// that can be described is (2 ^ 7) ^ b - 1:\n    ///\n    /// * b = 1,                         n < 128\n    /// * b = 2,                  128 <= n < 16384\n    /// * b = 3,                16384 <= n < 2097152\n    /// * ...\n    /// *           (2 ^ 7) ^ (b - 1) <= n < (2 ^ 7) ^ b\n    /// * ...\n    /// * b = 9,    72057594037927936 <= n < 9223372036854775808\n    /// * b = 10, 9223372036854775808 <= n < 18446744073709551616\n    ///\n    /// Note that the upper bound on n for b = 10 is 2 ^ 64, rather than\n    /// (2 ^ 7) ^ 10 - 1, because the former, lower figure is the\n    /// maximum number of elements that can be stored in a vector in the\n    /// first place, e.g. U64_MAX.\n    ///\n    /// In practice b > 2 is unlikely to be encountered.\n    fun test_size_of_val_vectors() {\n        // Declare vector base sizes.\n        let (base_size_1, base_size_2, base_size_3) = (1, 2, 3);\n        // A base size of 1 applies for 127 or less elements.\n        let n_elems_cutoff_1 = 127; // (2 ^ 7) ^ 1 - 1.\n        // A base size of 2 applies for 128 < n <= 16384 elements.\n        let n_elems_cutoff_2 = 16383; // (2 ^ 7) ^ 2 - 1.\n        let vector_u64 = vector::empty<u64>(); // Declare empty vector.\n        let null_element = 0; // Declare a null element.\n        // Get element size.\n        let element_size = size_of_val(&null_element);\n        // Vector size is 1 byte when length is 0.\n        assert!(size_of_val(&vector_u64) == base_size_1, 0);\n        let i = 0; // Declare loop counter.\n        while (i < n_elems_cutoff_1) { // Iterate until first cutoff:\n            // Add an element.\n            vector::push_back(&mut vector_u64, null_element);\n            i = i + 1; // Increment counter.\n        };\n        // Vector base size is still 1 byte.\n        assert!(size_of_val(&vector_u64) - element_size * i == base_size_1, 0);\n        // Add another element, exceeding the cutoff.\n        vector::push_back(&mut vector_u64, null_element);\n        i = i + 1; // Increment counter.\n        // Vector base size is now 2 bytes.\n        assert!(size_of_val(&vector_u64) - element_size * i == base_size_2, 0);\n        while (i < n_elems_cutoff_2) { // Iterate until second cutoff:\n            // Add an element.\n            vector::push_back(&mut vector_u64, null_element);\n            i = i + 1; // Increment counter.\n        };\n        // Vector base size is still 2 bytes.\n        assert!(size_of_val(&vector_u64) - element_size * i == base_size_2, 0);\n        // Add another element, exceeding the cutoff.\n        vector::push_back(&mut vector_u64, null_element);\n        i = i + 1; // Increment counter.\n        // Vector base size is now 3 bytes.\n        assert!(size_of_val(&vector_u64) - element_size * i == base_size_3, 0);\n        // Repeat for custom struct.\n        let vector_complex = vector::empty<ComplexStruct<address>>();\n        // Declare a null element.\n        let null_element = ComplexStruct{\n            field_1: false,\n            field_2: 0,\n            field_3: 0,\n            field_4: 0,\n            field_5: SimpleStruct{field: 0},\n            field_6: @0x0\n        };\n        element_size = size_of_val(&null_element); // Get element size.\n        // Vector size is 1 byte when length is 0.\n        assert!(size_of_val(&vector_complex) == base_size_1, 0);\n        i = 0; // Re-initialize loop counter.\n        while (i < n_elems_cutoff_1) { // Iterate until first cutoff:\n            // Add an element.\n            vector::push_back(&mut vector_complex, copy null_element);\n            i = i + 1; // Increment counter.\n        };\n        assert!( // Vector base size is still 1 byte.\n            size_of_val(&vector_complex) - element_size * i == base_size_1, 0);\n        // Add another element, exceeding the cutoff.\n        vector::push_back(&mut vector_complex, null_element);\n        i = i + 1; // Increment counter.\n        assert!( // Vector base size is now 2 bytes.\n            size_of_val(&vector_complex) - element_size * i == base_size_2, 0);\n        while (i < n_elems_cutoff_2) { // Iterate until second cutoff:\n            // Add an element.\n            vector::push_back(&mut vector_complex, copy null_element);\n            i = i + 1; // Increment counter.\n        };\n        assert!( // Vector base size is still 2 bytes.\n            size_of_val(&vector_complex) - element_size * i == base_size_2, 0);\n        // Add another element, exceeding the cutoff.\n        vector::push_back(&mut vector_complex, null_element);\n        i = i + 1; // Increment counter.\n        assert!( // Vector base size is now 3 bytes.\n            size_of_val(&vector_complex) - element_size * i == base_size_3, 0);\n    }\n\n}\n', "name": "type_info.move" }];
})();
